(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// handles audio files and raw, mono, audio buffers

module.exports = function(context, buff, cb){
  
  var name = buff.constructor.name
  //if(Math.random() < .05) console.log(buff)
  if(name == 'ArrayBuffer'){
    context.decodeAudioData(buff).then(function(data){
      var source = context.createBufferSource()
      source.buffer = data
/*      var gain = context.createGain()
      gain.channelCount = 1
      gain.channelCountMode = 'explicit'
      gain.channelInterpretation = 'speakers'
      source.connect(gain)
      source._connect = source.connect
      source.connect = gain.connect
 */     cb(null, source) 
    }).catch(function(err){cb(err, null)})
	
  }else if(name == 'Array'){
  
    var source = context.createBufferSource();
      
    var buffer = context.createBuffer(2, buff[0].length, context.sampleRate)

    try{ // new
      buffer.copyToChannel(buff[0], 0, 0)
      buffer.copyToChannel(buff[1], 1, 0)

    }catch(err){ // old
      //buffer.getChannelData(0).set(buff)
    }
    
    source.buffer = buffer;
    
    /*
    var gain = context.createGain()
    gain.channelCount = 2
    gain.channelCountMode = 'explicit'
    gain.channelInterpretation = 'speakers'
    source.gain = gain
    source.connect(gain)
    source._connect = source.connect
    source.connect = gain.connect
    if(cb) cb(null, source)
    */
    return source
  }
}

},{}],2:[function(require,module,exports){
module.exports = function(master, stream){
    var node = master.createMediaStreamSource(stream)
    var gain = master.createGain()
    gain.channelCount = 1
    gain.channelCountMode = 'explicit'
    gain. channelInterpretation = 'speakers'
    node.connect(gain)
    return gain
}

},{}],3:[function(require,module,exports){
(function (process,Buffer){(function (){

require('domready')(re => {
  const WebAudioContext = window.AudioContext || window.webkitAudioContext
  var master 
  var h = require('hyperscript')
  var ui = require('getids')()
  var bus = require('./sharedEmitter')
  bus.once('iframeLoaded', e => {
    console.log(e)
    bus.emit('pong', {goat: 1})
    bus.on('clock', e => console.log(e))
  })
  //var iframe = require('../iframarfi')
  //var peering = iframe(require('./peering.js'))
  //ui.peering.appendChild(peering)
  
  var Peer = require('simple-peer')
  var signalhub = require('signalhub')
  const {makeAutoObservable,  autorun} = require('mobx')
  const short = require('short-uuid');
  const toa = require('to-arraybuffer')
  const btob = require('blob-to-buffer')
  const thru = require('through2')
  var store = require('store')
  const Time = require('../since-when')
  var jmic = require('../jsynth-mic/stream')
  var sampler = require('../jsynth-file-sample')
  var media 
  var runp =require('run-waterfall')
  var qs = require('querystring')
  var nana = require('nanohref')
  var minimist = require('minimist')
  var argv = minimist(process.argv, {
    default: {
      host: 'folkstack.com',
      port: 80,
      protocol: 'https'
    }
  })
  var debub = signalhub('https://folkstack.com:80', 'debug')
  //var ret=debub.subscribe('return')

  var app 
  _log = e =>{
      
      console.log(typeof e, e)
      ui.debug.appendChild(h('p', e.toString()))    
      debub.broadcast('debug', JSON.stringify(e))
  }

  window.store = store

  runp([initState, initUI], (err, app)=>{
    app = app

    ui.init.addEventListener('change', e => {
      _log('init')

      try{
        runp([captureSource, captureSink, captureNetwork, initAudio, initCast(app)].reverse(), (err, app)=>{
          console.log(err, app)
          //app.audio.sourceStream.pipe(app.audio.sinkStream) // heh
          if(app.session.broadcasting) {
            app.network.distance = 1
//            app.network.sourceStream = app.audio.sourceStream
            app.network.isSeekWorthy()
            app.network.allowCalls(app.session.stream)
          
          }
          else app.network.sourceSeek()
      })} catch (err){
        _log(err)
      }
    })
    
  })

  var ael = ui.player
  var mime = 'audio/ogg;codecs=opus'


  function initState(cb){

    class App {
    
      constructor(){
        this.mic = 1/2
        this.monitor = 0
        this.call = 1/2
        this.track = 1/2
        this.quality = 64000
        this.update = null
        makeAutoObservable(this)
      }

      setGain(dial, value){
        this[dial] = value
        this.update = [dial, value]
      }
    
    }

    const app = new App
    bus.on('appStateChange', e =>{
      app.setGain(e[0], e[1])
    })
    var session = store.get('session')
    if(!session) session = {id: short().generate().split().reverse().join().slice(0,11)}
    session.broadcasting = true
    var q = qs.parse(window.location.search.slice(1))
    if(q.stream) {
      session.stream = q.stream
      session.broadcasting = false 
    }
    else {
      session.stream = session.stream || short().generate().split().reverse().join().slice(0,11)
    }

    app.session = session
    store.set('session', session)
    console.log(app)
    cb(null, app)
  }

  function initAudio(app, cb){
    const audio = {}
    var OpusMediaRecorder = require('opus-media-recorder') 
    window.MediaRecorder = OpusMediaRecorder;
    master = new WebAudioContext({sampleRate: 48000})
    audio.master = master
    audio.broadcastmixer = master.createChannelMerger(2)
    audio.callmixer = master.createChannelMerger(2)
    audio.broadcaststream = master.createMediaStreamDestination()
    audio.callstream = master.createMediaStreamDestination()
    audio.monitor = master.createGain()
    audio.mic = master.createGain()
    audio.call = master.createGain()
    audio.trackmixer = master.createChannelMerger(2)
    audio.track = master.createGain()
    audio.trackmixer.connect(audio.track)

    audio.broadcastmixer.connect(audio.broadcaststream)
    //audio.broadcastmixer.connect(audio.monitor)

    audio.callmixer.connect(audio.callstream)
    //audio.callmixer.connect(audio.monitor)


    audio.mic.connect(audio.monitor)
    audio.call.connect(audio.monitor)
    audio.track.connect(audio.monitor)
    audio.monitor.connect(master.destination)

    audio.mic.connect(audio.broadcastmixer)
    audio.track.connect(audio.broadcastmixer)
    audio.call.connect(audio.broadcastmixer)

    audio.mic.connect(audio.callmixer)
    audio.track.connect(audio.callmixer)

    audio.broadcastmixer.connect(audio.broadcaststream)
    audio.callmixer.connect(audio.callstream)
    
    const workerOptions = {
      encoderWorkerFactory: function () {
        // UMD should be used if you don't use a web worker bundler for this.
        return new Worker(tob(Buffer("CihmdW5jdGlvbiBPcHVzTWVkaWFXb3JrZXJVTUQocm9vdCwgZmFjdG9yeSkgewogIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmCiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHsKICAgIHZhciBpbml0V29ya2VyID0gZmFjdG9yeSgpOwogICAgaW5pdFdvcmtlcigpOwogIH0KCWVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKQoJCW1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOwoJZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpCgkJZGVmaW5lKFtdLCBmYWN0b3J5KTsKCWVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKQoJCWV4cG9ydHNbImVuY29kZXJXb3JrZXIiXSA9IGZhY3RvcnkoKTsKCWVsc2UKCQlyb290WyJlbmNvZGVyV29ya2VyIl0gPSBmYWN0b3J5KCk7Cn0pKHR5cGVvZiBPcHVzTWVkaWFSZWNvcmRlciAhPT0gJ3VuZGVmaW5lZCcgPyBPcHVzTWVkaWFSZWNvcmRlciA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHsKcmV0dXJuIGZ1bmN0aW9uKCkgeyFmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBuKHIpe2lmKHRbcl0pcmV0dXJuIHRbcl0uZXhwb3J0czt2YXIgbz10W3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxuKSxvLmw9ITAsby5leHBvcnRzfW4ubT1lLG4uYz10LG4uZD1mdW5jdGlvbihlLHQscil7bi5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OnJ9KX0sbi5yPWZ1bmN0aW9uKGUpeyJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LG4udD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9bihlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmIm9iamVjdCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIociksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJiJzdHJpbmciIT10eXBlb2YgZSlmb3IodmFyIG8gaW4gZSluLmQocixvLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsbykpO3JldHVybiByfSxuLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIG4uZCh0LCJhIix0KSx0fSxuLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG4ucD0iIixuKG4ucz01KX0oW2Z1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgbj0wLHI9ZS5sZW5ndGgtMTtyPj0wO3ItLSl7dmFyIG89ZVtyXTsiLiI9PT1vP2Uuc3BsaWNlKHIsMSk6Ii4uIj09PW8/KGUuc3BsaWNlKHIsMSksbisrKTpuJiYoZS5zcGxpY2UociwxKSxuLS0pfWlmKHQpZm9yKDtuLS07billLnVuc2hpZnQoIi4uIik7cmV0dXJuIGV9ZnVuY3Rpb24gcihlLHQpe2lmKGUuZmlsdGVyKXJldHVybiBlLmZpbHRlcih0KTtmb3IodmFyIG49W10scj0wO3I8ZS5sZW5ndGg7cisrKXQoZVtyXSxyLGUpJiZuLnB1c2goZVtyXSk7cmV0dXJuIG59dC5yZXNvbHZlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PSIiLG89ITEsaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFvO2ktLSl7dmFyIHU9aT49MD9hcmd1bWVudHNbaV06ZS5jd2QoKTtpZigic3RyaW5nIiE9dHlwZW9mIHUpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MiKTt1JiYodD11KyIvIit0LG89Ii8iPT09dS5jaGFyQXQoMCkpfXJldHVybihvPyIvIjoiIikrKHQ9bihyKHQuc3BsaXQoIi8iKSwoZnVuY3Rpb24oZSl7cmV0dXJuISFlfSkpLCFvKS5qb2luKCIvIikpfHwiLiJ9LHQubm9ybWFsaXplPWZ1bmN0aW9uKGUpe3ZhciBpPXQuaXNBYnNvbHV0ZShlKSx1PSIvIj09PW8oZSwtMSk7cmV0dXJuKGU9bihyKGUuc3BsaXQoIi8iKSwoZnVuY3Rpb24oZSl7cmV0dXJuISFlfSkpLCFpKS5qb2luKCIvIikpfHxpfHwoZT0iLiIpLGUmJnUmJihlKz0iLyIpLChpPyIvIjoiIikrZX0sdC5pc0Fic29sdXRlPWZ1bmN0aW9uKGUpe3JldHVybiIvIj09PWUuY2hhckF0KDApfSx0LmpvaW49ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIHQubm9ybWFsaXplKHIoZSwoZnVuY3Rpb24oZSx0KXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MiKTtyZXR1cm4gZX0pKS5qb2luKCIvIikpfSx0LnJlbGF0aXZlPWZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gcihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoJiYiIj09PWVbdF07dCsrKTtmb3IodmFyIG49ZS5sZW5ndGgtMTtuPj0wJiYiIj09PWVbbl07bi0tKTtyZXR1cm4gdD5uP1tdOmUuc2xpY2UodCxuLXQrMSl9ZT10LnJlc29sdmUoZSkuc3Vic3RyKDEpLG49dC5yZXNvbHZlKG4pLnN1YnN0cigxKTtmb3IodmFyIG89cihlLnNwbGl0KCIvIikpLGk9cihuLnNwbGl0KCIvIikpLHU9TWF0aC5taW4oby5sZW5ndGgsaS5sZW5ndGgpLGE9dSxzPTA7czx1O3MrKylpZihvW3NdIT09aVtzXSl7YT1zO2JyZWFrfXZhciBjPVtdO2ZvcihzPWE7czxvLmxlbmd0aDtzKyspYy5wdXNoKCIuLiIpO3JldHVybihjPWMuY29uY2F0KGkuc2xpY2UoYSkpKS5qb2luKCIvIil9LHQuc2VwPSIvIix0LmRlbGltaXRlcj0iOiIsdC5kaXJuYW1lPWZ1bmN0aW9uKGUpe2lmKCJzdHJpbmciIT10eXBlb2YgZSYmKGUrPSIiKSwwPT09ZS5sZW5ndGgpcmV0dXJuIi4iO2Zvcih2YXIgdD1lLmNoYXJDb2RlQXQoMCksbj00Nz09PXQscj0tMSxvPSEwLGk9ZS5sZW5ndGgtMTtpPj0xOy0taSlpZig0Nz09PSh0PWUuY2hhckNvZGVBdChpKSkpe2lmKCFvKXtyPWk7YnJlYWt9fWVsc2Ugbz0hMTtyZXR1cm4tMT09PXI/bj8iLyI6Ii4iOm4mJjE9PT1yPyIvIjplLnNsaWNlKDAscil9LHQuYmFzZW5hbWU9ZnVuY3Rpb24oZSx0KXt2YXIgbj1mdW5jdGlvbihlKXsic3RyaW5nIiE9dHlwZW9mIGUmJihlKz0iIik7dmFyIHQsbj0wLHI9LTEsbz0hMDtmb3IodD1lLmxlbmd0aC0xO3Q+PTA7LS10KWlmKDQ3PT09ZS5jaGFyQ29kZUF0KHQpKXtpZighbyl7bj10KzE7YnJlYWt9fWVsc2UtMT09PXImJihvPSExLHI9dCsxKTtyZXR1cm4tMT09PXI/IiI6ZS5zbGljZShuLHIpfShlKTtyZXR1cm4gdCYmbi5zdWJzdHIoLTEqdC5sZW5ndGgpPT09dCYmKG49bi5zdWJzdHIoMCxuLmxlbmd0aC10Lmxlbmd0aCkpLG59LHQuZXh0bmFtZT1mdW5jdGlvbihlKXsic3RyaW5nIiE9dHlwZW9mIGUmJihlKz0iIik7Zm9yKHZhciB0PS0xLG49MCxyPS0xLG89ITAsaT0wLHU9ZS5sZW5ndGgtMTt1Pj0wOy0tdSl7dmFyIGE9ZS5jaGFyQ29kZUF0KHUpO2lmKDQ3IT09YSktMT09PXImJihvPSExLHI9dSsxKSw0Nj09PWE/LTE9PT10P3Q9dToxIT09aSYmKGk9MSk6LTEhPT10JiYoaT0tMSk7ZWxzZSBpZighbyl7bj11KzE7YnJlYWt9fXJldHVybi0xPT09dHx8LTE9PT1yfHwwPT09aXx8MT09PWkmJnQ9PT1yLTEmJnQ9PT1uKzE/IiI6ZS5zbGljZSh0LHIpfTt2YXIgbz0iYiI9PT0iYWIiLnN1YnN0cigtMSk/ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlLnN1YnN0cih0LG4pfTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHQ8MCYmKHQ9ZS5sZW5ndGgrdCksZS5zdWJzdHIodCxuKX19KS5jYWxsKHRoaXMsbigyKSl9LGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlKXtyZXR1cm4obj0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHIoZSx0KXtpZigiZnVuY3Rpb24iIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmbyhlLHQpfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4obz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9ZnVuY3Rpb24gaShlKXt2YXIgdD1mdW5jdGlvbigpe2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoImZ1bmN0aW9uIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBuLHI9YShlKTtpZih0KXt2YXIgbz1hKHRoaXMpLmNvbnN0cnVjdG9yO249UmVmbGVjdC5jb25zdHJ1Y3Qocixhcmd1bWVudHMsbyl9ZWxzZSBuPXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB1KHRoaXMsbil9fWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4hdHx8Im9iamVjdCIhPT1uKHQpJiYiZnVuY3Rpb24iIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7cmV0dXJuIGV9KGUpOnR9ZnVuY3Rpb24gYShlKXtyZXR1cm4oYT1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4gdCYmYyhlLnByb3RvdHlwZSx0KSxuJiZjKGUsbiksZX12YXIgbD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIsbyl7c3dpdGNoKHModGhpcyxlKSx0aGlzLl9zaXplPW4sdGhpcy5fbW9kdWxlPXQsdGhpcy5fc2l6ZSl7Y2FzZSAxOnRoaXMuX2hlYXBBcnJheT1yP3RoaXMuX21vZHVsZS5IRUFQODp0aGlzLl9tb2R1bGUuSEVBUFU4O2JyZWFrO2Nhc2UgMjp0aGlzLl9oZWFwQXJyYXk9cj90aGlzLl9tb2R1bGUuSEVBUDE2OnRoaXMuX21vZHVsZS5IRUFQVTE2O2JyZWFrO2Nhc2UgNDp0aGlzLl9oZWFwQXJyYXk9cj90aGlzLl9tb2R1bGUuSEVBUDMyOnRoaXMuX21vZHVsZS5IRUFQVTMyO2JyZWFrO2RlZmF1bHQ6dGhpcy5faGVhcEFycmF5PXRoaXMuX21vZHVsZS5IRUFQVTh9byYmKHRoaXMuX3NpemU9NCx0aGlzLl9oZWFwQXJyYXk9dGhpcy5fbW9kdWxlLkhFQVBGMzIpLHRoaXMuX3BvaW50ZXI9dGhpcy5fbW9kdWxlLl9tYWxsb2Mobil9cmV0dXJuIGYoZSxbe2tleToiZnJlZSIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9tb2R1bGUuX2ZyZWUodGhpcy5wb2ludGVyKX19LHtrZXk6InBvaW50ZXIiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wb2ludGVyfX0se2tleToidmFsdWUiLGdldDpmdW5jdGlvbigpe3ZhciBlPTA7c3dpdGNoKHRoaXMuX3NpemUpe2Nhc2UgMjplPTE7YnJlYWs7Y2FzZSA0OmU9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiUG9pbnRlciBjYW4gYmUgb25seSBkZWZlcmVuY2VkIGFzIGludGVnZXItc2l6ZWQiKX1yZXR1cm4gdGhpcy5faGVhcEFycmF5W3RoaXMucG9pbnRlcj4+ZV19LHNldDpmdW5jdGlvbihlKXt2YXIgdD0wO3N3aXRjaCh0aGlzLl9zaXplKXtjYXNlIDI6dD0xO2JyZWFrO2Nhc2UgNDp0PTI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlBvaW50ZXIgY2FuIGJlIG9ubHkgZGVmZXJlbmNlZCBhcyBpbnRlZ2VyLXNpemVkIil9dGhpcy5faGVhcEFycmF5W3RoaXMucG9pbnRlcj4+dF09ZX19XSksZX0oKSxwPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyKXt2YXIgbztyZXR1cm4gcyh0aGlzLG4pLG89dC5jYWxsKHRoaXMsZSw0LCEwLCExKSx2b2lkIDAhPT1yJiYoby52YWx1ZT1yKSxvfXJldHVybiBufShsKSxfPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyKXt2YXIgbztyZXR1cm4gcyh0aGlzLG4pLG89dC5jYWxsKHRoaXMsZSw0LCExLCExKSx2b2lkIDAhPT1yJiYoby52YWx1ZT1yKSxvfXJldHVybiBufShsKSxkPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyLG8saSx1KXt2YXIgYTtzKHRoaXMsbiksYT10LmNhbGwodGhpcyxlLHIqbyxpLHUpO3ZhciBjPTA7c3dpdGNoKG8pe2Nhc2UgMTphLl9oZWFwQXJyYXk9aT9hLl9tb2R1bGUuSEVBUDg6YS5fbW9kdWxlLkhFQVBVOCxjPTA7YnJlYWs7Y2FzZSAyOmEuX2hlYXBBcnJheT1pP2EuX21vZHVsZS5IRUFQMTY6YS5fbW9kdWxlLkhFQVBVMTYsYz0xO2JyZWFrO2Nhc2UgNDphLl9oZWFwQXJyYXk9aT9hLl9tb2R1bGUuSEVBUDMyOmEuX21vZHVsZS5IRUFQVTMyLGM9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5pdCBzaXplIG11c3QgYmUgYW4gaW50ZWdlci1zaXplIil9dSYmKGEuX2hlYXBBcnJheT1hLl9tb2R1bGUuSEVBUEYzMixjPTIpO3ZhciBmPWEuX3BvaW50ZXI+PmM7cmV0dXJuIGEuX2J1ZmZlcj1hLl9oZWFwQXJyYXkuc3ViYXJyYXkoZixmK3IpLGEuX2xlbmd0aD1yLGF9cmV0dXJuIGYobixbe2tleToic2V0Iix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuX2J1ZmZlci5zZXQoZSx0KX19LHtrZXk6InN1YmFycmF5Iix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9idWZmZXIuc3ViYXJyYXkoZSx0KX19LHtrZXk6Imxlbmd0aCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xlbmd0aH19XSksbn0obCksaD1mdW5jdGlvbihlKXtyKG4sZSk7dmFyIHQ9aShuKTtmdW5jdGlvbiBuKGUscil7cmV0dXJuIHModGhpcyxuKSx0LmNhbGwodGhpcyxlLHIsNCwhMCwhMCl9cmV0dXJuIG59KGQpLG09ZnVuY3Rpb24oZSl7cihuLGUpO3ZhciB0PWkobik7ZnVuY3Rpb24gbihlLHIpe3JldHVybiBzKHRoaXMsbiksdC5jYWxsKHRoaXMsZSxyLDEsITEsITEpfXJldHVybiBufShkKSx5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSksdGhpcy5fbW9kdWxlPXR9cmV0dXJuIGYoZSxbe2tleToibWFsbG9jSW50MzIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgcCh0aGlzLl9tb2R1bGUsZSl9fSx7a2V5OiJtYWxsb2NVaW50MzIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgXyh0aGlzLl9tb2R1bGUsZSl9fSx7a2V5OiJtYWxsb2NVaW50OEJ1ZmZlciIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBtKHRoaXMuX21vZHVsZSxlKX19LHtrZXk6Im1hbGxvY0Zsb2F0MzJCdWZmZXIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgaCh0aGlzLl9tb2R1bGUsZSl9fV0pLGV9KCk7ZS5leHBvcnRzPXt3cml0ZVN0cmluZzpmdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspZS5zZXRVaW50OCh0K3Isbi5jaGFyQ29kZUF0KHIpKX0sRW1zY3JpcHRlbk1lbW9yeUFsbG9jYXRvcjp5fX0sZnVuY3Rpb24oZSx0KXt2YXIgbixyLG89ZS5leHBvcnRzPXt9O2Z1bmN0aW9uIGkoKXt0aHJvdyBuZXcgRXJyb3IoInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiB1KCl7dGhyb3cgbmV3IEVycm9yKCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiBhKGUpe2lmKG49PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KGUsMCk7aWYoKG49PT1pfHwhbikmJnNldFRpbWVvdXQpcmV0dXJuIG49c2V0VGltZW91dCxzZXRUaW1lb3V0KGUsMCk7dHJ5e3JldHVybiBuKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlLDApfX19IWZ1bmN0aW9uKCl7dHJ5e249ImZ1bmN0aW9uIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDppfWNhdGNoKGUpe249aX10cnl7cj0iZnVuY3Rpb24iPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDp1fWNhdGNoKGUpe3I9dX19KCk7dmFyIHMsYz1bXSxmPSExLGw9LTE7ZnVuY3Rpb24gcCgpe2YmJnMmJihmPSExLHMubGVuZ3RoP2M9cy5jb25jYXQoYyk6bD0tMSxjLmxlbmd0aCYmXygpKX1mdW5jdGlvbiBfKCl7aWYoIWYpe3ZhciBlPWEocCk7Zj0hMDtmb3IodmFyIHQ9Yy5sZW5ndGg7dDspe2ZvcihzPWMsYz1bXTsrK2w8dDspcyYmc1tsXS5ydW4oKTtsPS0xLHQ9Yy5sZW5ndGh9cz1udWxsLGY9ITEsZnVuY3Rpb24oZSl7aWYocj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KGUpO2lmKChyPT09dXx8IXIpJiZjbGVhclRpbWVvdXQpcmV0dXJuIHI9Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChlKTt0cnl7cihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlKX19fShlKX19ZnVuY3Rpb24gZChlLHQpe3RoaXMuZnVuPWUsdGhpcy5hcnJheT10fWZ1bmN0aW9uIGgoKXt9by5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMV09YXJndW1lbnRzW25dO2MucHVzaChuZXcgZChlLHQpKSwxIT09Yy5sZW5ndGh8fGZ8fGEoXyl9LGQucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LG8udGl0bGU9ImJyb3dzZXIiLG8uYnJvd3Nlcj0hMCxvLmVudj17fSxvLmFyZ3Y9W10sby52ZXJzaW9uPSIiLG8udmVyc2lvbnM9e30sby5vbj1oLG8uYWRkTGlzdGVuZXI9aCxvLm9uY2U9aCxvLm9mZj1oLG8ucmVtb3ZlTGlzdGVuZXI9aCxvLnJlbW92ZUFsbExpc3RlbmVycz1oLG8uZW1pdD1oLG8ucHJlcGVuZExpc3RlbmVyPWgsby5wcmVwZW5kT25jZUxpc3RlbmVyPWgsby5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119LG8uYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkIil9LG8uY3dkPWZ1bmN0aW9uKCl7cmV0dXJuIi8ifSxvLmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkIil9LG8udW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBlLndlYnBhY2tQb2x5ZmlsbHx8KGUuZGVwcmVjYXRlPWZ1bmN0aW9uKCl7fSxlLnBhdGhzPVtdLGUuY2hpbGRyZW58fChlLmNoaWxkcmVuPVtdKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwibG9hZGVkIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZS5sfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJpZCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuaX19KSxlLndlYnBhY2tQb2x5ZmlsbD0xKSxlfX0sZnVuY3Rpb24oZSx0KXt9LGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUpe3ZhciB0LHI9big2KSxvPW4oNyksaT1uKDgpO2Uub25tZXNzYWdlPWZ1bmN0aW9uKGUpe3ZhciBuPWUuZGF0YS5jb21tYW5kO3N3aXRjaChuKXtjYXNlImxvYWRFbmNvZGVyIjp2YXIgdSxhPWUuZGF0YSxzPWEubWltZVR5cGUsYz1hLndhc21QYXRoO3N3aXRjaChzKXtjYXNlImF1ZGlvL3dhdiI6Y2FzZSJhdWRpby93YXZlIjp1PXI7YnJlYWs7Y2FzZSJhdWRpby93ZWJtIjp1PW87YnJlYWs7Y2FzZSJhdWRpby9vZ2ciOnU9aX12YXIgZj17fTtjJiYoZi5sb2NhdGVGaWxlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubWF0Y2goLy53YXNtLyk/Yzp0K2V9KSx1KGYpLnRoZW4oKGZ1bmN0aW9uKGUpe3Q9ZSxzZWxmLnBvc3RNZXNzYWdlKHtjb21tYW5kOiJyZWFkeVRvSW5pdCJ9KX0pKTticmVhaztjYXNlImluaXQiOnZhciBsPWUuZGF0YSxwPWwuc2FtcGxlUmF0ZSxfPWwuY2hhbm5lbENvdW50LGQ9bC5iaXRzUGVyU2Vjb25kO3QuaW5pdChwLF8sZCk7YnJlYWs7Y2FzZSJwdXNoSW5wdXREYXRhIjpmb3IodmFyIGg9ZS5kYXRhLG09aC5jaGFubmVsQnVmZmVycyx5PShoLmxlbmd0aCxoLmR1cmF0aW9uLDApO3k8bS5sZW5ndGg7eSsrKW1beV09bmV3IEZsb2F0MzJBcnJheShtW3ldLmJ1ZmZlcik7dC5lbmNvZGUobSk7YnJlYWs7Y2FzZSJnZXRFbmNvZGVkRGF0YSI6Y2FzZSJkb25lIjoiZG9uZSI9PT1uJiZ0LmNsb3NlKCk7dmFyIHY9dC5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2NvbW1hbmQ6ImRvbmUiPT09bj8ibGFzdEVuY29kZWREYXRhIjoiZW5jb2RlZERhdGEiLGJ1ZmZlcnM6dn0sdiksImRvbmUiPT09biYmc2VsZi5jbG9zZSgpfX19InVuZGVmaW5lZCIhPXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSYmc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlJiZyKHNlbGYpLGUuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gbyhlKX0oZSl8fGZ1bmN0aW9uKGUpe2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oZSx0KXtpZighZSlyZXR1cm47aWYoInN0cmluZyI9PXR5cGVvZiBlKXJldHVybiBvKGUsdCk7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpOyJPYmplY3QiPT09biYmZS5jb25zdHJ1Y3RvciYmKG49ZS5jb25zdHJ1Y3Rvci5uYW1lKTtpZigiTWFwIj09PW58fCJTZXQiPT09bilyZXR1cm4gQXJyYXkuZnJvbShlKTtpZigiQXJndW1lbnRzIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiBvKGUsdCl9KGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLiIpfSgpfWZ1bmN0aW9uIG8oZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIG49MCxyPW5ldyBBcnJheSh0KTtuPHQ7bisrKXJbbl09ZVtuXTtyZXR1cm4gcn1mdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19dmFyIHU9bigxKS53cml0ZVN0cmluZyxhPUludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQscz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfSh0aGlzLGUpLHRoaXMuY29uZmlnPXtpbnB1dFNhbXBsZVJhdGU6dCxjaGFubmVsQ291bnQ6bn0sdGhpcy5lbmNvZGVkQnVmZmVycz1bXX12YXIgdCxuLHI7cmV0dXJuIHQ9ZSwobj1be2tleToiZW5jb2RlIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZVswXS5sZW5ndGgsbj1uZXcgQXJyYXlCdWZmZXIodCphKnRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCkscj1uZXcgRGF0YVZpZXcobiksbz0wO288dGhpcy5jb25maWcuY2hhbm5lbENvdW50O28rKylmb3IodmFyIGk9ZVtvXSx1PTA7dTx0O3UrKyl7dmFyIHM9MzI3NjcqaVt1XXwwO3M+MzI3Njc/cz0zMjc2NzpzPC0zMjc2OCYmKHM9LTMyNzY4KTt2YXIgYz0odSp0aGlzLmNvbmZpZy5jaGFubmVsQ291bnQrbykqYTtyLnNldEludDE2KGMsMHxzLCEwKX10aGlzLmVuY29kZWRCdWZmZXJzLnB1c2gobil9fSx7a2V5OiJnZXRIZWFkZXIiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5lbmNvZGVkQnVmZmVycy5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdC5ieXRlTGVuZ3RofSksMCksdD1uZXcgQXJyYXlCdWZmZXIoNDQpLG49bmV3IERhdGFWaWV3KHQpO3JldHVybiB1KG4sMCwiUklGRiIpLG4uc2V0VWludDMyKDQsMzYrZSwhMCksdShuLDgsIldBVkUiKSx1KG4sMTIsImZtdCAiKSxuLnNldFVpbnQzMigxNiwxNiwhMCksbi5zZXRVaW50MTYoMjAsMSwhMCksbi5zZXRVaW50MTYoMjIsdGhpcy5jb25maWcuY2hhbm5lbENvdW50LCEwKSxuLnNldFVpbnQzMigyNCx0aGlzLmNvbmZpZy5pbnB1dFNhbXBsZVJhdGUsITApLG4uc2V0VWludDMyKDI4LHRoaXMuY29uZmlnLmlucHV0U2FtcGxlUmF0ZSphKnRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCwhMCksbi5zZXRVaW50MTYoMzIsYSp0aGlzLmNvbmZpZy5jaGFubmVsQ291bnQsITApLG4uc2V0VWludDE2KDM0LDgqYSwhMCksdShuLDM2LCJkYXRhIiksbi5zZXRVaW50MzIoNDAsZSwhMCksdH19XSkmJmkodC5wcm90b3R5cGUsbiksciYmaSh0LHIpLGV9KCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXsoZT12b2lkIDAhPT1lJiZlfHx7fSkuaW5pdD1mdW5jdGlvbih0LG4scil7ZS5lbmNvZGVyPW5ldyBzKHQsbixyKX0sZS5lbmNvZGU9ZnVuY3Rpb24odCl7ZS5lbmNvZGVyLmVuY29kZSh0KX0sZS5mbHVzaD1mdW5jdGlvbigpe3ZhciB0PWUuZW5jb2Rlci5nZXRIZWFkZXIoKSxuPWUuZW5jb2Rlci5lbmNvZGVkQnVmZmVycy5zcGxpY2UoMCxlLmVuY29kZXIuZW5jb2RlZEJ1ZmZlcnMubGVuZ3RoKTtyZXR1cm5bdF0uY29uY2F0KHIobikpfSxlLmNsb3NlPWZ1bmN0aW9uKCl7fSx0KGUpfSkpfX0sZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbihlLHIsbyxpKXt2YXIgdTtmdW5jdGlvbiBhKGUpe3JldHVybihhPSJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJiJzeW1ib2wiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJiJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4gdCYmYyhlLnByb3RvdHlwZSx0KSxuJiZjKGUsbiksZX12YXIgbCxwPShsPShsPSJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8ZSxmdW5jdGlvbihlKXtlPXZvaWQgMCE9PShlPWV8fHt9KT9lOnt9O3ZhciB0PW4oMSksaT10LkVtc2NyaXB0ZW5NZW1vcnlBbGxvY2F0b3IsdT0yMDQ5LGM9NDhlMyxwPTRlMyxfPTIwLGQ9NixoPTQwOTYsbT0wLHk9NDAwMix2PTAsYj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobixyKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwO3ModGhpcyx0KSx0aGlzLmNvbmZpZz17aW5wdXRTYW1wbGVSYXRlOm4sY2hhbm5lbENvdW50OnJ9LHRoaXMubWVtb3J5PW5ldyBpKGUpLHRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZS5fb3B1c19lbmNvZGVyX2NyZWF0ZSx0aGlzLl9vcHVzX2VuY29kZXJfY3RsPWUuX29wdXNfZW5jb2Rlcl9jdGwsdGhpcy5fb3B1c19lbmNvZGVfZmxvYXQ9ZS5fb3B1c19lbmNvZGVfZmxvYXQsdGhpcy5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3ksdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQsdGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQ9ZS5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQsdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3k9ZS5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3ksdGhpcy5fY29udGFpbmVyPW5ldyBlLkNvbnRhaW5lcix0aGlzLl9jb250YWluZXIuaW5pdChjLHIsTWF0aC5mbG9vcig0Mjk0OTY3Mjk1Kk1hdGgucmFuZG9tKCkpKSx0aGlzLk9wdXNJbml0Q29kZWMoYyxyLG8pLHRoaXMuU3BlZXhJbml0UmVzYW1wbGVyKG4sYyxyKSx0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWw9bipfLzFlMyx0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWw9YypfLzFlMyx0aGlzLmlucHV0QnVmZmVySW5kZXg9MCx0aGlzLm1JbnB1dEJ1ZmZlcj10aGlzLm1lbW9yeS5tYWxsb2NGbG9hdDMyQnVmZmVyKHRoaXMuaW5wdXRTYW1wbGVzUGVyQ2hhbm5lbCpyKSx0aGlzLm1SZXNhbXBsZWRCdWZmZXI9dGhpcy5tZW1vcnkubWFsbG9jRmxvYXQzMkJ1ZmZlcih0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwqciksdGhpcy5tT3V0cHV0QnVmZmVyPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQ4QnVmZmVyKHApLHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzPTEhPT1yP25ldyBGbG9hdDMyQXJyYXkoaCpyKTp2b2lkIDB9cmV0dXJuIGYodCxbe2tleToiZW5jb2RlIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5pbnRlcmxlYXZlKGUpLG49MDtuPHQubGVuZ3RoOyl7dmFyIHI9TWF0aC5taW4odGhpcy5tSW5wdXRCdWZmZXIubGVuZ3RoLXRoaXMuaW5wdXRCdWZmZXJJbmRleCx0Lmxlbmd0aC1uKTtpZih0aGlzLm1JbnB1dEJ1ZmZlci5zZXQodC5zdWJhcnJheShuLG4rciksdGhpcy5pbnB1dEJ1ZmZlckluZGV4KSx0aGlzLmlucHV0QnVmZmVySW5kZXgrPXIsdGhpcy5pbnB1dEJ1ZmZlckluZGV4Pj10aGlzLm1JbnB1dEJ1ZmZlci5sZW5ndGgpe3ZhciBvPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWwpLGk9dGhpcy5tZW1vcnkubWFsbG9jVWludDMyKHRoaXMub3V0cHV0U2FtcGxlUGVyQ2hhbm5lbCksdT10aGlzLl9zcGVleF9yZXNhbXBsZXJfcHJvY2Vzc19pbnRlcmxlYXZlZF9mbG9hdCh0aGlzLnJlc2FtcGxlcix0aGlzLm1JbnB1dEJ1ZmZlci5wb2ludGVyLG8ucG9pbnRlcix0aGlzLm1SZXNhbXBsZWRCdWZmZXIucG9pbnRlcixpLnBvaW50ZXIpO2lmKG8uZnJlZSgpLGkuZnJlZSgpLHUhPT12KXRocm93IG5ldyBFcnJvcigiUmVzYW1wbGluZyBlcnJvci4iKTt2YXIgYT10aGlzLl9vcHVzX2VuY29kZV9mbG9hdCh0aGlzLmVuY29kZXIsdGhpcy5tUmVzYW1wbGVkQnVmZmVyLnBvaW50ZXIsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsLHRoaXMubU91dHB1dEJ1ZmZlci5wb2ludGVyLHRoaXMubU91dHB1dEJ1ZmZlci5sZW5ndGgpO2lmKGE8MCl0aHJvdyBuZXcgRXJyb3IoIk9wdXMgZW5jb2RpbmcgZXJyb3IuIik7dGhpcy5fY29udGFpbmVyLndyaXRlRnJhbWUodGhpcy5tT3V0cHV0QnVmZmVyLnBvaW50ZXIsYSx0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwpLHRoaXMuaW5wdXRCdWZmZXJJbmRleD0wfW4rPXJ9fX0se2tleToiY2xvc2UiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCxuPVtdLHI9MDtyPHQ7KytyKW4ucHVzaChuZXcgRmxvYXQzMkFycmF5KGgtdGhpcy5pbnB1dEJ1ZmZlckluZGV4L3QpKTt0aGlzLmVuY29kZShuKSxlLmRlc3Ryb3kodGhpcy5fY29udGFpbmVyKSx0aGlzLm1JbnB1dEJ1ZmZlci5mcmVlKCksdGhpcy5tUmVzYW1wbGVkQnVmZmVyLmZyZWUoKSx0aGlzLm1PdXRwdXRCdWZmZXIuZnJlZSgpLHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95KHRoaXMuZW5jb2RlciksdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3kodGhpcy5yZXNhbXBsZXIpfX0se2tleToiaW50ZXJsZWF2ZSIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7aWYoMT09PXQpcmV0dXJuIGVbMF07Zm9yKHZhciBuPTA7bjx0O24rKylmb3IodmFyIHI9ZVtuXSxvPTA7bzxyLmxlbmd0aDtvKyspdGhpcy5pbnRlcmxlYXZlZEJ1ZmZlcnNbbyp0K25dPXJbb107cmV0dXJuIHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzfX0se2tleToiT3B1c0luaXRDb2RlYyIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwLHI9dGhpcy5tZW1vcnkubWFsbG9jVWludDMyKHZvaWQgMCk7dGhpcy5lbmNvZGVyPXRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGUoZSx0LHUsci5wb2ludGVyKTt2YXIgbz1yLnZhbHVlO2lmKHIuZnJlZSgpLG8hPT1tKXRocm93IG5ldyBFcnJvcigiT3B1cyBlbmNvZG9yIGluaXRpYWxpemF0aW9uIGZhaWxlZC4iKTtuJiZ0aGlzLk9wdXNTZXRPcHVzQ29udHJvbCh5LG4pfX0se2tleToiT3B1c1NldE9wdXNDb250cm9sIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMubWVtb3J5Lm1hbGxvY0ludDMyKHQpO3RoaXMuX29wdXNfZW5jb2Rlcl9jdGwodGhpcy5lbmNvZGVyLGUsbi5wb2ludGVyKSxuLmZyZWUoKX19LHtrZXk6IlNwZWV4SW5pdFJlc2FtcGxlciIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih2b2lkIDApO3RoaXMucmVzYW1wbGVyPXRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9pbml0KG4sZSx0LGQsci5wb2ludGVyKTt2YXIgbz1yLnZhbHVlO2lmKHIuZnJlZSgpLG8hPT12KXRocm93IG5ldyBFcnJvcigiSW5pdGlhbGl6aW5nIHJlc2FtcGxlciBmYWlsZWQuIil9fV0pLHR9KCk7ZS5pbml0PWZ1bmN0aW9uKHQsbixyKXtlLmVuY29kZWRCdWZmZXJzPVtdLGUuZW5jb2Rlcj1uZXcgYih0LG4scil9LGUuZW5jb2RlPWZ1bmN0aW9uKHQpe2UuZW5jb2Rlci5lbmNvZGUodCl9LGUuZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4gZS5lbmNvZGVkQnVmZmVycy5zcGxpY2UoMCxlLmVuY29kZWRCdWZmZXJzLmxlbmd0aCl9LGUuY2xvc2U9ZnVuY3Rpb24oKXtlLmVuY29kZXIuY2xvc2UoKX07dmFyIGcsdz17fTtmb3IoZyBpbiBlKWUuaGFzT3duUHJvcGVydHkoZykmJih3W2ddPWVbZ10pO3ZhciBBPVtdLEM9ITEsUz0hMSx4PSExLFA9ITE7Qz0ib2JqZWN0Ij09PSgidW5kZWZpbmVkIj09dHlwZW9mIHdpbmRvdz8idW5kZWZpbmVkIjphKHdpbmRvdykpLFM9ImZ1bmN0aW9uIj09dHlwZW9mIGltcG9ydFNjcmlwdHMseD0ib2JqZWN0Ij09PSh2b2lkIDA9PT1yPyJ1bmRlZmluZWQiOmEocikpJiYib2JqZWN0Ij09PWEoci52ZXJzaW9ucykmJiJzdHJpbmciPT10eXBlb2Ygci52ZXJzaW9ucy5ub2RlLFA9IUMmJiF4JiYhUzt2YXIgRSxCLEksUixPPSIiO2Z1bmN0aW9uIGoodCl7cmV0dXJuIGUubG9jYXRlRmlsZT9lLmxvY2F0ZUZpbGUodCxPKTpPK3R9eD8oTz1TP24oMCkuZGlybmFtZShPKSsiLyI6bysiLyIsRT1mdW5jdGlvbihlLHQpe3JldHVybiBJfHwoST1uKDQpKSxSfHwoUj1uKDApKSxlPVIubm9ybWFsaXplKGUpLEkucmVhZEZpbGVTeW5jKGUsdD9udWxsOiJ1dGY4Iil9LEI9ZnVuY3Rpb24oZSl7dmFyIHQ9RShlLCEwKTtyZXR1cm4gdC5idWZmZXJ8fCh0PW5ldyBVaW50OEFycmF5KHQpKSxXKHQuYnVmZmVyKSx0fSxyLmFyZ3YubGVuZ3RoPjEmJnIuYXJndlsxXS5yZXBsYWNlKC9cXC9nLCIvIiksQT1yLmFyZ3Yuc2xpY2UoMiksci5vbigidW5jYXVnaHRFeGNlcHRpb24iLChmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBxZSkpdGhyb3cgZX0pKSxyLm9uKCJ1bmhhbmRsZWRSZWplY3Rpb24iLF9lKSxlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4iW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF0ifSk6UD8oInVuZGVmaW5lZCIhPXR5cGVvZiByZWFkJiYoRT1mdW5jdGlvbihlKXtyZXR1cm4gcmVhZChlKX0pLEI9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHJlYWRidWZmZXI/bmV3IFVpbnQ4QXJyYXkocmVhZGJ1ZmZlcihlKSk6KFcoIm9iamVjdCI9PT1hKHQ9cmVhZChlLCJiaW5hcnkiKSkpLHQpfSwidW5kZWZpbmVkIiE9dHlwZW9mIHNjcmlwdEFyZ3M/QT1zY3JpcHRBcmdzOnZvaWQgMCE9PWFyZ3VtZW50cyYmKEE9YXJndW1lbnRzKSwidW5kZWZpbmVkIiE9dHlwZW9mIHByaW50JiYoInVuZGVmaW5lZCI9PXR5cGVvZiBjb25zb2xlJiYoY29uc29sZT17fSksY29uc29sZS5sb2c9cHJpbnQsY29uc29sZS53YXJuPWNvbnNvbGUuZXJyb3I9InVuZGVmaW5lZCIhPXR5cGVvZiBwcmludEVycj9wcmludEVycjpwcmludCkpOihDfHxTKSYmKFM/Tz1zZWxmLmxvY2F0aW9uLmhyZWY6ZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKE89ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLGwmJihPPWwpLE89MCE9PU8uaW5kZXhPZigiYmxvYjoiKT9PLnN1YnN0cigwLE8ubGFzdEluZGV4T2YoIi8iKSsxKToiIixFPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKCJHRVQiLGUsITEpLHQuc2VuZChudWxsKSx0LnJlc3BvbnNlVGV4dH0sUyYmKEI9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oIkdFVCIsZSwhMSksdC5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSk7dmFyIGssVSxUPWUucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksRj1lLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtmb3IoZyBpbiB3KXcuaGFzT3duUHJvcGVydHkoZykmJihlW2ddPXdbZ10pO3c9bnVsbCxlLmFyZ3VtZW50cyYmKEE9ZS5hcmd1bWVudHMpLGUudGhpc1Byb2dyYW0mJmUudGhpc1Byb2dyYW0sZS5xdWl0JiZlLnF1aXQsZS53YXNtQmluYXJ5JiYoaz1lLndhc21CaW5hcnkpLGUubm9FeGl0UnVudGltZSYmZS5ub0V4aXRSdW50aW1lLCJvYmplY3QiIT09KCJ1bmRlZmluZWQiPT10eXBlb2YgV2ViQXNzZW1ibHk/InVuZGVmaW5lZCI6YShXZWJBc3NlbWJseSkpJiZGKCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkIik7dmFyIEg9bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtpbml0aWFsOjYwLG1heGltdW06NjAsZWxlbWVudDoiYW55ZnVuYyJ9KSxNPSExO2Z1bmN0aW9uIFcoZSx0KXtlfHxfZSgiQXNzZXJ0aW9uIGZhaWxlZDogIit0KX12YXIgRD0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcigidXRmOCIpOnZvaWQgMDtmdW5jdGlvbiB6KGUsdCxuKXtmb3IodmFyIHI9dCtuLG89dDtlW29dJiYhKG8+PXIpOykrK287aWYoby10PjE2JiZlLnN1YmFycmF5JiZEKXJldHVybiBELmRlY29kZShlLnN1YmFycmF5KHQsbykpO2Zvcih2YXIgaT0iIjt0PG87KXt2YXIgdT1lW3QrK107aWYoMTI4JnUpe3ZhciBhPTYzJmVbdCsrXTtpZigxOTIhPSgyMjQmdSkpe3ZhciBzPTYzJmVbdCsrXTtpZigodT0yMjQ9PSgyNDAmdSk/KDE1JnUpPDwxMnxhPDw2fHM6KDcmdSk8PDE4fGE8PDEyfHM8PDZ8NjMmZVt0KytdKTw2NTUzNilpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUpO2Vsc2V7dmFyIGM9dS02NTUzNjtpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGM+PjEwLDU2MzIwfDEwMjMmYyl9fWVsc2UgaSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmdSk8PDZ8YSl9ZWxzZSBpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUpfXJldHVybiBpfWZ1bmN0aW9uIEwoZSx0KXtyZXR1cm4gZT96KHEsZSx0KToiIn0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXIoInV0Zi0xNmxlIik7dmFyIFYscSxOLEc9NjU1MzY7ZnVuY3Rpb24gWCh0KXtWPXQsZS5IRUFQOD1uZXcgSW50OEFycmF5KHQpLGUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLGUuSEVBUDMyPU49bmV3IEludDMyQXJyYXkodCksZS5IRUFQVTg9cT1uZXcgVWludDhBcnJheSh0KSxlLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLGUuSEVBUFUzMj1uZXcgVWludDMyQXJyYXkodCksZS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkodCksZS5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkodCl9dmFyIFk9NTI4OTAyNCwkPTQ1OTg0LEo9ZS5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7ZnVuY3Rpb24gSyh0KXtmb3IoO3QubGVuZ3RoPjA7KXt2YXIgbj10LnNoaWZ0KCk7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIG4pe3ZhciByPW4uZnVuYzsibnVtYmVyIj09dHlwZW9mIHI/dm9pZCAwPT09bi5hcmc/ZS5keW5DYWxsX3Yocik6ZS5keW5DYWxsX3ZpKHIsbi5hcmcpOnIodm9pZCAwPT09bi5hcmc/bnVsbDpuLmFyZyl9ZWxzZSBuKCl9fShVPWUud2FzbU1lbW9yeT9lLndhc21NZW1vcnk6bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpKL0csbWF4aW11bTpKL0d9KSkmJihWPVUuYnVmZmVyKSxKPVYuYnl0ZUxlbmd0aCxYKFYpLE5bJD4+Ml09WTt2YXIgUT1bXSxaPVtdLGVlPVtdLHRlPVtdO2Z1bmN0aW9uIG5lKCl7aWYoZS5wcmVSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnByZVJ1biYmKGUucHJlUnVuPVtlLnByZVJ1bl0pO2UucHJlUnVuLmxlbmd0aDspdWUoZS5wcmVSdW4uc2hpZnQoKSk7SyhRKX1mdW5jdGlvbiByZSgpe0soWil9ZnVuY3Rpb24gb2UoKXtLKGVlKX1mdW5jdGlvbiBpZSgpe2lmKGUucG9zdFJ1bilmb3IoImZ1bmN0aW9uIj09dHlwZW9mIGUucG9zdFJ1biYmKGUucG9zdFJ1bj1bZS5wb3N0UnVuXSk7ZS5wb3N0UnVuLmxlbmd0aDspYWUoZS5wb3N0UnVuLnNoaWZ0KCkpO0sodGUpfWZ1bmN0aW9uIHVlKGUpe1EudW5zaGlmdChlKX1mdW5jdGlvbiBhZShlKXt0ZS51bnNoaWZ0KGUpfXZhciBzZT0wLGNlPW51bGwsZmU9bnVsbDtmdW5jdGlvbiBsZSh0KXtzZSsrLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHNlKX1mdW5jdGlvbiBwZSh0KXtpZihzZS0tLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHNlKSwwPT1zZSYmKG51bGwhPT1jZSYmKGNsZWFySW50ZXJ2YWwoY2UpLGNlPW51bGwpLGZlKSl7dmFyIG49ZmU7ZmU9bnVsbCxuKCl9fWZ1bmN0aW9uIF9lKHQpe3Rocm93IGUub25BYm9ydCYmZS5vbkFib3J0KHQpLFQodCs9IiIpLEYodCksTT0hMCx0PSJhYm9ydCgiK3QrIikuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uIixuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQpfWUucHJlbG9hZGVkSW1hZ2VzPXt9LGUucHJlbG9hZGVkQXVkaW9zPXt9O3ZhciBkZT0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCI7ZnVuY3Rpb24gaGUoZSl7cmV0dXJuIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9lLnN0YXJ0c1dpdGgoZGUpOjA9PT1lLmluZGV4T2YoZGUpfXZhciBtZT0iV2ViTU9wdXNFbmNvZGVyLndhc20iO2Z1bmN0aW9uIHllKCl7dHJ5e2lmKGspcmV0dXJuIG5ldyBVaW50OEFycmF5KGspO2lmKEIpcmV0dXJuIEIobWUpO3Rocm93ImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1jYXRjaChlKXtfZShlKX19ZnVuY3Rpb24gdmUoKXtyZXR1cm4ga3x8IUMmJiFTfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7ZSh5ZSgpKX0pKTpmZXRjaChtZSx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93ImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyIrbWUrIiciO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIHllKCl9KSl9ZnVuY3Rpb24gYmUoKXt2YXIgdD17YTpUZX07ZnVuY3Rpb24gbih0LG4pe3ZhciByPXQuZXhwb3J0cztlLmFzbT1yLHBlKCl9ZnVuY3Rpb24gcihlKXtuKGUuaW5zdGFuY2UpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIHZlKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCl9KSkudGhlbihlLChmdW5jdGlvbihlKXtGKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2UpLF9lKGUpfSkpfWlmKGxlKCksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbSh0LG4pfWNhdGNoKGUpe3JldHVybiBGKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGt8fCJmdW5jdGlvbiIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8aGUobWUpfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2gpcmV0dXJuIG8ocik7ZmV0Y2gobWUse2NyZWRlbnRpYWxzOiJzYW1lLW9yaWdpbiJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSx0KS50aGVuKHIsKGZ1bmN0aW9uKGUpe0YoIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAiK2UpLEYoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIiksbyhyKX0pKX0pKX0oKSx7fX1mdW5jdGlvbiBnZSh0LG4pe3ZhciByPW5ldyBVaW50OEFycmF5KGUuSEVBUFU4LmJ1ZmZlcix0LG4pO2UuZW5jb2RlZEJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShyKS5idWZmZXIpfWZ1bmN0aW9uIHdlKGUsdCxuLHIpe19lKCJBc3NlcnRpb24gZmFpbGVkOiAiK0woZSkrIiwgYXQ6ICIrW3Q/TCh0KToidW5rbm93biBmaWxlbmFtZSIsbixyP0wocik6InVua25vd24gZnVuY3Rpb24iXSl9aGUobWUpfHwobWU9aihtZSkpLFoucHVzaCh7ZnVuYzpmdW5jdGlvbigpe01lKCl9fSk7dmFyIEFlPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oZSx0KXt2YXIgbj1BZS5idWZmZXJzW2VdOzA9PT10fHwxMD09PXQ/KCgxPT09ZT9UOkYpKHoobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKHQpfSx2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQWUudmFyYXJncys9NCxOW0FlLnZhcmFyZ3MtND4+Ml19LGdldFN0cjpmdW5jdGlvbihlKXtyZXR1cm4gTChlKX0sZ2V0NjQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZX19O2Z1bmN0aW9uIENlKGUsdCxuKXtyZXR1cm4gQWUudmFyYXJncz1uLDB9ZnVuY3Rpb24gU2UoZSx0LG4pe0FlLnZhcmFyZ3M9bn1mdW5jdGlvbiB4ZShlLHQsbil7cmV0dXJuIEFlLnZhcmFyZ3M9biwwfWZ1bmN0aW9uIFBlKCl7X2UoKX1mdW5jdGlvbiBFZShlLHQsbil7cS5jb3B5V2l0aGluKGUsdCx0K24pfWZ1bmN0aW9uIEJlKGUpe19lKCJPT00iKX1mdW5jdGlvbiBJZShlKXtCZSgpfWZ1bmN0aW9uIFJlKGUpe3JldHVybiAwfWZ1bmN0aW9uIE9lKGUsdCxuLHIpe3ZhciBvPUFlLmdldFN0cmVhbUZyb21GRChlKSxpPUFlLmRvUmVhZHYobyx0LG4pO3JldHVybiBOW3I+PjJdPWksMH1mdW5jdGlvbiBqZShlLHQsbixyLG8pe31mdW5jdGlvbiBrZShlLHQsbixyKXtmb3IodmFyIG89MCxpPTA7aTxuO2krKyl7Zm9yKHZhciB1PU5bdCs4Kmk+PjJdLGE9Tlt0Kyg4KmkrNCk+PjJdLHM9MDtzPGE7cysrKUFlLnByaW50Q2hhcihlLHFbdStzXSk7bys9YX1yZXR1cm4gTltyPj4yXT1vLDB9ZnVuY3Rpb24gVWUoZSl7dmFyIHQ9RGF0ZS5ub3coKS8xZTN8MDtyZXR1cm4gZSYmKE5bZT4+Ml09dCksdH12YXIgVGU9e2E6d2UsZTpDZSxoOlNlLGc6eGUsYjpQZSxtOmdlLGs6RWUsbDpJZSxjOlJlLGY6T2UsajpqZSxkOmtlLG1lbW9yeTpVLHRhYmxlOkgsaTpVZX0sRmU9YmUoKTtlLmFzbT1GZTt2YXIgSGUsTWU9ZS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oTWU9ZS5fX193YXNtX2NhbGxfY3RvcnM9ZS5hc20ubikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxXZT0oZS5fX19lbV9qc19fZW1zY3JpcHRlblB1c2hCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fX19lbV9qc19fZW1zY3JpcHRlblB1c2hCdWZmZXI9ZS5hc20ubykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9lbXNjcmlwdGVuX2JpbmRfVm9pZFB0cl9fX2Rlc3Ryb3lfX18wPWZ1bmN0aW9uKCl7cmV0dXJuKFdlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Wb2lkUHRyX19fZGVzdHJveV9fXzA9ZS5hc20ucCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSksRGU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9Db250YWluZXJfMD1mdW5jdGlvbigpe3JldHVybihEZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX0NvbnRhaW5lcl8wPWUuYXNtLnEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0semU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9pbml0XzM9ZnVuY3Rpb24oKXtyZXR1cm4oemU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9pbml0XzM9ZS5hc20ucikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxMZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX3dyaXRlRnJhbWVfMz1mdW5jdGlvbigpe3JldHVybihMZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX3dyaXRlRnJhbWVfMz1lLmFzbS5zKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfX19kZXN0cm95X19fMD1mdW5jdGlvbigpe3JldHVybihWZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX19fZGVzdHJveV9fXzA9ZS5hc20udCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBxZShlKXt0aGlzLm5hbWU9IkV4aXRTdGF0dXMiLHRoaXMubWVzc2FnZT0iUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgiK2UrIikiLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gTmUodCl7ZnVuY3Rpb24gbigpe0hlfHwoSGU9ITAsZS5jYWxsZWRSdW49ITAsTXx8KHJlKCksb2UoKSxlLm9uUnVudGltZUluaXRpYWxpemVkJiZlLm9uUnVudGltZUluaXRpYWxpemVkKCksaWUoKSkpfXQ9dHx8QSxzZT4wfHwobmUoKSxzZT4wfHwoZS5zZXRTdGF0dXM/KGUuc2V0U3RhdHVzKCJSdW5uaW5nLi4uIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe2Uuc2V0U3RhdHVzKCIiKX0pLDEpLG4oKX0pLDEpKTpuKCkpKX1pZihlLl9vcHVzX2VuY29kZXJfY3JlYXRlPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZS5hc20udSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9vcHVzX2VuY29kZV9mbG9hdD1mdW5jdGlvbigpe3JldHVybihlLl9vcHVzX2VuY29kZV9mbG9hdD1lLmFzbS52KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2Rlcl9jdGw9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2N0bD1lLmFzbS53KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWUuYXNtLngpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5hc20ueSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1mdW5jdGlvbigpe3JldHVybihlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1lLmFzbS56KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuYXNtLkEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9mcmVlPWUuYXNtLkIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX21hbGxvYz1lLmFzbS5DKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuZHluQ2FsbF92aT1mdW5jdGlvbigpe3JldHVybihlLmR5bkNhbGxfdmk9ZS5hc20uRCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLmR5bkNhbGxfdj1mdW5jdGlvbigpe3JldHVybihlLmR5bkNhbGxfdj1lLmFzbS5FKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuYXNtPUZlLGUudGhlbj1mdW5jdGlvbih0KXtpZihIZSl0KGUpO2Vsc2V7dmFyIG49ZS5vblJ1bnRpbWVJbml0aWFsaXplZDtlLm9uUnVudGltZUluaXRpYWxpemVkPWZ1bmN0aW9uKCl7biYmbigpLHQoZSl9fXJldHVybiBlfSxmZT1mdW5jdGlvbiBlKCl7SGV8fE5lKCksSGV8fChmZT1lKX0sZS5ydW49TmUsZS5wcmVJbml0KWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZS5wcmVJbml0JiYoZS5wcmVJbml0PVtlLnByZUluaXRdKTtlLnByZUluaXQubGVuZ3RoPjA7KWUucHJlSW5pdC5wb3AoKSgpO2Z1bmN0aW9uIEdlKCl7fWZ1bmN0aW9uIFhlKGUpe3JldHVybihlfHxHZSkuX19jYWNoZV9ffWZ1bmN0aW9uIFllKGUsdCl7dmFyIG49WGUodCkscj1uW2VdO3JldHVybiByfHwoKHI9T2JqZWN0LmNyZWF0ZSgodHx8R2UpLnByb3RvdHlwZSkpLnB0cj1lLG5bZV09cil9ZnVuY3Rpb24gJGUoZSx0KXtyZXR1cm4gWWUoZS5wdHIsdCl9ZnVuY3Rpb24gSmUoZSl7aWYoIWUuX19kZXN0cm95X18pdGhyb3ciRXJyb3I6IENhbm5vdCBkZXN0cm95IG9iamVjdC4gKERpZCB5b3UgY3JlYXRlIGl0IHlvdXJzZWxmPykiO2UuX19kZXN0cm95X18oKSxkZWxldGUgWGUoZS5fX2NsYXNzX18pW2UucHRyXX1mdW5jdGlvbiBLZShlLHQpe3JldHVybiBlLnB0cj09PXQucHRyfWZ1bmN0aW9uIFFlKGUpe3JldHVybiBlLnB0cn1mdW5jdGlvbiBaZShlKXtyZXR1cm4gZS5fX2NsYXNzX199ZnVuY3Rpb24gZXQoKXt0aHJvdyJjYW5ub3QgY29uc3RydWN0IGEgVm9pZFB0ciwgbm8gY29uc3RydWN0b3IgaW4gSURMIn1mdW5jdGlvbiB0dCgpe3RoaXMucHRyPURlKCksWGUodHQpW3RoaXMucHRyXT10aGlzfXJldHVybiBOZSgpLEdlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksR2UucHJvdG90eXBlLmNvbnN0cnVjdG9yPUdlLEdlLnByb3RvdHlwZS5fX2NsYXNzX189R2UsR2UuX19jYWNoZV9fPXt9LGUuV3JhcHBlck9iamVjdD1HZSxlLmdldENhY2hlPVhlLGUud3JhcFBvaW50ZXI9WWUsZS5jYXN0T2JqZWN0PSRlLGUuTlVMTD1ZZSgwKSxlLmRlc3Ryb3k9SmUsZS5jb21wYXJlPUtlLGUuZ2V0UG9pbnRlcj1RZSxlLmdldENsYXNzPVplLGV0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPWV0LGV0LnByb3RvdHlwZS5fX2NsYXNzX189ZXQsZXQuX19jYWNoZV9fPXt9LGUuVm9pZFB0cj1ldCxldC5wcm90b3R5cGUuX19kZXN0cm95X189ZXQucHJvdG90eXBlLl9fZGVzdHJveV9fPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wdHI7V2UoZSl9LHR0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksdHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXR0LHR0LnByb3RvdHlwZS5fX2NsYXNzX189dHQsdHQuX19jYWNoZV9fPXt9LGUuQ29udGFpbmVyPXR0LHR0LnByb3RvdHlwZS5pbml0PXR0LnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLnB0cjtlJiYib2JqZWN0Ij09PWEoZSkmJihlPWUucHRyKSx0JiYib2JqZWN0Ij09PWEodCkmJih0PXQucHRyKSxuJiYib2JqZWN0Ij09PWEobikmJihuPW4ucHRyKSx6ZShyLGUsdCxuKX0sdHQucHJvdG90eXBlLndyaXRlRnJhbWU9dHQucHJvdG90eXBlLndyaXRlRnJhbWU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMucHRyO2UmJiJvYmplY3QiPT09YShlKSYmKGU9ZS5wdHIpLHQmJiJvYmplY3QiPT09YSh0KSYmKHQ9dC5wdHIpLG4mJiJvYmplY3QiPT09YShuKSYmKG49bi5wdHIpLExlKHIsZSx0LG4pfSx0dC5wcm90b3R5cGUuX19kZXN0cm95X189dHQucHJvdG90eXBlLl9fZGVzdHJveV9fPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wdHI7VmUoZSl9LGV9KTsib2JqZWN0Ij09PWEodCkmJiJvYmplY3QiPT09YShpKT9pLmV4cG9ydHM9cDp2b2lkIDA9PT0odT1mdW5jdGlvbigpe3JldHVybiBwfS5hcHBseSh0LFtdKSl8fChpLmV4cG9ydHM9dSl9KS5jYWxsKHRoaXMsIi9pbmRleC5qcyIsbigyKSwiLyIsbigzKShlKSl9LGZ1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24oZSxyLG8saSl7dmFyIHU7ZnVuY3Rpb24gYShlKXtyZXR1cm4oYT0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHMoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKX1mdW5jdGlvbiBjKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gZihlLHQsbil7cmV0dXJuIHQmJmMoZS5wcm90b3R5cGUsdCksbiYmYyhlLG4pLGV9dmFyIGwscD0obD0obD0idW5kZWZpbmVkIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fGUsZnVuY3Rpb24oZSl7ZT12b2lkIDAhPT0oZT1lfHx7fSk/ZTp7fTt2YXIgdD1uKDEpLGk9dC5FbXNjcmlwdGVuTWVtb3J5QWxsb2NhdG9yLHU9MjA0OSxjPTQ4ZTMscD00ZTMsXz0yMCxkPTYsaD00MDk2LG09MCx5PTQwMDIsdj0wLGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4scil7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMDtzKHRoaXMsdCksdGhpcy5jb25maWc9e2lucHV0U2FtcGxlUmF0ZTpuLGNoYW5uZWxDb3VudDpyfSx0aGlzLm1lbW9yeT1uZXcgaShlKSx0aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlPWUuX29wdXNfZW5jb2Rlcl9jcmVhdGUsdGhpcy5fb3B1c19lbmNvZGVyX2N0bD1lLl9vcHVzX2VuY29kZXJfY3RsLHRoaXMuX29wdXNfZW5jb2RlX2Zsb2F0PWUuX29wdXNfZW5jb2RlX2Zsb2F0LHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWUuX29wdXNfZW5jb2Rlcl9kZXN0cm95LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9pbml0PWUuX3NwZWV4X3Jlc2FtcGxlcl9pbml0LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95PWUuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95LHRoaXMuX2NvbnRhaW5lcj1uZXcgZS5Db250YWluZXIsdGhpcy5fY29udGFpbmVyLmluaXQoYyxyLE1hdGguZmxvb3IoNDI5NDk2NzI5NSpNYXRoLnJhbmRvbSgpKSksdGhpcy5PcHVzSW5pdENvZGVjKGMscixvKSx0aGlzLlNwZWV4SW5pdFJlc2FtcGxlcihuLGMsciksdGhpcy5pbnB1dFNhbXBsZXNQZXJDaGFubmVsPW4qXy8xZTMsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsPWMqXy8xZTMsdGhpcy5pbnB1dEJ1ZmZlckluZGV4PTAsdGhpcy5tSW5wdXRCdWZmZXI9dGhpcy5tZW1vcnkubWFsbG9jRmxvYXQzMkJ1ZmZlcih0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWwqciksdGhpcy5tUmVzYW1wbGVkQnVmZmVyPXRoaXMubWVtb3J5Lm1hbGxvY0Zsb2F0MzJCdWZmZXIodGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsKnIpLHRoaXMubU91dHB1dEJ1ZmZlcj10aGlzLm1lbW9yeS5tYWxsb2NVaW50OEJ1ZmZlcihwKSx0aGlzLmludGVybGVhdmVkQnVmZmVycz0xIT09cj9uZXcgRmxvYXQzMkFycmF5KGgqcik6dm9pZCAwfXJldHVybiBmKHQsW3trZXk6ImVuY29kZSIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMuaW50ZXJsZWF2ZShlKSxuPTA7bjx0Lmxlbmd0aDspe3ZhciByPU1hdGgubWluKHRoaXMubUlucHV0QnVmZmVyLmxlbmd0aC10aGlzLmlucHV0QnVmZmVySW5kZXgsdC5sZW5ndGgtbik7aWYodGhpcy5tSW5wdXRCdWZmZXIuc2V0KHQuc3ViYXJyYXkobixuK3IpLHRoaXMuaW5wdXRCdWZmZXJJbmRleCksdGhpcy5pbnB1dEJ1ZmZlckluZGV4Kz1yLHRoaXMuaW5wdXRCdWZmZXJJbmRleD49dGhpcy5tSW5wdXRCdWZmZXIubGVuZ3RoKXt2YXIgbz10aGlzLm1lbW9yeS5tYWxsb2NVaW50MzIodGhpcy5pbnB1dFNhbXBsZXNQZXJDaGFubmVsKSxpPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwpLHU9dGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQodGhpcy5yZXNhbXBsZXIsdGhpcy5tSW5wdXRCdWZmZXIucG9pbnRlcixvLnBvaW50ZXIsdGhpcy5tUmVzYW1wbGVkQnVmZmVyLnBvaW50ZXIsaS5wb2ludGVyKTtpZihvLmZyZWUoKSxpLmZyZWUoKSx1IT09dil0aHJvdyBuZXcgRXJyb3IoIlJlc2FtcGxpbmcgZXJyb3IuIik7dmFyIGE9dGhpcy5fb3B1c19lbmNvZGVfZmxvYXQodGhpcy5lbmNvZGVyLHRoaXMubVJlc2FtcGxlZEJ1ZmZlci5wb2ludGVyLHRoaXMub3V0cHV0U2FtcGxlUGVyQ2hhbm5lbCx0aGlzLm1PdXRwdXRCdWZmZXIucG9pbnRlcix0aGlzLm1PdXRwdXRCdWZmZXIubGVuZ3RoKTtpZihhPDApdGhyb3cgbmV3IEVycm9yKCJPcHVzIGVuY29kaW5nIGVycm9yLiIpO3RoaXMuX2NvbnRhaW5lci53cml0ZUZyYW1lKHRoaXMubU91dHB1dEJ1ZmZlci5wb2ludGVyLGEsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsKSx0aGlzLmlucHV0QnVmZmVySW5kZXg9MH1uKz1yfX19LHtrZXk6ImNsb3NlIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmNvbmZpZy5jaGFubmVsQ291bnQsbj1bXSxyPTA7cjx0OysrciluLnB1c2gobmV3IEZsb2F0MzJBcnJheShoLXRoaXMuaW5wdXRCdWZmZXJJbmRleC90KSk7dGhpcy5lbmNvZGUobiksZS5kZXN0cm95KHRoaXMuX2NvbnRhaW5lciksdGhpcy5tSW5wdXRCdWZmZXIuZnJlZSgpLHRoaXMubVJlc2FtcGxlZEJ1ZmZlci5mcmVlKCksdGhpcy5tT3V0cHV0QnVmZmVyLmZyZWUoKSx0aGlzLl9vcHVzX2VuY29kZXJfZGVzdHJveSh0aGlzLmVuY29kZXIpLHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95KHRoaXMucmVzYW1wbGVyKX19LHtrZXk6ImludGVybGVhdmUiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO2lmKDE9PT10KXJldHVybiBlWzBdO2Zvcih2YXIgbj0wO248dDtuKyspZm9yKHZhciByPWVbbl0sbz0wO288ci5sZW5ndGg7bysrKXRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzW28qdCtuXT1yW29dO3JldHVybiB0aGlzLmludGVybGVhdmVkQnVmZmVyc319LHtrZXk6Ik9wdXNJbml0Q29kZWMiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMCxyPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih2b2lkIDApO3RoaXMuZW5jb2Rlcj10aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlKGUsdCx1LHIucG9pbnRlcik7dmFyIG89ci52YWx1ZTtpZihyLmZyZWUoKSxvIT09bSl0aHJvdyBuZXcgRXJyb3IoIk9wdXMgZW5jb2RvciBpbml0aWFsaXphdGlvbiBmYWlsZWQuIik7biYmdGhpcy5PcHVzU2V0T3B1c0NvbnRyb2woeSxuKX19LHtrZXk6Ik9wdXNTZXRPcHVzQ29udHJvbCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLm1lbW9yeS5tYWxsb2NJbnQzMih0KTt0aGlzLl9vcHVzX2VuY29kZXJfY3RsKHRoaXMuZW5jb2RlcixlLG4ucG9pbnRlciksbi5mcmVlKCl9fSx7a2V5OiJTcGVleEluaXRSZXNhbXBsZXIiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLm1lbW9yeS5tYWxsb2NVaW50MzIodm9pZCAwKTt0aGlzLnJlc2FtcGxlcj10aGlzLl9zcGVleF9yZXNhbXBsZXJfaW5pdChuLGUsdCxkLHIucG9pbnRlcik7dmFyIG89ci52YWx1ZTtpZihyLmZyZWUoKSxvIT09dil0aHJvdyBuZXcgRXJyb3IoIkluaXRpYWxpemluZyByZXNhbXBsZXIgZmFpbGVkLiIpfX1dKSx0fSgpO2UuaW5pdD1mdW5jdGlvbih0LG4scil7ZS5lbmNvZGVkQnVmZmVycz1bXSxlLmVuY29kZXI9bmV3IGIodCxuLHIpfSxlLmVuY29kZT1mdW5jdGlvbih0KXtlLmVuY29kZXIuZW5jb2RlKHQpfSxlLmZsdXNoPWZ1bmN0aW9uKCl7cmV0dXJuIGUuZW5jb2RlZEJ1ZmZlcnMuc3BsaWNlKDAsZS5lbmNvZGVkQnVmZmVycy5sZW5ndGgpfSxlLmNsb3NlPWZ1bmN0aW9uKCl7ZS5lbmNvZGVyLmNsb3NlKCl9O3ZhciBnLHc9e307Zm9yKGcgaW4gZSllLmhhc093blByb3BlcnR5KGcpJiYod1tnXT1lW2ddKTt2YXIgQT1bXSxDPSExLFM9ITEseD0hMSxQPSExO0M9Im9iamVjdCI9PT0oInVuZGVmaW5lZCI9PXR5cGVvZiB3aW5kb3c/InVuZGVmaW5lZCI6YSh3aW5kb3cpKSxTPSJmdW5jdGlvbiI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLHg9Im9iamVjdCI9PT0odm9pZCAwPT09cj8idW5kZWZpbmVkIjphKHIpKSYmIm9iamVjdCI9PT1hKHIudmVyc2lvbnMpJiYic3RyaW5nIj09dHlwZW9mIHIudmVyc2lvbnMubm9kZSxQPSFDJiYheCYmIVM7dmFyIEUsQixJLFIsTz0iIjtmdW5jdGlvbiBqKHQpe3JldHVybiBlLmxvY2F0ZUZpbGU/ZS5sb2NhdGVGaWxlKHQsTyk6Tyt0fXg/KE89Uz9uKDApLmRpcm5hbWUoTykrIi8iOm8rIi8iLEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSXx8KEk9big0KSksUnx8KFI9bigwKSksZT1SLm5vcm1hbGl6ZShlKSxJLnJlYWRGaWxlU3luYyhlLHQ/bnVsbDoidXRmOCIpfSxCPWZ1bmN0aW9uKGUpe3ZhciB0PUUoZSwhMCk7cmV0dXJuIHQuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksVyh0LmJ1ZmZlciksdH0sci5hcmd2Lmxlbmd0aD4xJiZyLmFyZ3ZbMV0ucmVwbGFjZSgvXFwvZywiLyIpLEE9ci5hcmd2LnNsaWNlKDIpLHIub24oInVuY2F1Z2h0RXhjZXB0aW9uIiwoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgV2UpKXRocm93IGV9KSksci5vbigidW5oYW5kbGVkUmVqZWN0aW9uIixfZSksZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdIn0pOlA/KCJ1bmRlZmluZWQiIT10eXBlb2YgcmVhZCYmKEU9ZnVuY3Rpb24oZSl7cmV0dXJuIHJlYWQoZSl9KSxCPWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiByZWFkYnVmZmVyP25ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZSkpOihXKCJvYmplY3QiPT09YSh0PXJlYWQoZSwiYmluYXJ5IikpKSx0KX0sInVuZGVmaW5lZCIhPXR5cGVvZiBzY3JpcHRBcmdzP0E9c2NyaXB0QXJnczp2b2lkIDAhPT1hcmd1bWVudHMmJihBPWFyZ3VtZW50cyksInVuZGVmaW5lZCIhPXR5cGVvZiBwcmludCYmKCJ1bmRlZmluZWQiPT10eXBlb2YgY29uc29sZSYmKGNvbnNvbGU9e30pLGNvbnNvbGUubG9nPXByaW50LGNvbnNvbGUud2Fybj1jb25zb2xlLmVycm9yPSJ1bmRlZmluZWQiIT10eXBlb2YgcHJpbnRFcnI/cHJpbnRFcnI6cHJpbnQpKTooQ3x8UykmJihTP089c2VsZi5sb2NhdGlvbi5ocmVmOmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihPPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxsJiYoTz1sKSxPPTAhPT1PLmluZGV4T2YoImJsb2I6Iik/Ty5zdWJzdHIoMCxPLmxhc3RJbmRleE9mKCIvIikrMSk6IiIsRT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbigiR0VUIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LFMmJihCPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKCJHRVQiLGUsITEpLHQucmVzcG9uc2VUeXBlPSJhcnJheWJ1ZmZlciIsdC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpfSkpO3ZhciBrLFUsVD1lLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEY9ZS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7Zm9yKGcgaW4gdyl3Lmhhc093blByb3BlcnR5KGcpJiYoZVtnXT13W2ddKTt3PW51bGwsZS5hcmd1bWVudHMmJihBPWUuYXJndW1lbnRzKSxlLnRoaXNQcm9ncmFtJiZlLnRoaXNQcm9ncmFtLGUucXVpdCYmZS5xdWl0LGUud2FzbUJpbmFyeSYmKGs9ZS53YXNtQmluYXJ5KSxlLm5vRXhpdFJ1bnRpbWUmJmUubm9FeGl0UnVudGltZSwib2JqZWN0IiE9PSgidW5kZWZpbmVkIj09dHlwZW9mIFdlYkFzc2VtYmx5PyJ1bmRlZmluZWQiOmEoV2ViQXNzZW1ibHkpKSYmRigibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCIpO3ZhciBIPW5ldyBXZWJBc3NlbWJseS5UYWJsZSh7aW5pdGlhbDozNixtYXhpbXVtOjM2LGVsZW1lbnQ6ImFueWZ1bmMifSksTT0hMTtmdW5jdGlvbiBXKGUsdCl7ZXx8X2UoIkFzc2VydGlvbiBmYWlsZWQ6ICIrdCl9dmFyIEQ9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoInV0ZjgiKTp2b2lkIDA7ZnVuY3Rpb24geihlLHQsbil7Zm9yKHZhciByPXQrbixvPXQ7ZVtvXSYmIShvPj1yKTspKytvO2lmKG8tdD4xNiYmZS5zdWJhcnJheSYmRClyZXR1cm4gRC5kZWNvZGUoZS5zdWJhcnJheSh0LG8pKTtmb3IodmFyIGk9IiI7dDxvOyl7dmFyIHU9ZVt0KytdO2lmKDEyOCZ1KXt2YXIgYT02MyZlW3QrK107aWYoMTkyIT0oMjI0JnUpKXt2YXIgcz02MyZlW3QrK107aWYoKHU9MjI0PT0oMjQwJnUpPygxNSZ1KTw8MTJ8YTw8NnxzOig3JnUpPDwxOHxhPDwxMnxzPDw2fDYzJmVbdCsrXSk8NjU1MzYpaSs9U3RyaW5nLmZyb21DaGFyQ29kZSh1KTtlbHNle3ZhciBjPXUtNjU1MzY7aSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjPj4xMCw1NjMyMHwxMDIzJmMpfX1lbHNlIGkrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJnUpPDw2fGEpfWVsc2UgaSs9U3RyaW5nLmZyb21DaGFyQ29kZSh1KX1yZXR1cm4gaX1mdW5jdGlvbiBMKGUsdCl7cmV0dXJuIGU/eihxLGUsdCk6IiJ9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyKCJ1dGYtMTZsZSIpO3ZhciBWLHEsTixHPTY1NTM2O2Z1bmN0aW9uIFgodCl7Vj10LGUuSEVBUDg9bmV3IEludDhBcnJheSh0KSxlLkhFQVAxNj1uZXcgSW50MTZBcnJheSh0KSxlLkhFQVAzMj1OPW5ldyBJbnQzMkFycmF5KHQpLGUuSEVBUFU4PXE9bmV3IFVpbnQ4QXJyYXkodCksZS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheSh0KSxlLkhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KHQpLGUuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLGUuSEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KHQpfXZhciBZPTUyODk3MjgsJD00NjY4OCxKPWUuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2Z1bmN0aW9uIEsodCl7Zm9yKDt0Lmxlbmd0aD4wOyl7dmFyIG49dC5zaGlmdCgpO2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBuKXt2YXIgcj1uLmZ1bmM7Im51bWJlciI9PXR5cGVvZiByP3ZvaWQgMD09PW4uYXJnP2UuZHluQ2FsbF92KHIpOmUuZHluQ2FsbF92aShyLG4uYXJnKTpyKHZvaWQgMD09PW4uYXJnP251bGw6bi5hcmcpfWVsc2UgbigpfX0oVT1lLndhc21NZW1vcnk/ZS53YXNtTWVtb3J5Om5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6Si9HLG1heGltdW06Si9HfSkpJiYoVj1VLmJ1ZmZlciksSj1WLmJ5dGVMZW5ndGgsWChWKSxOWyQ+PjJdPVk7dmFyIFE9W10sWj1bXSxlZT1bXSx0ZT1bXTtmdW5jdGlvbiBuZSgpe2lmKGUucHJlUnVuKWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZS5wcmVSdW4mJihlLnByZVJ1bj1bZS5wcmVSdW5dKTtlLnByZVJ1bi5sZW5ndGg7KXVlKGUucHJlUnVuLnNoaWZ0KCkpO0soUSl9ZnVuY3Rpb24gcmUoKXtLKFopfWZ1bmN0aW9uIG9lKCl7SyhlZSl9ZnVuY3Rpb24gaWUoKXtpZihlLnBvc3RSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnBvc3RSdW4mJihlLnBvc3RSdW49W2UucG9zdFJ1bl0pO2UucG9zdFJ1bi5sZW5ndGg7KWFlKGUucG9zdFJ1bi5zaGlmdCgpKTtLKHRlKX1mdW5jdGlvbiB1ZShlKXtRLnVuc2hpZnQoZSl9ZnVuY3Rpb24gYWUoZSl7dGUudW5zaGlmdChlKX12YXIgc2U9MCxjZT1udWxsLGZlPW51bGw7ZnVuY3Rpb24gbGUodCl7c2UrKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhzZSl9ZnVuY3Rpb24gcGUodCl7aWYoc2UtLSxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhzZSksMD09c2UmJihudWxsIT09Y2UmJihjbGVhckludGVydmFsKGNlKSxjZT1udWxsKSxmZSkpe3ZhciBuPWZlO2ZlPW51bGwsbigpfX1mdW5jdGlvbiBfZSh0KXt0aHJvdyBlLm9uQWJvcnQmJmUub25BYm9ydCh0KSxUKHQrPSIiKSxGKHQpLE09ITAsdD0iYWJvcnQoIit0KyIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLiIsbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih0KX1lLnByZWxvYWRlZEltYWdlcz17fSxlLnByZWxvYWRlZEF1ZGlvcz17fTt2YXIgZGU9ImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwiO2Z1bmN0aW9uIGhlKGUpe3JldHVybiBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg/ZS5zdGFydHNXaXRoKGRlKTowPT09ZS5pbmRleE9mKGRlKX12YXIgbWU9Ik9nZ09wdXNFbmNvZGVyLndhc20iO2Z1bmN0aW9uIHllKCl7dHJ5e2lmKGspcmV0dXJuIG5ldyBVaW50OEFycmF5KGspO2lmKEIpcmV0dXJuIEIobWUpO3Rocm93ImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1jYXRjaChlKXtfZShlKX19ZnVuY3Rpb24gdmUoKXtyZXR1cm4ga3x8IUMmJiFTfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7ZSh5ZSgpKX0pKTpmZXRjaChtZSx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93ImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyIrbWUrIiciO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIHllKCl9KSl9ZnVuY3Rpb24gYmUoKXt2YXIgdD17YTpSZX07ZnVuY3Rpb24gbih0LG4pe3ZhciByPXQuZXhwb3J0cztlLmFzbT1yLHBlKCl9ZnVuY3Rpb24gcihlKXtuKGUuaW5zdGFuY2UpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIHZlKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCl9KSkudGhlbihlLChmdW5jdGlvbihlKXtGKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2UpLF9lKGUpfSkpfWlmKGxlKCksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbSh0LG4pfWNhdGNoKGUpe3JldHVybiBGKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGt8fCJmdW5jdGlvbiIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8aGUobWUpfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2gpcmV0dXJuIG8ocik7ZmV0Y2gobWUse2NyZWRlbnRpYWxzOiJzYW1lLW9yaWdpbiJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSx0KS50aGVuKHIsKGZ1bmN0aW9uKGUpe0YoIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAiK2UpLEYoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIiksbyhyKX0pKX0pKX0oKSx7fX1mdW5jdGlvbiBnZSh0LG4pe3ZhciByPW5ldyBVaW50OEFycmF5KGUuSEVBUFU4LmJ1ZmZlcix0LG4pO2UuZW5jb2RlZEJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShyKS5idWZmZXIpfWZ1bmN0aW9uIHdlKGUsdCxuLHIpe19lKCJBc3NlcnRpb24gZmFpbGVkOiAiK0woZSkrIiwgYXQ6ICIrW3Q/TCh0KToidW5rbm93biBmaWxlbmFtZSIsbixyP0wocik6InVua25vd24gZnVuY3Rpb24iXSl9ZnVuY3Rpb24gQWUoKXtfZSgpfWZ1bmN0aW9uIENlKGUsdCxuKXtxLmNvcHlXaXRoaW4oZSx0LHQrbil9ZnVuY3Rpb24gU2UoZSl7X2UoIk9PTSIpfWZ1bmN0aW9uIHhlKGUpe1NlKCl9aGUobWUpfHwobWU9aihtZSkpLFoucHVzaCh7ZnVuYzpmdW5jdGlvbigpe2tlKCl9fSk7dmFyIFBlPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oZSx0KXt2YXIgbj1QZS5idWZmZXJzW2VdOzA9PT10fHwxMD09PXQ/KCgxPT09ZT9UOkYpKHoobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKHQpfSx2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUGUudmFyYXJncys9NCxOW1BlLnZhcmFyZ3MtND4+Ml19LGdldFN0cjpmdW5jdGlvbihlKXtyZXR1cm4gTChlKX0sZ2V0NjQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZX19O2Z1bmN0aW9uIEVlKGUpe3JldHVybiAwfWZ1bmN0aW9uIEJlKGUsdCxuLHIsbyl7fWZ1bmN0aW9uIEllKGUsdCxuLHIpe2Zvcih2YXIgbz0wLGk9MDtpPG47aSsrKXtmb3IodmFyIHU9Tlt0KzgqaT4+Ml0sYT1OW3QrKDgqaSs0KT4+Ml0scz0wO3M8YTtzKyspUGUucHJpbnRDaGFyKGUscVt1K3NdKTtvKz1hfXJldHVybiBOW3I+PjJdPW8sMH12YXIgUmU9e2E6d2UsYzpBZSxkOmdlLGY6Q2UsZzp4ZSxoOkVlLGU6QmUsYjpJZSxtZW1vcnk6VSx0YWJsZTpIfSxPZT1iZSgpO2UuYXNtPU9lO3ZhciBqZSxrZT1lLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihrZT1lLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5pKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFVlPShlLl9fX2VtX2pzX19lbXNjcmlwdGVuUHVzaEJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybihlLl9fX2VtX2pzX19lbXNjcmlwdGVuUHVzaEJ1ZmZlcj1lLmFzbS5qKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX2Vtc2NyaXB0ZW5fYmluZF9Wb2lkUHRyX19fZGVzdHJveV9fXzA9ZnVuY3Rpb24oKXtyZXR1cm4oVWU9ZS5fZW1zY3JpcHRlbl9iaW5kX1ZvaWRQdHJfX19kZXN0cm95X19fMD1lLmFzbS5rKS5hcHBseShudWxsLGFyZ3VtZW50cyl9KSxUZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX0NvbnRhaW5lcl8wPWZ1bmN0aW9uKCl7cmV0dXJuKFRlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfQ29udGFpbmVyXzA9ZS5hc20ubCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxGZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX2luaXRfMz1mdW5jdGlvbigpe3JldHVybihGZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX2luaXRfMz1lLmFzbS5tKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfd3JpdGVGcmFtZV8zPWZ1bmN0aW9uKCl7cmV0dXJuKEhlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfd3JpdGVGcmFtZV8zPWUuYXNtLm4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTWU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9fX2Rlc3Ryb3lfX18wPWZ1bmN0aW9uKCl7cmV0dXJuKE1lPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfX19kZXN0cm95X19fMD1lLmFzbS5vKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIFdlKGUpe3RoaXMubmFtZT0iRXhpdFN0YXR1cyIsdGhpcy5tZXNzYWdlPSJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCIrZSsiKSIsdGhpcy5zdGF0dXM9ZX1mdW5jdGlvbiBEZSh0KXtmdW5jdGlvbiBuKCl7amV8fChqZT0hMCxlLmNhbGxlZFJ1bj0hMCxNfHwocmUoKSxvZSgpLGUub25SdW50aW1lSW5pdGlhbGl6ZWQmJmUub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxpZSgpKSl9dD10fHxBLHNlPjB8fChuZSgpLHNlPjB8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoIlJ1bm5pbmcuLi4iKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zZXRTdGF0dXMoIiIpfSksMSksbigpfSksMSkpOm4oKSkpfWlmKGUuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2NyZWF0ZT1lLmFzbS5wKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2RlX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2RlX2Zsb2F0PWUuYXNtLnEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fb3B1c19lbmNvZGVyX2N0bD1mdW5jdGlvbigpe3JldHVybihlLl9vcHVzX2VuY29kZXJfY3RsPWUuYXNtLnIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZS5hc20ucykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fbWFsbG9jPWUuYXNtLnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9mcmVlPWUuYXNtLnUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5hc20udikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1mdW5jdGlvbigpe3JldHVybihlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1lLmFzbS53KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuYXNtLngpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5keW5DYWxsX3ZpPWZ1bmN0aW9uKCl7cmV0dXJuKGUuZHluQ2FsbF92aT1lLmFzbS55KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuZHluQ2FsbF92PWZ1bmN0aW9uKCl7cmV0dXJuKGUuZHluQ2FsbF92PWUuYXNtLnopLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5hc209T2UsZS50aGVuPWZ1bmN0aW9uKHQpe2lmKGplKXQoZSk7ZWxzZXt2YXIgbj1lLm9uUnVudGltZUluaXRpYWxpemVkO2Uub25SdW50aW1lSW5pdGlhbGl6ZWQ9ZnVuY3Rpb24oKXtuJiZuKCksdChlKX19cmV0dXJuIGV9LGZlPWZ1bmN0aW9uIGUoKXtqZXx8RGUoKSxqZXx8KGZlPWUpfSxlLnJ1bj1EZSxlLnByZUluaXQpZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnByZUluaXQmJihlLnByZUluaXQ9W2UucHJlSW5pdF0pO2UucHJlSW5pdC5sZW5ndGg+MDspZS5wcmVJbml0LnBvcCgpKCk7ZnVuY3Rpb24gemUoKXt9ZnVuY3Rpb24gTGUoZSl7cmV0dXJuKGV8fHplKS5fX2NhY2hlX199ZnVuY3Rpb24gVmUoZSx0KXt2YXIgbj1MZSh0KSxyPW5bZV07cmV0dXJuIHJ8fCgocj1PYmplY3QuY3JlYXRlKCh0fHx6ZSkucHJvdG90eXBlKSkucHRyPWUsbltlXT1yKX1mdW5jdGlvbiBxZShlLHQpe3JldHVybiBWZShlLnB0cix0KX1mdW5jdGlvbiBOZShlKXtpZighZS5fX2Rlc3Ryb3lfXyl0aHJvdyJFcnJvcjogQ2Fubm90IGRlc3Ryb3kgb2JqZWN0LiAoRGlkIHlvdSBjcmVhdGUgaXQgeW91cnNlbGY/KSI7ZS5fX2Rlc3Ryb3lfXygpLGRlbGV0ZSBMZShlLl9fY2xhc3NfXylbZS5wdHJdfWZ1bmN0aW9uIEdlKGUsdCl7cmV0dXJuIGUucHRyPT09dC5wdHJ9ZnVuY3Rpb24gWGUoZSl7cmV0dXJuIGUucHRyfWZ1bmN0aW9uIFllKGUpe3JldHVybiBlLl9fY2xhc3NfX31mdW5jdGlvbiAkZSgpe3Rocm93ImNhbm5vdCBjb25zdHJ1Y3QgYSBWb2lkUHRyLCBubyBjb25zdHJ1Y3RvciBpbiBJREwifWZ1bmN0aW9uIEplKCl7dGhpcy5wdHI9VGUoKSxMZShKZSlbdGhpcy5wdHJdPXRoaXN9cmV0dXJuIERlKCksemUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSx6ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9emUsemUucHJvdG90eXBlLl9fY2xhc3NfXz16ZSx6ZS5fX2NhY2hlX189e30sZS5XcmFwcGVyT2JqZWN0PXplLGUuZ2V0Q2FjaGU9TGUsZS53cmFwUG9pbnRlcj1WZSxlLmNhc3RPYmplY3Q9cWUsZS5OVUxMPVZlKDApLGUuZGVzdHJveT1OZSxlLmNvbXBhcmU9R2UsZS5nZXRQb2ludGVyPVhlLGUuZ2V0Q2xhc3M9WWUsJGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSwkZS5wcm90b3R5cGUuY29uc3RydWN0b3I9JGUsJGUucHJvdG90eXBlLl9fY2xhc3NfXz0kZSwkZS5fX2NhY2hlX189e30sZS5Wb2lkUHRyPSRlLCRlLnByb3RvdHlwZS5fX2Rlc3Ryb3lfXz0kZS5wcm90b3R5cGUuX19kZXN0cm95X189ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnB0cjtVZShlKX0sSmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSxKZS5wcm90b3R5cGUuY29uc3RydWN0b3I9SmUsSmUucHJvdG90eXBlLl9fY2xhc3NfXz1KZSxKZS5fX2NhY2hlX189e30sZS5Db250YWluZXI9SmUsSmUucHJvdG90eXBlLmluaXQ9SmUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMucHRyO2UmJiJvYmplY3QiPT09YShlKSYmKGU9ZS5wdHIpLHQmJiJvYmplY3QiPT09YSh0KSYmKHQ9dC5wdHIpLG4mJiJvYmplY3QiPT09YShuKSYmKG49bi5wdHIpLEZlKHIsZSx0LG4pfSxKZS5wcm90b3R5cGUud3JpdGVGcmFtZT1KZS5wcm90b3R5cGUud3JpdGVGcmFtZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5wdHI7ZSYmIm9iamVjdCI9PT1hKGUpJiYoZT1lLnB0ciksdCYmIm9iamVjdCI9PT1hKHQpJiYodD10LnB0ciksbiYmIm9iamVjdCI9PT1hKG4pJiYobj1uLnB0ciksSGUocixlLHQsbil9LEplLnByb3RvdHlwZS5fX2Rlc3Ryb3lfXz1KZS5wcm90b3R5cGUuX19kZXN0cm95X189ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnB0cjtNZShlKX0sZX0pOyJvYmplY3QiPT09YSh0KSYmIm9iamVjdCI9PT1hKGkpP2kuZXhwb3J0cz1wOnZvaWQgMD09PSh1PWZ1bmN0aW9uKCl7cmV0dXJuIHB9LmFwcGx5KHQsW10pKXx8KGkuZXhwb3J0cz11KX0pLmNhbGwodGhpcywiL2luZGV4LmpzIixuKDIpLCIvIixuKDMpKGUpKX1dKTt9fSk7","base64")))
      },
      OggOpusEncoderWasmPath: tob(Buffer("AGFzbQEAAAABtwVDYAF/AX9gBH9/f38AYAN/f38AYAF/AGACf38Bf2AFf39/f38AYAJ/fwBgA39/fwF/YAZ/f39/f38AYAZ/f39/f38Bf2AFf39/f38Bf2AEf39/fwF/YAAAYAd/f39/f39/AGABfAF8YAh/f39/f39/fwBgC39/f39/f39/f39/AGAHf39/f39/fwF/YAR/f39/AX1gCX9/f39/f39/fwBgCn9/f39/f39/f38AYA9/f39/f39/f39/f39/f38AYAR/f31/AGAEf35+fwBgAAF/YAp/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gBn98f39/fwF/YAJ+fwF/YAJ8fwF8YAJ8fAF8YAx/f39/f39/f39/f38AYBF/f39/f39/f39/f39/f39/fwBgFn9/f39/f39/f39/f39/f39/f39/f38AYBp/f39/f39/f39/f39/f39/f39/f39/f39/fwBgDH9/f39/fX1/f39/fwBgBH9/f30AYAN/f30AYAV/f31/fwBgCX9/fX1/f39/fwBgA399fwBgCX9/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2ASf39/f39/f39/f39/f39/f39/AX9gD39/f39/f39/f39/f399fwF/YAp/f39/f39/f31/AX9gC39/f39/f39/fX9/AX9gCX9/f39/f399fwF/YAd/f39/f399AX9gCX9/f39/f31/fwF/YAt/f39/f399fX9/fwF/YAR/f39+AX9gA35/fwF/YAF9AX9gAn1/AX9gAnx/AX9gA39+fwF+YAN/f38BfWAJf39/f39/f39/AX1gE39/f39/f39/f39/f39/f39/f38BfWAGf39/f31/AX1gBn9/fX9/fwF9YAR9fX9/AX1gAn9/AXxgA39/fwF8YAJ+fgF8YAN8fH8BfAJMCgFhAWEAAQFhAWIACwFhAWMADAFhAWQABgFhAWUACgFhAWYABwFhAWcAAAFhAWgAAAFhBm1lbW9yeQIBgAKAAgFhBXRhYmxlAXAAJAPRAs8CBwEHBwMANQI/BQIHBwACLgAHAAsdHAADAAAJL0IeDgAAQAYGAgQFAwADBAUABh4MDgUFJQEAAQQACAIBAgAKAAATBhoNCAgHAAUBAg4OBQUBCwUHAAEEBAQDAgAdBAcIPgAnKgcKBwQ6AQAQAQIA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ACACRQ0AGiAEQQh1IgEgBEEBcUUNABogAigCACABaigCAAsgAmogA0ECIARBAnEbIAAoAgAoAhwRAQALHAAgABDFAiABBEAgACABEMICIAAgARC+AgsgAAsLACAAIAE2AgAgAAsjACAAQQA2AgwgACABNgIEIAAgATYCACAAIAFBAWo2AgggAAspAQF/IwBBEGsiASQAIAFBADYCDEGIGigCACIBIAAQugEgARCuARACAAujAgACQAJAIAFBFEsNACABQXdqIgFBCUsNAAJAAkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQQoRBgALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0IBA38gACgCACwAABAhBEADQCAAKAIAIgIsAAAhAyAAIAJBAWo2AgAgAyABQQpsakFQaiEBIAIsAAEQIQ0ACwsgAQt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBkIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLEgAgAEUEQEEADwsgACABEL4BC+4FAgp/AX4CQCAARQ0AIAAoAhwiB0H/ASAHQf8BSBsiA0UNACAAKAIAIghFDQACQAJAAkAgACgCzAIiCQRAIAdBAU4NAUJ/IQ1BACEDDAILIANBACADQQBKGyEDA0AgAyAFRg0CIAVBAnQhBiAFQQFqIgQhBSAGIAAoAhBqLQAAQf8BRg0ACyAEIQMMAQsgA0EBIANBAUobIQRCfyENQQAhAwJAA0AgBUGAIEwgBkEDTHJFBEBBASECDAILQQAhBiAAKAIQIANBAnRqLQAAIgpB/wFHBEAg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BUGBAiAFQYECSBshBkEBIARB6QdHDQEaIA1BwANqIAZBfmpBgAIQLEEBDAELIABBADYCwG5BACEGQQALIQUCfyASKAIAIgdB6AdGBEAgDSgC3AMhBCANKALUAyEIIA1BwANqEJYBIAggBGdqQWdqQQN1IgwMAQsgDUHAA2ogGCAGayIMECtBAAshCAJAAkAgBUUEQCASKAIAQegHRg0BCyANIA1BqARqNgLwASAOQabOACANQfABahALGiASKAIAQekHRw0AIA0gACgCZDYCuAMgDSAAKAJoNgK8AyANIA1BuANqNgLQASAOQazOACANQdABahALGgwBCyANQQA2AuABIA5BrM4AIA1B4AFqEAsaCyAUQQBHIAVxIgRBAUYEQCANQQA2AsABIA5Bms4AIA1BwAFqEAsaIA1BADYCsAEgDkGmHyANQbABahALGiANQX82AqABIA5Boh8gDUGgAWoQCxpBfSAOIBEgACgCkAFByAFtIAwgF2ogBkEAECJBAEgNARogDSANQegEajYCkAEgDkG/HyANQZABahALGiAOQbwfQQAQCxoLIA1BAEERIAdB6gdGGzYCgAEgDkGazgAgDUGAAWoQCxoCQCASKAIAIgdB6AdGDQAgByAAKAKsbiILRiALQQFIckUEQCAOQbwfQQAQCxogDiAJIAAoApABQZADbSANQbgDakECQQAQIhogDUEANgJwIA5Bks4AIA1B8ABqEAsaCyANKALUAyANKALcA2dqQWBqIAxBA3RKDQACQCAERQ0AIBIoAgBB6QdHDQAgACgClAFFDQAgDSAAKAKgASAAKAIkazYCYCAOQaIfIA1B4ABqEAsaCyANIAAoApQBNgJQIA5Bph8gDUHQAGoQCxpBfSAOIBEgAkEAIAwgDUHAA2oQIiIIQQBIDQEaIARFDQAgEigCAEHpB0cNACAAKAKUAUUNACAIIBdqIAwgF2ogBhATGiAGIAxqIQwLAkAgFCAFRXJFBEAgACgCkAEhBCAOQbwfQQAQCxogDUEANgJAIA5Bms4AIA1BQGsQCxogDUEANgIwIA5Bks4AIA1BMGoQCxogDUEANgIgIA5Bph8gDUEgahALGiANQX82AhAgDkGiHyANQRBqEAsaIARBkANtIQcgBEHIAW0hBCAAKAKobkHpB0YEQCANQcADaiAIECsgCCEMCyAOIBEgACgC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ABAUBEAgASACIAMQRA8LIAAoAgwhBCAAQRBqIgUgASACIAMQXQJAIARBAkgNACAFIARBA3RqIQQgAEEYaiEAA0AgACABIAIgAxBdIAEtADYNASAAQQhqIgAgBEkNAAsLCzEAIAAgASgCCEEAEBQEQCABIAIgAxBEDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRAQALGAAgACABKAIIQQAQFARAIAEgAiADEEQLC6gCAQR/IwBBQGoiASQAIAAoAgAiAkF8aigCACEDIAJBeGooAgAhBCABQQA2AhQgAUH0GzYCECABIAA2AgwgAUGkHDYCCEEAIQIgAUEYakEAQScQChogACAEaiEAAkAgA0GkHEEAEBQEQCABQQE2AjggAyABQQhqIAAgAEEBQQAgAygCACgCFBEIACAAQQAgASgCIEEBRhshAgwBCyADIAFBCGogAEEBQQAgAygCACgCGBEFACABKAIsIgBBAUsNACAAQQFrBEAgASgCHEEAIAEoAihBAUYbQQAgASgCJEEBRhtBACABKAIwQQFGGyECDAELIAEoAiBBAUcEQCABKAIwDQEgASgCJEEBRw0BIAEoAihBAUcNAQsgASgCGCECCyABQUBrJAAgAgueAQEBfyMAQUBqIgMkAAJ/QQEgACABQQAQFA0AGkEAIAFFDQAaQQAgARCmASIBRQ0AGiADQX82AhQgAyAANgIQIANBADYCDCADIAE2AgggA0EYakEAQScQChogA0EBNgI4IAEgA0EIaiACKAIAQQEgASgCACgCHBEBAEEAIAMoAiBBAUcNABogAiADKAIYNgIAQQELIQAgA0FAayQAIAALSgECfwJAIAAtAAAiAkUgAiABLQAAIgNHcg0AA0AgAS0AASEDIAAtAAEiAkUNASABQQFqIQEgAEEBaiEAIAIgA0YNAAsLIAIgA2sLCABBmhsQYQALMgEBfyMAQRBrIgEkACABQQhqIAAoAgQQXygCAEEBOgAAIAAoAghBAToAACABQRBqJAALMwECfwJAIAAoAggiAC0AACICQQFHBH8gAkECcQ0BIABBAjoAAEEBBUEACw8LQeQaEGEACzUBAn8jAEEQayIBJAAgAUEIaiAAKAIEEF8oAgAtAABBAUcEQCAAEKsBIQILIAFBEGokACACC1ABA38jAEEQayIBJAAgAUE2EF4iAigCACIDEMoBIAAgAyACEFxBf0EAEDMgAEEBEDJFBEBB1QlBtAlBxwBB7wkQAAALIAIQoAEgAUEQaiQAC3oBAX8gACgCTEEASARAAkAgACwAS0EKRg0AIAAoAhQiASAAKAIQTw0AIAAgAUEBajYCFCABQQo6AAAPCyAAEJ4BDwsCQAJAIAAsAEtBCkYNACAAKAIUIgEgACgCEE8NACAAIAFBAWo2AhQgAUEKOgAADAELIAAQngELCyQAIABBC08EfyAAQRBqQXBxIgAgAEF/aiIAIABBC0YbBUEKCwuPAQEDfyMAQRBrIgQkAEFvIAJPBEACQCACQQpNBEAgACACOgALIAAhAwwBC0F/IAIQrwFBAWoiBSIDSQRAEDcACyAAIAMQRyIDNgIAIAAgBUGAgICAeHI2AgggACACNgIECyACBEAgAyABIAIQCBoLIARBADoADyACIANqIAQtAA86AAAgBEEQaiQADwsQNwALOwEBfyMAQRBrIgMkACAAKAI8IAGnIAFCIIinIAJB/wFxIANBCGoQBBBFGiADKQMIIQEgA0EQaiQAIAELxwIBBn8jAEEgayIDJAAgAyAAKAIcIgQ2AhAgACgCFCEFIAMgAjYCHCADIAE2AhggAyAFIARrIgE2AhQgASACaiEEQQIhBiADQRBqIQECfwJAAkAgACgCPCADQRBqQQIgA0EMahABEEVFBEADQCAEIAMoAgwiBUYNAiAFQX9MDQMgAUEIaiABIAUgASgCBCIHSyIIGyIBIAUgB0EAIAgbayIHIAEoAgBqNgIAIAEgASgCBCAHazYCBCAEIAVrIQQgACgCPCABIAYgCGsiBiADQQxqEAEQRUUNAAsLIANBfzYCDCAEQX9HDQELIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhAgAgwBCyAAQQA2AhwgAEIANwMQIAAgACgCAEEgcjYCAEEAIAZBAkYNABogAiABKAIEawshBCADQSBqJAAgBAtRAQN/IwBBEGsiASQAIAAgAUETEF4iAigCACIDEOABIAAgAyACEFxBf0EAEDMgAEEBEDJFBEBB1QlBtAlBO0HhCRAAAAsgAhCgASABQRBqJAALCQAgACgCPBAHCykAIAEgASgCAEEPakFwcSIBQRBqNgIAIAAgASkDACABKQMIELsBOQMAC8kWAxF/An4BfCMAQbAEayIJJAAgCUEANgIsAn8gAb0iF0J/VwRAQQEhEiABmiIBvSEXQeAZDAELIARBgBBxBEBBASESQeMZDAELQeYZQeEZIARBAXEiEhsLIRYCQCAXQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEkEDaiIMIARB//97cRARIAAgFiASEA8gAEH7GUH/GSAFQQV2QQFxIgMbQfMZQfcZIAMbIAEgAWIbQQMQDwwBCyAJQRBqIRECQAJ/AkAgASAJQSxqEGQiASABoCIBRAAAAAAAAAAAYgRAIAkgCSgCLCIGQX9qNgIsIAVBIHIiEEHhAEcNAQwDCyAFQSByIhBB4QBGDQIgCSgCLCEKQQYgAyADQQBIGwwBCyAJIAZBY2oiCjYCLCABRAAAAAAAALBBoiEBQQYgAyADQQBIGwshCyAJQTBqIAlB0AJqIApBAEgbIg4hCANAIAgCfyABRAAAAAAAAPBBYyABRAAAAAAAAAAAZnEEQCABqwwBC0EACyIDNgIAIAhBBGohCCABIAO4oUQAAAAAZc3NQaIiAUQAAAAAAAAAAGINAAsCQCAKQQFIBEAgCCEGIA4hBwwBCyAOIQcDQCAKQR0gCkEdSBshDQJAIAhBfGoiBiAHSQ0AIA2tIRhCACEXA0AgBiAXQv////8PgyAGNQIAIBiGfCIXIBdCgJTr3AOAIhdCgJTr3AN+fT4CACAGQXxqIgYgB08NAAsgF6ciA0UNACAHQXxqIgcgAzYCAAsDQCAIIgYgB0sEQCAGQXxqIggoAgBFDQELCyAJIAkoAiwgDWsiCjYCLCAGIQggCkEASg0ACwsgCkF/TARAIAtBGWpBCW1BAWohEyAQQeYARiEUA0BBCUEAIAprIApBd0gbIRUCQCAHIAZPBEAgByAHQQRqIAcoAgAbIQcMAQtBgJTr3AMgFXYhD0F/IBV0QX9zIQ1BACEKIAchCANAIAggCCgCACIDIBV2IApqNgIAIAMgDXEgD2whCiAIQQRqIgggBkkNAAsgByAHQQRqIAcoAgAbIQcgCkUNACAGIAo2AgAgBkEEaiEGCyAJIAkoAiwgFWoiCjYCLCAOIAcgFBsiAyATQQJ0aiAGIAYgA2tBAnUgE0obIQYgCkEASA0ACwtBACEIAkAgByAGTw0AIA4gB2tBAnVBCWwhCEEKIQogBygCACIDQQpJDQADQCAIQQFqIQggAyAKQQpsIgpPDQALCyALQQAgCCAQQeYARhtrIBBB5wBGIAtBAEdxayIDIAYgDmtBAnVBCWxBd2pIBEAgA0GAyABqIg1BCW0iA0ECdCAOakGEYGohDEEKIQogDSADQQlsayIDQQdMBEADQCAKQQpsIQogA0EBaiIDQQhHDQALCwJAQQAgBiAMQQRqIhNGIAwoAgAiDyAPIApuIg0gCmxrIhQbDQBEAAAAAAAA4D9EAAAAAAAA8D9EAAAAAAAA+D8gFCAKQQF2IgNGG0QAAAAAAAD4PyAGIBNGGyAUIANJGyEZRAEAAAAAAEBDRAAAAAAAAEBDIA1BAXEbIQECQCASRQ0AIBYtAABBLUcNACAZmiEZIAGaIQELIAwgDyAUayIDNgIAIAEgGaAgAWENACAMIAMgCmoiAzYCACADQYCU69wDTwRAA0AgDEEANgIAIAxBfGoiDCAHSQRAIAdBfGoiB0EANgIACyAMIAwoAgBBAWoiAzYCACADQf+T69wDSw0ACwsgDiAHa0ECdUEJbCEIQQohCiAHKAIAIgNBCkkNAANAIAhBAWohCCADIApBCmwiCk8NAAsLIAxBBGoiAyAGIAYgA0sbIQYLAn8DQEEAIAYiDSAHTQ0BGiANQXxqIgYoAgBFDQALQQELIQoCQCAQQecARwRAIARBCHEhEAwBCyAIQX9zQX8gC0EBIAsbIgYgCEogCEF7SnEiAxsgBmohC0F/QX4gAxsgBWohBSAEQQhxIhANAEEJIQYCQCAKRQ0AIA1BfGooAgAiD0UNAEEKIQNBACEGIA9BCnANAANAIAZBAWohBiAPIANBCmwiA3BFDQALCyANIA5rQQJ1QQlsQXdqIQMgBUEgckHmAEYEQEEAIRAgCyADIAZrIgNBACADQQBKGyIDIAsgA0gbIQsMAQtBACEQIAsgAyAIaiAGayIDQQAgA0EAShsiAyALIANIGyELCyALIBByIhVBAEchFCAAQSAgAgJ/IAhBACAIQQBKGyAFQSByIg9B5gBGDQAaIBEgCCAIQR91IgNqIANzrSAREB0iBmtBAUwEQANAIAZBf2oiBkEwOgAAIBEgBmtBAkgNAAsLIAZBfmoiEyAFOgAAIAZBf2pBLUErIAhBAEgbOgAAIBEgE2sLIAsgEmogFGpqQQFqIgwgBBARIAAgFiASEA8gAEEwIAIgDCAEQYCABHMQEQJAAkACQCAPQeYARgRAIAlBEGpBCHIhAyAJQRBqQQlyIQggDiAHIAcgDksbIgUhBwNAIAc1AgAgCBAdIQYCQCAFIAdHBEAgBiAJQRBqTQ0BA0AgBkF/aiIGQTA6AAAgBiAJQRBqSw0ACwwBCyAGIAhHDQAgCUEwOgAYIAMhBgsgACAGIAggBmsQDyAHQQRqIgcgDk0NAAsgFQRAIABBgxpBARAPCyALQQFIIAcgDU9yDQEDQCAHNQIAIAgQHSIGIAlBEGpLBEADQCAGQX9qIgZBMDoAACAGIAlBEGpLDQALCyAAIAYgC0EJIAtBCUgbEA8gC0F3aiEGIAdBBGoiByANTw0DIAtBCUohAyAGIQsgAw0ACwwCCwJAIAtBAEgNACANIAdBBGogChshBSAJQRBqQQhyIQMgCUEQakEJciEOIAchCANAIA4gCDUCACAOEB0iBkYEQCAJQTA6ABggAyEGCwJAIAcgCEcEQCAGIAlBEGpNDQEDQCAGQX9qIgZBMDoAACAGIAlBEGpLDQALDAELIAAgBkEBEA8gBkEBaiEGIBBFQQAgC0EBSBsNACAAQYMaQQEQDwsgACAGIA4gBmsiBiALIAsgBkobEA8gCyAGayELIAhBBGoiCCAFTw0BIAtBf0oNAAsLIABBMCALQRJqQRJBABARIAAgEyARIBNrEA8MAgsgCyEGCyAAQTAgBkEJakEJQQAQEQsMAQsgFkEJaiAWIAVBIHEiDhshDQJAIANBC0sNAEEMIANrIgZFDQBEAAAAAAAAIEAhGQNAIBlEAAAAAAAAMECiIRkgBkF/aiIGDQALIA0tAABBLUYEQCAZIAGaIBmhoJohAQwBCyABIBmgIBmhIQELIBEgCSgCLCIGIAZBH3UiBmogBnOtIBEQHSIGRgRAIAlBMDoADyAJQQ9qIQYLIBJBAnIhCyAJKAIsIQggBkF+aiIPIAVBD2o6AAAgBkF/akEtQSsgCEEASBs6AAAgBEEIcSEIIAlBEGohBwNAIAciBQJ/IAGZRAAAAAAAAOBBYwRAIAGqDAELQYCAgIB4CyIGQdAZai0AACAOcjoAACAFQQFqIgcgCUEQamtBAUcgCCADQQBKckVBACABIAa3oUQAAAAAAAAwQKIiAUQAAAAAAAAAAGEbckUEQCAFQS46AAEgBUECaiEHCyABRAAAAAAAAAAAYg0ACyAAQSAgAiALIBEgCUEQamsgD2sgB2ogAyARaiAPa0ECaiADRSAHIAlrQW5qIANOchsiA2oiDCAEEBEgACANIAsQDyAAQTAgAiAMIARBgIAEcxARIAAgCUEQaiAHIAlBEGprIgUQDyAAQTAgAyAFIBEgD2siA2prQQBBABARIAAgDyADEA8LIABBICACIAwgBEGAwABzEBEgCUGwBGokACACIAwgDCACSBsLNAAgAFBFBEADQCABQX9qIgEgAKdBD3FB0BlqLQAAIAJyOgAAIABCBIgiAEIAUg0ACwsgAQstACAAUEUEQANAIAFBf2oiASAAp0EHcUEwcjoAACAAQgOIIgBCAFINAAsLIAELWQAgACABIAIgAxBxIABBEGogAxDGAQRAQagJQbQJQR5B0AkQAAALIABCADcDiAMgAEIANwKUAyAAQQE2ApADIABCADcCnAMgAEEANgKkAyAAELMBIAAQrQELyAIBBH8jAEHQAWsiAiQAIAJBADYCzAEgAkGgAWpBAEEoEAoaIAIgAigCzAE2AsgBAkBBACABIAJByAFqIAJB0ABqIAJBoAFqEEZBAEgNACAAKAJMQQBOBEBBASEECyAAKAIAIQMgACwASkEATARAIAAgA0FfcTYCAAsgA0EgcSEFAn8gACgCMARAIAAgASACQcgBaiACQdAAaiACQaABahBGDAELIABB0AA2AjAgACACQdAAajYCECAAIAI2AhwgACACNgIUIAAoAiwhAyAAIAI2AiwgACABIAJByAFqIAJB0ABqIAJBoAFqEEYgA0UNABogAEEAQQAgACgCJBEHABogAEEANgIwIAAgAzYCLCAAQQA2AhwgAEEANgIQIAAoAhQaIABBADYCFEEACxogACAAKAIAIAVyNgIAIARFDQALIAJB0AFqJAAL2QMCAn8CfiMAQSBrIgIkAAJAIAFC////////////AIMiBUKAgICAgIDA/0N8IAVCgICAgICAwIC8f3xUBEAgAUIEhiAAQjyIhCEEIABC//////////8PgyIAQoGAgICAgICACFoEQCAEQoGAgICAgICAwAB8IQQMAgsgBEKAgICAgICAgEB9IQQgAEKAgICAgICAgAiFQgBSDQEgBEIBgyAEfCEEDAELIABQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgAUIEhiAAQjyIhEL/////////A4NCgICAgICAgPz/AIQhBAwBC0KAgICAgICA+P8AIQQgBUL///////+//8MAVg0AQgAhBCAFQjCIpyIDQZH3AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBCADQf+If2oQvQEgAiAAIARBgfgAIANrELwBIAIpAwhCBIYgAikDACIAQjyIhCEEIAIpAxAgAikDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgBEIBfCEEDAELIABCgICAgICAgIAIhUIAUg0AIARCAYMgBHwhBAsgAkEgaiQAIAQgAUKAgICAgICAgIB/g4S/C1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC1ABAX4CQCADQcAAcQRAIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAiADrSIEhiABQcAAIANrrYiEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC4sCAAJAIAAEfyABQf8ATQ0BAkBB4OECKAIAKAIARQRAIAFBgH9xQYC/A0YNAwwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAsANPQQAgAUGAQHFBgMADRxtFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIB8akH//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDwsLQfDjAkEZNgIAQX8FQQELDwsgACABOgAAQQELvAEBAX8gAUEARyECAkACQAJAAkAgAUUgAEEDcUVyDQADQCAALQAARQ0CIABBAWohACABQX9qIgFBAEchAiABRQ0BIABBA3ENAAsLIAJFDQELIAAtAABFDQECQCABQQRPBEADQCAAKAIAIgJBf3MgAkH//ft3anFBgIGChHhxDQIgAEEEaiEAIAFBfGoiAUEDSw0ACwsgAUUNAQsDQCAALQAARQ0CIABBAWohACABQX9qIgENAAsLQQAPCyAAC00BAn8CQCAARQ0AIAAo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BygCSBAMIAcoAkwQDCAHKAI8EAwgBygCRBAMIAcoAkAQDCAHEAxBACEHCyAGRQ0AIAYgADYCAAsgBwsTACAAIAEgAiABIAIgAyAEENYBC84BAQJ/IwBBEGsiASQAAkAgAL1CIIinQf////8HcSICQfvDpP8DTQRAIAJBgIDA8gNJDQEgAEQAAAAAAAAAAEEAECQhAAwBCyACQYCAwP8HTwRAIAAgAKEhAAwBCyAAIAEQeEEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwhBARAkIQAMAwsgASsDACABKwMIECUhAAwCCyABKwMAIAErAwhBARAkmiEADAELIAErAwAgASsDCBAlmiEACyABQRBqJAAgAAu6FwEDfyMAQeABayIDJAAgAyACNgLcASAAIAAoAgBqIQRBeyECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQeBgaiIFQS9LBEAgAUHhsX9qIgVBC00NASABQYaqf2oiAUERSw0mAkACQAJAIAFBAWsOESkpKSkpKSkpKSkpKSkpKQABAgsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFqQeUASw0oIAAgATYCjAFBACECDCgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwoCyABIAAoAowBNgIAQQAhAgwnCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGYeGpBA08EQEF/IQIgAUGYeEcNJwsgACABNgKIAUEAIQIMJgsgBUEBaw4vIyIhHh0SERwbGBcWFRQTGhklJRAPIB8ODSUMAQslCiUlJSUJCCUlBwYFBCUlAwIkCwJAAkACQCAFQQFrDgsnJycnJycnJwInAQALIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwnCyADIAA2AnAgBEGfzgAgA0HwAGoQCyECDCYLIAMgAygC3AEiAUEEajYC3AEgACABKAIAIgA2AshuIAMgADYCYCAEQarOACADQeAAahALIQIMJQsgAyADKALcASIBQQRqNgLcASAAIAEoAgAiADYCsAEgAyAANgJQIARBqM4AIANB0ABqEAshAgwkCyAAKAIEIQEg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BCACIApqIAxqQQF0ai4BAEEDdSIOIA5saiEDIAJBAWoiAiAFRw0ACyABIANqIgFB/////wcgAUH/////B0kbIQEgCEEDbCEIIAYoAgAhBkEAIQJBACEDA0AgAyAEIAIgCGogBmpBAXRqLgEAQQN1IgogCmxqIQMgAkEBaiICIAVHDQALCyALIAEgA0EBdmoiAUH/////ByABQf////8HSRs2AgAgDSADNgI4IAlBAWoiCUEERw0AC0EAIQUgACgCjAEiCUHnB0wEQEH//wEgCUEEdUEBam0hBQtB/////wcgBygCICIIIAAoAnxqIgFB/////wcgAUH/////B0kbIgRuIQNBgAEhASAAAn9BgAEgBCAAKAJcIgJBA3RKDQAaQYAIIAQgAkgNABogAkEQdEEQdSIEIANBEHZsIAMgAkEPdUEBakEBdWxqIANB//8DcSAEbEEQdWoiAkEQdUELdCACQQV2Qf8PcXILIgIgBSACIAVKG0EQdEEQdSICIAMgACgCbCIDayIEQRB1bCADaiACIARB//8DcWxBEHVqIgM2AmwgAEH/////ByADbSIDQf///wcgA0H///8HSBsiAzYCXEH/////ByAHKAIkIgogACgCgAFqIgJB/////wcgAkH/////B0kbIgZuIQICQCAGIAAoAmAiBEEDdEoNAEGACCEBIAYgBEgNACAEQRB0QRB1IgEgAkEQdmwgAiAEQQ91QQFqQQF1bGogAkH//wNxIAFsQRB1aiIBQRB1QQt0IAFBBXZB/w9xciEBCyAAIAEgBSABIAVKG0EQdEEQdSIBIAIgACgCcCICayIEQRB1bCACaiABIARB//8DcWxBEHVqIgE2AnAgAEH/////ByABbSIBQf///wcgAUH///8HSBs2AmBB/////wcgBygCKCIMIAAoAoQBaiIBQf////8HIAFB/////wdJGyIGbiECQYABIQEgAAJ/QYABIAYgACgCZCIEQQN0Sg0AGkGACCAGIARIDQAaIARBEHRBEHUiBiACQRB2bCACIARBD3VBAWpBAXVsaiACQf//A3EgBmxBEHVqIgRBEHVBC3QgBEEFdkH/D3FyCyIEIAUgBCAFShtBEHRBEHUiBCACIAAoAnQiAmsiBkEQdWwgAmogBCAGQf//A3FsQRB1aiICNgJ0IABB/////wcgAm0iAkH///8HIAJB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TW9kdWxlLkhFQVBVOC5idWZmZXIsIGJ1ZiwgbGVuKTsgTW9kdWxlLmVuY29kZWRCdWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYXJyYXkpLmJ1ZmZlcik7IH0AAAAAAIwFAAABAAAAAgAAAHJlc3VsdCA9PSAwAC9idWlsZC9zcmMvT2dnQ29udGFpbmVyLmNwcABpbml0AHJlc3VsdCAhPSAwAHByb2R1Y2VJRFBhZ2UAcHJvZHVjZUNvbW1lbnRQYWdlACFvZ2dfc3RyZWFtX2NoZWNrKCZzdHJlYW1fc3RhdGVfKQBwcm9kdWNlUGFja2V0UGFnZQAhKGRhdGEgPT0gbnVsbHB0ciAmJiBzaXplID4gMCkAd3JpdGVQYWNrZXQAIW9nZ19zdHJlYW1fZW9zKCZzdHJlYW1fc3RhdGVfKQA5Q29udGFpbmVyALwOAACBBQAAAAAAAAEAAADYBgAAAAAAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAANgGAAAHAAAACAAAAHNhbXBsZV9yYXRlID09IDQ4MDAwAC9idWlsZC9zcmMvQ29udGFpbmVySW50ZXJmYWNlLmNwcABpbml0AGNoYW5uZWxfY291bnQgPiAwICYmIGNoYW5uZWxfY291bnQgPD0gMgBoZWFkZXIAd3JpdGVPcHVzSWRIZWFkZXIAT3B1c0hlYWQAd3JpdGVPcHVzQ29tbWVudEhlYWRlcgBPcHVzVGFncwBvcHVzLW1lZGlhLXJlY29yZGVyAFRJVExFPXJlY29yZGluZwAxOENvbnRhaW5lckludGVyZmFjZQAAOA4AAMIGAAAAAAAAtx3BBG47ggnZJkMN3HYEE2trxReyTYYaBVBHHrjtCCYP8Mki1taKL2HLSytkmww104bNMQqgjjy9vU84cNsRTMfG0Ege4JNFqf1SQaytFV8bsNRbwpaXVnWLVlLINhlqfyvYbqYNm2MREFpnFEAdeaNd3H16e59wzWZedOC2I5hXq+Kcjo2hkTmQYJU8wCeLi93mj1L7pYLl5mSGWFsrvu9G6ro2YKm3gX1os4QtL60zMO6p6hatpF0LbKCQbTLUJ3Dz0P5WsN1JS3HZTBs2x/sG98MiILTOlT11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ycm8vLCNQijBwcHBwcHBwcHBwcHCwsK4uK2LQSfMzMzMzMzMzMnJycnGxsa7u6+MQigAQcK7AQu5KWAAwAAgAYABIACAAOAAQAGgAUAAoAAAAWABwAEIAGgAyAAoAYgBKACIAOgASAGoAUgAqAAIAWgByAEQAHAA0AAwAZABMACQAPAAUAGwAVAAsAAQAXAB0AEYAHgA2AA4AZgBOACYAPgAWAG4AVgAuAAYAXgB2AEEAGQAxAAkAYQBJACEAOQARAGkAUQApAAEAWQBxAEMAGwAzAAsAYwBLACMAOwATAGsAUwArAAMAWwBzAEUAHQA1AA0AZQBNACUAPQAVAG0AVQAtAAUAXQB1AEcAHwA3AA8AZwBPACcAPwAXAG8AVwAvAAcAXwB3AEBAGEAwQAhAYEBIQCBAOEAQQGhAUEAoQABAWEBwQEJAGkAyQApAYkBKQCJAOkASQGpAUkAqQAJAWkByQERAHEA0QAxAZEBMQCRAPEAUQGxAVEAsQARAXEB0QEZAHkA2QA5AZkBOQCZAPkAWQG5AVkAuQAZAXkB2QEFAGUAxQAlAYUBJQCFAOUARQGlAUUApQAFAWUBxQENAG0AzQAtAY0BLQCNAO0ATQGtAU0ArQANAW0BzQEVAHUA1QA1AZUBNQCVAPUAVQG1AVUAtQAVAXUB1QEdAH0A3QA9AZ0BPQCdAP0AXQG9AV0AvQAdAX0B3QECAGIAwgAiAYIBIgCCAOIAQgGiAUIAogACAWIBwgEKAGoAygAqAYoBKgCKAOoASgGqAUoAqgAKAWoBygESAHIA0gAyAZIBMgCSAPIAUgGyAVIAsgASAXIB0gEaAHoA2gA6AZoBOgCaAPoAWgG6AVoAugAaAXoB2gEGAGYAxgAmAYYBJgCGAOYARgGmAUYApgAGAWYBxgEOAG4AzgAuAY4BLgCOAO4ATgGuAU4ArgAOAW4BzgEWAHYA1gA2AZYBNgCWAPYAVgG2AVYAtgAWAXYB1gEeAH4A3gA+AZ4BPgCeAP4AXgG+AV4AvgAeAX4B3gEDAGMAwwAjAYMBIwCDAOMAQwGjAUMAowADAWMBwwELAGsAywArAYsBKwCLAOsASwGrAUsAqwALAWsBywETAHMA0wAzAZMBMwCTAPMAUwGzAVMAswATAXMB0wEbAHsA2wA7AZsBOwCbAPsAWwG7AVsAuwAbAXsB2wEHAGcA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aAAQACgAQABYAHAABAAcADQATABkAAwAJAA8AFQAbAAUACwARABcAHQAAQAZADEASQBhAAkAIQA5AFEAaQARACkAQQBZAHEABQAdADUATQBlAA0AJQA9AFUAbQAVAC0ARQBdAHUAAgAaADIASgBiAAoAIgA6AFIAagASACoAQgBaAHIABgAeADYATgBmAA4AJgA+AFYAbgAWAC4ARgBeAHYAAwAbADMASwBjAAsAIwA7AFMAawATACsAQwBbAHMABwAfADcATwBnAA8AJwA/AFcAbwAXAC8ARwBfAHcAeAAAAIiICDwCAAAABQAYAAMACAACAAQABAABAEG85wELBqByAACAYQBB0ucBC40BDAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7ADwAAACJiIg8AwAAAAUADAADAAQABAABAEH06AELLNBzAACAYQAAAAAAAAAAnT4AQF4+AMAEPgCA7T4AQIk+AAAAAADATD8AAM09AEGx6QELowH/AP8A/wD/AP8A/gEAAf8A/gD9AgAB/wD+AP0DAAH/lYsAADeYAAD/pQAABLUAAGfFAABF1wAAweoAAP//AAAAAM5AAADIQAAAuEAAAKpAAACiQAAAmkAAAJBAAACMQAAAnEAAAJZAAACSQAAAjkAAAJxAAACUQAAAikAAAJBAAACMQAAAlEAAAJhAAACOQAAAcEAAAHBAAABwQAAAcEAAAHBAAEHg6gEL8gJIf0GBQoBBgECAPoBAgECAXE5cT1xOWk90KXMociiEGoQakRGhDLAKsQsYszCKNoc2hDWGOIU3hDeEPXJGYEpYS1hXSllCW0NkO2wyeCh6JWErTjJTTlRRWEtWSldHWkldSl1KbShyJHUidSKPEZESkhOiDKUKsge9Br4IsQkXsjZzP2ZCYkVjSllHW0lbTllWUFxCXUBmO2c8aDx1NHssiiOFH2EmTS09Wl08aSprKW4tdCZxJnAmfBqEG4gTjBSbDp8QnhKqDbEKuwjABq8JnwoVsjtuR1ZLVVRTW0JYSVdIXEtiSGk6azZzNHI3cDiBM4QoliGMHWIjTSoqeWBCbCtv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","base64")),
      WebMOpusEncoderWasmPath: tob(Buffer("AGFzbQEAAAABngZTYAF/AX5gA39/fwF/YAF/AX9gBH9/f38AYAF/AGACf38Bf2ADf39/AGAFf39/f38AYAJ/fwBgAn9+AX9gBn9/f39/fwBgA39+fgBgBn9/f39/fwF/YAR/f39/AX9gBX9/f39/AX9gAABgB39/f39/f38AYAF8AXxgAn9/AX5gAAF/YAh/f39/f39/fwBgC39/f39/f39/f39/AGAHf39/f39/fwF/YAN/fn4Bf2AEf39/fwF9YAl/f39/f39/f38AYAp/f39/f39/f39/AGAPf39/f39/f39/f39/f39/AGAEf399fwBgBH9+fn8AYAp/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gBn98f39/fwF/YAJ+fwF/YAN/f38BfmADf35/AX5gAn5+AX5gAnx/AXxgAnx8AXxgDH9/f39/f39/f39/fwBgEX9/f39/f39/f39/f39/f39/AGAWf39/f39/f39/f39/f39/f39/f39/fwBgGn9/f39/f39/f39/f39/f39/f39/f39/f39/AGAMf39/f399fX9/f39/AGAEf39/fQBgBX9/fn5+AGADf399AGAFf399f38AYAl/f319f39/f38AYAJ/fgBgA399fwBgCX9/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2ASf39/f39/f39/f39/f39/f39/AX9gD39/f39/f39/f39/f399fwF/YAp/f39/f39/f31/AX9gC39/f39/f39/fX9/AX9gCX9/f39/f399fwF/YAd/f39/f399AX9gCX9/f39/f31/fwF/YAt/f39/f399fX9/fwF/YAN/fn8Bf2AEf35/fgF/YAR/fn5/AX9gA39+fQF/YAN+f38Bf2ABfQF/YAJ9fwF/YAJ8fwF/YAJ/fgF+YAJ+fwF+YAN+f34BfmACfn0BfmADf39/AX1gCX9/f39/f39/fwF9YBN/f39/f39/f39/f39/f39/f39/AX1gBn9/f399fwF9YAZ/f31/f38BfWAEfX1/fwF9YAJ/fwF8YAN/f38BfGACfn4BfGADfHx/AXwCag8BYQFhAAMBYQFiAA8BYQFjAAIBYQFkAA0BYQFlAAEBYQFmAA0BYQFnAAEBYQFoAAEBYQFpAAIBYQFqAA4BYQFrAAEBYQFsAAIBYQFtAAgBYQZtZW1vcnkC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NgI8DAULIAMgAygCDCIBQQRqNgIMIAEoAgAiAUH0A0wEQEF/IQIgAUF/Rw0GCyAAIAEgACgCBEGg7w9sIgAgASAASBs2AigMBAsgAyADKAIMIgFBBGo2AgwgACABKAIANgIsDAMLIAMgAygCDCIBQQRqNgIMIAAgASgCADYCNAwCCyADIAMoAgwiAUEEajYCDEF/IQIgASgCACIBQeQASw0CIAAgATYCOAwBCyADIAMoAgwiAUEEajYCDEF/IQIgASgCACIBQQpLDQEgACABNgIYC0EAIQILIANBEGokACACC4YEAgR/An4jAEEQayIFJAACQCAARQ0AIAAgASAAIAAoAgAoAgQRAAAgACgCACgCEBELAEEBIQMCQCABQoACVA0AQQIhAyABQoCABFQNAEEDIQMgAUKAgIAIVA0AQQQhAyABQoCAgIAQVA0AQQUhAyABQoCAgICAIFQNAEEGIQMgAUKAgICAgIDAAFQNAEEHQQggAUKAgICAgICAgAFUGyIDQX9qQQdLDQELIANBAWqtIQhCASEHAkADQAJAIAUgASADIAena0EDdK2HPAANIAAgBUENakEBIAAoAgAoAgARAQAiBCAGIARBAEgbIQYgBEF/TA0AIAggB0IBfCIHUg0BDAILC0EAIQQgBg0BCyAFAn9BASACQoACVA0AGkECIAJCgIAEVA0AGkEDIAJCgICACFQNABpBBCACQoCAgIAQVA0AGkEFIAJCgICAgIAgVA0AGkEGIAJCgICAgICAwABUDQAaQQdBCCACQoCAgICAgICAAVQbCyIDQYABcjoADkEAIQQgACAFQQ5qQQEgACgCACgCABEBAEEASA0AIANBAWqtIQFCASEHAkADQCAFIAIgAyAHp2tBA3SthzwADyAAIAVBD2pBASAAKAIAKAIAEQEAIgQgBiAEQQBIGyEGIARBf0wNASAHQgF8IgcgAVINAAtBACEGCyAGRSEECyAFQRBqJAAgBAvfAQEBfkIBIQICfkIBIABCgAJUDQAaQgIgAEKAgARUDQAaQgMgAEKAgIAIVA0AGkIEIABCgICAgBBUDQAaQgUgAEKAgICAgCBUDQAaQgYgAEKAgICAgIDAAFQNABpCB0IIIABCgICAgICAgIABVBsLIQACQCABQv8AVA0AQgIhAiABQv//AFQNAEIDIQIgAUL///8AVA0AQgQhAiABQv////8AVA0AQgUhAiABQv//////AFQNAEIGIQIgAUL///////8AVA0AQgdCCCABQv////////8AVBshAgsgACACfAv6AwIEfwJ+IwBBEGsiBiQAAkAgAEUNACAAIAEgACAAKAIAKAIEEQAAIAAoAgAoAhARCwBBASEDAkAgAUKAAlQNAEECIQMgAUKAgARUDQBBAyEDIAFCgICACFQNAEEEIQMgAUKAgICAEFQNAEEFIQMgAUKAgICAgCBUDQBBBiEDIAFCgICAgICAwABUDQBBB0EIIAFCgICAgICAgIABVBsiA0F/akEHSw0BCyADQQFqrSEIQgEhBwJAA0ACQCAGIAEgAyAHp2tBA3SthzwADiAAIAZBDmpBASAAKAIAKAIAEQEAIgQgBSAEQQBIGyEFIARBf0wNACAIIAdCAXwiB1INAQwCCwtBACEEIAUNAQtBfyEFAkBCAQJ/QQEgAkL/AFQNABpBAiACQv//AFQNABpBAyACQv///wBUDQAaQQQgAkL/////AFQNABpBBSACQv//////AFQNABpBBiACQv///////wBUDQAaQQdBCCACQv////////8AVBsLIgNBB2ythiIBQn58IAJUDQAgASAChCEBIANBAWqtIQJCASEHA0AgBiABIAMgB6drQQN0rYc8AA8gACAGQQ9qQQEgACgCACgCABEBACIEIAUgBEEASBshBSAEQX9MDQEgB0IBfCIHIAJSDQALQQAhBQsgBUUhBAsgBkEQaiQAIAQLZQECfwJAQRggAGciAWsiAkUNACAAQf8ATQRAIAAgAUFoanQgAEE4IAFrdnIhAAwBCyAAIAFBCGp0IAAgAnZyIQALIABB/wBxIgAgAUEHdGsgAEGAASAAa2xBswFsQRB2akGAH2oLMAECfyAAQQEgABshAANAAkAgABApIgENAEH83gIoAgAiAkUNACACEQ8ADAELCyABCxsAIACQIgCLQwAAAE9dBEAgAKgPC0GAgICAeAt4ACABRQRAQgAPCwJ+QgIgAEKAAlQNABpCAyAAQoCABFQNABpCBCAAQoCAgAhUDQAaQgUgAEKAgICAEFQNABpCBiAAQoCAgICAIFQNABpCByAAQoCAgICAgMAAVA0AGkIIQgkgAEKAgICAgICAgAFUGwsgARAirXwLFwAgAC0AAEEgcUUEQCABIAIgABDq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CxgBAX8gABApIgEEQCABQQAgABARGgsgAQtJAQJ/IAAoAgQiBUEIdSEGIAAoAgAiACABIAVBAXEEfyACKAIAIAZqKAIABSAGCyACaiADQQIgBUECcRsgBCAAKAIAKAIYEQcACxYAIABFBEBBAA8LQfDeAiAANgIAQX8LmwQCBH8CfiMAQRBrIgYkAAJAIANQIABFIAJFcnINACAAIAEgACAAKAIAKAIEEQAAIAAoAgAoAhARCwBBASEFAkAgAUKAAlQNAEECIQUgAUKAgARUDQBBAyEFIAFCgICACFQNAEEEIQUgAUKAgICAEFQNAEEFIQUgAUKAgICAgCBUDQBBBiEFIAFCgICAgICAwABUDQBBB0EIIAFCgICAgICAgIABVBsiBUF/akEHSw0BCyAFQQFqrSEJQgEhCAJAA0ACQCAGIAEgBSAIp2tBA3SthzwADiAAIAZBDmpBASAAKAIAKAIAEQEAIgQgByAEQQBIGyEHIARBf0wNACAJIAhCAXwiCFINAQwCCwtBACEEIAcNAQtBACEEQgECf0EBIANC/wBUDQAaQQIgA0L//wBUDQAaQQMgA0L///8AVA0AGkEEIANC/////wBUDQAaQQUgA0L//////wBUDQAaQQYgA0L///////8AVA0AGkEHQQggA0L/////////AFQbCyIFQQdsrYYiAUJ+fCADVA0AIAEgA4QhASAFQQFqrSEJQgEhCAJAA0ACQCAGIAEgBSAIp2tBA3SthzwADyAAIAZBD2pBASAAKAIAKAIAEQEAIgQgByAEQQBIGyEHIARBf0wNACAJIAhCAXwiCFINAQwCCwtBACEEIAcNAQsgACACIAOnIAAoAgAoAgARAQBFIQQLIAZBEGokACAEC/QDAgV/An4jAEEQayIEJAACQCAARQ0AIAAgASAAIAAoAgAoAgQRAAAgACgCACgCEBELAEEBIQUCQCABQoACVA0AQQIhBSABQoCABFQNAEEDIQUgAUKAgIAIVA0AQQQhBSABQoCAgIAQVA0AQQUhBSABQoCAgICAIFQNAEEGIQUgAUKAgICAgIDAAFQNAEEHQQggAUKAgICAgICAgAFUGyIFQX9qQQdLDQELIAVBAWqtIQlCASEIAkADQAJAIAQgASAFIAina0EDdK2HPAANIAAgBEENakEBIAAoAgAoAgARAQAiAyAGIANBAEgb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CyAAQSAgDCAGIAlrIgogCCAIIApIGyIOaiIGIAsgCyAGSBsiASAGIAcQHSAAIA8gDBAaIABBMCABIAYgB0GAgARzEB0gAEEwIA4gCkEAEB0gACAJIAoQGiAAQSAgASAGIAdBgMAAcxAdDAELC0EAIQwMAQtBfyEMCyAFQdAAaiQAIAwLaQECfwJAIAAoAhQgACgCHE0NACAAQQBBACAAKAIkEQEAGiAAKAIUDQBBfw8LIAAoAgQiASAAKAIIIgJJBEAgACABIAJrrEEBIAAoAigRIwAaCyAAQQA2AhwgAEIANwMQIABCADcCBEEAC54FAgR/Bn4jAEEQayIDJAACQCAARQ0AAn5CASABQn98IgZC/wBUDQAaQgIgBkL//wBUDQAaQgMgBkL///8AVA0AGkIEIAZC/////wBUDQAaQgUgBkL//////wBUDQAaQgYgBkL///////8AVA0AGkIHQgggBkL/////////AFQbCyEHAn5CAiAGIAd9IgZC/wBUDQAaQgMgBkL//wBUDQAaQgQgBkL///8AVA0AGkIFIAZC/////wBUDQAaQgYgBkL//////wBUDQAaQgcgBkL///////8AVA0AGkIIQgkgBkL/////////AFQbCyAGfCABUg0AIAAgACgCACgCBBEAACIJQgBTDQAgAELsASAAIAAoAgAoAgQRAAAgACgCACgCEBELACADQewBOgAOQQEhAiAAIANBDmpBASAAKAIAKAIAEQEAQQBIDQACQCAGQv8AVA0AQQIhAiAGQv//AFQNAEEDIQIgBkL///8AVA0AQQQhAiAGQv////8AVA0AQQUhAiAGQv//////AFQNAEEGIQIgBkL///////8AVA0AQQdBCCAGQv////////8AVBshAgtCASACQQdsrYYiB0J+fCAGVA0AIAYgB4QhCiACQQFqrSELQgEhBwJAA0ACQCADIAogAiAHp2tBA3SthzwADyAAIANBD2pBASAAKAIAKAIAEQEAIgQgBSAEQQBIGyEFIARBf0wNACALIAdCAXwiB1INAQwCCwsgBQ0BC0EAIQIgA0EAOgANAkAgBqciBEEATA0AA0AgACADQQ1qQQEgACgCACgCABEBAEUEQCACQQFqIgIgBEgNAQwCCwsMAQsgAUIAIAEgACAAKAIAKAIEEQAAIgEgCX1RG0IAIAFCf1UbIQgLIANBEGokACAIC5YCAgR/An4jAEEQayIEJAACQCAARQRAQX8hAwwBCyAAIAEgACAAKAIAKAIEEQAAIAAoAgAoAhARCwBBASECAkAgAUKAAlQNAEECIQIgAUKAgARUDQBBAyECIAFCgICACFQNAEEEIQIgAUKAgICAEFQNAEEFIQIgAUKAgICAgCBUDQBBBiECIAFCgICAgICAwABUDQBBfyEDQQdBCCABQoCAgICAgICAAVQbIgJBf2pBB0sNAQsgAkEBaq0hB0IBIQYDQCAEIAEgAiAGp2tBA3SthzwADyAAIARBD2pBASAAKAIAKAIAEQEAIgUgAyAFQQBIGyEDIAVBf0wNASAGQgF8IgYgB1INAAtBACEDCyAEQRBqJAAgAwt8AgN/AX4jAEEQayICJABBfyEBAkAgAEUNAEIBIQQDQCACQv//////////AUEIIASna0EDdK2HPAAPIAAgAkEPakEBIAAoAgAoAgARAQAiAyABIANBAEgbIQEgA0F/TA0BIARCAXwiBEIJUg0AC0EAIQELIAJBEGokACABC5oBAQJ/IwBB0ABrIgMkAAJ/QQAgAUUgAkVyDQAaIAAoArQBIQQgAyABNgIEIAMgBDYCACADQRBqQcAAQbkOIAMQwgFBACAAKALMASIAECIgA0EQahAiakEBahAXIgFFDQAaIAEgABArIgAQIiAAaiADQRBqECsaIAIoAgAiAQRAIAEQDgsgAiAANgIAQQELIQAgA0HQAGokACAAC8UCAgV/AX4gACgC9AEiAUUEQEEADwsgACgC4AEiA0EBSARAQX8PCyAAKALYASADQQJ0akF8aigCACIFRQRAQX8PCwJAIAAoAvwBIgJBAUgNAEEAIQMDQCABIANBAnRqIgIoAgAiASkDQFBFBEAgAEEENgK4CgsgBSABEE1FBEBBfw8LAkACQCAALQCcCkUNACAAKQPoASIGIAIoAgAiASkDMFINASAAIAEpAzggBhBMDQBBfw8LIAIoAgAhAQsCQAJAIAEpAzgiBiAAKQOQAlYEQCAAIAY3A5ACIAEoAjBBA3QgAGogBjcDkAIMAQsgAUUNAQsgASgCICIEBEAgBBAOCyABKAIIIgQEQCAEEA4LIAEQDgsgAkEANgIAIANBAWoiAyAAKAL8ASICTg0BIAAoAvQBIQEMAAALAAsgAEEANgL8ASACCwgAIAAQTxAOC9MFAgJ/A34CQCABRQ0AIAApAyhQDQAgACgCBEUNACABQq4BIAAgACgCACgCDBEAABAVRQ0AQtcBIAApAyAQD0LF5wEgACkDMBAPfEKDASAAKQMoEA98IQQgACgCBCICBEBChgEgAhAZIAR8IQQLIAAoAggiAgRAQqLHASACIAApA1AQOyAEfCEECyAAKAIMIgIEQEKc64oBIAIQGSAEfCEECyAAKAIYIgIEQELupgEgAhAZIAR8IQQLIAApAxAiBVBFBEBC7qsBIAUQDyAEfCEECyAAKQM4IgVQRQRAQqqtASAFEA8gBHwhBAsgACkDQCIFUEUEQEK7rQEgBRAPIAR8IQQLIAApA0giBVBFBEBCg8ePASAFEA8gBHwhBAsgASABKAIAKAIEEQAAIgVCAFMNACABQtcBIAApAyAQE0UNACABQsXnASAAKQMwEBNFDQAgAUKDASAAKQMoEBNFDQAgACkDECIGUEUEQCABQu6rASAGEBNFDQELIAApAzgiBlBFBEAgAUKqrQEgBhATRQ0BCyAAKQNAIgZQRQRAIAFCu60BIAYQE0UNAQsgACkDSCIGUEUEQCABQoPHjwEgBhATRQ0BCyAAKAIEIgIEQCABQoYBIAIQIEUNAQsgACgCCCICBEAgAUKixwEgAiAAKQNQEEhFDQELIAAoAgwiAgRAIAFCnOuKASACECBFDQELIAAoAhgiAgRAIAFC7qYBIAIQIEUNAQsgASABKAIAKAIEEQAAIgZCAFMgBiAFfSAEUnINAAJAIAAoAlxFDQBCACEEA0AgACgCWCADQQJ0aigCABB/IAR8IQQgA0EBaiIDIAAoAlxJDQALQQAhAyABQoDbASAEEBVFDQEgACgCXEUNAANAIAAoAlggA0ECdGooAgAgARCRAgRAIANBAWoiAyAAKAJcSQ0BDAILC0EADwsgASABKAIAKAIEEQAAQn9VIQMLIAMLsQYBD38jAEEQayIIJAAgACgCGCILQX9qIQ8gACgCSCIQIAAoAhwiESABbCISQQJ0aiENIAAoAlghEyAFKAIAIQkgAygCACEMAkAgAUECdCIGIAAoAkRqIgcoAgAEQCAIIAk2AgwgCCAHKAIANgIIIABBATYCOCAAIAEgDSAIQQhqIAQgCEEMaiAAKAJUEQwAIQ4gACgCPCAGaiIKKAIAIgcgCCgCCCIGSARAIAggBzYCCCAHIQYLIAggDjYCDCAKIAooAgAgBms2AgAgCCgCCCEHIAtBAk4EQEEAIQYDQCANIAZBAnRqIA0gBiAHakECdGooAgA2AgAgBkEBaiIGIA9HDQALCyAAKAJEIAFBAnRqIgogCigCACAHayIHNgIAIAcEQEEAIQYgCCgCCCEOA0AgDSAGIA9qIhRBAnRqIA0gDiAUakECdGooAgA2AgAgBkEBaiIGIAdHDQALCyAJIAgoAgwiBmshCSAKKAIADQEgBCAAKAJcIAZsQQJ0aiEECyAJRSAMRXINACARIA9rIQogCyASakECdCAQakF8aiESA0AgCCAKIAwgDCAKSxsiBzYCDCAIIAk2AggCQCACRQRAIAdFDQEgEkEAIAdBAnQQERoMAQtBACEGIAdFDQADQCANIAYgD2pBAnRqIAIgBiATbEECdGooAgA2AgAgBkEBaiIGIAdHDQALCyAAQQE2AjggACgCGCELIAAgASAAKAJIIAAoAhwgAWxBAnRqIhAgCEEMaiAEIAhBCGogACgCVBEMACEOIAAoAjwgAUECdGoiESgCACIHIAgoAgwiBkgEQCAIIAc2AgwgByEGCyAIIA42AgggESARKAIAIAZrNgIAIAgoAgwiByEGIAtBAk4EQCALQX9qIQtBACEGA0AgECAGQQJ0aiAQIAYgB2pBAnRqKAIANgIAIAZBAWoiBiALRw0ACyAIKAIMIQYLIAwgB2shDCAJIAgoAggiB2siCUUNASACIAYgE2xBAnRqQQAgAhshAiAEIAAoAlwgB2xBAnRqIQQgDA0ACwsgAyADKAIAIAxrNgIAIAUgBSgCACAJazYCACAAKAJUGiAIQRBqJAALtwICAX8CfkLXASAAKQMgEA9CxecBIAApAzAQD3xCgwEgACkDKBAPfCECIAAoAgQiAQRAQoYBIAEQGSACfCECCyAAKAIIIgEEQEKixwEgASAAKQNQEDsgAnwhAgsgACgCDCIBBEBCnOuKASABEBkgAnwhAgsgACgCGCIBBEBC7qYBIAEQGSACfCECCyAAKQMQIgNQRQRAQu6rASADEA8gAnwhAgsgACkDOCIDUEUEQEKqrQEgAxAPIAJ8IQILIAApA0AiA1BFBEBCu60BIAMQDyACfCECCyAAKQNIIgNQRQRAQoPHjwEgAxAPIAJ8IQILIAAoAlwEfkIAIQNBACEBA0AgACgCWCABQQJ0aigCABB/IAN8IQMgAUEBaiIBIAAoAlxJDQALQoDbASADEBQgAiADfHwFIAILC7cCAgJ9B3wgAbsiBpkiB0SN7bWg98awPmMEQCAADwsgByACtyIHRAAAAAAAAOA/omQEfUMAAAAABSAAIAGUIQEgAygCAAJ/IAYgBqAgB6O2iyADKAIEspQiBI4iBYtDAAAAT10EQCAFqAwBC0GAgICAeAsiAkEDdGoiAysDCCEHIAMrAwAhCiADKwMQIQkgAysDGCEGIAG7RBgtRFT7IQlAoiIIEPwBIAC7oiAIoyAGIAQgArKTIgAgACAAlCIBlLsiCESVqGdVVVXFP6IiCyAAuyIGRJWoZ1VVVcU/oqEiDKIgCSABu0QAAAAAAADgP6IiCSAGoCAIRAAAAAAAAOA/oqEiCKIgCiAJIAZEtStMVVVV1b+ioCALoSIGoiAHRAAAAAAAAPA/IAyhIAihIAahoqCgoKK2Cwu2DAISfwJ9IAAgACgCCCIBIAAoAgwiA24iAjYCJCAAIAEgAiADbGs2AiggACAAKAIQQRRsIgJBlM4CaigCACIENgIwIAAoAhghCSAAIAJBkM4CaigCACIFNgIYIAAoAhwhDAJAIAEgA0sEQCAAIAEgBWwgA25BB2pBeHEiBTYCGCAAIAJBmM4CaioCACADs5QgAbOVOAIsIAQgA0EBdCABSSICdiADQQJ0IAFJIgZ2IANBA3QiByABSXYhBCACIAZyRUEAIAcgAU8bRQRAIAAgBDYCMAsgBCADQQR0IAFJIgJ2IQEgAkVBACABGw0BIAAgAUEBIAEbIgQ2AjAMAQsgACACQZzOAmooAgA2AiwLAkACQAJAIAMgBWwiASAEIAVsQQhqIgJNBEBBASEGQf////8BIANuIAVPDQELQQAhBiACIQFB9////wEgBG4gBUkNAQsgACgCUCABSQRAIAAoAkwgAUECdBCwASICRQ0BIAAgATYCUCAAIAI2AkwLIAACfwJAAkAgBkUEQEF8IQIgACgCGCIBIAAoAjAiBGxBBGoiBUF8Sg0BIAAoAhAhAwwCCyAAKAIYIQEgACgCDCIEBEAgAUF+bSEFIASzIRNBACEDA0AgAQRAIAEgA2whBiADsyATlSEUIAAoAhBBFGxBoM4CaigCACEHIAAoAkwhCEEAIQIDQCAIIAIgBmpBAnRqIAAqAiwgAkEBaiICIAVqsiAUkyABIAcQdDgCACABIAJHDQALCyADQQFqIgMgBEcNAAsLQTdBOCAAKAIQQQhKGwwCCyABQQF2syETIAAoAhAiA0EUbEGgzgJqKAIAIQYgBLMhFCAAKAJMIQQDQCACQQJ0IARqIAAqAiwgArIgFJUgE5MgASAGEHQ4AhAgAkEBaiICIAVHDQALC0E5QTogA0EIShsLNgJUIAEgACgCIGpBf2oiAiAAKAIcIgFLBEBB/////wEgACgCFCIBbiACSQ0BIAAoAkggASACbEECdBCwASIBRQ0BIAAgAjYCHCAAIAE2AkggAiEBCyAAKAI4RQRAIAEgACgCFGwiAUUEQEEADwsgACgCSEEAIAFBAnQQERpBAA8LIAAoAhgiAiAJSwRAIAAoAhQiA0UEQEEADwsgCUF/aiENIANBAnRBfGohDiAAKAJEIQ9BACEGA0AgDyADQX9qIgNBAnQiEGoiBygCACIBQQF0IQUgASANaiICBEAgAyAMbCEIIAAoAhwgA2whCiAAKAJIIQQDQCAEIAJBf2oiAiABaiAKakECdGogBCACIAhqQQJ0aigCADYCACACDQALCyAOIAZBAnRrIQggAQRAIAAoAkggACgCHCAIbGpBACABQQJ0EBEaCyAHQQA2AgACQCAFIAlqIgQgACgCGCIFSQRAIARBf2oiBwRAIAVBfmohESAEQX5qIRIgACgCHCADbCEKIAAoAkghC0EAIQJBACEBA0AgCyACIBFqIApqQQJ0aiALIAIgEmogCmpBAnRqKAIANgIAIAFBf3MhAiABQQFqIgEgB0cNAAsLIAVBf2oiASAHSwRAIAAoAkggACgCHCAIbGpBACABIAdrQQJ0EBEaCyAAKAI8IBBqIgEgASgCACAFIARrQQF2ajYCAAwBCyAHIAQgBWtBAXYiATYCACABQX9qIgJBACAAKAIYIgRrRg0AIAIgBGoiAkEBIAJBAUsbIQUgACgCHCADbCEHIAAoAkghBEEAIQIDQCAEIAIgB2oiCEECdGogBCABIAhqQQJ0aigCADYCACACQQFqIgIgBUcNAAsLIAZBAWohBiADDQALQQAPC0EAIQEgAiAJTw0BIAAoAhRFDQEgACgCRCEGQQAhAwNAIAYgA0ECdGoiASgCACEFIAEgCSACa0EBdiIENgIAIAQgBWoiB0F/aiICQQAgACgCGCIFa0cEQCACIAVqIgJBASACQQFLGyEIIAAoAhwgA2whCiAAKAJIIQVBACECA0AgBSACIApqIgtBAnRqIAUgBCALakECdGooAgA2AgAgAkEBaiICIAhHDQALCyABIAc2AgAgA0EBaiIDIAAoAhRPBEBBAA8FIAAoAhghAgwBCwAACwALIAAgCTYCGCAAQTs2AlRBASEBCyABC7kCAgJ/AX0gBEGA9wIgCG0iCm0hCAJAIAZBAUcEQEEAIQQgCEEATA0BA0AgASAEQQN0IglqIAAgCWoqAgAgByAEIApsQQJ0aioCACILIAuUIgsgA5RDAACAPyALkyAClJIiC5Q4AgAgASAJQQRyIglqIAAgCWoqAgAgC5Q4AgAgBEEBaiIEIAhHDQALDAELIAhBAUgNAEEAIQQDQCABIARBAnQiCWogACAJaioCACAHIAQgCmxBAnRqKgIAIgsgC5QiCyADlEMAAIA/IAuTIAKUkpQ4AgAgBEEBaiIEIAhHDQALCyAGQQEgBkEBShshCkEAIQcDQCAIIgQgBUgEQANAIAEgBCAGbCAHakECdCIJaiAAIAlqKgIAIAOUOAIAIARBAWoiBCAFRw0ACwsgB0EBaiIHIApHDQALC89UAxt/Cn0BfCMAQfAEayINJAAgDUEANgLoBCAAQQA2AvCMAUF/IQwCQCACQQFIDQAgBEH8CSAEQfwJSBsiE0EBSA0AIBNBAUYEQEF+IQwgACgCkAEgAkEKbEYNAQsgACAAKAIAaiEOIAAoAgQhHCAAKAJsQYMQRwRAIAAoAnQhGgsgACgCqAEhDCANIA1B5ARqNgKwAyAOQZ/OACANQbADahASGiANQQA2AqgEIAUgDCAMIAVKGyEXAkAgACgCLEEGTARAIABBADYC4IwBQX8hDyAAQX82AowBIABB4IwBaiEKQQEhJEF/IRYMAQtBfyEPQX8hFgJAIAAoApABIgVBgP0ASA0AIAAoAnAgAmwiD0EBTgRAQQAhDANAICkgASAMQQJ0aioCACIoICkgKF0bISkgJyAoICcgKF4bIScgDEEBaiIMIA9HDQALCyAnICmMIiggJyAoXhtDAACAP0EBIBd0spVfQQFzRQRAIABBADYC4IwBIABB4IwBaiEKQX8hD0EBISUMAgsgAEGUwgBqKAIAIQ8gAEGQwgBqKAIAIRYgAEG8AWogDSgC5AQgBiAHIAIgCCAJIAUgFyAKIA1BqARqEIgCIA0qAsgEQ83MzD1eQQFzDQAgACoC6IwBQ3e+fz+UISkCQAJAIAAoAnAgAmwiBUEBTgRAQQAhDEMAAAAAISgDQCAoIAEgDEECdGoqAgAiJyAnlJIhKCAMQQFqIgwgBUcNAAsgKSAoIAWyIiqVXg0CQQAhDEMAAAAAISgDQCAoIAEgDEECdGoqAgAiJyAnlJIhKCAMQQFqIgwgBUcNAAsMAQtDAAAAACEoIClDAAAAACAFsiIqlV4NAQsgKCAqlSEpCyAAICk4AuiMAQsgDSgCqAQhBSAAQQA2AuCMASAAQX82AowBIABB4IwBaiEKQQEhJCAFRQ0AIAAoAnxBmHhGBEAgAAJ/QwAAgD8gDSoCvASTQwAAyEKUu0QAAAAAAADgP6CcIjGZRAAAAAAAAOBBYwRAIDGqDAELQYCAgIB4CzYCjAELIA0oAsQEIgVBDEwEQCAKQc0INgIADAELIAVBDkwEQCAKQc4INgIADAELIAVBEEwEQCAKQc8INgIADAELIAVBEkwEQCAKQdAINgIADAELIApB0Qg2AgALQwAAAAAhKAJAIAAoAnBBAkcNACAAKAJ4QQFGDQAgASACIAAoApABIABBzO4AahCAAiEoCyACIgZFBEAgACgCkAFBkANtIQYLAkACQCAAKAKkASIMQZh4RwRAIAxBf0YNASAAKAKQASEFDAILIAAoApABIgUgACgCcGwgBUE8bCAGbWohDAwBCyATIAAoApABIgVsQQN0IAZtIQwLIAAgDDYCoAEgBSACbSEVAkACfyAAKAKUASIQRQRAIAAgBUEMbCACbSIGIAZBAm0gDEEMbEEIbWogBm0iBiATIAYgE0gbIhNsQQN0QQxtIgw2AqABQQEgE0ECSA0BGgsCQCATQQNIIAwgFUEYbEhyDQAgEyAVbCEfIBVBMUoNAiAfQawCSA0AIAxB3xJKDQILIBMLIQcgACgCuG4iAUHNCCABGyEGQQAhBSAAKAKIbiEJQQAhDAJ/QTIgFSAVQRlGQeoHIAAoAqhuIgFB6AcgARsgFUHkAEobIghB6AdHcSIBGyICQRBKBEAgAgwBCyAEQQFHQQAgAkEKRiAIQegHR3IbRQRAIAJBDUghAUHoByEIQRlBECACQQxGGwwBC0EyIAJtIQVBAyEBQTILIgJBjwNMBEADQCAMQQFqIQwgAkEBdCICQZADSA0ACyAMQQN0IQwLAn8gBkHQCE4EQEHPCCAIQegHRg0BGgsgBkHOCEYEQEHNCCAIQeoHRg0BGgtB0AggBiAIQekHRhsgBiAGQdEISBsLIQIgAwJ/AkAgCEGYeGoiBEECSw0AAkACQCAEQQFrDgICAQALIAxBcGogAkEFdEHgAGpB4AFxcgwCCyACQc4IIAJBzghKG0EFdEFAa0HgAHEgDHJBgAFyDAELIAxB8AFqIAJBBHRyQeAAcgsgCUECRkECdCABcnI6AAAgAUEDRgRAIAMgBToAAQtBAUECIAFBAkkbIQwgACgClAENAUF9IAcgDCAHIAxKGyIAIAMgDCAAEHgbIQwMAQsgDCAVQU5qIhkgACgCcCIGQShsQRRqbGshByAAKAIoIgkgEAR/IAcFIAcgB0EMbWsLIAAoAiwiGEHaAGoiG2xB5ABtIhRsIAlBDGxBFGoiHW0hEQJ/IAAoAnxBx2hqIgdBAU0EQEH/ACAHQQFrDQEaQQAMAQsgACgCjAEiB0EATgRAIAdBxwJsQQh1IgcgACgCbEGBEEcNARogB0HzACAHQfMASBsMAQtB8wBBMCAAKAJsQYAQRhsLIQcCQAJAIAAoAngiCEGYeEcEQCAGQQJGDQIMAQsgBkECRw0AQQJBASAUIBFrQdizAUGowwEgACgCiG5BAkYbShshCAwBCyAGIQgLIAAgCDYCiG4gDCAIQShsQRRqIBlsayEGIBAEfyAGBSAGIAZBDG1rCyAbbEHkAG0iBiAJbCAdbSERAkAgACgCbCISQYMQRgRAQeoHIQcgAEHqBzYCqG4gAEGo7gBqIRIgBUHkAG0gAkohBgwBCwJAIAAoAogBIhRBmHhGBEAgAEHoB0HqByAGIBFrAn8gKEMAAHpGlEMAAIA/ICiTIidDAAB6RpSSIimLQwAAAE9dBEAgKagMAQtBgICAgHgLIgYCfyAoQwCgDEeUICdDAAB6R5SSIieLQwAAAE9dBEAgJ6gMAQtBgICAgHgLIAZrIAcgB2xsQQ51aiIGQcA+aiAGIBJBgBBGGyIGQeBgaiAGQaAfaiAGIAAoAqxuIgZBAEobIAZB6gdGG0gbIhQ2AqhuIAAoAjBFIAlBgAEgB2tBBHVMckUEQCAAQegHNgKobkHoByEUCyAAIA0oAqgEICVyRSAAKAK4AUEAR3EiBjYCOEEAIBNBqMYAQfAuIBVBMkobIAJsIAVBA3RtSCIRRSAHQeQASiAGcRsNAUHqB0HoByARGyEUCyAAIBQ2AqhuCyAAQajuAGohEiAFQeQAbSIFIAJKIQYgBSACTARAIBQhBwwBC0HqByEHIBRB6gdGBEAgFCEHDAELIBJB6gc2AgBBASEGCyAAKAKwAQRAIBJB6gc2AgBB6gchBwtBACEUAn8CQCAAKAKsbiIFQQFIDQAgBUHqB0YiHiAHQeoHRyIgc0EBcyERIB4gIHJFBEBB6gchByAGDQEgEiAFNgIAIAUhB0EBIRFBAQwCCyARIRRBAAwBC0EAIRFBAAshIAJAAkAgCEEBRw0AIAAoArBuQQJHDQAgACgCRCAFQeoHRnIgB0HqB0ZyDQBBAiEIIABBAjYCiG4gAEEBNgJEDAELIABBADYCRAsgDCAIQShsQRRqIBlsayEGIAAgHGohHCAQBH8gBgUgBiAGQQxtawsgG2xB5ABtIRACQAJAAkACQAJAAkACfyAHQQFyQekHRgRAQeoHIQggGEEBTARAIBBBAnRBBW0hEAsgECAJIBBsIAlBBmxBCmptayIQIAdB6gdHDQEaQQAhGUEBIQUMAgtB6gchCCAHQeoHRgRAQQAhGUEBIQUgGEEESg0CIBBBCWxBCm0hEAwCCyAQIAkgEGwgHW1rCyEQQQAhGSAFQeoHRgRAIBwgACgCtAEgDUHAA2oQVxpBASEZIAAoAqhuIQcLQQEhBSAHQeoHRg0AQQAhBSAAKALEbkUEQCAAKAJURQ0CCyAHIQgLAn8CQCAAKALEbiIGRQRAQdEIIQwgEEGA/QBB4N0AIAAoArxuIgdB0QhIG0gNAQwFC0G86QAgEEGw7QBIDQEaIABC0YiAgJCKATcCuG5B0QghDAwFC0Gk8QBB1OEAIAdB0AhIGwshB0HQCCEMIBAgB04NAiAGRQRAQc8IIQwgEEHg3QBBkM4AIAAoArxuIgdBzwhIG04NA0H41QBBqMYAIAdBzghIGyEMDAILQZDOACEMIBBB+NUASA0BIABCz4iAgPCJATcCuG5BzwghDAwDCyAAKAK4biEMDAMLQc0IQc4IIBAgDEgbIQwLIAAgDDYCuG4gACAMNgK8biAFIAZyIAxB0AhJcg0AIAAoAlgNAEHPCCEMIABBzwg2ArhuCyAIIQcLIAwgACgChAEiBkoEQCAAIAY2ArhuIAYhDAsgACgCgAEiCEGYeEcEQCAAIAg2ArhuIAghDAsgB0HqB0YgH0HSDkpyRQRAIAAgDEHPCCAMQc8ISBsiDDYCuG4LAkAgACgCkAEiB0HAuwFKBEAgDCEGDAELQdAIIQYCQAJAAkACQCAMQdAITARAIAdBgf0ATgRAIAwhBgwGCyAMQc8ISg0BIAdB4d0ASA0CIAwhBgwFCyAAQdAINgK4biAHQYH9AE4NBAtBzwghBiAAQc8INgK4biAHQeHdAE4NAwwBCyAMQc4ISg0AIAdBwD5KBEAgDCEGDAMLIAwiBkHOCEcNAgwBC0HOCCEGIABBzgg2ArhuIAdBwD5KDQELQc0IIQYgAEHNCDYCuG4LIAooAgAiCkUgCEGYeEdyRQRAIAAgCgJ/AkAgECAAKAKIbiIHQdCMAWxMBEBBACEJIAVFDQFBASEFQc0IDAILIBAgB0HAuwFsSgRAIAUhCQwBCyAFIQlBzgggBUEBc0UNARoLIAkhBUHRCEHQCCAQIAdB4NcCbEobQc8IIBAgB0Gw6gFsShsLIgcgCiAHShsiBzYC4IwBIAAgBiAHIAYgB0gbIgY2ArhuC0EAIQwCQCAFDQAgACgCMEUNACAAKAIoIgVFDQBB/QAgBUEZIAVBGUgbayEHIAAoAjQiCEEBRiEJIAVBBkghBSAGIQwCQANAIAVBACAMQQN0IgpB3IcCaigCACIYa0EAIAkbIApB2IcCaigCAGpBACAYIAgbaiAHbCIKQf//A3FBjwVsQRB2IApBEHVBjwVsaiIKIBBIcg0BIAxBzQhKBEAgACAMQX9qIgw2ArhuDAELCyAAIAY2ArhuQQAhDAwBCyAKIBBIIQwLIAAgDDYCNCANIBc2AqADIA5BxB8gDUGgA2oQEhoCQCAAKAKobiIMQeoHRw0AIAAoArhuQc4IRw0AIABBzwg2ArhuCwJAAkACQAJAAkACQCAAKAKwAQRAQc0IIQogAEHNCDYCuG4MAQsgACgCuG4hCiAMQegHRw0AIApBzwhKDQELIAxB6QdHIApBzwhKckUEQCASQegHNgIAQegHIQwLIAAoApABIgdBMm0iBSACSA0BIAwhCAwCC0HpByEIIABB6Qc2AqhuIAAoApABIgdBMm0iBSACSA0CIAdBA2xBMm0gAkgNAgwDC0HoByEIIAxB6AdHDQELIAdBA2wiBkEybSIJIAJODQEgCEHoB0cNACACIAdBAXRBGW1GBEAgB0EZbSEFDAELIAkgBSAGQRltIAJGGyEFCyACIAVtIQIgFkF/RwRAIABBlMIAaiAPNgIAIABBkMIAaiAWNgIACyAAIAEgAiAFIAMgBCAgIBcgCxD/ASEMDAELIAAoAsBuBEAgAEEANgLAbkEBIRFBASEZQQEhFAsgACgCoAEhBEEAIRYCf0EAIBFFDQAaQQAgCEHqB0YNABogEUEAIAAoAohuIgZBKGxBFGoiBUHIASAVa2wgBGpBA2xBgBltIgggE0EDdCAFQQF0a0HwAWxBgPcCIBVtQfABam0gBWpBCG0iBSAIIAVIGyIFQYECIAVBgQJIG0EAIAUgBkEDdEEEckobIhYbCyEbIA1BwANqIANBAWoiFyATQX9qIhgQpwEgDSACIBpqIh0gACgCcGxBAnRBD2pBcHFrIgYiBSQAIAYgAEHg7gBqIh4gACgCcCIGIAAoAqwBIBprbEECdGogBiAabEECdBANIREgAiAEbCAHQQN0bSEMIAACfyAAKAKobkHqB0YEQEE8EBZBCHQMAQsgHCgCCAsgACgCkG4iBGsiBkEQdUHXB2wgBGogBkH//wNxQdcHbEEQdmoiBDYCkG4gBEEIdRA1IQggESAAKAJwIgcgGmxBAnRqIQYgACgCkAEhBAJAIAAoAmxBgBBGBEAgCEEQdEEQdUGnE2wgBEHoB21tIQQgAkEBSA0BIARBEHRBEHUiCCAEQRB1bCAIIARB//8DcWxBEHVqIARBD3VBAWpBAXUgBGxqQYCAgHxqIg9BEHRBEHUiISAEQal8bEGAgICAAWoiCEEGdSIJQf//A3EiImxBEHUgISAIQRZ1IiNsaiAPQQ91QQFqQQF1IAlsarJDAACAMZQhKiAIQRV1QQFqQQF1IAlsIAlBEHRBEHUiCSAjbGogCSAibEEQdWqyQwAAgDGUISsgBEGuB2xBgICAgH5qskMAAIAxlCEsIAiyQwAAgDGUIS4gAEGc7gBqKgIAIScgACoCmG4hKUEAIQQDQCAAIC4gASAEIAdsQQJ0IghqKgIAIi+UIiggKyApICiSIi2Uk0NgQqINkiIoOAKcbiAAICwgL5QgJyAqIC2Uk5IiKTgCmG4gBiAIaiAtOAIAICghJyAEQQFqIgQgAkcNAAsgB0ECRw0BIAZBBGohCCABQQRqIQkgAEGk7gBqKgIAIScgAEGg7gBqKgIAISlBACEEA0AgACAuIAkgBEEDdCIPaioCACIvlCIoICsgKSAokiItlJNDYEKiDZIiKDgCpG4gACAsIC+UICcgKiAtlJOSIik4AqBuIAggD2ogLTgCACAoIScgBEEBaiIEIAJHDQALDAELQwAAgD9DAABAQSAEspUiKZMhKiAAQZzuAGoqAgAhKCAAKgKYbiEnAkAgB0ECRwRAQQAhBCACQQBMDQEDQCAGIARBAnQiCGogASAIaioCACIrICeTIiwgKJM4AgAgKiAnlCApICuUQ2BCog2SkiEnICogKJQgKSAslENgQqINkpIhKCAEQQFqIgQgAkcNAAsMAQsgAEGk7gBqKgIAISsgAEGg7gBqKgIAISwgAkEBTgRAQQAhBANAIAEgBEEDdCIIQQRyIglqKgIAIS4gBiAIaiABIAhqKgIAIi0gJ5MiLyAokzgCACAGIAlqIC4gLJMiMCArkzgCACAqICeUICkgLZRDYEKiDZKSIScgKiAolCApIC+UQ2BCog2SkiEoICogLJQgKSAulENgQqINkpIhLCAqICuUICkgMJRDYEKiDZKSISsgBEEBaiIEIAJHDQALCyAAICs4AqRuIAAgLDgCoG4LIAAgKDgCnG4gACAnOAKYbgsCQCALRQ0AQwAAAAAhKCACIAdsIghBAU4EQEEAIQQDQCAoIAYgBEECdGoqAgAiJyAnlJIhKCAEQQFqIgQgCEcNAAsLIChDKGtuTl1BAXNFQQAgKCAoWxsNACAGQQAgCEECdBARGiAAQZjuAGoiBEIANwIIIARCADcCAAtDAACAPyEpAn8gEigCAEHqB0cEQEEBIQQgEyAWayIGIAwgBiAMSBtBA3RBeGogFWwhDyAFIgYgAiAHbEEBdEEPakFwcWsiCyQAAkACQAJAAkAgAAJ/AkAgEigCACIJQekHRgRAIAAoAjRBAXRBAkEBIAAoApABIAJBMmxGG2ohBSAAKAKUASEHIA9B4N0ASA0BQQIhBCAPQYD9AEgNAUEDIQQgD0GgnAFIDQFBBCEEIA9BwLsBSA0BQQUhBCAPQYD6AUgNAUEGIQQgD0GA9ANIDQEgBUECdEHozQJqKAIAIA9BgIx8akECbWoMAgsgACAPNgIkIAAoAshuIgcNAiAPIQUMBQsgBEEUbCIEQfDMAmoiCCgCACIMIA9rIARB3MwCaiIEIAVBAnQiBWooAgBsIAUgCGooAgAgDyAEKAIAIgRrbGogDCAEa20LIgQgBEHkAGogBxsiBEGsAmogBCAKQdAIRhsiBTYCJCAAKALIbiIHRQ0BIAUhDwsgACgClAENASAPIQUMAgtDAACAPyAFIA9rskMAAIA6lLtE7zn6/kIu5j+iEF62kyEpDAELIAAoArABBEAgDyEFDAELAn8gACgCuG4iIUGzd2oiBEEBTQRAQwAA+kUhKkENIARBAWsNARpDAIA7RiEqQQ8MAQtDAAB6RiEqQRELIQRDAAAAACEnIAAoAnAiCEEBTgRAQQAhBQNAIAVBFWwhIkEAIQwDQCAnIAcgDCAiakECdGoqAgAiJ0MAAAA/QwAAAMAgJ0MAAAA/ICdDAAAAP10iIxtDAAAAwF4iJhsiJyAjGyAnICYbIidDAAAAP5QgJyAnQwAAAABeG5IhJyAMQQFqIgwgBEcNAAsgBUEBaiIFIAhHDQALC0EAIA9BAXRrQQNtIQUCfyAqICcgBLKVIAiylEPNzEw+kpQiJ4tDAAAAT10EQCAnqAwBC0GAgICAeAsiBCAFIAUgBEgbIQQgACAhQX5xQdAIRgR/IARBA2xBBW0FIAQLIA9qIgU2AiQLIAAgACgCcCIINgIIIAAgACgCiG42AgwgACACQegHbCAAKAKQASIHbTYCIAJAIApBzQhGBEBBwD4hDCAAQcA+NgIcDAELIABB4N0AQYD9ACAKQc4IRhsiDDYCHAsgAEGA/QA2AhQgAEGA/QBBwD4gCUHpB0YbNgIYAkAgCUHoB0cNACAVQTNIBH8gH0EDdAUgH0EEdEEDbQsiBEG/PkoNACAAQeDdADYCFCAAIAxB4N0AIAxB4N0ASRs2AhwgBEHXNkoNACAAQcA+NgIcIABBwD42AhQLIABBQGsgGEEDdCIMNgIAIAAgACgClAEiBEU2AjwCQAJAAkACQCAbRSAWQQJIckUEQCAAIAwgFkEDdEEBcmsiDDYCQCAJQekHRw0EIAAgDEFsaiIMNgJAIARFDQEMAwsgBA0BIAlB6QdHDQMLIAAgDCACIAVsIAdtIgQgDCAESBs2AkAMAgsgCUHpB0cNAQtBASEFIAAoAjRBAXRBAkEBIAcgAkEybEYbaiEJIAACfwJAIAcgDGwgAm0iBEHg3QBIDQBBAiEFIARBgP0ASA0AQQMhBSAEQaCcAUgNAEEEIQUgBEHAuwFIDQBBBSEFIARBgPoBSA0AQQYhBSAEQYD0A0gNACAJQQJ0QejNAmooAgAgBEGAjHxqQQJtagwBCyAFQRRsIgVB8MwCaiIMKAIAIg8gBGsgBUHczAJqIgUgCUECdCIJaigCAGwgCSAMaigCACAEIAUoAgAiBGtsaiAPIARrbQsiBEGsAmogBCAKQdAIRhsgAmwgB202AkALIABBCGohBAJ/IBkEQEEAIQwgDUEANgK4AyAAIAAoAqwBIAdBkANtIgVrIAAoAnRrIAhsQQJ0IglqQeDuAGoiDyAPQwAAAABDAACAPyANKALkBCIPKAIEIAUgCCAPKAI8IAcQdiAeQQAgCRARGiAAKAKsASIFIAAoAnBsIgdBAU4EQANAIAsgDEEBdGogACAMQQJ0akHg7gBqKgIAQwAAAEeUIidDAAAAxyAnQwAAAMdeGyInQwD+/0YgJ0MA/v9GXRsQGDsBACAMQQFqIgwgB0cNAAsLIBwgBCALIAVBACANQbgDakEBEIcBGiAAKAJwIQgLIAIgCGwiBUEBTgsEQCAIIBpsIQdBACEMA0AgCyAMQQF0aiARIAcgDGpBAnRqKgIAQwAAAEeUIidDAAAAxyAnQwAAAMdeGyInQwD+/0YgJ0MA/v9GXRsQGDsBACAMQQFqIgwgBUcNAAsLAkAgHCAEIAsgAiANQcADaiANQewEakEAEIcBBH9BfQUCQCASKAIAIgVB6AdHDQAgACgCUCIEQcA+RgRAQc0IIQoMAQsgBEGA/QBHBEAgBEHg3QBHDQFBzgghCgwBC0HPCCEKCwJAIAAoAmAEQCAAIAAoAuyMASIERTYCSCANKALsBEUNASAEDQMgAEEBNgLAbkEAIRQgACgCoAEgACgCiG4iBUEobEEUaiIEQcgBIBVrbGpBA2xBgBltIgcgE0EDdCAEQQF0a0HwAWxBgPcCIBVtQfABam0gBGpBCG0iBCAHIARIGyIEQYECIARBgQJIG0EAIAQgBUEDdEEEckobIhZBAEchGwwDCyAAQQA2AkggDSgC7AQNAgtBACEMIABBADYC8IwBIAAoAohuIQEgACgCkAEgAm0iAEGPA0wEQANAIAxBAWohDCAAQQF0IgBBkANIDQALIAxBA3QhDAsgAwJ/AkAgBUGYeGoiAEECSw0AAkACQCAAQQFrDgICAQALIAxBcGogCkEFdEHgAGpB4AFxcgwCCyAKQc4IIApBzghKG0EFdEFAa0HgAHEgDHJBgAFyDAELIAxB8AFqIApBBHRyQeAAcgsgAUECRkECdHI6AABBAQsMAgsgBiEFCyANIApBs3dqIgRBA00EfyAEQQJ0QfzNAmooAgAFQRULNgKQAyAOQZzOACANQZADahASGiANIAAoAohuNgKAAyAOQZjOACANQYADahASGiANQX82AvACIA5Boh8gDUHwAmoQEhoCQCAAKAKobkHoB0YEQCAFIAAoAnAiDCAAKAKQAWxBkANtQQJ0QQ9qQXBxayIJJAAMAQsgDUEANgLgAiAOQaYfIA1B4AJqEBIaIA0gACgCTEVBAXQ2AtACIA5Bks4AIA1B0AJqEBIaIAAoApQBIQYCQAJAAkAgACgCqG4iBEHpB0YEQCAGRQRAIAUgACgCkAEiCCAAKAJwIgxsQZADbSIFQQJ0QQ9qQXBxayIJJABB6QchBAwECyANIAAoAqABIAAoAiRrNgKQAiAOQaIfIA1BkAJqEBIaIA1BADYCgAIgDkG0HyANQYACahASGgwBCyAGRQ0BIA1BATYCwAIgDkGmHyANQcACahASGiANIAAoApgBNgKwAiAOQbQfIA1BsAJqEBIaIA0gACgCoAE2AqACIA5Boh8gDUGgAmoQEhoLIBIoAgAhBAsgBSAAKAKQASIIIAAoAnAiDGxBkANtIgVBAnRBD2pBcHFrIgkkACAEQegHRg0BCyAEIAAoAqxuIgZGIAZBAUhyDQAgCSAAIAAoAqwBIAhB8HxtIBpraiAMbEECdGpB4O4AaiAFQQJ0EA0aCwJAIAAoAqwBIgQgHWsgDGwiBUEBTgRAIB4gAEHg7gBqIgQgAiAMbEECdGogBUECdCIFEB8aIAQgBWogESAMIB1sQQJ0EA0aDAELIB4gESAdIARrIAxsQQJ0aiAEIAxsQQJ0EA0aCyApQwAAgD9dRUEAIAAqApRuIidDAACAP11BAXMbRQRAIBEgESAnICkgDSgC5AQiBCgCBCACIAAoAnAgBCgCPCAAKAKQARB2CyAAICk4ApRuAkAgACgCqG4iBUHpB0YEQCAAKAKIbkEBRw0BCyAAIBBBwLsBIBBBwLsBShtBAXRBgIl9aiIEQYCAASAEQYCAAUgbNgJcCwJAIAAoAshuDQAgACgCcEECRw0AIAAuAYxuIgdBgIABTkEAIAAoAlwiBkH//wBKGw0AQwAAgD8gBrJDAACAOJSTISdBACEMAn8gDSgC5AQiCCgCBEGA9wIgACgCkAFtIgttIgRBAEoEQEMAAIA/IAeyQwAAgDiUkyEoIAgoAjwhBwNAIBEgDEEDdCIIaiIPIA8qAgAiKSAnIAcgCyAMbEECdGoqAgAiKiAqlCIqlCAoQwAAgD8gKpOUkiApIBEgCEEEcmoiCCoCACIpk0MAAAA/lJQiKpM4AgAgCCApICqSOAIAIAxBAWoiDCAERw0ACyAEIQwLIAwgAkgLBEADQCARIAxBA3QiBGoiByAHKgIAIiggJyAoIBEgBEEEcmoiBCoCACIok0MAAAA/lJQiKZM4AgAgBCAoICmSOAIAIAxBAWoiDCACRw0ACwsgACAGOwGMbgsCfwJAIAVB6gdGDQAgDSgC3ANnIA0oAtQDQQVBcSAFQekHRhtqaiAYQQN0Sg0AIAVB6QdGBEAgDUHAA2ogG0EMEBwLIBtFDQAgDUHAA2ogFEEBEBwgGCANKALUAyANKALcA2dqIgRBa2ogBEFgaiASKAIAIgRB6QdGG0EHakEDdWsiBSAWIAUgFkgbIgVBAiAFQQJKGyIFQYECIAVBgQJIGyEGQQEgBEHpB0cNARogDUHAA2ogBkF+akGAAhA5QQEMAQsgAEEANgLAbkEAIQZBAAshBQJ/IBIoAgAiB0HoB0YEQCANKALcAyEEIA0oAtQDIQggDUHAA2oQpgEgCCAEZ2pBZ2pBA3UiDAwBCyANQcADaiAYIAZrIgwQOEEACyEIAkACQCAFRQRAIBIoAgBB6AdGDQELIA0gDUGoBGo2AvABIA5Bps4AIA1B8AFqEBIaIBIoAgBB6QdHDQAgDSAAKAJkNgK4AyANIAAoAmg2ArwDIA0gDUG4A2o2AtABIA5BrM4AIA1B0AFqEBIaDAELIA1BADYC4AEgDkGszgAgDUHgAWoQEhoLIBRBAEcgBXEiBEEBRgRAIA1BADYCwAEgDkGazgAgDUHAAWoQEhogDUEANgKwASAOQaYfIA1BsAFqEBIaIA1BfzYCoAEgDkGiHyANQaABahASGkF9IA4gESAAKAKQAUHIAW0gDCAXaiAGQQAQMEEASA0BGiANIA1B6ARqNgKQASAOQb8fIA1BkAFqEBIaIA5BvB9BABASGgsgDUEAQREgB0HqB0YbNgKAASAOQZrOACANQYABahASGgJAIBIoAgAiB0HoB0YNACAHIAAoAqxuIgtGIAtBAUhyRQRAIA5BvB9BABASGiAOIAkgACgCkAFBkANtIA1BuANqQQJBABAwGiANQQA2AnAgDkGSzgAgDUHwAGoQEhoLIA0oAtQDIA0oAtwDZ2pBYGogDEEDdEoNAAJAIARFDQAgEigCAEHpB0cNACAAKAKUAUUNACANIAAoAqABIAAoAiRrNgJgIA5Boh8gDUHgAGoQEhoLIA0gACgClAE2AlAgDkGmHyANQdAAahASGkF9IA4gESACQQAgDCANQcADahAwIghBAEgNARogBEUNACASKAIAQekHRw0AIAAoApQBRQ0AIAggF2ogDCAXaiAGEB8aIAYgDGohDAsCQCAUIAVFckUEQCAAKAKQASEEIA5BvB9BABASGiANQQA2AkAgDkGazgAgDUFAaxASGiANQQA2AjAgDkGSzgAgDUEwahASGiANQQA2AiAgDkGmHyANQSBqEBIaIA1BfzYCECAOQaIfIA1BEGoQEhogBEGQA20hByAEQcgBbSEEIAAoAqhuQekHRgRAIA1BwANqIAgQOCAIIQwLIA4gESAAKAJwIAIgBGsiCSAHa2xBAnRqIAcgDUG4A2pBAkEAEDAaIA4gESAAKAJwIAlsQQJ0aiAEIAwgF2ogBkEAEDBBAEgNASANIA1B6ARqNgIAIA5Bvx8gDRASGgsgACgCiG4hByAAKAKobiEJQQAhDCAAKAKQASACbSIEQY8DTARAA0AgDEEBaiEMIARBAXQiBEGQA0gNAAsgDEEDdCEMCyADAn8CQCAJQZh4aiIEQQJLDQACQAJAIARBAWsOAgIBAAsgDEFwaiAKQQV0QeAAakHgAXFyDAILIApBzgggCkHOCEobQQV0QUBrQeAAcSAMckGAAXIMAQsgDEHwAWogCkEEdHJB4AByCyAHQQJGQQJ0cjoAACAAIA0oAtwDIgcgDSgC6ARzNgLwjAEgACAgBH9B6gcFIBIoAgALNgKsbiAAQQA2AsRuIAAgAjYCtG4gACAAKAKIbiIJNgKwbgJAIAAoArgBRQ0AIA0oAqgEICVyRQ0AAkAgJARAIA0qAsgEQ83MzD1dQQFzDQEgACoC6IwBISdDAAAAACEoIAAoAnAgAmwiBEEBTgRAQQAhDANAICggASAMQQJ0aioCACIoICiUkiEoIAxBAWoiDCAERw0ACwsgKCAEspVDcR2eQ5QgJ19BAXMNAQsgACAAKALkjAEiAUEBajYC5IwBIAFBCkgNASABQR5OBEAgAEEKNgLkjAEMAgtBACEMIABBADYC8IwBIAAoAqhuIQEgACgCkAEgAm0iAEGPA0wEQANAIAxBAWohDCAAQQF0IgBBkANIDQALIAxBA3QhDAsgAwJ/AkAgAUGYeGoiAEECSw0AAkACQCAAQQFrDgICAQALIAxBcGogCkEFdEHgAGpB4AFxcgwCCyAKQc4IIApBzghKG0EFdEFAa0HgAHEgDHJBgAFyDAELIAxB8AFqIApBBHRyQeAAcgsgCUECRkECdHI6AABBAQwDCyAAQQA2AuSMAQsCQCANKALUAyAHZ2pBYGogGEEDdEoEQEF+IBNBAkgNAxogF0EAOgAAIABBADYC8IwBQQEhCAwBCyAIQQNIDQAgBSASKAIAQegHR3INAANAIAMgCGotAAANASAIQQNKIQEgCEF/aiEIIAENAAtBAiEICyAGIAhqQQFqIQECQCAAKAKUAQRAIAEhEwwBC0F9IAMgASATEHgNAhoLIBMMAQtBfQshDAsgDUHwBGokACAMC3QBAn8jAEGwAmsiAyQAQX8hBAJAIAFBAUgNAEEAIQQgASACRg0AQX8hBCABIAJKDQAgA0EANgIEIAMgACACaiABayAAIAEQHyABEHoiBA0AIAMgAygCBCAAIAJBARB5IgBBH3UgAHEhBAsgA0GwAmokACAEC7cGAQd/QX8hBQJAIAFBAEwNACAAKAIEIAFIDQAgAEHIAWohCAJAAkACQCABIgdBf2oiBUEBTQRAIAVBAWsEQEF+IQUgCC4BAEEBaiIGIANKDQUgAiAALQAAQfwBcToAACACQQFqIQUMAgsgCC8BACIFQRB0QRB1IQYgBSAILwECIglGBEBBfiEFIAZBAXRBAXIiBiADSg0FIAIgAC0AAEH8AXFBAXI6AAAgAkEBaiEFDAILQX4hBSAJQRB0QRB1IAZqIAZB+wFKakECaiIGIANKDQQgAiAALQAAQfwBcUECcjoAACAILgEAIAJBAWoiBRB7IAVqIQUMAQsgAiEFIAdBAkoNAQsgBEUgBiADTnINAQtBASEFIAguAQAhBgJ/AkAgB0EBTA0AIAZB//8DcSEJA0AgCSAIIAVBAXRqLwEARgRAIAcgBUEBaiIFRw0BDAILC0EBIQUgBkECakECQQEgBkH7AUobaiEGIAFBf2oiCUECTgRAA0AgBiAIIAVBAXRqLgEAIgpqQQJBASAKQfsBShtqIQYgBUEBaiIFIAlHDQALC0F+IQUgBiAIIAdBf2pBAXRqLgEAaiIGIANKDQMgAC0AACEFIAIgB0GAf3IiCToAASACIAVBA3I6AABBAAwBC0F+IQUgBiAHbEECaiIGIANKDQIgAC0AACEFIAIgBzoAASACIAVBA3I6AAAgByEJQQELIQsgAkECaiEFAkAgBEUNACADIAZrIgpFDQAgAiAJQcAAcjoAASAKQX9qQf8BbSEGIApBgAJOBEAgBUH/ASAGQQEgBkEBShsiBRARGiACIAVqQQJqIQULIAUgBkGBfmwgCmpBf2o6AAAgBUEBaiEFIAMhBgsgCyAHQQJIcg0AIAFBf2oiAUEBIAFBAUobIQlBACEBA0AgCCABQQF0ai4BACAFEHsgBWohBSABQQFqIgEgCUcNAAsLIAdBAU4EQCAAQQhqIQFBACEAA0AgBSABIABBAnRqKAIAIAggAEEBdGoiBS4BABAfIAUuAQBqIQUgAEEBaiIAIAdHDQALCyAERSAFIAIgA2pPckUEQCAFQQAgAiADIAVrahARGgsgBiEFCyAFC7cBAQR/IwBBEGsiBCQAQXwhAwJAIAJBAUgNAAJAIAAoAgRFBEAgACABLQAAOgAAIAAgARCHAjYCqAIMAQsgAS0AACAALQAAc0EDSw0BCyABIAIQhQIiBUEBSA0AIAAoAqgCIAAoAgQiBiAFamxBwAdKDQAgASACIARBD2ogACAGQQJ0akEIaiAAIAZBAXRqQcgBahCGAiIDQQFIDQAgACAAKAIEIAVqNgIEQQAhAwsgBEEQaiQAIAMLNgEBfyAAQfsBTARAIAEgADoAAEEBDwsgASAAQXxyIgI6AAAgASAAIAJB/wFxa0ECdjoAAUECC8UFAgN/CH0jACIJIQogBEUEQCAKJABDAAAAAA8LAkAgCEGA9wJGBEAgBUEBdCEFIARBAXQhBAwBCyAIQYD9AEcNACAFQQF0QQNtIQUgBEEBdEEDbSEECyAJIARBAnRBD2pBcHFrIgkiCyQAIAEgCSAEIAVBACAGIAcgABEQAEMAAAA4IAeylUMAAIA3QwAAADggBkF/ShsgBkF+RhshDSAEQQFOBEBBACEGA0AgCSAGQQJ0aiIAIA0gACoCAJQ4AgAgBkEBaiIGIARHDQALCwJAIAhBgPcCRgRAIARBAm0hAEMAAAAAIQ0gBEECSA0BQQAhBgNAIAMgCSAGQQN0IgFqKgIAIgwgDCADKgIAIg6TQ/+AGz+UIg+SOAIAIAMgCSABQQRyaioCACIMIAwgAyoCBCIQk0PAPho+lCIRkjgCBCADIAyMIAMqAggiEpNDwD4aPpQiEyAMkzgCCCACIAZBAnRqIBAgDiAPkiIMkiARkkMAAAA/lDgCACANIAwgEpIgE5IiDSANlJIhDSAGQQFqIgYgAEcNAAsMAQtDAAAAACENIAhBgP0ARwRAIAhBwLsBRw0BIAIgCSAEQQJ0EA0aDAELIAsgBEEDbCIBQQJ0QQ9qQXBxayIAJAAgBEEBTgRAQQAhBgNAIAAgBkEMbGoiBSAJIAZBAnRqKAIAIgc2AgggBSAHNgIEIAUgBzYCACAGQQFqIgYgBEcNAAsLIAFBAm0hBCABQQJOBEBBACEGA0AgAyAAIAZBA3QiAWoqAgAiDCAMIAMqAgAiDpND/4AbP5QiD5I4AgAgAyAAIAFBBHJqKgIAIgwgDCADKgIEIhCTQ8A+Gj6UIhGSOAIEIAMgDIwgAyoCCJNDwD4aPpQgDJM4AgggAiAGQQJ0aiAQIA4gD5KSIBGSQwAAAD+UOAIAIAZBAWoiBiAERw0ACwsLIAokACANCyIAIABBgPAAKAIAQQJ0QYTwACgCAEEEdGpBgCBqbEHsAWoLzRICCn8DfSAAKAIkIRIgACgCHCENIAAoAhAhECAAKAIAIQxBASELAn8gBSgCACIOIAAoAggiEygCOCAAKAIMIg9BAXRqLgEAIAhBA3RqIghrQWBqIhEgCEEBdUEQQQQgBEECRiAJQQBHcSIIG2sgBEEBdEF+QX8gCBtqIghsIA5qIAhtIgggESAISBsiCEHAACAIQcAASBsiCEEETgRAIAhBB3FBAXRBsKgCai4BAEEOIAhBA3ZrdUEBakF+cSELCyALC0EBIAsgCRsgDyAQSBshCwJ/AkACQAJAAkACQAJAAkACQAJAIAwEQCACIAMgCSAEIAAoAiwQnAIhCCANECEhECALQQFHBEACQAJ/AkAgCQRAIAAoAjAiAA0BIAggC2xBgEBrQQ51DAILAkAgCCALbCIMQYBAayIOQQ51IgggC04EQCAIIQAMAQsgDEGAwABIBEAgCCEADAELIAAoAjhFBEAgCCEADAELIA5BgIB/cSALIgBuQRB0Ig5BDXUgDkEQdWxBgIACakEQdSIMQY57bEGAgAFqQQ91QdXAAGogDGxBAXRBgIACakGAgHxxQYCA9JB+akEQdSAMbEGAgAFqQQ92IAxrQRB0QYCAgIB4akEQdSIRZyIUQYCAgIAEIA5rIgxBDXUgDEEQdWxBgIACakEQdSIMQY57bEGAgAFqQQ91QdXAAGogDGxBAXRBgIACakGAgHxxQYCA9JB+akEQdSAMbEGAgAFqQQ92IAxrQRB0QYCAgIB4akEQdSIMZyIOa0ELdCARIBRBb2p0QRB0QRB1IhFB22tsQYCAAWpBD3VB/D1qIBFsQYCAAWpBD3ZrIAwgDkFvanRBEHRBEHUiDEHba2xBgIABakEPdUH8PWogDGxBgIABakEPdmpBEHRBEHUgBEEXdEGAgIB8akEQdWxBgIABakEPdSIMIAUoAgAiDkoNAEEAIAggDEEAIA5rSBshAAsgB0EBTA0CDAcLIABBf3NBH3ZBACAIIAtsQf//AUGBgH4gCEGAwABKGyALbWoiAEEOdSAAQQBIGyIAIAtBf2ogCyAAShtqCyEAIARBAkwNBSANIABBA2wiCSALQQJtIgdBA2xBA2oiCCAHQX9zaiAAaiAAIAdMIgwbIAlBA2ogCCAHayAAaiAMGyAHIAhqEEMgAEEOdCIAIAtuIQgMBgsgAEEBaiIHIAsgAGsiCEEBaiIJIAAgC0EBdSICTBshDyACQQFqIgMgA2whAyANIAAgAkwEfyAAIAdsQQF1BSADIAkgCEECamxBAXVrCyIJIAkgD2ogAxBDIABBDnQgC24hCAwHCyAJRQ0GQQAhCUEAIQcCQCAIQYHAAEgNACAAKAI0IggNAEEBIQcgBEEBSA0AIAhFIQdBACELA0AgAyALQQJ0aiIIIAgqAgCMOAIAIAtBAWoiCyAERw0ACwsgBEEBSA0BIBIgEygCCCAPakECdGoqAgAiFSASIA9BAnRqKgIAIhYgFpRDfR2QJpIgFSAVlJKRQ30dkCaSIhWVIRcgFiAVlSEVA0AgAiAJQQJ0IghqIgsgFSALKgIAlCAXIAMgCGoqAgCUkjgCACAJQQFqIgkgBEcNAAsMAQsgDRAhIRAgC0EBRw0BQQAhByAJRQ0EC0EAAn9BACAFKAIAQRFIDQAaQQAgACgCIEERSA0AGiAMBEAgDSAHQQIQHCAHDAELIA0Q3gILIAAoAjQbIQcMAwsCQCAJRSAEQQNIckUEQCANAn8gDSALQQJtIgBBAWoiB0EDbCICIABqIggQowEiAyACSARAIANBA20MAQsgAyAHQQF0awsiCUEDbCIDIAIgAEF/c2ogCWogCSAATCIHGyADQQNqIAIgAGsgCWogBxsgCBCiAQwBC0EAIAdBAUwgCRtFBEAgDSALQQFqEKEBIQkMAQsgDQJ/IA0gC0EBdSIHQQFqIgAgAGwiAxCjASICIAAgB2xBAXVIBEAgAkEDdEEBchCCAUF/akEBdiIJQQFqIgAgCWxBAXYMAQsgAyALQQFqIgAgAEEBdCACQX9zIANqQQN0QQFyEIIBa0EBdiIJayIAIAsgCWtBAmpsQQF1awsiAiAAIAJqIAMQogELIAlBDnQgC24hCAwDCyANIAAgC0EBahA5IABBDnQiACALbiEIIAlFDQILIAsgAEsEQEEAIQcgBEEBSA0BIBIgEygCCCAPakECdGoqAgAiFSASIA9BAnRqKgIAIhYgFpRDfR2QJpIgFSAVlJKRQ30dkCaSIhWVIRcgFiAVlSEVQQAhCQNAIAIgCUECdCIAaiIIIBUgCCoCAJQgFyAAIANqKgIAlJI4AgAgCUEBaiIJIARHDQALDAELIARBAUgNAUEAIQkDQCACIAlBAnQiAGoiByAHKgIAQ/MENT+UIhUgACADaiIAKgIAQ/MENT+UIhaSOAIAIAAgFiAVkzgCACAJQQFqIgkgBEcNAAsMAQsgDRAhIQAgBSAFKAIAIAAgEGsiAGs2AgAMAQsgDRAhIQAgBSAFKAIAIAAgEGsiAGs2AgBBgIABIQkgCEGAgAFGDQEgCA0CIAghBwsgCiAKKAIAQX8gBnRBf3NxNgIAQf//ASEDQQAhCUEAIQJBgIB/DAILIAogCigCAEF/IAZ0QX9zIAZ0cTYCAEH//wEhAkEAIQdBACEDQYCAAQwBC0EAIQcgCCEJIAhBEHQiBUENdSAFQRB1bEGAgAJqQRB1IgJBjntsQYCAAWpBD3VB1cAAaiACbEEBdEGAgAJqQYCAfHFBgID0kH5qQRB1IAJsQYCAAWpBD3YgAmtBEHRBgICAgHhqQRB1IgNnIgZBgICAgAQgBWsiAkENdSACQRB1bEGAgAJqQRB1IgJBjntsQYCAAWpBD3VB1cAAaiACbEEBdEGAgAJqQYCAfHFBgID0kH5qQRB1IAJsQYCAAWpBD3YgAmtBEHRBgICAgHhqQRB1IgJnIgVrQQt0IAMgBkFvanRBEHRBEHUiBkHba2xBgIABakEPdUH8PWogBmxBgIABakEPdmsgAiAFQW9qdEEQdEEQdSIFQdtrbEGAgAFqQQ91Qfw9aiAFbEGAgAFqQQ92akEQdEEQdSAEQRd0QYCAgHxqQRB1bEGAgAFqQQ91CyEEIAEgADYCFCABIAk2AhAgASAENgIMIAEgAjYCCCABIAM2AgQgASAHNgIAC4ABAQF+An5CAELnjwFC6I8BIAApAygQDyIBEBQgAXxC4o8BIAAoAgggACkDMBA7fELhjwEgACkDABAPfCIBUA0AGkK1oAEgARAUIAF8CyEBQsDEAUKzoAEgACkDIBAPIAF8QrKgASAAKQMYEA98QrGgASAAKQMQEA98IgEQFCABfAuRAgEHfyMAIgQhCCAEIAEgAmwiCUECdEEPakFwcWsiBSQAAkAgA0UEQCACQQFIDQFBACEEIAFBAUghBgNAIAZFBEAgASAEbCEHQQAhAwNAIAUgAyAHakECdGogACACIANsIARqQQJ0aigCADYCACADQQFqIgMgAUcNAAsLIARBAWoiBCACRw0ACwwBCyACQQFIDQAgAkECdEGopwJqIQZBACEEIAFBAUghBwNAIAdFBEAgBiAEQQJ0aigCACABbCEKQQAhAwNAIAUgAyAKakECdGogACACIANsIARqQQJ0aigCADYCACADQQFqIgMgAUcNAAsLIARBAWoiBCACRw0ACwsgACAFIAlBAnQQDRogCCQAC6UBAgV/An0gAkEBTgRAIAFBAXUiA0EBIANBAUobIQUgAkEBdCEGQQAhAyABQQJIIQcDQEEAIQEgB0UEQANAIAAgASAGbCADakECdGoiBCAEKgIAQ/MENT+UIgggACABQQF0QQFyIAJsIANqQQJ0aiIEKgIAQ/MENT+UIgmSOAIAIAQgCCAJkzgCACABQQFqIgEgBUcNAAsLIANBAWoiAyACRw0ACwsLWgEEf0EBQR8gAGdrQQF1IgJ0IQMDQCAAQQAgBEEBdCADaiACdCIBIAAgAUkiARtrIQBBACADIAEbIARqIQQgAkEASiEBIANBAXYhAyACQX9qIQIgAQ0ACyAEC8sBAQJ/IwBBEGsiASQAAnwgAL1CIIinQf////8HcSICQfvDpP8DTQRARAAAAAAAAPA/IAJBnsGa8gNJDQEaIABEAAAAAAAAAAAQMwwBCyAAIAChIAJBgIDA/wdPDQAaIAAgARCEAUEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwgQMwwDCyABKwMAIAErAwhBARAymgwCCyABKwMAIAErAwgQM5oMAQsgASsDACABKwMIQQEQMgshACABQRBqJAAgAAvACQMEfwF+BHwjAEEwayIEJAACQAJAAkAgAL0iBkIgiKciAkH/////B3EiA0H61L2ABE0EQCACQf//P3FB+8MkRg0BIANB/LKLgARNBEAgBkIAWQRAIAEgAEQAAEBU+yH5v6AiAEQxY2IaYbTQvaAiBzkDACABIAAgB6FEMWNiGmG00L2gOQMIQQEhAgwFCyABIABEAABAVPsh+T+gIgBEMWNiGmG00D2gIgc5AwAgASAAIAehRDFjYhphtNA9oDkDCEF/IQIMBAsgBkIAWQRAIAEgAEQAAEBU+yEJwKAiAEQxY2IaYbTgvaAiBzkDACABIAAgB6FEMWNiGmG04L2gOQMIQQIhAgwECyABIABEAABAVPshCUCgIgBEMWNiGmG04D2gIgc5AwAgASAAIAehRDFjYhphtOA9oDkDCEF+IQIMAwsgA0G7jPGABE0EQCADQbz714AETQRAIANB/LLLgARGDQIgBkIAWQRAIAEgAEQAADB/fNkSwKAiAETKlJOnkQ7pvaAiBzkDACABIAAgB6FEypSTp5EO6b2gOQMIQQMhAgwFCyABIABEAAAwf3zZEkCgIgBEypSTp5EO6T2gIgc5AwAgASAAIAehRMqUk6eRDuk9oDkDCEF9IQIMBAsgA0H7w+SABEYNASAGQgBZBEAgASAARAAAQFT7IRnAoCIARDFjYhphtPC9oCIHOQMAIAEgACAHoUQxY2IaYbTwvaA5AwhBBCECDAQLIAEgAEQAAEBU+yEZQKAiAEQxY2IaYbTwPaAiBzkDACABIAAgB6FEMWNiGmG08D2gOQMIQXwhAgwDCyADQfrD5IkESw0BCyABIAAgAESDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIIRAAAQFT7Ifm/oqAiByAIRDFjYhphtNA9oiIKoSIAOQMAIANBFHYiBSAAvUI0iKdB/w9xa0ERSCEDAn8gCJlEAAAAAAAA4EFjBEAgCKoMAQtBgICAgHgLIQICQCADDQAgASAHIAhEAABgGmG00D2iIgChIgkgCERzcAMuihmjO6IgByAJoSAAoaEiCqEiADkDACAFIAC9QjSIp0H/D3FrQTJIBEAgCSEHDAELIAEgCSAIRAAAAC6KGaM7oiIAoSIHIAhEwUkgJZqDezmiIAkgB6EgAKGhIgqhIgA5AwALIAEgByAAoSAKoTkDCAwBCyADQYCAwP8HTwRAIAEgACAAoSIAOQMAIAEgADkDCEEAIQIMAQsgBkL/////////B4NCgICAgICAgLDBAIS/IQBBACECA0AgBEEQaiACIgVBA3RqAn8gAJlEAAAAAAAA4EFjBEAgAKoMAQtBgICAgHgLtyIHOQMAIAAgB6FEAAAAAAAAcEGiIQBBASECIAVFDQALIAQgADkDIAJAIABEAAAAAAAAAABiBEBBAiECDAELQQEhBQNAIAUiAkF/aiEFIARBEGogAkEDdGorAwBEAAAAAAAAAABhDQALCyAEQRBqIAQgA0EUdkHqd2ogAkEBahCkAiECIAQrAwAhACAGQn9XBEAgASAAmjkDACABIAQrAwiaOQMIQQAgAmshAgwBCyABIAA5AwAgASAEKQMINwMICyAEQTBqJAAgAgvwBQILfwh9IwBBEGsiDyQAIA9CADcDCCAGQQNqIAVMBEAgCSAMQQMQHAsCfSAMBEBDAJgZPgwBCyALQQJ0IgZBkOgBaioCACEcIAZBoOgBaioCAAshHUEAIQYgASACSARAIApBASAKQQFKGyESIApBA2whEyAFQSBqIRQgACgCCCEFIAEhCwNAIA5BAEcgC0EBSnEhFSATIAIgC2tsIRYgByALQRQgC0EUSBtBAXQiCmohFyAHIApBAXJqIRhBACEKA0AgAyAFIApsIAtqQQJ0IgVqKgIAIhogBCAFaioCACIbQwAA4MGXIA2TIh5dQQFzIQUgBQJ/IBogHCAbQwAAEMGXlCIfkyAPQQhqIApBAnRqIhkqAgAiG5MiIEMAAAA/ko4iIYtDAAAAT10EQCAhqAwBC0GAgICAeAsiDEF/SnJFBEACfyAeIBqTIhqLQwAAAE9dBEAgGqgMAQtBgICAgHgLIAxqIgVBH3UgBXEhDAsgDyAMNgIEIBQgCSgCFGsgCSgCHGdrIRAgDCEFAkAgASALRg0AIBAgFmsiEUEXSg0AIA8gDEEBIAxBAUgbIgU2AgQgEUEPSg0AIA8gBUF/IAVBf0obIgU2AgQLIBUEQCAPIAVBH3UgBXEiBTYCBAsCQCAQQQ9OBEAgCSAPQQRqIBctAABBB3QgGC0AAEEGdBCoAgwBCyAQQQJOBEAgDyAFQQEgBUEBSBsiBUF/IAVBf0obIgU2AgQgCSAFQQF0IAVBH3VzQbDoAUECEBAMAQsgEEEBRgRAIA8gBUEfdSAFcSIFNgIEIAlBACAFa0EBEBwMAQsgD0F/NgIECyAIIAAoAggiBSAKbCALakECdCIQaiAgIA8oAgQiEbIiGpM4AgAgBCAQaiAbIB+SIBqSOAIAIBkgGyAakiAdIBqUkzgCACAGIAwgEWsiBiAGQR91IgZqIAZzaiEGIApBAWoiCiASRw0ACyALQQFqIgsgAkcNAAsLIA9BEGokAEEAIAYgDhsLywUCBX8KfQJAIAVDAAAAAFwgBkMAAAAAXHJFBEAgACABRg0BIAAgASAEQQJ0EB8aDwtBACELQX4gA0EPIANBD0obIgxrIQ0gDEF/cyEOQQEgDGshD0EAIAxrIRAgCEEMbCIDQejjAWoqAgAgBpQhFCADQeTjAWoqAgAgBpQhFSADQeDjAWoqAgAgBpQhFkEAIAogByAIRhsgCiAFIAZbGyAKIAJBDyACQQ9KGyIIIAxGGyICQQFOBEAgB0EMbCIDQejjAWoqAgAgBZQhFyADQeTjAWoqAgAgBZQhGCADQeDjAWoqAgAgBZQhGUECIAxrIQMgASAPQQJ0aioCACERIAEgEEECdGoqAgAhEiABIA5BAnRqKgIAIRMgASANQQJ0aioCACEFQQAhCgNAIAAgCkECdCIHaiAFIAEgAyAKakECdGoqAgAiGpIgFCAHIAlqKgIAIgUgBZQiBZSUIBEgE5IgFSAFlJQgEiAWIAWUlCABIAdqKgIAIAEgCiAIa0ECdGoiByoCACAZQwAAgD8gBZMiBZSUkiAYIAWUIAcqAgQgB0F8aioCAJKUkiAXIAWUIAcqAgggB0F4aioCAJKUkpKSkjgCACATIQUgEiETIBEhEiAaIREgCkEBaiIKIAJHDQALIAIhCwsgBkMAAAAAWwRAIAAgAUYNASAAIAJBAnQiA2ogASADaiAEIAJrQQJ0EB8aDwsgBCALayIHQQFIDQAgACALQQJ0IgRqIQNBAiAMayECIAEgBGoiASANQQJ0aioCACETIAEgDkECdGoqAgAhBSABIBBBAnRqKgIAIREgASAPQQJ0aioCACESQQAhCgNAIAMgCkECdCIAaiAUIBMgASACIApqQQJ0aioCACIGkpQgFSAFIBKSlCAWIBGUIAAgAWoqAgCSkpI4AgAgBSETIBEhBSASIREgBiESIApBAWoiCiAHRw0ACwsL8hsBJX8jAEEQayIXIRMgFyQAIAEoAkQEQCAAQQE2AoBzIABBATYCtCQLIABBADYC8CwgAEEANgK8ewJAIAEQ5QIiCA0AIABBzM4AaiEfIAFBADYCWAJAIAEoAgQgACgC3J0BTA0AIB8gACgC4CcQRCEOIABCATcCqJ0BIABCADcCoJ0BIABBADYCmJ0BIABCgYCAgICAEDcCsJ0BIAAoAtidAUECRw0AIABB2PsAaiAAQYwtakGsAhANGiAAIAApAgA3AsxOCwJ/IAEoAhgiGCAAKAKAJEcEQCABKAIEIQlBAQwBCyABKAIEIgkgACgC3J0BRwshECABKAIAIQggACAJNgLcnQEgACAINgLYnQEgA0HkAGwiCiABKAIIIgttIQwCQAJAAkAgBgRAQZt/IQggDEEBRw0EIAlBAEwNAgNAIAAgB0HMzgBsaiIIIAgoAuAnEEQhDiAHQQFqIgghByAIIAEoAgQiCUgNAAsgASgCGCEYIAFBCjYCGCABKAIkIRpBACEHIAFBADYCJCAJQQFIDQMDQCAAIAdBzM4AbGoiCEEBNgLEJCAIQQA2ArgkIAdBAWoiByAJRw0ACwwBC0GbfyEIIAsgDGwgCkcgA0EASHINAyALIBhsIQpBACEYIANB6AdsIApKDQMLIAlBAUgNASAQQX9zIQoDQEEAIQcgACANQczOAGxqIgsgASAAKALonQEgDSANQQFGBH8gACgC3CMFQQALEOICIggNAwJAIAogCygCtCRFcQ0AIAAoAuwsQQFIDQADQCALIAdBAnRqQfAkakEANgIAIAdBAWoiByAAKALsLEgNAAsLIAsgCygCuC82ArwvIA1BAWoiDSABKAIESA0AC0EAIQ4MAQsgAUEKNgIYIAEoAiQhGiABQQA2AiQLIAxBAXVBASAMQQFKGyIbQQF0ISMgG0F/aiEkIABB3M8AaiElIABByIYBaiEgIABBuPMAaiEhIABBtPYAaiEmIABB6CdqIScgAEGYnQFqISggAEHMnQFqIRUgAEG88wBqISkgAEG6nQFqIRwgAEGw9gBqIR0gAEHY+wBqIR4gAEHkJ2ohFiAAQYwtaiEZIBcgACgC3CMiCCAMQQpsIipsIiIgACgCyCNsIAhB6AdsbUEBdEEPakFwcWsiEiQAAn8DQCAAKALkIyAAKALoLCIKayIIICIgCCAiSBsiDCAAKALII2wgACgC3CNB6AdsbSEPAkACQCABKAIAQQJHDQAgASgCBEF/aiIIQQFLDQAgCEEBa0UEQCAAKALwLCEIQQAhByAPQQFIIhBFBEADQCASIAdBAXRqIAIgB0ECdGovAQA7AQAgB0EBaiIHIA9HDQALCwJAIAgNACAAKALgnQFBAUcNACAeIBlBrAIQDRoLIBkgCkEBdCAWakEEaiASIA8QJyEJIAAgACgC6CwgDGo2AugsIAAoArByIAAoArR7IgtrIgogACgCqHIgKmwiCCAKIAhIGyEKQQAhByAQRQRAA0AgEiAHQQF0aiACIAdBAnRBAnJqLwEAOwEAIAdBAWoiByAPRw0ACwsgHiALQQF0IB1qQQRqIBIgDxAnIQggACAAKAK0eyAKajYCtHsgCCAJIA5qaiEOIAAoAugsIQcMAgtBACEHIA9BAU4EQANAIBIgB0EBdGogAiAHQQJ0IghBAnJqLgEAIAIgCGouAQBqIghBAXYgCEEBcWo7AQAgB0EBaiIHIA9HDQALCyAZIApBAXQgFmpBBGogEiAPECcgDmohDgJAIAAoAuCdAUECRw0AIAAoAvAsDQAgHiAAKAK0e0EBdCAdakEEaiASIA8QJyAOaiEOIAAoAuQjIhBBAUgNACAAKAK0eyEJIAAoAugsIQtBACEHA0AgFiAHQQJqIgogC2pBAXRqIgggHSAJIApqQQF0ai4BACAILgEAakEBdjsBACAHQQFqIgcgEEcNAAsLIAAgACgC6CwgDGoiBzYC6CwMAQsgGSAKQQF0IBZqQQRqIBIgAiAPQQF0EA0gDxAnIQggACAAKALoLCAMaiIHNgLoLCAIIA5qIQ4LIAEoAgAhK0EAIRcgAEEANgLonQFBACAHIAAoAuQjSA0BGiAAKALwLCAGckUEQEEAIREgE0EAOwEGIBNBAEGAAiABKAIEIAAoAuwsQQFqbHZrOgAGIARBACATQQZqQQgQECABKAIEIghBAEoEQANAQQAhB0EAIQkgACARQczOAGxqIgooAuwsIgtBAU4EQANAIAogB0ECdGpB8CRqKAIAIAd0IAlyIQkgB0EBaiIHIAtHDQALCyAKIAlBAEo6AO8kIAlFIAtBAkhyRQRAIAQgCUF/aiALQQJ0QYA4aigCAEEIEBAgASgCBCEICyARQQFqIhEgCEgNAAsLQQAhDSAAKALsLEEASgRAA0AgCEEBTgRAIA1Bf2ohESANIBVqIQwgKSANQQJ0IhBqIQsgHCANQQZsaiEKQQAhCQNAIAAgCUHMzgBsaiIHIBBqQfAkaigCAARAAkAgCSAIQQJHcg0AIAQgChClASALKAIADQAgBCAMLAAAEKQBCyAHIAQgDUEBAn8gDQRAQQIgByARQQJ0akHwJGooAgANARoLQQALEGAgBCAHIA1BJGxqIghB7S9qLAAAIAhB7i9qLAAAIAcgDUHAAmxqQbwwaiAHKALkIxBfIAEoAgQhCAsgCUEBaiIJIAhIDQALCyANQQFqIg0gACgC7CxIDQALC0EAIQcgCEEASgRAA0AgACAHQczOAGxqIghCADcC8CQgCEH4JGpBADYCACAHQQFqIgcgASgCBEgNAAsLIAAgBCgCFCAEKAIcZ2pBYGo2AtCdAQsgABDbAiABKAIYIgogASgCHCIIbEHoB20hCSAGBH8gCQUgCSAAKALQnQFrCyAAKALsLG0iC0EQdEEQdUHkAEEyIApBCkYbbCAAKALUnQFBAXRrIQkCQCAGDQAgACgC8CwiCkEBSA0AIAkgBCgCHGcgBCgCFCAKIAtsa2ogACgC0J0Ba0EBdGtBQGshCQsCQCAIQYknTgRAIAkgCCIKSg0BIAlBiCcgCUGIJ0obIQoMAQtBiCchCiAJQYgnSg0AIAggCSAJIAhIGyEKCwJAIAEoAgRBAkYEQCAoICcgJiAcIAAoAvAsIghBBmxqIAggFWogE0EIaiAKIAAoArAjIAEoAjwgACgC3CMgACgC5CMQ2QICQCAVIAAoAvAsIghqLQAARQRAIAAoAuydAUEBRgRAICBCADcCACAgQQA2AgggAEIANwLcTiAlQQBBoCIQERogAEEKOgDIhgEgAEHkADYCxHEgAEHkADYCiHIgAEEAOgCFciAAQQE2AoBzIABBgIAENgLUcQsgHxCIAQwBCyAIICFqQQA6AAALIAYNASAEIBwgACgC8CxBBmxqEKUBICEgACgC8CwiCGotAAANASAEIAggFWosAAAQpAEMAQsgACAAKAKcnQE2AuQnIAAgFiAAKALkI0EBdGooAQA2ApydAQsgABCIASABKAIEIgxBAU4EQCAURSAbQQJGcSEQQQAhBwNAIAEoAjghCwJ/IBAEQCALQQNsQQVtDAELIAsgG0EDRw0AGiAURQRAIAtBAXRBBW0MAQsgCyAUQQFHDQAaIAtBA2xBBG0LIQggFCAkRiABKAI0QQBHcSERAkAgDEEBRgRAIAohCQwBCyATQQhqIAdBAnRqKAIAIQkgBw0AIBMoAgxBAUgNACAIIAsgI21rIQhBACERCyAJQQFOBEAgACAHQczOAGxqIgsgCRCsAiALIAUgBAJ/QQAgACgC8CwgB0wNABogBwRAQQEgACgC7J0BDQEaC0ECCyAIIBEQrQIhDiABKAIEIQwLIAAgB0HMzgBsaiIIQQA2AugsIAhBADYCuCQgCCAIKALwLEEBajYC8CwgB0EBaiIHIAxIDQALCyAPICtsQQF0IQsgAyAPayEDIAAgACgC8CwiECAVakF/aiwAADYC7J0BAkAgBSgCAEEBSA0AIBAgACgC7CxHDQBBACERQQAhBwJAIAxBAUgEQAwBCwNAIAdBAXQhCUEAIQcgACARQczOAGxqIgooAuwsIghBAU4EQANAIAkgByAKakHsJGosAAByQQF0IQkgB0EBaiIHIAhHDQALCyAJIAosAO8kciEHIBFBAWoiESAMRw0ACwsgBkUEQCAEIAcgEEEBaiAMbBDgAgsCQCAAKAK8L0UNACABKAIEQQFHBEAgACgCiH5FDQELIAVBADYCAAsgACAAKALUnQEgBSgCAEEDdGogASgCGCIKIAEoAhxsQegHbWsiCEEAIAhBAEobIghBkM4AIAhBkM4ASBs2AtSdASAAKAKwIyAAKALknQEiCEEQdEEQdUH0GGxBEHVBDWpIBEAgAEKAgICAEDcC5J0BDAELIABBADYC6J0BIAAgCCAKajYC5J0BCyACIAtqIQIgFEEBaiEUIAMNAAsgACgC6J0BCyEHIA4hCCAAIAEoAgQiAzYC4J0BIAEgBzYCTCABIAAoAtwjIgJBEEYEfyAAKAIcRQVBAAs2AlAgASACQRB0QRB1QegHbDYCSEEAIQcgASABKAI8BH9BAAUgAC4BtJ0BCzYCVAJAIAZFDQAgASAaNgIkIAEgGDYCGCADQQFIDQADQCAAIAdBzM4AbGoiAkEANgLEJCACQQA2ArgkIAdBAWoiByADRw0ACwsgASAALACZJSICNgJcIAEgAkEBdEF8cSAALACaJUEBdGpBoDhqLgEANgJgCyATQRBqJAAgCAuEAQECfyAAIABB5idqEOgCAkAgACgCsCNBDEwEQCAAQZklakEAOgAAIAAgACgCwC8iAkEBajYCwC8gAkEJTgRAIAJBHkgNAiAAQQo2AsAvCyAAQQA2ArwvDAELIABCADcCvC9BASEBIABBmSVqQQE6AAALIAAgACgC8CxqQewkaiABOgAACy0BAn8gAUEBTgRAA0AgACADaiwAACACQQh0aiECIANBAWoiAyABRw0ACwsgAgvNAwEHfyAEQQFOBEADQCABIAhBAnRqIgooAgAQFhogACAIaiIGIAooAgAQFkEQdEGAgNi+f2pBEHVByxFsIgdBEHYiBToAACAHQQh0QRh1IAIsAABIBEAgBiAFQQFqIgU6AAALIAYgBUEAIAVBGHRBGHVBAEobIgVBPyAFQRh0QRh1QT9IGyIHOgAAIAIsAAAhBQJAIAMgCHJFBEAgBiAFQXxqIgZBPyAGIAdB/wFxIgdIGyAGIAcgBiAHShsgBUHDAEobIgU6AAAgAiAFOgAADAELIAYgByAFayIFOgAAIAIsAAAiCUEIaiIHIAVBGHRBGHUiC0gEQCAGIAsgCWtB+QNqQQF2IAdqIgU6AAALIAYgBUF8IAVBGHRBGHVBfEobIgVBJCAFQRh0QRh1QSRIGyIFOgAAIAICfyAHIAVBGHRBGHUiCUgEQCACIAItAAAgCUEBdCAHa2oiBToAACAFQT8gBUEYdEEYdUE/SBsMAQsgAi0AACAFags6AAAgBiAGLQAAQQRqOgAAIAItAAAhBQsgCiAFQRh0QRh1IgVB8ThsQRB1IAVBHWxqIgVB1Q4gBUHVDkgbQaoQahA1NgIAIAhBAWoiCCAERw0ACwsLzQsDC38DfQl8IwBB4AdrIgckACABIAMgBGwQGyEYIAdBoAZqQQBBwAEQERogBEEBTgRAA0BBASEGIAVBAU4EQCABIAMgCGxBAnRqIQkDQCAGQQN0IAdqIgpBmAZqIAkgCSAGQQJ0aiADIAZrEDYgCisDmAagOQMAIAUgBkchCiAGQQFqIQYgCg0ACwsgCEEBaiIIIARHDQALCyAHQeAEaiAHQaAGakHAARANGiAHIBggGEQAAACAtfjkPqIiHKBEAAAA4AsuET6gIhU5A8ABIAcgFTkDkAMCfAJAIAVBAUgEQEQAAAAAAADwPyEUDAELIAK7IRlBACEIQQIhEEEBIQ9EAAAAAAAA8D8hFwNAIARBAU4EQCADIAhrIg1Bf2ohDkEAIQoDQCABIAMgCmxBAnRqIgkgDkECdGoqAgAiArshFCAJIAhBAnRqKgIAIhG7IRVBACEGIAgEQANAIAZBA3QiCyAHQaAGamoiDCAMKwMAIBEgCSAIIAZBf3NqQQJ0aioCACISlLuhOQMAIAdB4ARqIAtqIgwgDCsDACACIAkgBiANakECdGoqAgAiE5S7oTkDACAVIAcgC2orAwAiFiASu6KgIRUgFCAWIBO7oqAhFCAGQQFqIgYgCEcNAAsLQQAhBgNAIAZBA3QiCyAHQZADamoiDCAMKwMAIBUgCSAIIAZrQQJ0aioCALuioTkDACAHQcABaiALaiILIAsrAwAgFCAJIAYgDmpBAnRqKgIAu6KhOQMAIAZBAWoiBiAPRw0ACyAKQQFqIgogBEcNAAsLIAhBA3QiDiAHQeAEamorAwAhFSAHQaAGaiAOaisDACEUQQAhBiAIBEADQCAVIAcgBkEDdGorAwAiFiAIIAZBf3NqQQN0IgkgB0GgBmpqKwMAoqAhFSAUIBYgB0HgBGogCWorAwCioCEUIAZBAWoiBiAIRw0ACwsgCEEBaiIJQQN0IgYgB0GQA2pqIBQ5AwAgB0HAAWogBmoiCyAVOQMAQQAhBiAHKwPAASEUIAcrA5ADIhohFiAIBEADQCAWIAcgBkEDdGorAwAiGyAGQQFqIgpBA3QiDSAHQZADamorAwCioCEWIBQgGyAHQcABaiANaisDAKKgIRQgFSAbIAdBwAFqIAggBmtBA3RqKwMAoqAhFSAKIgYgCEcNAAsLQQAhBkEAIQogF0QAAAAAAADwPyAVRAAAAAAAAADAoiAWIBSgoyIUIBSioaIiFiAZZUEBc0UEQEQAAAAAAADwPyAZIBejoZ8iFpogFiAVRAAAAAAAAAAAZBshFEEBIQogGSEWCyAJQf7///8HcQRAIA9BAXYhDQNAIAcgBkEDdGoiDCAMKwMAIhcgFCAHIAggBkF/c2pBA3RqIgwrAwAiFaKgOQMAIAwgFSAUIBeioDkDACAGQQFqIgYgDUcNAAsLIAcgDmogFDkDAAJAIApFBEAgByAaIBQgCysDACIXoqA5A5ADIAsgFyAUIBqioDkDAEEBIQYDQCAHQcABaiAJIAZrQQN0aiIIIAgrAwAiFyAUIAdBkANqIAZBA3RqIggrAwAiFaKgOQMAIAggFSAUIBeioDkDACAGQQFqIgYgEEcNAAsMAQsgCSAFSARAIAcgCUEDdGpBACAFIAlrQQN0EBEaC0EAIQYDQCAAIAZBAnRqIAcgBkEDdGorAwC2jDgCACAGQQFqIgYgBUcNAAtBACEGIARBAEoEQANAIBggASADIAZsQQJ0aiAFEBuhIRggBkEBaiIGIARHDQALCyAWIBiiDAMLIBBBAWohECAPQQFqIQ8gFiEXIAkiCCAFRw0AC0EAIQZEAAAAAAAA8D8hFCAHKwOQAyEVA0AgB0GQA2ogBkEBaiIBQQN0aisDACEZIAAgBkECdGogByAGQQN0aisDACIWtow4AgAgFSAWIBmioCEVIBQgFiAWoqAhFCABIgYgBUcNAAsLIBUgHCAUoqELIRQgB0HgB2okACAUtguDAgIDfwJ+IAAoAiAiAgRAIAIQDgsgAEIANwMoIABBADYCIAJAIAEpAygiBVANACABKAIgIgNFDQAgBaciBBAXIgJFBEBBAA8LIAAgBTcDKCAAIAI2AiAgAiADIAQQDRoLIABCADcDACAAKAIIIgIEQCACEA4LIABCADcDECAAQQA2AggCQCABKQMQIgVQDQAgASgCCCIDRQ0AIAEpAwAhBiAFpyIEEBciAkUEQEEADwsgACAFNwMQIAAgAjYCCCAAIAY3AwAgAiADIAQQDRoLIAAgASkDGDcDGCAAIAEtACQ6ACQgACABKQMwNwMwIAAgASkDODcDOCAAIAEpA0A3A0BBAQsIACAAQeAAagucBgEIfyMAQfAHayIHJAACQCAAKALgIyIKQQFOBEAgACgCmCQiCUEBSCELA0AgC0UEQCAIQRhsIQxBACEGA0AgB0EwaiAGIAxqIg1BAXRqIAEgDUECdGoqAvQBQwAAAEaUEBg7AQAgBkEBaiIGIAlHDQALCyAIQQFqIgggCkcNAAtBACEIA0AgASAIQQJ0IgZqIgkqAoQFQwAAgEaUEBghCyAHQSBqIAZqIAkqAvQEQwAAgEaUEBhB//8DcSALQRB0cjYCACAHQRBqIAZqIAkqApQFQwAAgEaUEBg2AgAgBiAHaiAJKgKkBUMAAIBGlBAYNgIAIAhBAWoiCCAKRw0ACyAKQQVsIgZBASAGQQFKGyEIQQAhBiABKgK0BUMAAIBElBAYIQkDQCAHQfABaiAGQQF0aiABIAZBAnRqKgKQAUMAAIBGlBAYOwEAIAZBAWoiBiAIRw0ACwwBCyABKgK0BUMAAIBElBAYIQkLQQAhBiAAKAKcJCIIQQBKBEADQCAHQaACaiAGQQF0aiABIAZBAnRqKgIQQwAAgEWUEBg7AQAgBkEBaiIGIAhHDQALQQAhBgNAIAZBAXQgB2ogASAGQQJ0aioCUEMAAIBFlBAYOwHAAiAGQQFqIgYgCEcNAAsLQQAhBiAKQQBKBEADQCAGQQJ0IgggB0HgAmpqIAEgCGoqAgBDAACAR5QQGDYCACAGQQFqIgYgCkcNAAsLQQAhBkEAIQggAi0AHUECRgRAIAIsACFBAXRBqDhqLgEAIQgLIAAoAuQjIgpBAU4EQANAIAdB8AJqIAZBAXRqIAUgBkECdGoqAgAQGDsBACAGQQFqIgYgCkcNAAsLAkACQCAAKAKQJEEBTARAIAAoArwkQQFIDQELIAAgAyACIAdB8AJqIAQgB0GgAmogB0HwAWogB0EwaiAHIAdBEGogB0EgaiAHQeACaiABQeQBaiAJIAgQvAIMAQsgACADIAIgB0HwAmogBCAHQaACaiAHQfABaiAHQTBqIAcgB0EQaiAHQSBqIAdB4AJqIAFB5AFqIAkgCBC6AgsgB0HwB2okAAtRAQN/IwBBQGoiAyQAIAJBAU4EQANAIAMgBEECdCIFaiABIAVqKgIAQwAAgEeUEBg2AgAgBEEBaiIEIAJHDQALCyAAIAMgAhDFAiADQUBrJAALyQQBEn8jAEEQayIJJAAgCEEBSCETQf////8HIRADQCADKAIAIQ4CQCATBEBBACENQQAhCyAOIQwMAQsgD0HcwQBqLAAAIRQgD0ECdCIMQdDBAGooAgAhFSAMQYDBAGooAgAhFiAMQdA+aigCACEXQQAhEUEAIQtBACENIAYhEiAFIQoDQCAJQQxqIBFqIAlBCGogCUEEaiAJIAogEiAWIBUgFyAHQdUwIA5rEDVBTWogFBC5AiAJKAIEIAtqIgtB/////wdJIRggCSgCCCANaiINQf////8HSSEZQQAhDCALQf////8HIBgbIQsgDUH/////ByAZGyENIBJBFGohEiAKQeQAaiEKIAkoAgBBM2oQFiAOakGAB04EQCAJKAIAQTNqEBYgDmpBgHlqIQwLIAwhDiARQQFqIhEgCEcNAAsLIAsgEEwEQCACIA86AAAgASAJQQxqIAgQDRogDCEaIAshEAsgD0EBaiIPQQNHDQALIAhBAU4EQCACLAAAQQJ0QYDBAGooAgAhAkEAIQoDQCAAIApBCmxqIgUgAiABIApqIgYsAABBBWxqLAAAQQd0OwEAIAUgBiwAAEEFbCACaiwAAUEHdDsBAiAFIAYsAABBBWwgAmosAAJBB3Q7AQQgBSAGLAAAQQVsIAJqLAADQQd0OwEGIAUgBiwAAEEFbCACaiwABEEHdDsBCCAKQQFqIgogCEcNAAsLIAMgGjYCACAEIA1BAUECIAhBAkYbdhAWQRB0QYCAgERqQRB1QX1sNgIAIAlBEGokAAuwAQEBfwJAIABCo7+X0gFChoUBQgEQD0L3hQFCARAPfELyhQFCBBAPfELzhQFCCBAPfEKChQFBxA0QGXxCh4UBIAEQD3xChYUBQgIQD3wQFUUNACAAQoaFAUIBEBNFDQAgAEL3hQFCARATRQ0AIABC8oUBQgQQE0UNACAAQvOFAUIIEBNFDQAgAEKChQFBxA0QIEUNACAAQoeFASABEBNFDQAgAEKFhQFCAhATIQILIAILoAIBBn8gBCADSARAIARBB0ghCiAEIQUDQCACLgECIAVBAXQiCyABaiIGQXxqLgEAbCACLgEAIAZBfmoiCS4BAGxqIAIuAQQgBkF6ai4BAGxqIAIuAQYgBkF4ai4BAGxqIAIuAQggBkF2ai4BAGxqIAIuAQogBkF0ai4BAGxqIQdBBiEIIApFBEADQCAHIAIgCEEBdCIHai4BACAJIAdrLgEAbGogAiAHQQJyai4BACAJIAhBf3NBAXRqLgEAbGohByAIQQJqIgggBEgNAAsLIAAgC2ogBi4BAEEMdCAHa0ELdUEBakEBdSIGQYCAfiAGQYCAfkobIgZB//8BIAZB//8BSBs7AQAgBUEBaiIFIANHDQALCyAAQQAgBEEBdBARGgv+BQEOfyABIAJBAXRqIQ0gACACQX9qIgtBAXRqIQkgAkECSCEPAkADQCAALgEAIgMgAS4BACIGayEFQQEhBEEAIQcgD0UEQANAIANBEHQhCCAAIARBAXQiCmouAQAiAyAIQRB1ayABIApqLgEAayIIIAUgCCAFSCIIGyEFIAQgByAIGyEHIARBAWoiBCACRw0ACwtBgIACIA0uAQAiCCAJLgEAamsiAyAFIAMgBUgiAxtBf0oNAQJAIAIgByADGyIDRQRAIAAgBjsBAAwBCwJAAkAgAiADRwRAIANBAU4NAUEAIQYMAgsgCUGAgH4gCGs7AQAMAgtBASEEIANBAUYNAANAIAYgASAEQQF0ai4BAGohBiAEQQFqIgQgA0cNAAsLIAYgASADQQF0IgxqIhAuAQBBAXUiCmohBUGAgAIhBwJAIAMgAk4NAEGAgAIgCGshByALIgQgA0wNAANAIAcgASAEQQF0ai4BAGshByAEQX9qIgQgA0oNAAsLIAAgDGoiCC4BACAIQX5qIgwuAQBqIgNBAXUgA0EBcWohBgJAIAUgByAKayIESgRAIAYgBSIDSg0BIAQgBiAGIARIGyEDDAELIAYgBCIDSg0AIAUgBiAGIAVIGyEDCyAMIAMgCmsiAzsBACAIIAMgEC8BAGo7AQALIA5BAWoiDkEURw0ACyAAIAIQwgIgACAALgEAIgMgAS4BACIEIAMgBEobIgU7AQAgAkECSCIDRQRAQQEhBANAIAAgBEEBdCILaiIHIAcuAQAiByABIAtqLgEAIAVBEHRBEHVqIgVB//8BIAVB//8BSBsiBUGAgH4gBUGAgH5KGyIFIAcgBUobIgU7AQAgBEEBaiIEIAJHDQALCyAJIAkuAQAiBEGAgAIgDS4BAGsiBSAFIARKGyIFOwEAIAMNACACQX5qIQQDQCAAIARBAXQiAmoiAyADLgEAIgMgBUEQdEEQdSABIAJqLgECayICIAIgA0obIgU7AQAgBEEASiECIARBf2ohBCACDQALCwuBAwEIfwJAIANBAEwNAANAIAEgBEECdGogBDYCACAEQQFqIgQgA0cNAAtBASEFIANBAUwNAANAIAAgBUECdGooAgAhByAFIQQCQANAIAcgACAEQX9qIglBAnQiBmooAgAiCk4NASAAIARBAnQiCGogCjYCACABIAhqIAEgBmooAgA2AgAgBEEBSiEGIAkhBCAGDQALQQAhBAsgACAEQQJ0IgRqIAc2AgAgASAEaiAFNgIAQQEhByAFQQFqIgUgA0cNAAsLIAMgAkgEQCADQX5qIQkgA0ECdCAAakF8aiEKA0AgACADQQJ0aigCACIGIAooAgBIBEAgCSIEIQUCQCAHRQ0AA0AgBiAAIARBAnQiBWooAgAiCE4EQCAEIQUMAgsgACAFQQRqIgtqIAg2AgAgASALaiABIAVqKAIANgIAQX8hBSAEQQBKIQggBEF/aiEEIAgNAAsLIAAgBUECdEEEaiIEaiAGNgIAIAEgBGogAzYCAAsgA0EBaiIDIAJHDQALCwujAgEFf0EBIQUgAEGAgAggAS4BAiABLgEAIgNrIgRBASAEQQFKG24iBEGAgAggA0EBIANBAUobbmoiA0H//wEgA0H//wFJGzsBACACQX9qIQMgAkEDTgRAA0AgACAFQQF0IgJqIARBgIAIIAEgAkECaiIEaiIGLgEAIAEgAmouAQBrIgJBASACQQFKG24iAmoiB0H//wEgB0H//wFJGzsBACAAIARqIAJBgIAIIAEgBUECaiIFQQF0ai4BACAGLgEAayICQQEgAkEBShtuIgRqIgJB//8BIAJB//8BSRs7AQAgBSADSA0ACwsgACADQQF0IgJqQYCACEGAgAIgASACai4BAGsiAEEBIABBAUobbiAEaiIAQf//ASAAQf//AUkbOwEAC5UHAgx/BH4jAEHgAGshBwJAIAFBAU4EQANAIAcgBEECdGogACAEQQF0ai4BACIJQQx0NgIAIAIgCWohAiAEQQFqIgQgAUcNAAsgAkH/H0oNAQsgByABQX9qIgJBAnRqKAIAIgBBnt//B2pBvL7/D0shBEKAgICABCEOIAFBAk4EQANAIARBAXEEQEEADwsgDkGAgICABEEAIABBB3RrrCIQIBB+QiCIpyIGayIIrH5CHoinQXxxIg1B7sYGSA0CIAIhCUH/////ASAIIAZBgICAgHxqIgsgCCAGQYCAgIAESxtnIgVBf2p0IgRBEHUiAm0iAEEPdUEBakEBdUEAIABBEHQiAEEQdSIDIARB//8DcWxBEHUgAiADbGpBA3RrIgJsIABqIAJBEHUgA2xqIAJB+P8DcSADbEEQdWohAwJ/IAggCyAGQYCAgIAESRtnIgggBWsiAEEATARAAkBBgICAgHhBACAAayIFdSIEQf////8HIAV2IgJKBEAgAyAEIgBKDQEgAiADIAMgAkgbIAV0DAMLIAMgAiIASg0AIAQgAyADIARIGyEACyAAIAV0DAELIAMgAHVBACAAQSBIGwshAiABQQF2IgBBASAAQQFLGyELQR8gCGutIREgAqwhD0EAIQIDQEGAgICAeEH/////ByAHIAJBAnRqIgUoAgAiDCAHIAkgAkF/c2pBAnRqIgQoAgAiBqwgEH5CHohCAXxCAYinIgNrIgBBf0oiARsgACADIAwgARtBgICAgHhzIAwgAyABG3FBAEgbrCAPfiEOAn4gDkIBgyAOQgGHfCAIQR9HIgFFDQAaIA4gEYdCAXxCAYcLIg5CgICAgAh8Qv////8PVg0DIAUgDj4CAEGAgICAeEH/////ByAGIAysIBB+Qh6IQgF8QgGIpyIDayIAQX9KIgUbIAAgAyAGIAUbQYCAgIB4cyAGIAMgBRtxQQBIG6wgD34hDiABBH4gDiARh0IBfEIBhwUgDkIBgyAOQgGHfAsiDkKAgICACHxC/////w9WDQMgBCAOPgIAIAJBAWoiAiALRw0ACyAHIAlBf2oiAkECdGooAgAiAEGe3/8HakG8vv8PSyEEIA2sIQ4gCSIBQQFKDQALCyAEDQBBAEKAgICAgICAgMAAQQAgBygCAEEHdGusIg8gD35CgICAgPD/////AIN9QiCHIA5+Qh6Ip0F8cSIAIABB7sYGSBshCgsgCgu/AwEEfyABIANBAnQiBGpBgIAENgIAIAIgBGpBgIAENgIAAkAgA0EBSA0AQQAhBANAIAEgBEECdCIFakEAIAAgAyAEakECdGoiBigCACAAIARBf3MgA2pBAnRqIgcoAgBqazYCACACIAVqIAYoAgAgBygCAGs2AgAgBEEBaiIEIANHDQALIAMhBANAIAEgBEF/aiIAQQJ0IgVqIgYgBigCACABIARBAnQiBmooAgBrNgIAIAIgBWoiBSAFKAIAIAIgBmooAgBqNgIAIARBAUohBSAAIQQgBQ0AC0ECIQAgA0ECSA0AA0AgACADIgRIBEADQCABIARBAnRqIgVBeGoiBiAGKAIAIAUoAgBrNgIAIARBf2oiBCAASg0ACwtBAiEFIAEgAEECdGoiBEF4aiIGIAYoAgAgBCgCAEEBdGs2AgAgACADRyEEIABBAWohACAEDQALA0AgBSADIgRIBEADQCACIARBAnRqIgBBeGoiASABKAIAIAAoAgBrNgIAIARBf2oiBCAFSg0ACwsgAiAFQQJ0aiIAQXhqIgEgASgCACAAKAIAQQF0azYCACADIAVHIQAgBUEBaiEFIAANAAsLC6EBAQR/IAJB/P8DcSIDBEADQCAAIARBAnQiBWoiBiAGKgIAIAGUOAIAIAAgBUEEcmoiBiAGKgIAIAGUOAIAIAAgBUEIcmoiBiAGKgIAIAGUOAIAIAAgBUEMcmoiBSAFKgIAIAGUOAIAIARBBGoiBCADSQ0ACwsgAyACSARAA0AgACADQQJ0aiIEIAQqAgAgAZQ4AgAgA0EBaiIDIAJHDQALCwvyAQEHfyADQQJOBEAgA0EBdSIDQQEgA0EBShshCCAAKAIEIQQgACgCACEFQQAhAwNAIAEgA0EBdGpB//8BIAIgA0ECdCIGai4BAEEKdCIHIAVrIgVB//8DcUGBt35sQRB1IAVBEHVBgbd+bGogB2oiByAEaiACIAZBAnJqLgEAQQp0IgYgBGsiBEH//wNxQZDNAGxBEHYgBEEQdUGQzQBsaiIEaiIJQQp1QQFqQQF1IgpBgIB+IApBgIB+ShsgCUH/9/8fShs7AQAgBCAGaiEEIAUgB2ohBSADQQFqIgMgCEcNAAsgACAENgIEIAAgBTYCAAsLpAECB38DfUEBIQUgAkEBTgRAA0AgASADQQJ0IgdqKgIAIQogA0EBaiIIQf7///8HcQRAIAVBAXYhCUEAIQQDQCAAIARBAnRqIgYgBioCACILIAogACADIARBf3NqQQJ0aiIGKgIAIgyUkjgCACAGIAwgCiALlJI4AgAgBEEBaiIEIAlHDQALCyAAIAdqIAqMOAIAIAVBAWohBSAIIgMgAkcNAAsLC74CAgR/A3wjAEGQA2siBCQAIAJBAWpBASACQQBKGyEGA0AgBCADQQR0aiIFIAEgA0ECdGoqAgC7Igc5AwAgBSAHOQMIIANBAWoiAyAGRw0ACyACQQFOBEBBACEBIAIhBgNAIAAgASIDQQJ0aiAEIANBAWoiAUEEdGoiBSsDAJogBCsDCCIIRAAAAOALLhE+IAhEAAAA4AsuET5kG6MiB7Y4AgACQCADIAJODQAgBSAFKwMAIgkgByAIoqA5AwAgBCAIIAcgCaKgOQMIQQEhAyAGQQFGDQADQCAEIAEgA2pBBHRqIgUgBSsDACIIIAcgBCADQQR0aiIFKwMIIgmioDkDACAFIAkgByAIoqA5AwggA0EBaiIDIAZHDQALCyAGQX9qIQYgASACRw0ACwsgBCsDCCEHIARBkANqJAAgB7YLRQECfyACIAMgAyACShsiBEEBTgRAQQAhAwNAIAAgA0ECdCIFaiABIAEgBWogAiADaxA2tjgCACADQQFqIgMgBEcNAAsLC0oAAkAgAUGA9wJGBEAgAkF/akH/AXFBAk8NASAAIAI6AAggAEGA9wI2AgQPC0H8C0GRDEEUQbMMEAAAC0G4DEGRDEEWQbMMEAAAC70KAQp/IwBBEGsiCCQAIAhBBGogCEEMaiABIAQQnwEgCCAIQQhqIAIgBBCfASAIIAgoAgAgCCgCDCIHIAgoAggiBiAHIAZKGyILQQFxIAtqIgogBmt1NgIAIAggCCgCBCAKIAdrdSIHQQEgB0EBShs2AgQgASACIAogBBDaAiILIAsgC0EfdSIBaiABc2ciB0F/anQiAkH/////ASAIKAIEIgQgBCAEQR91IgFqIAFzZyIJQX9qdCIGQRB1bUEQdEEQdSIBIAJB//8DcWxBEHUgAkEQdSABbGoiAqwgBqx+Qh2Ip0F4cWsiBkEQdSABbCACaiAGQf//A3EgAWxBEHVqIQYgBQJ/IAcgCWtBEGoiAUF/TARAAkBBgICAgHhBACABayIJdSICQf////8HIAl2IgdKBEAgBiACIgFKDQEgByAGIAYgB0gbIAl0DAMLIAYgByIBSg0AIAIgBiAGIAJIGyEBCyABIAl0DAELIAYgAXVBACABQSBIGwsiAkGAgH8gAkGAgH9KGyIBQYCAASABQYCAAUgbIgdB//8DcSAHbEEQdSAHQRB1IAdsaiINIA1BH3UiAWogAXMiASABIAVIGyEBIApBAXUhBkEAIQUgAygCACEKIAMCfyAEQQBMBEAgAUEQdEEQdSICQQAgCmtBEHVsDAELIARnIgVBaGohDkGAgAJBhukCIAVBAXEbIAVBAXZ2IgwgDAJ/IARBGCAFayIJRQ0AGiAEIA50IARBOCAFa3ZyIARB/wBNDQAaIAQgBUEIanQgBCAJdnILQf8AcUGAgNQGbEEQdmxBEHZqIAZ0IAprQRB1IQ8gAUEQdEEQdSECIAwCfyAEIAlFDQAaIAQgDnQgBEE4IAVrdnIgBEH/AE0NABogBCAFQQhqdCAEIAl2cgtB/wBxQYCA1AZsQRB2IAxsQRB2aiEFIAIgD2wLIApqIAUgBnQgCmtB//8DcSACbEEQdWoiDDYCACAIIAgoAgAgByALQRB1bCAHIAtB//8DcWxBEHVqQQR0ayANQRB0QRB1IgEgBEH//wNxbEEQdSABIARBEHVsakEGdGoiBDYCACADIAMoAgQiCwJ/IARBAUgEQEEAIQRBAAwBCyAEZyIFQWhqIQ1BgIACQYbpAiAFQQFxGyAFQQF2diIJIAkCfyAEQRggBWsiCkUNABogBCANdCAEQTggBWt2ciAEQf8ATQ0AGiAEIAVBCGp0IAQgCnZyC0H/AHFBgIDUBmxBEHZsQRB2aiEBAkAgCkUNACAEQf8ATQRAIAQgDXQgBEE4IAVrdnIhBAwBCyAEIAVBCGp0IAQgCnZyIQQLIAkgBEH/AHFBgIDUBmxBEHYgCWxBEHZqIQQgASAGdAsgC2tBEHUgAmxqIAQgBnQgC2tB//8DcSACbEEQdWoiATYCBCABIAEgAUEfdSICaiACc2ciBEF/anQiAkH/////ASAMQQEgDEEBShsiASABZyIFQX9qdCIDQRB1bUEQdEEQdSIBIAJB//8DcWxBEHUgAkEQdSABbGoiAqwgA6x+Qh2Ip0F4cWsiA0EQdSABbCACaiADQf//A3EgAWxBEHVqIQMgAAJ/IAQgBWtBD2oiAUF/TARAAkBBgICAgHhBACABayIEdSIBQf////8HIAR2IgJKBEAgAyABIgVKDQEgAiADIAMgAkgbIAR0DAMLIAMgAiIFSg0AIAEgAyADIAFIGyEFCyAFIAR0DAELIAMgAXVBACABQSBIGwsiBEEAIARBAEobIgBB//8BIABB//8BSBs2AgAgCEEQaiQAIAcLoAIBBn8gA0F/aiEIQR8gA2ciB2shBQJAIANBAkgEQCADIQQMAQsgAyEEA0AgBCACIAZBAXQiBEECcmouAQAiCSAJbCACIARqLgEAIgQgBGxqIAV2aiEEIAZBAmoiBiAISA0ACyADQX5xIQYLIAYgA0gEQCAEIAIgBkEBdGouAQAiBCAEbCAFdmohBAtBACEFQSIgByAEZ2prIgRBACAEQQBKGyEEIANBAkgEf0EABUEAIQYDQCAFIAIgBkEBdCIFQQJyai4BACIHIAdsIAIgBWouAQAiBSAFbGogBHZqIQUgBkECaiIGIAhIDQALIANBfnELIgYgA0gEQCACIAZBAXRqLgEAIgIgAmwgBHYgBWohBQsgASAENgIAIAAgBTYCAAsEACAAC/YFAQt/AkAgAUF/aiIKQYACTwRAIAAgACgCHCIDIApBGCAKZ2siBnYiAkEBaiIEbiIBNgIkIAAgACgCICIFIAJBACAFIAFuIgVBAWoiCCAEayIEIAQgCEsbIAIgBWtqIgtrIAFsIgJrIgc2AiAgACABIAMgAmsgCxsiAjYCHCACQYCAgARNBEAgACgCGCEDIAAoAighBCAAKAIUIQUgACgCBCEMA0AgACACQQh0Igg2AhwgACAFQQhqIgU2AhRBACEBIAMgDEkEQCAAIANBAWoiCTYCGCAAKAIAIANqLQAAIQEgCSEDCyAAIAE2AiggACABIARBCHRyQQF2Qf8BcSAHQQh0QYD+//8HcXJB/wFzIgc2AiAgAkGBgAJJIQkgASEEIAghAiAJDQALCyALIAZ0IQggACgCDCEHAkAgACgCECIBIAZPBEAgASEFDAELIAAoAgghAiAAKAIEIQQDQEEAIQMgAiAESQR/IAAgAkEBaiICNgIIIAAoAgAgBCACa2otAAAFQQALIAF0IAdyIQcgAUERSCEDIAFBCGoiBSEBIAMNAAsLIAAgBSAGazYCECAAIAcgBnY2AgwgACAAKAIUIAZqNgIUIAdBfyAGdEF/c3EgCHIiBiAKTQ0BIABBATYCLCAKDwsgACAAKAIcIgMgAW4iAjYCJCAAIAAoAiAiBCABIAQgAm4iBEF/cyABakEAIARBAWoiBCABayIBIAEgBEsbaiIGQX9zaiACbCIBayIHNgIgIAAgAiADIAFrIAYbIgI2AhwgAkGAgIAESw0AIAAoAhghAyAAKAIoIQQgACgCFCEFIAAoAgQhCgNAIAAgAkEIdCIINgIcIAAgBUEIaiIFNgIUQQAhASADIApJBEAgACADQQFqIgk2AhggACgCACADai0AACEBIAkhAwsgACABNgIoIAAgASAEQQh0ckEBdkH/AXEgB0EIdEGA/v//B3FyQf8BcyIHNgIgIAJBgYACSSEJIAEhBCAIIQIgCQ0ACwsgBgvrAQEGfyAAIAAoAiAgACgCJCIEIAMgAmtsIgNrIgY2AiAgACABBH8gBCACIAFrbAUgACgCHCADawsiAjYCHCACQYCAgARNBEAgACgCGCEDIAAoAighBCAAKAIUIQcgACgCBCEIA0AgACACQQh0Igk2AhwgACAHQQhqIgc2AhRBACEBIAMgCEkEQCAAIANBAWoiBTYCGCAAKAIAIANqLQAAIQEgBSEDCyAAIAE2AiggACAGQQh0QYD+//8HcSABIARBCHRyQQF2Qf8BcXJB/wFzIgY2AiAgAkGBgAJJIQUgASEEIAkhAiAFDQALCws4AQF/IAAgACgCHCABbiICNgIkIAAoAiAgAm4iAEF/cyABakEAIABBAWoiACABayIBIAEgAEsbagsNACAAIAFB+TdBCBAQC1EAIAAgASwABSABLAACQQVsakHgN0EIEBAgACABLAAAQa44QQgQECAAIAEsAAFBtThBCBAQIAAgASwAA0GuOEEIEBAgACABLAAEQbU4QQgQEAvjBgEHfwJAAkBB/////wcgACgCHCIDZyIFdiIBIAAoAiAiBGpBgICAgHggBXVxIgIgAXIgAyAEak8EQCABQQF2IgEgBGogAUF/c3EhAiAFQQFqIQUMAQsgBUUNAQsgBSEEA0ACQCACQRd2IgZB/wFHBEAgAkEfdiEFIAAoAigiB0EATgRAQX8hASAAIAAoAhgiAyAAKAIIaiAAKAIESQR/IAAgA0EBajYCGCAAKAIAIANqIAUgB2o6AABBAAVBfwsgACgCLHI2AiwLIAAoAiQiAQRAIAVBf2ohBwNAQX8hAyAAIAAoAhgiBSAAKAIIaiAAKAIESQR/IAAgBUEBajYCGCAAKAIAIAVqIAc6AABBACEDIAAoAiQFIAELQX9qIgE2AiQgACAAKAIsIANyNgIsIAENAAsLIAAgBkH/AXE2AigMAQsgACAAKAIkQQFqNgIkCyACQQh0QYD+//8HcSECIARBCEohASAEQXhqIgUhBCABDQALC0F/IQECQAJAAkAgACgCKCIEQX9MBEAgACgCJCIBDQEMAwsgACAAKAIYIgIgACgCCGogACgCBEkEfyAAIAJBAWo2AhggACgCACACaiAEOgAAQQAFQX8LIAAoAixyNgIsIAAoAiQiAUUNAQsDQEF/IQMgACAAKAIYIgIgACgCCGogACgCBEkEfyAAIAJBAWo2AhggACgCACACakH/AToAAEEAIQMgACgCJAUgAQtBf2oiATYCJCAAIAAoAiwgA3I2AiwgAQ0ACwsgAEEANgIoCyAAKAIMIQMCQCAAKAIQIgJBB0wEQCAAKAIsIQQMAQsgAiEBA0BBfyECIAAgACgCCCIEIAAoAhhqIAAoAgQiBkkEfyAAIARBAWoiAjYCCCAAKAIAIAYgAmtqIAM6AABBAAVBfwsgACgCLHIiBDYCLCADQQh2IQMgAUEPSiEGIAFBeGoiAiEBIAYNAAsLAkAgBA0AIAAoAhgiASAAKAIAakEAIAAoAgQgAWsgACgCCGsQERogAkEBSA0AIAAoAggiASAAKAIEIgRPBEAgAEF/NgIsDwsCQCACQQAgBWsiAkwNACAAKAIYIAFqIARJDQAgAEF/NgIsIANBfyACdEF/c3EhAwsgACgCACAEIAFBf3NqaiIAIAAtAAAgA3I6AAALC0UAIABCgICAgICAgICAfzcCGCAAQoCAgICQBDcCECAAQgA3AgggACABNgIAIABCADcCICAAQv////8PNwIoIAAgAjYCBAuoAwEJfyMAQbACayICIQkgAiQAAn8gASAAKALcIyIDRgRAQQAgACgCzCMgACgCyCNGDQEaCyADRQRAIABBjC1qIAAoAsgjIAFB6AdsQQEQYgwBCyACIAAoAuAjQQpsQQVqIgcgA2wiAyABIAdsIgQgAyAEShtBAXRBD2pBcHFrIggiCiQAIANBAU4EQCADIQIDQCAIIAJBf2oiBUEBdGogACAFQQJ0akGIOGoqAgAQGCIGQYCAfiAGQYCAfkobIgZB//8BIAZB//8BSBs7AQAgAkEBSiEGIAUhAiAGDQALCyAJIAAuAdwjQegHbCAAKALII0EAEGIhBSAKIAAoAsgjQegHbSAHbCIHQQF0QQ9qQXBxayICJAAgCSACIAggAxAnIAVqIABBjC1qIgMgACgCyCMgAUEQdEEQdUHoB2xBARBiaiEFIAMgCCACIAcQJyECIARBAU4EQANAIAAgBEF/aiIBQQJ0akGIOGogCCABQQF0ai4BALI4AgAgBEEBSiEDIAEhBCADDQALCyACIAVqCyEEIAAgACgCyCM2AswjIAlBsAJqJAAgBAuvEgERfyMAIgchEiAHIAAoApQCIgggACgCjAIiBGpBAnRBD2pBcHFrIgckACAHIABBGGoiEyAIQQJ0EA0hDCAAKAKoAiIHQQRqIRAgACgCkAIhDyAHIQUDQCAAIAwgCEECdGogAiAFIAMgBCADIARIGyIOEKoBAkAgACgClAIiEUFuaiIFQRJLDQAgDkEQdCENAkACQAJAIAVBAWsOEgMDAwMDAQMDAwMDAwMDAwMDAgALIA1BAUgNAiAAKAKYAiIGQRB0QRB1IRRBACEFA0AgAUH//wEgECAFQf//A3EgFGxBEHUiCkESbGoiBC4BACIJIAwgBUEQdUECdGoiCCgCACILQf//A3FsQRB1IAtBEHUgCWxqIAQuAQIiCSAIKAIEIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQQiCSAIKAIIIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQYiCSAIKAIMIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQgiCSAIKAIQIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQoiCSAIKAIUIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQwiCSAIKAIYIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQ4iCSAIKAIcIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuARAiBCAIKAIgIglBEHVsaiAJQf//A3EgBGxBEHVqIBAgBiAKQX9zakESbGoiBC4BACIKIAgoAkQiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BAiIKIAgoAkAiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BBCIKIAgoAjwiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BBiIKIAgoAjgiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BCCIKIAgoAjQiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BCiIKIAgoAjAiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BDCIKIAgoAiwiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BDiIKIAgoAigiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BECIEIAgoAiQiCEEQdWxqIAhB//8DcSAEbEEQdWoiCEEFdUEBakEBdSIEQYCAfiAEQYCAfkobIAhB3///AEobOwEAIAFBAmohASAFIA9qIgUgDUgNAAsMAgtBACEIIA1BAEwNAQNAIAFB//8BIAcuAQQiBCAMIAhBEHVBAnRqIgUoAlwgBSgCAGoiBkH//wNxbEEQdSAGQRB1IARsaiAHLgEGIgQgBSgCWCAFKAIEaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEIIgQgBSgCVCAFKAIIaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEKIgQgBSgCUCAFKAIMaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEMIgQgBSgCTCAFKAIQaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEOIgQgBSgCSCAFKAIUaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEQIgQgBSgCRCAFKAIYaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgESIgQgBSgCQCAFKAIcaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEUIgQgBSgCPCAFKAIgaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEWIgQgBSgCOCAFKAIkaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEYIgQgBSgCNCAFKAIoaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEaIgQgBSgCMCAFKAIsaiIFQRB1bGogBUH//wNxIARsQRB1aiIFQQV1QQFqQQF1IgRBgIB+IARBgIB+ShsgBUHf//8AShs7AQAgAUECaiEBIAggD2oiCCANSA0ACwwBC0EAIQggDUEATA0AA0AgAUH//wEgBy4BBCIEIAwgCEEQdUECdGoiBSgCjAEgBSgCAGoiBkH//wNxbEEQdSAGQRB1IARsaiAHLgEGIgQgBSgCiAEgBSgCBGoiBkEQdWxqIAZB//8DcSAEbEEQdWogBy4BCCIEIAUoAoQBIAUoAghqIgZBEHVsaiAGQf//A3EgBGxBEHVqIAcuAQoiBCAFKAKAASAFKAIMaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEMIgQgBSgCfCAFKAIQaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEOIgQgBSgCeCAFKAIUaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEQIgQgBSgCdCAFKAIYaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgESIgQgBSgCcCAFKAIcaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEUIgQgBSgCbCAFKAIgaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEWIgQgBSgCaCAFKAIkaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEYIgQgBSgCZCAFKAIoaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEaIgQgBSgCYCAFKAIsaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEcIgQgBSgCXCAFKAIwaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEeIgQgBSgCWCAFKAI0aiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEgIgQgBSgCVCAFKAI4aiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEiIgQgBSgCUCAFKAI8aiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEkIgQgBSgCTCAFKAJAaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEmIgQgBSgCSCAFKAJEaiIFQRB1bGogBUH//wNxIARsQRB1aiIFQQV1QQFqQQF1IgRBgIB+IARBgIB+ShsgBUHf//8AShs7AQAgAUECaiEBIAggD2oiCCANSA0ACwsgAyAOayIDQQJOBEAgDCAMIA5BAnRqIBFBAnQQDRogAiAOQQF0aiECIAAoAqgCIQUgACgClAIhCCAAKAKMAiEEDAELCyATIAwgDkECdGogEUECdBANGiASJAALlQEBBX8gBEEBTgRAIAAoAgAhBSADLgECIQYgAy4BACEHQQAhAwNAIAEgA0ECdGogAiADQQF0ai4BAEEIdCAFaiIFNgIAIAAoAgQhCCAAIAVBAnQiBUH8/wNxIgkgBmxBEHUgBUEQdSIFIAZsajYCBCAAIAggBSAHbGogByAJbEEQdWoiBTYCACADQQFqIgMgBEcNAAsLC7EDAQp/IwAiBSEJIAUgACgCjAIiBEECdEEfakFwcWsiBSQAIAUgACkCIDcCCCAFIAApAhg3AgAgBUEQaiEKIAAoApACIQsDQCAAIAogAiADIAQgAyAESBsiBxCtAUEAIQggB0ERdCIMQQFOBEADQCABQf//ASAIQf//A3FBDGxBEHYiDUEDdCIGQfI7ai4BACAFIAhBEHVBAXRqIgQuAQJsIAZB8DtqLgEAIAQuAQBsaiAGQfQ7ai4BACAELgEEbGogBkH2O2ouAQAgBC4BBmxqQQsgDWtBA3QiBkH2O2ouAQAgBC4BCGxqIAZB9DtqLgEAIAQuAQpsaiAGQfI7ai4BACAELgEMbGogBkHwO2ouAQAgBC4BDmxqIgRBDnVBAWpBAXUiBkGAgH4gBkGAgH5KGyAEQf///v8DShs7AQAgAUECaiEBIAggC2oiCCAMSA0ACwsgAyAHayIDQQFOBEAgBSAFIAdBAnRqIgQpAgA3AgAgBSAEKQIINwIIIAIgB0EBdGohAiAAKAKMAiEEDAELCyAAIAUgB0ECdGoiASkCADcCGCAAIAEpAgg3AiAgCSQACw0AIAAgASACIAMQrQEL2wMBDn8gA0EBTgRAIAAoAhQhCCAAKAIQIQYgACgCDCEEIAAoAgghCSAAKAIEIQcgACgCACEFA0AgASAKQQJ0IgtqQf//ASAHIAUgAiAKQQF0ai4BAEEKdCIMIAVrIgVB//8DcUHSDWxBEHYgBUEQdUHSDWxqIg1qIg4gB2siB0H//wNxQYr1AGxBEHYgB0EQdUGK9QBsaiIPaiIFIAlrIgdB//8DcUGrsX5sQRB1IAdBEHVBq7F+bGogBWoiBUEJdUEBakEBdSIJQYCAfiAJQYCAfkobIAVB//v/D0obOwEAIAEgC0ECcmpB//8BIAYgBCAMIARrIgRB//8DcUHGNWxBEHYgBEEQdUHGNWxqIgtqIhAgBmsiBkH//wNxQanJAWxBEHYgBkEQdUGpyQFsaiIRaiIEIAhrIgZB//8DcUH2sX9sQRB1IAZBEHVB9rF/bGogBGoiBEEJdUEBakEBdSIIQYCAfiAIQYCAfkobIARB//v/D0obOwEAIAQgBmohCCAFIAdqIQkgECARaiEGIA4gD2ohByALIAxqIQQgDCANaiEFIApBAWoiCiADRw0ACyAAIAg2AhQgACAGNgIQIAAgBDYCDCAAIAk2AgggACAHNgIEIAAgBTYCAAsLfwEDfyMAQRBrIgEkACABQQo6AA8CQCAAKAIQIgJFBEAgABCvAQ0BIAAoAhAhAgsCQCAAKAIUIgMgAk8NACAALABLQQpGDQAgACADQQFqNgIUIANBCjoAAAwBCyAAIAFBD2pBASAAKAIkEQEAQQFHDQAgAS0ADxoLIAFBEGokAAtZAQF/IAAgAC0ASiIBQX9qIAFyOgBKIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAsJACAAIAEQ7gILrwMBBn8gABDsAiIBQQFOBH9BECEDIAAgAWoiBEFwaiICQRA2AgwgAkEQNgIAAkACQAJAQYDnAigCACIARQ0AIAEgACgCCEcNACABIAFBfGooAgAiA0EfdSADc2siBkF8aigCACEFIAAgBDYCCEFwIQMgBiAFIAVBH3VzayIAIAAoAgBqQXxqKAIAQX9KDQEgACgCBCIBIAAoAgg2AgggACgCCCABNgIEIAAgAiAAayIBNgIADAILIAFBEDYCDCABQRA2AgAgASAENgIIIAEgADYCBEGA5wIgATYCAAsgASADaiIAIAIgAGsiATYCAAsgAUF8cSAAakF8aiABQX9zNgIAIAACfyAAKAIAQXhqIgFB/wBNBEAgAUEDdkF/agwBCyABZyECIAFBHSACa3ZBBHMgAkECdGtB7gBqIAFB/x9NDQAaIAFBHiACa3ZBAnMgAkEBdGtBxwBqIgFBPyABQT9JGwsiAUEEdCICQYDfAmo2AgQgACACQYjfAmoiAigCADYCCCACIAA2AgAgACgCCCAANgIEQYjnAkGI5wIpAwBCASABrYaENwMAQQEFQQALCwMAAQtSAQF/IAAoAgQhBCAAKAIAIgAgAQJ/QQAgAkUNABogBEEIdSIBIARBAXFFDQAaIAIoAgAgAWooAgALIAJqIANBAiAEQQJxGyAAKAIAKAIcEQMACwQAQQALCwAgACABNgIAIAALJgAgAEEANgIMIABBnN4CNgIEIABBnN4CNgIAIABBnd4CNgIIIAALKwEBfyMAQRBrIgEkACABQQA2AgxB5BQoAgAiASAAQQAQvQEgARCAAxABAAsEAEF/CwUAEAEACxIAIABFBEBBAA8LIAAgARCIAwt/AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARC7ASEAIAEoAgBBQGoLNgIAIAAPCyABIAJBgnhqNgIAIANC/////////4eAf4NCgICAgICAgPA/hL8FIAALCxgAIAEgAhAMIAAgACkDECACrXw3AxBBAAsLACAAIAEgAhCdAwujAgACQAJAIAFBFEsNACABQXdqIgFBCUsNAAJAAkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQSARCAALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0IBA38gACgCACwAABA6BEADQCAAKAIAIgIsAAAhAyAAIAJBAWo2AgAgAyABQQpsakFQaiEBIAIsAAEQOg0ACwsgAQsDAAELdgEBfyAABEAgACgCTEF/TARAIAAQag8LIAAQag8LQaDeAigCAARAQaDeAigCABDBASEBC0Gs3gIoAgAiAARAA0AgACgCTEEATgR/QQEFQQALGiAAKAIUIAAoAhxLBEAgABBqIAFyIQELIAAoAjgiAA0ACwsgAQsmAQF/IwBBEGsiBCQAIAQgAzYCDCAAIAEgAiADEJcDIARBEGokAAsoAQF/AkAgAUUNACAAKAIEDQAgACABEI8DIgA2AgQgAEEARyECCyACC2UAIAAQKkEEdEGA/gNxIAAQKkEEdkH/AXFyQRB0IAAQKkEEdEGA/gNxciAAECpBBHZB/wFxcq1CEIYgABAqQQR0QYD+A3GthCAAECpBBHZB/wFxrYRCCIYgABAqQQR2Qf8Bca2EC9wTAgR/C34jAEEQayIDJAACQCAARSABRXINACACRSABEK4CIgRFcg0AIAIpAygiB1ANAEJ/IAEpAzggB4AgAikDIH0iByAHQv//AVYbIhBC//8BVg0AAn8CQCABKAIIDQAgASkDQEIAUg0AIAEpAxhQIQULIAULBEAgAEKjASAAIAAoAgAoAgQRAAAgACgCACgCEBELACADQaMBOgALQQEhAiAAIANBC2pBASAAKAIAKAIAEQEAQQBIDQECQCABKQMoQiCGQoCAgIBAfUIghyIIQv8AVA0AQQIhAiAIQv//AFQNAEEDIQIgCEL///8AVA0AQQQhAiAIQv////8AVA0AQQVBCCAIQv//////AFQbIQILQgEgAkEHbK2GIgdCfnwgCFQNASAHIAiEIQkgAkEBaq0hCkIBIQcCQANAAkAgAyAJIAIgB6drQQN0rYc8AAwgACADQQxqQQEgACgCACgCABEBACIFIAQgBUEASBshBCAFQX9MDQAgCiAHQgF8IgdSDQEMAgsLIAQNAgtCAQJ/QQEgASkDMCIHQv8AVA0AGkECIAdC//8AVA0AGkEDIAdC////AFQNABpBBCAHQv////8AVA0AGkEFIAdC//////8AVA0AGkEGIAdC////////AFQNABpBB0EIIAdC/////////wBUGwsiAkEHbK2GIglCfnwgB1QNASAHIAmEIQkgAkEBaq0hCkIBIQcCQANAAkAgAyAJIAIgB6drQQN0rYc8AA0gACADQQ1qQQEgACgCACgCABEBACIFIAQgBUEASBshBCAFQX9MDQAgCiAHQgF8IgdSDQEMAgsLIAQNAgsgAyAQQgiIPAAOIAAgA0EOakEBIAAoAgAoAgARAQAiBEEASA0BIAMgEDwADiAAIANBDmpBASAAKAIAKAIAEQEAIgJBf0xBACACIAQgAkEASBsbDQEgAyABLQAkQQBHQQd0OgAPIAAgA0EPakEBIAAoAgAoAgARAQBBAEgNASAAIAEoAiAgASgCKCAAKAIAKAIAEQEADQECfkIGIAhC/wBUDQAaQgcgCEL//wBUDQAaQgggCEL///8AVA0AGkIJIAhC/////wBUDQAaQgogCEL//////wBUDQAaQgsgCEL///////8AVA0AGkIMQg0gCEL/////////AFQbCyABKQMofCENDAELIAIpAyghDSABKAIIBEBCASEHAn5CASABKQMQIglC/wBUDQAaQgIgCUL//wBUDQAaQgMgCUL///8AVA0AGkIEIAlC/////wBUDQAaQgUgCUL//////wBUDQAaQgYgCUL///////8AVA0AGkIHQgggCUL/////////AFQbCyEKAkAgASkDACIIQoACVA0AQgIhByAIQoCABFQNAEIDIQcgCEKAgIAIVA0AQgQhByAIQoCAgIAQVA0AQgUhByAIQoCAgICAIFQNAEIGIQcgCEKAgICAgIDAAFQNAEIHQgggCEKAgICAgICAgAFUGyEHC0IBIQgCfkIBIAkgCnwgB3xCA3wiCUL/AFQNABpCAiAJQv//AFQNABpCAyAJQv///wBUDQAaQgQgCUL/////AFQNABpCBSAJQv//////AFQNABpCBiAJQv///////wBUDQAaQgdCCCAJQv////////8AVBsLIQcCQCAHIAl8QgF8IgpC/wBUDQBCAiEIIApC//8AVA0AQgMhCCAKQv///wBUDQBCBCEIIApC/////wBUDQBCBSEIIApC//////8AVA0AQgYhCCAKQv///////wBUDQBCB0IIIApC/////////wBUGyEICyAIIAp8QgJ8IQgLIAEpA0AiB1BFBEACfkIBIAdCP4cgB4VCAYYiB0KAAlQNABpCAiAHQoCABFQNABpCAyAHQoCAgAhUDQAaQgQgB0KAgICAEFQNABpCBSAHQoCAgICAIFQNABpCBiAHQoCAgICAgMAAVA0AGkIHQgggB0KAgICAgICAgAFUGwtCA3whEQsgASkDSCANgCELIAEtACRFBEACfkIBIAtCgAJUDQAaQgIgC0KAgARUDQAaQgMgC0KAgIAIVA0AGkIEIAtCgICAgBBUDQAaQgUgC0KAgICAgCBUDQAaQgYgC0KAgICAgIDAAFQNABpCB0IIIAtCgICAgICAgIABVBsLQgJ8IQ8LIAEpAxgiByANgCEMIAcgDVQiBkUEQAJ+QgEgDEKAAlQNABpCAiAMQoCABFQNABpCAyAMQoCAgAhUDQAaQgQgDEKAgICAEFQNABpCBSAMQoCAgICAIFQNABpCBiAMQoCAgICAgMAAVA0AGkIHQgggDEKAgICAgICAgAFUGwtCAnwhDgtCACENIABCoAECfkIBIAEpAyhCBHwiB0L/AFQNABpCAiAHQv//AFQNABpCAyAHQv///wBUDQAaQgQgB0L/////AFQNABpCBSAHQv//////AFQNABpCBiAHQv///////wBUDQAaQgdCCCAHQv////////8AVBsLIAggEXwgD3wgDnwgB3x8QgF8IggQFUUNACAAQqEBIAcQFUUNAEIBAn9BASABKQMwIgdC/wBUDQAaQQIgB0L//wBUDQAaQQMgB0L///8AVA0AGkEEIAdC/////wBUDQAaQQUgB0L//////wBUDQAaQQYgB0L///////8AVA0AGkEHQQggB0L/////////AFQbCyICQQdsrYYiDkJ+fCAHVA0AIAcgDoQhDiACQQFqrSEPQgEhBwJAA0ACQCADIA4gAiAHp2tBA3SthzwACiAAIANBCmpBASAAKAIAKAIAEQEAIgUgBCAFQQBIGyEEIAVBf0wNACAPIAdCAXwiB1INAQwCCwsgBA0BCyADIBBCCIg8AAkgACADQQlqQQEgACgCACgCABEBACIEQQBIDQAgAyAQPAAJIAAgA0EJakEBIAAoAgAoAgARAQAiAkF/TEEAIAIgBCACQQBIGxsNACADQQA6AAggACADQQhqQQEgACgCACgCABEBAEEASA0AIAAgASgCICABKAIoIAAoAgAoAgARAQANACABKAIIBEAgAEKh6wEgChAVRQ0BIABCpgEgCRAVRQ0BIABC7gEgASkDABATRQ0BIABCpQEgASgCCCABKQMQEEhFDQELIAEpA0AiB1BFBEAgACAHEMcBRQ0BCyABLQAkRQRAIABC+wEgCxATRQ0BCyAGRQRAIABCmwEgDBATRQ0BCwJ+QgIgCEL/AFQNABpCAyAIQv//AFQNABpCBCAIQv///wBUDQAaQgUgCEL/////AFQNABpCBiAIQv//////AFQNABpCByAIQv///////wBUDQAaQghCCSAIQv////////8AVBsLIAh8IQ0LIANBEGokACANC5QEAgR/AX4jAEEQayIDJAACQCAARQ0AIABC4YgBIAAgACgCACgCBBEAACAAKAIAKAIQEQsAQgEhBgJAA0ACQCADQuGIAUECIAana0EDdK2HPAANIAAgA0ENakEBIAAoAgAoAgARAQAiBCACIARBAEgbIQIgBEF/TA0AIAZCAXwiBkIDUg0BDAILCyACDQELIANBiAE6AA4gACADQQ5qQQEgACgCACgCABEBAEEASA0AIAMgAUI4iDwADwJAIAAgA0EPakEBIAAoAgAoAgARAQAiBEEASA0AIAMgAUIwiDwADyAAIANBD2pBASAAKAIAKAIAEQEAIgIgBCACQQBIGyEEIAJBf0wNACADIAFCKIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCIIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCGIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCEIg8AA8gACADQQ9qQQEgACgCACgCABEB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BEH/////A3EgBEcbEBciAwR/An8CQAJAQTgQFyIBBEAgAUIANwMwIAFCATcDKCABQgE3AyAgAUIBNwMYIAFCADcDECABQQA2AgggAUIFNwMAIAAoAlghAiAFRQ0BA0AgAyAGQQJ0IgdqIAIgB2ooAgA2AgAgBkEBaiIGIAVHDQALDAILIAMQDkEADwsgAg0AQQAMAQsgAhAOIAAoAlwLIQIgACADNgJYIAMgAkECdGogATYCACAAIAQ2AlxBAQVBAAsLzwEBAn8jAEEQayIBJAACQCAAvUIgiKdB/////wdxIgJB+8Ok/wNNBEAgAkGAgMDyA0kNASAARAAAAAAAAAAAQQAQMiEADAELIAJBgIDA/wdPBEAgACAAoSEADAELIAAgARCEAUEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwhBARAyIQAMAwsgASsDACABKwMIEDMhAAwCCyABKwMAIAErAwhBARAymiEADAELIAErAwAgASsDCBAzmiEACyABQRBqJAAgAAu6FwEDfyMAQeABayIDJAAgAyACNgLcASAAIAAoAgBqIQRBeyECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQeBgaiIFQS9LBEAgAUHhsX9qIgVBC00NASABQYaqf2oiAUERSw0mAkACQAJAIAFBAWsOESkpKSkpKSkpKSkpKSkpKQABAgsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFqQeUASw0oIAAgATYCjAFBACECDCgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwoCyABIAAoAowBNgIAQQAhAgwnCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGYeGpBA08EQEF/IQIgAUGYeEcNJwsgACABNgKIAUEAIQIMJgsgBUEBaw4vIyIhHh0SERwbGBcWFRQTGhklJRAPIB8ODSUMAQslCiUlJSUJCCUlBwYFBCUlAwIkCwJAAkACQCAFQQFrDgsnJycnJycnJwInAQALIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwnCyADIAA2AnAgBEGfzgAgA0HwAGoQEiECDCYLIAMgAygC3AEiAUEEajYC3AEgACABKAIAIgA2AshuIAMgADYCYCAEQarOACADQeAAahASIQIMJQsgAyADKALcASIBQQRqNgLcASAAIAEoAgAiADYCsAEgAyAANgJQIARBqM4AIANB0ABqEBIhAgwkCyAAKAIEIQEgAEG8AWoiAkEMakEAQcDsABARGiACQs2Zs+7jzJmzPzcCwEBBACECIABBiO4AakEAQeweEBEaIARBvB9BABASGiAAIAFqIAAoArQBIANB+ABqEFcaIABBATYCxG4gAEGAgID8AzYClG4gAEGAgAE7AYxuIABB0Qg2ArhuIABB6Qc2AqhuIAAgACgCcDYCiG4gAEE8EBZBCHQ2ApBuDCMLIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwjCyADIAA2AkAgBEHPHyADQUBrEBIaQQAhAgwiCyADIAMoAtwBIgBBBGo2AtwBQX8hAiAAKAIAIgBBAUsNISADIAA2AjAgBEHOHyADQTBqEBIaQQAhAgwhCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMIQsgASAAKAJMNgIAQQAhAgwgCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBAUsNHyAAIAE2AkxBACECDB8LIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwfCyABIAAoApwBNgIAQQAhAgweCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFB+FhqQQlLDR0gACABNgKcASADIAE2AiAgBEHIHyADQSBqEBIaQQAhAgwdCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMHQsgASAAKAKoATYCAEEAIQIMHAsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQXhqQRBLDRsgACABNgKoAUEAIQIMGwsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBsLIAEgACgC8IwBNgIAQQAhAgwaCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMGgsgASAAKAKQATYCAEEAIQIMGQsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBkLIAEgACgCkAFBkANtIgQ2AgBBACECIAAoAmxBgxBGDRggASAAKAJ0IARqNgIADBgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwYCyABIAAoAnw2AgBBACECDBcLIAMgAygC3AEiAUEEajYC3AEgASgCACIBQcdoakECTwRAQX8hAiABQZh4Rw0XCyAAIAE2AnxBACECDBYLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwWCyABIAAoApgBNgIAQQAhAgwVCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBAUsNFCAAIAE2ApgBQQAhAgwUCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMFAsgASAAKAKUATYCAEEAIQIMEwsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFLDRIgACABNgKUASAAQQEgAWs2AjxBACECDBILIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwSCyABIAAoAig2AgBBACECDBELIAMgAygC3AEiAUEEajYC3AFBfyECIAEoAgAiAUHkAEsNECAAIAE2AiggAyABNgIQIARBrh8gA0EQahASGkEAIQIMEAsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBALIAEgACgCMDYCAEEAIQIMDwsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFLDQ4gACABNgIwQQAhAgwOCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMDgsgASAAKAIsNgIAQQAhAgwNCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBCksNDCAAIAE2AiwgAyABNgIAIARBqh8gAxASGkEAIQIMDAsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDAwLIAEgACgCuAE2AgBBACECDAsLIAMgAygC3AEiAUEEajYC3AFBfyECIAEoAgAiAUEBSw0KIAAgATYCuAFBACECDAoLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwKCyABIAAoArhuNgIAQQAhAgwJCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGzd2pBBU8EQEF/IQIgAUGYeEcNCQsgACABNgKAASABQc0IRgRAIABBwD42AhRBACECDAkLIAFBzghGBEAg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IApqQQF0ai4BAEEDdSIMIAxsaiEDIAJBAWoiAiAFRw0ACyABIANqIgFB/////wcgAUH/////B0kbIQEgCEEBdCEKIAYoAgAhDEEAIQJBACEDA0AgAyAEIAIgCmogDGpBAXRqLgEAQQN1Ig4gDmxqIQMgAkEBaiICIAVHDQALIAEgA2oiAUH/////ByABQf////8HSRshASAIQQNsIQggBigCACEGQQAhAkEAIQMDQCADIAQgAiAIaiAGakEBdGouAQBBA3UiCiAKbGohAyACQQFqIgIgBUcNAAsLIAsgASADQQF2aiIBQf////8HIAFB/////wdJGzYCACANIAM2AjggCUEBaiIJQQRHDQALQQAhBSAAKAKMASIJQecHTARAQf//ASAJQQR1QQFqbSEFC0H/////ByAHKAIgIgggACgCfGoiAUH/////ByABQf////8HSRsiBG4hA0GAASEBIAACf0GAASAEIAAoAlwiAkEDdEoNABpBgAggBCACSA0AGiACQRB0QRB1IgQgA0EQdmwgAyACQQ91QQFqQQF1bGogA0H//wNxIARsQRB1aiICQRB1QQt0IAJBBXZB/w9xcgsiAiAFIAIgBUobQRB0QRB1IgIgAyAAKAJsIgNrIgRBEHVsIANqIAIgBEH//wNxbEEQdWoiAzYCbCAAQf////8HIANtIgNB////ByADQf///wdIGyIDNgJcQf////8HIAcoAiQiCiAAKAKAAWoiAkH/////ByACQf////8HSRsiBm4hAgJAIAYgACgCYCIEQQN0Sg0AQYAIIQEgBiAESA0AIARBEHRBEHUiASACQRB2bCACIARBD3VBAWpBAXVsaiACQf//A3EgAWxBEHVqIgFBEHVBC3QgAUEFdkH/D3FyIQELIAAgASAFIAEgBUobQRB0QRB1IgEgAiAAKAJwIgJrIgRBEHVsIAJqIAEgBEH//wNxbEEQdWoiATYCcCAAQf////8HIAFtIgFB////ByABQf///wdIGzYCYEH/////ByAHKAIoIgwgACgChAFqIgFB/////wcgAUH/////B0kbIgZuIQJBgAEhASAAAn9BgAEgBiAAKAJkIgRBA3RKDQAaQYAIIAYgBEgNABogBEEQdEEQdSIGIAJBEHZsIAIgBEEPdUEBakEBdWxqIAJB//8DcSAGbEEQdWoiBEEQdUELdCAE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GkEAIAFFDQAaQQAgARD6AiIBRQ0AGiADQX82AhQgAyAANgIQIANBADYCDCADIAE2AgggA0EYakEAQScQERogA0EBNgI4IAEgA0EIaiACKAIAQQEgASgCACgCHBEDAEEAIAMoAiBBAUcNABogAiADKAIYNgIAQQELIQAgA0FAayQAIAALCQBB7xUQtwEACzMBAX8jAEEQayIBJAAgAUEIaiAAKAIEELUBKAIAQQE6AAAgACgCCEEBOgAAIAFBEGokAAs0AQJ/AkAgACgCCCIALQAAIgJBAUcEfyACQQJxDQEgAEECOgAAQQEFQQALDwtBuRUQtwEACzYBAn8jAEEQayIBJAAgAUEIaiAAKAIEELUBKAIALQAAQQFHBEAgABD+AiECCyABQRBqJAAgAgt6AQF/IAAoAkxBAEgEQAJAIAAsAEtBCkYNACAAKAIUIgEgACgCEE8NACAAIAFBAWo2AhQgAUEKOgAADwsgABCuAQ8LAkACQCAALABLQQpGDQAgACgCFCIBIAAoAhBPDQAgACABQQFqNgIUIAFBCjoAAAwBCyAAEK4BCwskACAAQQtPBH8gAEEQakFwcSIAIABBf2oiACAAQQtGGwVBCgsLnAEBA38jAEEQayICJABBbyAATwRAAkAgAEEKTQRAQZveAiAAOgAAQZDeAiEBDAELQX8gABCBA0EBaiIDIgFJBEAQuQEAC0GQ3gIgARAXIgE2AgBBmN4CIANBgICAgHhyNgIAQZTeAiAANgIACyAABEAgAUH5DCAAEA0aCyACQQA6AA8gACABaiACLQAPOgAAIAJBEGokAA8LELkBAAvZAwICfwJ+IwBBIGsiAiQAAkAgAUL///////////8AgyIFQoCAgICAgMD/Q3wgBUKAgICAgIDAgLx/fFQEQCABQgSGIABCPIiEIQQgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhBAwCCyAEQoCAgICAgICAQH0hBCAAQoCAgICAgICACIVCAFINASAEQgGDIAR8IQQMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KAgICAgICA/P8AhCEEDAELQoCAgICAgID4/wAhBCAFQv///////7//wwBWDQBCACEEIAVCMIin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","base64"))
    };

    audio.broadcastencoder = new MediaRecorder(audio.broadcaststream.stream, {audioBitsPerSecond:64000, mimeType:mime}, workerOptions)
    audio.callencoder = new MediaRecorder(audio.callstream.stream, {audioBitsPerSecond:64000, mimeType:mime}, workerOptions)

    audio.broadcastencoder.addEventListener('dataavailable', e => {
      btob(e.data, (err, buf) => {
        //bufr.push(new Uint8Array(buf))
        //app.audio.decoder.decode(buf)     
        app.network.broadcast(buf)
        //strSrc.write(buf)
      })

    })

    audio.callencoder.addEventListener('dataavailable', e => {
      btob(e.data, (err, buf) => {
        //bufr.push(new Uint8Array(buf))
        app.audio.decoder.decode(buf)     
        //app.network.send(buf)
        //strSrc.write(buf)
      })
    })

    
    audio.broadcastencoder.start(1000)

    autorun(()=>{
      if(app.update) {
        audio[app.update[0]].gain.value = Math.max(0, app.update[1])//.monitor
      } 
    })

    _log(`mediaRecorder added? ${(!!audio.broadcastencoder)}`)

    app.audio = audio
    master.resume()
    cb(null, app)
  }

  function initUI(app, cb){

    ui.livelink.innerText = 'https://gabr.vercel.app?stream='+app.session.stream
    ui.copybutton.onchange = e => {
      navigator.clipboard.writeText(ui.link.innerText)
    }
    ui.request.addEventListener('change', e => {
      app.network.initCall(app.session.stream)
    })
    ui.file.addEventListener('change', e => {
      console.log(e.target.files[0])
      var a = h('audio.invert', {controls: true, src : URL.createObjectURL(e.target.files[0])})
      ui.tracks.appendChild(a)
      var c= app.audio.master.createMediaElementSource(a)
      console.log(a)
      c.connect(app.audio.trackmixer)
      btob(e.target.files[0], (err, buf) => {
        sampler(app.audio.master, buf.buffer, (err, node) =>{
          //node.connect(app.audio.master.destination)
          //node.start(0)
        })      
      })
    })

    ;[].forEach.call(document.querySelectorAll('input[type=range]'), e => {
      e.addEventListener('input', ev => {
        bus.emit('appStateChange', [ev.target.name, Number(ev.target.value)])
      })
    })

    ;[].forEach.call(document.querySelectorAll('[data-mute]'), e => {
      e.addEventListener('change', ev => {
        bus.emit('appStateChange', [ev.target.dataset.mute, - app[ev.target.dataset.mute]])
      })
    })


    ui.monitorRange.addEventListener('change', e => {
      console.log(e.target.value)
      //bus.emit('appStateChange', ['monitor', Number(e.target.value)])
      //app.setGain('monitor', Number(e.target.value))
    })

    cb(null,app)

  }


  function initCast(app){
  
    return function(cb){
      _log('stateInit')
      cb(null, app)
    
    }
  }
  function captureNetwork(app, cb) {
    var network = new Network(app, argv.protocol + '://' + argv.host + ':' + argv.port)
    _log('netCap')
    app.network = network

    cb(null, app)
  }

  function captureSource (app, cb) {
    // TODO source is either the mediastream or a peer connection
    
    if(true || app.session.broadcasting){
      addMedia((err, stream) =>{
        _log(`mediaStream added? ${(!!stream)}`)
        _log(`mediaStream error? ${(err)}`)

        console.log(err)
        console.log(stream)

        const mic = app.audio.master.createMediaStreamSource(stream) 
        mic.connect(app.audio.mic)

        app.audio.mediastream = stream
        app.audio.micnode = mic
    
        /*
        var bufr = []
        app.audio.buffer = bufr
        const strSrc = thru((b, r, cb)=>{
            console.log('source', b)
          cb(null, b)
        },e=>{
          console.log(e)
        } )
        app.audio.sourceStream = strSrc
        */
        // do same for host monitoring:
        //for(var smith in phonebook) mediaStream.pipe(phonebook[smith]) 
        //ui.monitor.srcObject = stream// = URL.createObjectURL(stream)      
        // Delete the encoder when finished with it (Emscripten does not automatically call C++ object destructors)
        //encoder.delete();
       _log('sourceCap')
        cb(err, app)
        
      
      })
    }




  }

  function captureSink(app, cb){
    var {OggOpusDecoder} = require('ogg-opus-decoder')

    async function wsm(log){
    
      const decoder = new OggOpusDecoder({onDecode, onDecodeAll})

      function onDecode () {
      }

      function onDecodeAll ({channelData, samplesDecoded, sampleRate}) {
        //console.log('channel')//channelData)
        let sam = sampler(app.audio.master, channelData)
        sam.connect(app.audio.master.destination)
        sam.start(0)
      }

      await decoder.ready

      const sinkStream = thru((buf, enc, cb) => {
        console.log('sink', buf)
        decoder.decode(buf)
        cb()
      }, e =>{
        console.log(e)
      
      })

      var sinkState = {
        sink: sinkStream,
      }

      log()
      app.audio.decoder = decoder
      app.audio.sinkStream = sinkStream
      _log('sinkCap')
      cb(null, app)
      
    }


    wsm(function(){console.log('WASM')})

  }



  function tob(buf){
    return URL.createObjectURL(new Blob([new Buffer(buf).buffer], {type: 'application/wasm'}))
  }
   
  var peers = {}

  //ui.addMic.onclick = e => addMedia()

  function mute(torf){
    micStream.getAudioTracks()[0].enabled = torf
  }


  var connecting = {}
  function initBroadcast(){
    // source cap then broadcast
    session.broadcastId = short().generate()
    sessios.distance = 0
    session.maxConnections = 20
    session.offersOut = 0
    // be seekable when..
    seekable(session)
    return session
  }



  class Network { 

    constructor(app, addr){
      const self = this
      //console.log(state, addr)
      this.hub = signalhub(addr, app.session.stream)
      this.channel = app.session.stream
      this.id = app.session.id
      this.state = app.state
      this.connections = {}
      this.hubs = {} 
      this.peers = {}
      this.callers = {}
      this.connecting = {}
      this.distance = 1
      this.offersOut = 0
      this.maxConnections = 4 // start low, test high, also helps spread early pcast testing
      this.duration = null // since-when
      this.channels = {}
      this.duration = new Time
      this.sinkStream = thru(buf => {
        for(var n in this.peers){
          let p = this.peers[n]
          if(p.writable) p.write(buf)
        }
      }, function close(){})
    }

    broadcast(buf){
      for(var n in this.peers) this.peers[n].write(buf)
    }

    send(buf){
      for(var n in this.callers) this.callers[n].write(buf)
    }

    log(){
      console.log.apply(this, arguments)
    }

    closePeerSignal(addr){
      this.hub.unsubscribe(addr)
      //delete this.connections[addr]
    }

    disallowCalls(id){
      this.hub.unsubscribe('caller:'+id)
    }

    allowCalls(id){
      let calls = this.hub.subscribe('caller:'+id)
      calls.on('data', msg=>{
        msg=JSON.parse(msg)
        bus.emit('caller', msg)
      })
      bus.on('call', msg =>{
        this.callDirect(msg.peerId)
      })

    }

    initCall(id){
      
      this.hub.broadcast('caller:'+id, {peerId: this.id})
      let peer = this.initConnect(id, false, this.id)
      peer.once('connected', e =>{
        this.callers[id] = peer
        bus.emit('Call Source Captured', peer)

      })
      
      
    }

    callDirect(id){
      let peer = this.initConnect(id, true, this.id)
      peer.once('connected', e =>{
        this.callers[id] = peer
        bus.emit('Call Source Captured', peer)

      })
    }

    sourceSeek(){ // id for a peer stream
      var self = this 
      let mask = short().generate()
      let offerings = this.hub.subscribe(mask)
      var best = 0//Infinity
      var chosen
      var start = new Time
      offerings.on('data', offer => {
        offer = JSON.parse(offer)
        _log(offer)
        let score = (1 / offer.distance) * offer.duration
        if(score > best) {
          best = score //offer.distance
          chosen = offer
        }
      console.log(chosen)
      })
      let t0 = setTimeout(e => {
      console.log(chosen)
        if(chosen) {
    //      this.hub.unsubscribe(mask)
          // do chosen
          bus.emit('sourcePeerIdCaptured', chosen.peerId)
          //self.sourceCap(chosen)
          let peer = this.initConnect(chosen.peerId, true, mask)
          peer.once('connect', e => {
            bus.emit('sourcePeerCaptured', peer)
            this.distance = chosen.distance + 1
            this.sourceStream = peer
            peer.on('data', buf => {
              app.audio.decoder.decode(buf)
            })
            _log('Source Peer Captured.')

          })
          peer.on('close', e => {
            _log('Source Peer Closed')

          })
        } else {
          _log('Err: No source peer found.')    
        }
      }, 13000)
      

      this.hub.broadcast('source', 
        JSON.stringify({
          peerId: mask
        })
      )
      
    }

    set sourceStream(stream){
      this._sourceStream = stream
      this.duration = new Time()
      //stream.pipe(this.sinkStream)
      //stream.pipe(app.audio.sinkStream)
    }

    get sourceStream(){
      return this._sourceStream
    }

    unseekable(session){
      if(sesion) this.hub.unsubscribe(session)
    }

    isSeekWorthy(){
      let r = this.offersOut < this.maxConnections
      let s = this.maxConnections > Object.keys(this.connections).length  
      let q = r && s 
      this._seekable = q
      if(q) {
        this.sourcer = this.hub.subscribe('source')
        this.sourcer.on('data', msg => this.seekable(JSON.parse(msg)))
      }
      else {
        if(this.sourcer) this.sourcer.close()
        
      }
      return this._seekable
    }

    setsub(id){
      if(this.hubs[id]) return this.hubs[id]
      else this.hubs[id] = this.hub.subscribe(id)
    }
    getsub(id){
      return this.hubs[id]
    }

    unsub(id){
      if(this.hubs[id]) {
        this.hub.unsubscribe(id) 
        delete this.hubs[id] 
      }
    }

    seekable(msg){ 
    _log(msg)
      let self = this
      if(false) return // || Math.random() < 1 / Math.pow(self.distance, 2)) return
      else{
        self.offersOut += 1
        setTimeout(e=>{
          this.offersOut--
          //this.disnit(msg.peerId, mask)
        }, 1111*3)
        let mask = short().generate()
        let peer = this.initConnect(msg.peerId, false, mask)
        peer.once('connect', e =>{
          self.peers[msg.peerId] = peer
        })
        peer.once('close', e =>{
          delete self.peers[msg.peerId]
          self.isSeekWorthy()
        })
        this.hub.broadcast(msg.peerId, JSON.stringify({
          peerId: mask,
          to: msg.peerId,
          distance: this.distance,
          duration: this.duration.sinceBeginNS()
        }))
      }
    }

    disnit(id, mask){
      //delete this.connecting[id]
      //this.hub.unsubscribe(mask)
    }

    initConnect(id, init, mask){
      var self = this
      let pipe = this.hub.subscribe(mask)
      var caller = new Peer({initiator: init, trickle: false, objectMode: false})
      this.connecting[id] = caller
      pipe.on('error', e => console.log.apply(this, arguments))
      pipe.on('data', function(data){
        data = JSON.parse(data)
        // callerID
        var peer = self.connecting[data.peerId]
        peer.signal(data.signal)
        peer.once('connect', e => {
          // close mask hub
        })
        //ui.callers.appendChild(h('div.caller', h('button.connect', `Connect to ${data.name || from}`, {onclick: _connect})))  
      })
      caller._debug = console.log
      caller.on('signal', sig => this.hub.broadcast(id, JSON.stringify({peerId: mask, to: id, signal: sig })))
      caller.once('connect', e => {
        this.connections[id] = caller
        this.connecting[id] = null
        console.log(`connected to ${Object.keys(this.connections).length} peers`)
      })
      caller.on('close', e => {
        this.disnit(id, mask)
      })
      caller.on('error', e => console.log(e))
      return caller
    }

  }

  function addMedia(cb, audio=true, video=false){
    var gam = require('getusermedia')
    // Web worker and .wasm configuration. Note: This is NOT a part of W3C standard.
    _log(`getUserMedia? ${!!gam}`)
    gam({video, audio}, function(err, stream){
      //console.log(stream.getAudioTracks())


      cb(err, stream)
    })
   }    
})


}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

},{"../jsynth-file-sample":1,"../jsynth-mic/stream":2,"../since-when":113,"./sharedEmitter":112,"_process":136,"blob-to-buffer":6,"buffer":117,"domready":13,"getids":17,"getusermedia":18,"hyperscript":19,"minimist":22,"mobx":23,"nanohref":28,"ogg-opus-decoder":29,"opus-media-recorder":30,"querystring":139,"run-waterfall":49,"short-uuid":52,"signalhub":53,"simple-peer":63,"store":64,"through2":84,"to-arraybuffer":85}],4:[function(require,module,exports){
var Converter = require('./src/converter');

/**
 * Function get source and destination alphabet and return convert function
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 *
 * @returns {function(number|Array)}
 */
function anyBase(srcAlphabet, dstAlphabet) {
    var converter = new Converter(srcAlphabet, dstAlphabet);
    /**
     * Convert function
     *
     * @param {string|Array} number
     *
     * @return {string|Array} number
     */
    return function (number) {
        return converter.convert(number);
    }
};

anyBase.BIN = '01';
anyBase.OCT = '01234567';
anyBase.DEC = '0123456789';
anyBase.HEX = '0123456789abcdef';

module.exports = anyBase;
},{"./src/converter":5}],5:[function(require,module,exports){
'use strict';

/**
 * Converter
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 * @constructor
 */
function Converter(srcAlphabet, dstAlphabet) {
    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
        throw new Error('Bad alphabet');
    }
    this.srcAlphabet = srcAlphabet;
    this.dstAlphabet = dstAlphabet;
}

/**
 * Convert number from source alphabet to destination alphabet
 *
 * @param {string|Array} number - number represented as a string or array of points
 *
 * @returns {string|Array}
 */
Converter.prototype.convert = function(number) {
    var i, divide, newlen,
    numberMap = {},
    fromBase = this.srcAlphabet.length,
    toBase = this.dstAlphabet.length,
    length = number.length,
    result = typeof number === 'string' ? '' : [];

    if (!this.isValid(number)) {
        throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ')');
    }

    if (this.srcAlphabet === this.dstAlphabet) {
        return number;
    }

    for (i = 0; i < length; i++) {
        numberMap[i] = this.srcAlphabet.indexOf(number[i]);
    }
    do {
        divide = 0;
        newlen = 0;
        for (i = 0; i < length; i++) {
            divide = divide * fromBase + numberMap[i];
            if (divide >= toBase) {
                numberMap[newlen++] = parseInt(divide / toBase, 10);
                divide = divide % toBase;
            } else if (newlen > 0) {
                numberMap[newlen++] = 0;
            }
        }
        length = newlen;
        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
    } while (newlen !== 0);

    return result;
};

/**
 * Valid number with source alphabet
 *
 * @param {number} number
 *
 * @returns {boolean}
 */
Converter.prototype.isValid = function(number) {
    var i = 0;
    for (; i < number.length; ++i) {
        if (this.srcAlphabet.indexOf(number[i]) === -1) {
            return false;
        }
    }
    return true;
};

module.exports = Converter;
},{}],6:[function(require,module,exports){
(function (Buffer){(function (){
/*! blob-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* global Blob, FileReader */

module.exports = function blobToBuffer (blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob')
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function')
  }

  const reader = new FileReader()

  function onLoadEnd (e) {
    reader.removeEventListener('loadend', onLoadEnd, false)
    if (e.error) cb(e.error)
    else cb(null, Buffer.from(reader.result))
  }

  reader.addEventListener('loadend', onLoadEnd, false)
  reader.readAsArrayBuffer(blob)
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":117}],7:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],8:[function(require,module,exports){
// contains, add, remove, toggle
var indexof = require('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":20}],9:[function(require,module,exports){
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})

},{"../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":133}],10:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))

},{"./common":11,"_process":136}],11:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":26}],12:[function(require,module,exports){
(function (process){(function (){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
    }
    return BrowserInfo;
}());
exports.BrowserInfo = BrowserInfo;
var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());
exports.NodeInfo = NodeInfo;
var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());
exports.BotInfo = BotInfo;
// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp)|(MSNBot)|(Ask Jeeves\/Teoma)|(ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['vivaldi', /Vivaldi\/([0-9\.]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /Edg\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FBAV\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
    ['Search Bot', SEARCHBOT_OS_REGEX],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
exports.detect = detect;
function parseUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    var matchedRule = ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
        }
    }
    else {
        versionParts = [];
    }
    return new BrowserInfo(name, versionParts.join('.'), detectOS(ua));
}
exports.parseUserAgent = parseUserAgent;
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.test(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
exports.detectOS = detectOS;
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
exports.getNodeVersion = getNodeVersion;
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}

}).call(this)}).call(this,require('_process'))

},{"_process":136}],13:[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? setTimeout(fn, 0) : fns.push(fn)
  }

});

},{}],14:[function(require,module,exports){
'use strict';

/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */

/**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */
function assign(obj, props) {
    for (const key in props) {
        Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true,
        });
    }

    return obj;
}

/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */
function createError(err, code, props) {
    if (!err || typeof err === 'string') {
        throw new TypeError('Please pass an Error to err-code');
    }

    if (!props) {
        props = {};
    }

    if (typeof code === 'object') {
        props = code;
        code = '';
    }

    if (code) {
        props.code = code;
    }

    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;

        const ErrClass = function () {};

        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

        // @ts-ignore
        const output = assign(new ErrClass(), props);

        return output;
    }
}

module.exports = createError;

},{}],15:[function(require,module,exports){
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
    const retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
    });

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
    }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
    /**
     * The type of this event.
     * @type {string}
     */
    get type() {
        return pd(this).event.type
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get target() {
        return pd(this).eventTarget
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get currentTarget() {
        return pd(this).currentTarget
    },

    /**
     * @returns {EventTarget[]} The composed path of this event.
     */
    composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
            return []
        }
        return [currentTarget]
    },

    /**
     * Constant of NONE.
     * @type {number}
     */
    get NONE() {
        return 0
    },

    /**
     * Constant of CAPTURING_PHASE.
     * @type {number}
     */
    get CAPTURING_PHASE() {
        return 1
    },

    /**
     * Constant of AT_TARGET.
     * @type {number}
     */
    get AT_TARGET() {
        return 2
    },

    /**
     * Constant of BUBBLING_PHASE.
     * @type {number}
     */
    get BUBBLING_PHASE() {
        return 3
    },

    /**
     * The target of this event.
     * @type {number}
     */
    get eventPhase() {
        return pd(this).eventPhase
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopPropagation() {
        const data = pd(this);
        if (typeof data.event.stopPropagation === "function") {
            data.event.stopPropagation();
        }
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopImmediatePropagation() {
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
            data.event.stopImmediatePropagation();
        }
    },

    /**
     * The flag to be bubbling.
     * @type {boolean}
     */
    get bubbles() {
        return Boolean(pd(this).event.bubbles)
    },

    /**
     * The flag to be cancelable.
     * @type {boolean}
     */
    get cancelable() {
        return Boolean(pd(this).event.cancelable)
    },

    /**
     * Cancel this event.
     * @returns {void}
     */
    preventDefault() {
        const data = pd(this);
        if (data.passiveListener != null) {
            console.warn("Event#preventDefault() was called from a passive listener:", data.passiveListener);
            return
        }
        if (!data.event.cancelable) {
            return
        }

        data.canceled = true;
        if (typeof data.event.preventDefault === "function") {
            data.event.preventDefault();
        }
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     */
    get defaultPrevented() {
        return pd(this).canceled
    },

    /**
     * The flag to be composed.
     * @type {boolean}
     */
    get composed() {
        return Boolean(pd(this).event.composed)
    },

    /**
     * The unix time of this event.
     * @type {number}
     */
    get timeStamp() {
        return pd(this).timeStamp
    },
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", { value: Event, configurable: true, writable: true });

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
    return {
        get() {
            return pd(this).event[key]
        },
        set(value) {
            pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
    return {
        value() {
            const event = pd(this).event;
            return event[key].apply(event, arguments)
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
        return BaseEvent
    }

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true },
    });

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = (typeof descriptor.value === "function");
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
            );
        }
    }

    return CustomEvent
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
        return Event
    }

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
    }
    return wrapper
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
}

/**
 * Get the stopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
    return pd(event).stopped
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
        throw new TypeError("'this' is expected an EventTarget object, but got another value.")
    }
    return listeners
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
                }
                node = node.next;
            }
            return null
        },

        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
            }
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                    }
                    else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                    }
                    else {
                        listeners.delete(eventName);
                    }
                }
                else {
                    prev = node;
                }

                node = node.next;
            }

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
                };
                if (prev === null) {
                    listeners.set(eventName, newNode);
                }
                else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
        EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: { value: CustomEventTarget, configurable: true, writable: true },
    });

    for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }

    return CustomEventTarget
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0])
    }
    if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i];
        }
        return defineCustomEventTarget(types)
    }
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string} eventName The event name to add.
     * @param {Function} listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {boolean} `true` if the listener was added actually.
     */
    addEventListener(eventName, listener, options) {
        if (listener == null) {
            return false
        }
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.")
        }

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = (capture ? CAPTURE : BUBBLE);
        const newNode = {
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
        };

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) {
            listeners.set(eventName, newNode);
            return true
        }

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) {
            if (node.listener === listener && node.listenerType === listenerType) {
                // Should ignore duplication.
                return false
            }
            prev = node;
            node = node.next;
        }

        // Add it.
        prev.next = newNode;
        return true
    },

    /**
     * Remove a given listener from this event target.
     * @param {string} eventName The event name to remove.
     * @param {Function} listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {boolean} `true` if the listener was removed actually.
     */
    removeEventListener(eventName, listener, options) {
        if (listener == null) {
            return false
        }

        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = (capture ? CAPTURE : BUBBLE);

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
            if (node.listener === listener && node.listenerType === listenerType) {
                if (prev !== null) {
                    prev.next = node.next;
                }
                else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                }
                else {
                    listeners.delete(eventName);
                }
                return true
            }

            prev = node;
            node = node.next;
        }

        return false
    },

    /**
     * Dispatch a given event.
     * @param {Event|{type:string}} event The event to dispatch.
     * @returns {boolean} `false` if canceled.
     */
    dispatchEvent(event) { //eslint-disable-line complexity
        if (event == null || typeof event.type !== "string") {
            throw new TypeError("\"event.type\" should be a string.")
        }

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
            return true
        }

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) {
            // Remove this listener if it's once
            if (node.once) {
                if (prev !== null) {
                    prev.next = node.next;
                }
                else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                }
                else {
                    listeners.delete(eventName);
                }
            }
            else {
                prev = node;
            }

            // Call this listener
            setPassiveListener(wrappedEvent, (node.passive ? node.listener : null));
            if (typeof node.listener === "function") {
                try {
                    node.listener.call(this, wrappedEvent);
                }
                catch (err) {
                    /*eslint-disable no-console */
                    if (typeof console !== "undefined" && typeof console.error === "function") {
                        console.error(err);
                    }
                    /*eslint-enable no-console */
                }
            }
            else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
                node.listener.handleEvent(wrappedEvent);
            }

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) {
                break
            }

            node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
    },
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", { value: EventTarget, configurable: true, writable: true });

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports.default = EventTarget;

module.exports = EventTarget
module.exports.EventTarget = module.exports["default"] = EventTarget
module.exports.defineEventAttribute = defineEventAttribute


},{}],16:[function(require,module,exports){
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof globalThis === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection ||
      globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription ||
      globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate ||
      globalThis.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

},{}],17:[function(require,module,exports){
module.exports = function(el){

    var ids = {};

    if('string' == typeof el) el = document.getElementById(el);

    if(!el) el = document;

    var children = el.getElementsByTagName('*');

    Array.prototype.forEach.call(children, function(e){

	if(e.id.length > 0){

	    ids[e.id] = e

	}

    })

    return ids

}

},{}],18:[function(require,module,exports){
// getUserMedia helper by @HenrikJoreteg used for navigator.getUserMedia shim
var adapter = require('webrtc-adapter');

module.exports = function (constraints, cb) {
    var error;
    var haveOpts = arguments.length === 2;
    var defaultOpts = {video: true, audio: true};

    var denied = 'PermissionDeniedError';
    var altDenied = 'PERMISSION_DENIED';
    var notSatisfied = 'ConstraintNotSatisfiedError';

    // make constraints optional
    if (!haveOpts) {
        cb = constraints;
        constraints = defaultOpts;
    }

    // treat lack of browser support like an error
    if (typeof navigator === 'undefined' || !navigator.mediaDevices){ //getUserMedia) {
        // throw proper error per spec
        error = new Error('MediaStreamError');
        error.name = 'NotSupportedError';

        // keep all callbacks async
        return setTimeout(function () {
            cb(error);
        }, 0);
    }

    // normalize error handling when no media types are requested
    if (!constraints.audio && !constraints.video) {
        error = new Error('MediaStreamError');
        error.name = 'NoMediaRequestedError';

        // keep all callbacks async
        return setTimeout(function () {
            cb(error);
        }, 0);
    }

    navigator.mediaDevices.getUserMedia(constraints)
    .then(function (stream) {
        cb(null, stream);
    }).catch(function (err) {
        var error;
        // coerce into an error object since FF gives us a string
        // there are only two valid names according to the spec
        // we coerce all non-denied to "constraint not satisfied".
        if (typeof err === 'string') {
            error = new Error('MediaStreamError');
            if (err === denied || err === altDenied) {
                error.name = denied;
            } else {
                error.name = notSatisfied;
            }
        } else {
            // if we get an error object make sure '.name' property is set
            // according to spec: http://dev.w3.org/2011/webrtc/editor/getusermedia.html#navigatorusermediaerror-and-navigatorusermediaerrorcallback
            error = err;
            if (!error.name) {
                // this is likely chrome which
                // sets a property called "ERROR_DENIED" on the error object
                // if so we make sure to set a name
                if (error[denied]) {
                    err.name = denied;
                } else {
                    err.name = notSatisfied;
                }
            }
        }

        cb(error);
    });
};

},{"webrtc-adapter":102}],19:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')

var w = typeof window === 'undefined' ? require('html-element') : window
var document = w.document
var Text = w.Text

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        // Our minimal parser doesnt understand escaping CSS special
        // characters like `#`. Dont use them. More reading:
        // https://mathiasbynens.be/notes/css-escapes .

        var m = split(string, /([\.#]?[^\s#.]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  var match = l[k][s].match(/(.*)\W+!important\W*$/);
                  if (match) {
                    e.style.setProperty(s, match[1], 'important')
                  } else {
                    e.style.setProperty(s, l[k][s])
                  }
              })(s, l[k][s])
            }
          } else if(k === 'attrs') {
            for (var v in l[k]) {
              e.setAttribute(v, l[k][v])
            }
          }
          else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}



},{"browser-split":7,"class-list":8,"html-element":116}],20:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],21:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],22:[function(require,module,exports){
module.exports = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        for (var i = 0; i < keys.length-1; i++) {
            var key = keys[i];
            if (key === '__proto__') return;
            if (o[key] === undefined) o[key] = {};
            if (o[key] === Object.prototype || o[key] === Number.prototype
                || o[key] === String.prototype) o[key] = {};
            if (o[key] === Array.prototype) o[key] = [];
            o = o[key];
        }

        var key = keys[keys.length - 1];
        if (key === '__proto__') return;
        if (o === Object.prototype || o === Number.prototype
            || o === String.prototype) o = {};
        if (o === Array.prototype) o = [];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg)
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /^(true|false)$/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}


},{}],23:[function(require,module,exports){
(function (process){(function (){

'use strict'

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./mobx.cjs.production.min.js')
} else {
  module.exports = require('./mobx.cjs.development.js')
}

}).call(this)}).call(this,require('_process'))

},{"./mobx.cjs.development.js":24,"./mobx.cjs.production.min.js":25,"_process":136}],24:[function(require,module,exports){
(function (global){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function _(annotationType, key) {
    return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
  },

  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function _(index, length) {
    return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function _(other) {
    return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
  },
  20: function _(other) {
    return "Cannot initialize map from " + other;
  },
  21: function _(dataStructure) {
    return "Cannot convert to map from '" + dataStructure + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function _(thing) {
    return "Cannot obtain administration from " + thing;
  },
  25: function _(property, name) {
    return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
  },
  26: "please specify a property",
  27: function _(property, name) {
    return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
  },
  28: function _(thing) {
    return "Cannot obtain atom from " + thing;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function _(name, derivation) {
    return "Cycle detected in computation " + name + ": " + derivation;
  },
  33: function _(name) {
    return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function _(name) {
    return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function _(method) {
    return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
};
var errors =  niceErrors ;
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  {
    var e = typeof error === "string" ? error : errors[error];
    if (typeof e === "function") e = e.apply(null, args);
    throw new Error("[MobX] " + e);
  }
}

var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }

  if (typeof window !== "undefined") {
    return window;
  }

  if (typeof global !== "undefined") {
    return global;
  }

  if (typeof self !== "undefined") {
    return self;
  }

  return mockGlobal;
}

var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /*#__PURE__*/Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die( "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" );
  }
}
function warnAboutProxyRequirement(msg) {
  if ( globalState.verifyProxies) {
    die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
  }
}
function getNextId() {
  return ++globalState.mobxGuid;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */

function once(func) {
  var invoked = false;
  return function () {
    if (invoked) return;
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop() {};
function isFunction(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t = typeof value;

  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }

  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  var _proto$constructor;

  if (!isObject(value)) return false;
  var proto = Object.getPrototypeOf(value);
  if (proto == null) return true;
  return ((_proto$constructor = proto.constructor) == null ? void 0 : _proto$constructor.toString()) === plainObjectString;
} // https://stackoverflow.com/a/37865170

function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) return false;
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) return true;
  return false;
}
function addHiddenProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value: value
  });
}
function addHiddenFinalProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function (x) {
    return isObject(x) && x[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
/**
 * Returns the following: own enumerable keys and symbols.
 */

function getPlainObjectKeys(object) {
  var keys = Object.keys(object); // Not supported in IE, so there are not going to be symbol props anyway...

  if (!hasGetOwnPropertySymbols) return keys;
  var symbols = Object.getOwnPropertySymbols(object);
  if (!symbols.length) return keys;
  return [].concat(keys, symbols.filter(function (s) {
    return objectPrototype.propertyIsEnumerable.call(object, s);
  }));
} // From Immer utils
// Returns all own keys, including non-enumerable and symbolic

var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} :
/* istanbul ignore next */
Object.getOwnPropertyNames;
function stringifyKey(key) {
  if (typeof key === "string") return key;
  if (typeof key === "symbol") return key.toString();
  return new String(key).toString();
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
} // From Immer utils

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
  var res = {}; // Note: without polyfill for ownKeys, symbols won't be picked up

  ownKeys(target).forEach(function (key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var storedAnnotationsSymbol = /*#__PURE__*/Symbol("mobx-stored-annotations");
/**
 * Creates a function that acts as
 * - decorator
 * - annotation object
 */

function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }

  return Object.assign(decorator, annotation);
}
/**
 * Stores annotation to prototype,
 * so it can be inspected later by `makeObservable` called from constructor
 */

function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  } // @override must override something


  if ( isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', " + "but no such decorated member was found on prototype.");
  } // Cannot re-decorate


  assertNotDecorated(prototype, annotation, key); // Ignore override

  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}

function assertNotDecorated(prototype, annotation, key) {
  if ( !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed." + "\nUse '@override' decorator for methods overriden by subclass.");
  }
}
/**
 * Collects annotations from prototypes and stores them on target (instance)
 */


function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    if ( !target[storedAnnotationsSymbol]) {
      die("No annotations were passed to makeObservable, but no decorated members have been found either");
    } // We need a copy as we will remove annotation from the list once it's applied.


    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }

  return target[storedAnnotationsSymbol];
}

var $mobx = /*#__PURE__*/Symbol("mobx administration");
var Atom = /*#__PURE__*/function () {
  // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed

  /**
   * Create a new atom. For debugging purposes it is recommended to give it a name.
   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
   */
  function Atom(name_) {
    if (name_ === void 0) {
      name_ =  "Atom@" + getNextId() ;
    }

    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  } // onBecomeObservedListeners


  var _proto = Atom.prototype;

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Invoke this method to notify mobx that your atom has been used somehow.
   * Returns true if there is currently a reactive context.
   */
  ;

  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  }
  /**
   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
   */
  ;

  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };

  _proto.toString = function toString() {
    return this.name_;
  };

  return Atom;
}();
var isAtom = /*#__PURE__*/createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }

  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }

  var atom = new Atom(name); // default `noop` listener will not initialize the hook Set

  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }

  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }

  return atom;
}

function identityComparer(a, b) {
  return a === b;
}

function structuralComparer(a, b) {
  return deepEqual(a, b);
}

function shallowComparer(a, b) {
  return deepEqual(a, b, 1);
}

function defaultComparer(a, b) {
  if (Object.is) return Object.is(a, b);
  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
}

var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};

function deepEnhancer(v, _, name) {
  // it is an observable already, done
  if (isObservable(v)) return v; // something that can be converted and mutated?

  if (Array.isArray(v)) return observable.array(v, {
    name: name
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name
  });

  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
    if (isGenerator(v)) {
      return flow(v);
    } else {
      return autoAction(name, v);
    }
  }

  return v;
}
function shallowEnhancer(v, _, name) {
  if (v === undefined || v === null) return v;
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) return v;
  if (Array.isArray(v)) return observable.array(v, {
    name: name,
    deep: false
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name,
    deep: false
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name,
    deep: false
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name,
    deep: false
  });
  die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(newValue) {
  // never turn into an observable
  return newValue;
}
function refStructEnhancer(v, oldValue) {
  if ( isObservable(v)) die("observable.struct should not be used with observable values");
  if (deepEqual(v, oldValue)) return oldValue;
  return v;
}

var OVERRIDE = "override";
var override = /*#__PURE__*/createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_: make_,
  extend_: extend_
});
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}

function make_(adm, key) {
  // Must not be plain object
  if ( adm.isPlainObject_) {
    die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
  } // Must override something


  if ( !hasProp(adm.appliedAnnotations_, key)) {
    die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', " + "but no such annotated member was found on prototype.");
  }

  return 0
  /* Cancel */
  ;
}

function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}

function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1
  };
}

function make_$1(adm, key, descriptor, source) {
  var _this$options_;

  // bound
  if ((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 1
    /* Break */
    ;
  } // own


  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 2
    /* Continue */
    ;
  } // prototype


  if (isAction(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1
    /* Break */
    ;
  }

  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2
  /* Continue */
  ;
}

function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}

function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}

function createActionDescriptor(adm, annotation, key, descriptor, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3;

  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;

  if ((_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.bound) {
    var _adm$proxy_;

    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return {
    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2
  };
}

function make_$2(adm, key, descriptor, source) {
  var _this$options_;

  // own
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 2
    /* Continue */
    ;
  } // prototype
  // bound - must annotate protos to support super.flow()


  if (((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) && !isFlow(adm.target_[key])) {
    if (this.extend_(adm, key, descriptor, false) === null) return 0
    /* Cancel */
    ;
  }

  if (isFlow(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1
    /* Break */
    ;
  }

  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2
  /* Continue */
  ;
}

function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;

  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}

function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}

function createFlowDescriptor(adm, annotation, key, descriptor, bound, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;

  if (bound) {
    var _adm$proxy_;

    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return {
    value: flow(value),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3
  };
}

function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0
  /* Cancel */
  : 1
  /* Break */
  ;
}

function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}

function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get = _ref2.get;

  if ( !get) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}

function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4
  };
}

function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0
  /* Cancel */
  : 1
  /* Break */
  ;
}

function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;

  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}

function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;

  if ( !("value" in descriptor)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}

var AUTO = "true";
var autoAnnotation = /*#__PURE__*/createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5
  };
}

function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;

  // getter -> computed
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  } // lone setter -> action setter


  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.make_
    var set = createAction(key.toString(), descriptor.set); // own

    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set
      }) === null ? 0
      /* Cancel */
      : 2
      /* Continue */
      ;
    } // proto


    defineProperty(source, key, {
      configurable: true,
      set: set
    });
    return 2
    /* Continue */
    ;
  } // function on proto -> autoAction/flow


  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;

    if (isGenerator(descriptor.value)) {
      var _this$options_;

      var flowAnnotation = ((_this$options_ = this.options_) == null ? void 0 : _this$options_.autoBind) ? flow.bound : flow;
      return flowAnnotation.make_(adm, key, descriptor, source);
    }

    var actionAnnotation = ((_this$options_2 = this.options_) == null ? void 0 : _this$options_2.autoBind) ? autoAction.bound : autoAction;
    return actionAnnotation.make_(adm, key, descriptor, source);
  } // other -> observable
  // Copy props from proto as well, see test:
  // "decorate should work with Object.create"


  var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable; // if function respect autoBind option

  if (typeof descriptor.value === "function" && ((_this$options_4 = this.options_) == null ? void 0 : _this$options_4.autoBind)) {
    var _adm$proxy_;

    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return observableAnnotation.make_(adm, key, descriptor, source);
}

function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;

  // getter -> computed
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  } // lone setter -> action setter


  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.extend_
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  } // other -> observable
  // if function respect autoBind option


  if (typeof descriptor.value === "function" && ((_this$options_5 = this.options_) == null ? void 0 : _this$options_5.autoBind)) {
    var _adm$proxy_2;

    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }

  var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);
}

var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct"; // Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases

var defaultCreateObservableOptions = {
  deep: true,
  name: undefined,
  defaultDecorator: undefined,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /*#__PURE__*/createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;

  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;

  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */

function createObservable(v, arg2, arg3) {
  // @observable someProp;
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  } // already observable - ignore


  if (isObservable(v)) return v; // plain object

  if (isPlainObject(v)) return observable.object(v, arg2, arg3); // Array

  if (Array.isArray(v)) return observable.array(v, arg2); // Map

  if (isES6Map(v)) return observable.map(v, arg2); // Set

  if (isES6Set(v)) return observable.set(v, arg2); // other object - ignore

  if (typeof v === "object" && v !== null) return v; // anything else

  return observable.box(v, arg2);
}

Object.assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
  },
  ref: /*#__PURE__*/createDecoratorAnnotation(observableRefAnnotation),
  shallow: /*#__PURE__*/createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /*#__PURE__*/createDecoratorAnnotation(observableStructAnnotation)
}; // eslint-disable-next-line

var observable = /*#__PURE__*/assign(createObservable, observableFactories);

var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */

var computed = function computed(arg1, arg2) {
  if (isStringish(arg2)) {
    // @computed
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }

  if (isPlainObject(arg1)) {
    // @computed({ options })
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  } // computed(expr, options?)


  {
    if (!isFunction(arg1)) die("First argument to `computed` should be an expression.");
    if (isFunction(arg2)) die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  }

  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  /* for generated name */

  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /*#__PURE__*/createDecoratorAnnotation(computedStructAnnotation);

var _getDescriptor$config, _getDescriptor;
// mobx versions

var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/getDescriptor(function () {}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false; // we can safely recycle this object

var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction, ref) {
  if (autoAction === void 0) {
    autoAction = false;
  }

  {
    if (!isFunction(fn)) die("`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName) die("actions should have valid names, got: '" + actionName + "'");
  }

  function res() {
    return executeAction(actionName, autoAction, fn, ref || this, arguments);
  }

  res.isMobxAction = true;

  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    Object.defineProperty(res, "name", tmpNameDescriptor);
  }

  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);

  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, // true for autoAction
scope, args) {
  var notifySpy_ =  isSpyEnabled() && !!actionName;
  var startTime_ = 0;

  if ( notifySpy_) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }

  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow

  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }

  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_: prevDerivation_,
    prevAllowStateChanges_: prevAllowStateChanges_,
    prevAllowStateReads_: prevAllowStateReads_,
    notifySpy_: notifySpy_,
    startTime_: startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }

  currentActionId = runInfo.parentActionId_;

  if (runInfo.error_ !== undefined) {
    globalState.suppressReactionErrors = true;
  }

  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) untrackedEnd(runInfo.prevDerivation_);

  if ( runInfo.notifySpy_) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }

  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges, func) {
  var prev = allowStateChangesStart(allowStateChanges);

  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}

var _Symbol$toPrimitive;
var CREATE = "create";
_Symbol$toPrimitive = Symbol.toPrimitive;
var ObservableValue = /*#__PURE__*/function (_Atom) {
  _inheritsLoose(ObservableValue, _Atom);

  function ObservableValue(value, enhancer, name_, notifySpy, equals) {
    var _this;

    if (name_ === void 0) {
      name_ =  "ObservableValue@" + getNextId() ;
    }

    if (notifySpy === void 0) {
      notifySpy = true;
    }

    if (equals === void 0) {
      equals = comparer["default"];
    }

    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, undefined, name_);

    if ( notifySpy && isSpyEnabled()) {
      // only notify spy if this is a stand-alone observable
      spyReport({
        type: CREATE,
        object: _assertThisInitialized(_this),
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }

    return _this;
  }

  var _proto = ObservableValue.prototype;

  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.set = function set(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();

      if ( notifySpy) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue: newValue,
          oldValue: oldValue
        });
      }

      this.setNewValue_(newValue);
      if ( notifySpy) spyReportEnd();
    }
  };

  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue: newValue
      });
      if (!change) return globalState.UNCHANGED;
      newValue = change.newValue;
    } // apply modifier


    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };

  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();

    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue: newValue,
        oldValue: oldValue
      });
    }
  };

  _proto.get = function get() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) listener({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: UPDATE,
      newValue: this.value_,
      oldValue: undefined
    });
    return registerListener(this, listener);
  };

  _proto.raw = function raw() {
    // used by MST ot get undehanced value
    return this.value_;
  };

  _proto.toJSON = function toJSON() {
    return this.get();
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.value_ + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive] = function () {
    return this.valueOf();
  };

  return ObservableValue;
}(Atom);
var isObservableValue = /*#__PURE__*/createInstanceofPredicate("ObservableValue", ObservableValue);

var _Symbol$toPrimitive$1;
/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */

_Symbol$toPrimitive$1 = Symbol.toPrimitive;
var ComputedValue = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  // during tracking it's an array with new observed observers
  // to check for cycles
  // N.B: unminified as it is used by MST

  /**
   * Create a new computed value based on a function expression.
   *
   * The `name` property is for debug purposes only.
   *
   * The `equals` property specifies the comparer function to use to determine if a newly produced
   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.
   * Structural comparison can be convenient if you always produce a new aggregated object and
   * don't want to notify observers if it is structurally the same.
   * This is useful for working with vectors, mouse coordinates etc.
   */
  function ComputedValue(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) die(31);
    this.derivation = options.get;
    this.name_ = options.name || ( "ComputedValue@" + getNextId() );

    if (options.set) {
      this.setter_ = createAction( this.name_ + "-setter" , options.set);
    }

    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = !!options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }

  var _proto = ComputedValue.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Returns the current value of this computed value.
   * Will evaluate its computation first if needed.
   */
  ;

  _proto.get = function get() {
    if (this.isComputing_) die(32, this.name_, this.derivation);

    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch(); // See perf test 'computed memoization'

        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);

      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) globalState.trackingContext = this;
        if (this.trackAndCompute()) propagateChangeConfirmed(this);
        globalState.trackingContext = prevTrackingContext;
      }
    }

    var result = this.value_;
    if (isCaughtException(result)) throw result.cause;
    return result;
  };

  _proto.set = function set(value) {
    if (this.setter_) {
      if (this.isRunningSetter_) die(33, this.name_);
      this.isRunningSetter_ = true;

      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else die(34, this.name_);
  };

  _proto.trackAndCompute = function trackAndCompute() {
    // N.B: unminified as it is used by MST
    var oldValue = this.value_;
    var wasSuspended =
    /* see #1208 */
    this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
    var newValue = this.computeValue_(true);

    if ( isSpyEnabled()) {
      spyReport({
        observableKind: "computed",
        debugObjectName: this.name_,
        object: this.scope_,
        type: "update",
        oldValue: this.value_,
        newValue: newValue
      });
    }

    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);

    if (changed) {
      this.value_ = newValue;
    }

    return changed;
  };

  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true; // don't allow state changes during computation

    var prev = allowStateChangesStart(false);
    var res;

    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }

    allowStateChangesEnd(prev);
    this.isComputing_ = false;
    return res;
  };

  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = undefined; // don't hold on to computed value!

      if ( this.isTracing_ !== TraceMode.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;

    var firstTime = true;
    var prevValue = undefined;
    return autorun(function () {
      // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place
      var newValue = _this.get();

      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue: newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }

      firstTime = false;
      prevValue = newValue;
    });
  };

  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {

    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }

    if (globalState.computedRequiresReaction || this.requiresReaction_) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive$1] = function () {
    return this.valueOf();
  };

  return ComputedValue;
}();
var isComputedValue = /*#__PURE__*/createInstanceofPredicate("ComputedValue", ComputedValue);

var IDerivationState_;

(function (IDerivationState_) {
  // before being run or (outside batch and not being observed)
  // at this point derivation is not holding any data about dependency tree
  IDerivationState_[IDerivationState_["NOT_TRACKING_"] = -1] = "NOT_TRACKING_"; // no shallow dependency changed since last computation
  // won't recalculate derivation
  // this is what makes mobx fast

  IDerivationState_[IDerivationState_["UP_TO_DATE_"] = 0] = "UP_TO_DATE_"; // some deep dependency changed, but don't know if shallow dependency changed
  // will require to check first if UP_TO_DATE or POSSIBLY_STALE
  // currently only ComputedValue will propagate POSSIBLY_STALE
  //
  // having this state is second big optimization:
  // don't have to recompute on every dependency change, but only when it's needed

  IDerivationState_[IDerivationState_["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_"; // A shallow dependency has changed since last computation and the derivation
  // will need to recompute when it's needed next.

  IDerivationState_[IDerivationState_["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));

var TraceMode;

(function (TraceMode) {
  TraceMode[TraceMode["NONE"] = 0] = "NONE";
  TraceMode[TraceMode["LOG"] = 1] = "LOG";
  TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));

var CaughtException = function CaughtException(cause) {
  this.cause = void 0;
  this.cause = cause; // Empty
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */

function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;

    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;

    case IDerivationState_.POSSIBLY_STALE_:
      {
        // state propagation can occur outside of action/reactive context #2195
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.

        var obs = derivation.observing_,
            l = obs.length;

        for (var i = 0; i < l; i++) {
          var obj = obs[i];

          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            } // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
            // and `derivation` is an observer of `obj`
            // invariantShouldCompute(derivation)


            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }

        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
  }
}
function isComputingDerivation() {
  return globalState.trackingDerivation !== null; // filter out actions inside computations
}
function checkIfStateModificationsAreAllowed(atom) {

  var hasObservers = atom.observers_.size > 0; // Should not be possible to change observed state outside strict mode, except during initialization, see #563

  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
}
function checkIfStateReadsAreAllowed(observable) {
  if ( !globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable '" + observable.name_ + "' being read outside a reactive context.");
  }
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */

function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true); // pre allocate array allocation + room for variation in deps
  // array will be trimmed by bindDependencies

  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;

  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }

  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}

function warnAboutDerivationWithoutDependencies(derivation) {
  if (derivation.observing_.length !== 0) return;

  if (globalState.reactionRequiresObservable || derivation.requiresObservable_) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */


function bindDependencies(derivation) {
  // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_; // Go through all new observables and check diffValue: (this list can contain duplicates):
  //   0: first occurrence, change to 1 and keep it
  //   1: extra occurrence, drop it

  var i0 = 0,
      l = derivation.unboundDepsCount_;

  for (var i = 0; i < l; i++) {
    var dep = observing[i];

    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i) observing[i0] = dep;
      i0++;
    } // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
    // not hitting the condition


    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }

  observing.length = i0;
  derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
  // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
  //   0: it's not in new observables, unobserve it
  //   1: it keeps being observed, don't want to notify it. change to 0

  l = prevObserving.length;

  while (l--) {
    var _dep = prevObserving[l];

    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }

    _dep.diffValue_ = 0;
  } // Go through all new observables and check diffValue: (now it should be unique)
  //   0: it was set to 0 in last loop. don't need to do anything.
  //   1: it wasn't observed, let's observe it. set back to 0


  while (i0--) {
    var _dep2 = observing[i0];

    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  } // Some new observed derivations may become stale during this derivation computation
  // so they have had no chance to propagate staleness (#916)


  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}

function clearObserving(derivation) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;

  while (i--) {
    removeObserver(obs[i], derivation);
  }

  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action) {
  var prev = untrackedStart();

  try {
    return action();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */

function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) return;
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;

  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}

/**
 * These values will persist if global state is reset
 */

var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
var MobXGlobals = function MobXGlobals() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /*#__PURE__*/function () {
  var global = /*#__PURE__*/getGlobal();
  if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) canMergeGlobalState = false;
  if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) canMergeGlobalState = false;

  if (!canMergeGlobalState) {
    setTimeout(function () {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global.__mobxGlobals) {
    global.__mobxInstanceCount += 1;
    if (!global.__mobxGlobals.UNCHANGED) global.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible

    return global.__mobxGlobals;
  } else {
    global.__mobxInstanceCount = 1;
    return global.__mobxGlobals = /*#__PURE__*/new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) die(36);
  isolateCalled = true;

  if (canMergeGlobalState) {
    var global = getGlobal();
    if (--global.__mobxInstanceCount === 0) global.__mobxGlobals = undefined;
    globalState = new MobXGlobals();
  }
}
function getGlobalState() {
  return globalState;
}
/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */

function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();

  for (var key in defaultGlobals) {
    if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];
  }

  globalState.allowStateChanges = !globalState.enforceActions;
}

function hasObservers(observable) {
  return observable.observers_ && observable.observers_.size > 0;
}
function getObservers(observable) {
  return observable.observers_;
} // function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }

function addObserver(observable, node) {
  // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
  // invariantObservers(observable);
  observable.observers_.add(node);
  if (observable.lowestObserverState_ > node.dependenciesState_) observable.lowestObserverState_ = node.dependenciesState_; // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}
function removeObserver(observable, node) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
  // invariantObservers(observable);
  observable.observers_["delete"](node);

  if (observable.observers_.size === 0) {
    // deleting last observer
    queueForUnobservation(observable);
  } // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");

}
function queueForUnobservation(observable) {
  if (observable.isPendingUnobservation_ === false) {
    // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
    observable.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable);
  }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */

function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions(); // the batch is actually about to finish, all unobserving should happen here.

    var list = globalState.pendingUnobservations;

    for (var i = 0; i < list.length; i++) {
      var observable = list[i];
      observable.isPendingUnobservation_ = false;

      if (observable.observers_.size === 0) {
        if (observable.isBeingObserved_) {
          // if this observable had reactive observers, trigger the hooks
          observable.isBeingObserved_ = false;
          observable.onBUO();
        }

        if (observable instanceof ComputedValue) {
          // computed values are automatically teared down when the last observer leaves
          // this process happens recursively, this computed might be the last observabe of another, etc..
          observable.suspend_();
        }
      }
    }

    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable) {
  checkIfStateReadsAreAllowed(observable);
  var derivation = globalState.trackingDerivation;

  if (derivation !== null) {
    /**
     * Simple optimization, give each derivation run an unique id (runId)
     * Check if last time this observable was accessed the same runId is used
     * if this is the case, the relation is already known
     */
    if (derivation.runId_ !== observable.lastAccessedBy_) {
      observable.lastAccessedBy_ = derivation.runId_; // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...

      derivation.newObserving_[derivation.unboundDepsCount_++] = observable;

      if (!observable.isBeingObserved_ && globalState.trackingContext) {
        observable.isBeingObserved_ = true;
        observable.onBO();
      }
    }

    return true;
  } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable);
  }

  return false;
} // function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }

/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes

function propagateChanged(observable) {
  // invariantLOS(observable, "changed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_; // Ideally we use for..of here, but the downcompiled version is really slow...

  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if ( d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }

      d.onBecomeStale_();
    }

    d.dependenciesState_ = IDerivationState_.STALE_;
  }); // invariantLOS(observable, "changed end");
} // Called by ComputedValue when it recalculate and its value changed

function propagateChangeConfirmed(observable) {
  // invariantLOS(observable, "confirmed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d.dependenciesState_ = IDerivationState_.STALE_;

      if ( d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }
    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.
    ) {
        observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      }
  }); // invariantLOS(observable, "confirmed end");
} // Used by computed when its dependency changed, but we don't wan't to immediately recompute.

function propagateMaybeChanged(observable) {
  // invariantLOS(observable, "maybe start");
  if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) return;
  observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d.onBecomeStale_();
    }
  }); // invariantLOS(observable, "maybe end");
}

function logTraceInfo(derivation, observable) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable.name_ + "'");

  if (derivation.isTracing_ === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1); // prettier-ignore

    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}

function printDepTree(tree, lines, depth) {
  if (lines.length >= 1000) {
    lines.push("(and many more)");
    return;
  }

  lines.push("" + new Array(depth).join("\t") + tree.name); // MWE: not the fastest, but the easiest way :)

  if (tree.dependencies) tree.dependencies.forEach(function (child) {
    return printDepTree(child, lines, depth + 1);
  });
}

var Reaction = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ =  "Reaction@" + getNextId() ;
    }

    if (requiresObservable_ === void 0) {
      requiresObservable_ = false;
    }

    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }

  var _proto = Reaction.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };

  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };

  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  }
  /**
   * internal, use schedule() if you intend to kick off a reaction
   */
  ;

  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;

      if (shouldCompute(this)) {
        this.isTrackPending_ = true;

        try {
          this.onInvalidate_();

          if ("development" !== "production" && this.isTrackPending_ && isSpyEnabled()) {
            // onInvalidate didn't trigger track right away..
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }

      globalState.trackingContext = prev;
      endBatch();
    }
  };

  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return; // console.warn("Reaction already disposed") // Note: Not a warning / error in mobx 4 either
    }

    startBatch();
    var notify = isSpyEnabled();
    var startTime;

    if ( notify) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }

    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext; // reactions could create reactions...

    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, undefined);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;

    if (this.isDisposed_) {
      // disposed during last run. Clean up everything that was bound after the dispose call.
      clearObserving(this);
    }

    if (isCaughtException(result)) this.reportExceptionInDerivation_(result.cause);

    if ( notify) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }

    endBatch();
  };

  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;

    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }

    if (globalState.disableErrorBoundaries) throw error;
    var message =  "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" ;

    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
      /** If debugging brought you here, please, read the above message :-). Tnx! */
    } else console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)"); // prettier-ignore


    if ( isSpyEnabled()) {
      spyReport({
        type: "error",
        name: this.name_,
        message: message,
        error: "" + error
      });
    }

    globalState.globalReactionErrorHandlers.forEach(function (f) {
      return f(error, _this);
    });
  };

  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;

      if (!this.isRunning_) {
        // if disposed while running, clean up later. Maybe not optimal, but rare case
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };

  _proto.getDisposer_ = function getDisposer_() {
    var r = this.dispose.bind(this);
    r[$mobx] = this;
    return r;
  };

  _proto.toString = function toString() {
    return "Reaction[" + this.name_ + "]";
  };

  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }

    trace(this, enterBreakPoint);
  };

  return Reaction;
}();
function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function () {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);
  };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */

var MAX_REACTION_ITERATIONS = 100;

var reactionScheduler = function reactionScheduler(f) {
  return f();
};

function runReactions() {
  // Trampolining, if runReactions are already running, new reactions will be picked up
  if (globalState.inBatch > 0 || globalState.isRunningReactions) return;
  reactionScheduler(runReactionsHelper);
}

function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0; // While running reactions, new reactions might be triggered.
  // Hence we work with two variables and check whether
  // we converge to no remaining reactions after a while.

  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error( "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) );
      allReactions.splice(0); // clear reactions
    }

    var remainingReactions = allReactions.splice(0);

    for (var i = 0, l = remainingReactions.length; i < l; i++) {
      remainingReactions[i].runReaction_();
    }
  }

  globalState.isRunningReactions = false;
}

var isReaction = /*#__PURE__*/createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;

  reactionScheduler = function reactionScheduler(f) {
    return fn(function () {
      return baseScheduler(f);
    });
  };
}

function isSpyEnabled() {
  return  !!globalState.spyListeners.length;
}
function spyReport(event) {

  if (!globalState.spyListeners.length) return;
  var listeners = globalState.spyListeners;

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](event);
  }
}
function spyReportStart(event) {

  var change = _extends({}, event, {
    spyReportStart: true
  });

  spyReport(change);
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: true
};
function spyReportEnd(change) {
  if (change) spyReport(_extends({}, change, {
    type: "report-end",
    spyReportEnd: true
  }));else spyReport(END_EVENT);
}
function spy(listener) {
  {
    globalState.spyListeners.push(listener);
    return once(function () {
      globalState.spyListeners = globalState.spyListeners.filter(function (l) {
        return l !== listener;
      });
    });
  }
}

var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /*#__PURE__*/createActionAnnotation(ACTION);
var actionBoundAnnotation = /*#__PURE__*/createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});

function createActionFactory(autoAction) {
  var res = function action(arg1, arg2) {
    // action(fn() {})
    if (isFunction(arg1)) return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction); // action("name", fn() {})

    if (isFunction(arg2)) return createAction(arg1, arg2, autoAction); // @action

    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);
    } // action("name") & @action("name")


    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction
      }));
    }

    die("Invalid arguments for `action`");
  };

  return res;
}

var action = /*#__PURE__*/createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /*#__PURE__*/createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /*#__PURE__*/createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /*#__PURE__*/createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}

/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */

function autorun(view, opts) {
  var _opts$name, _opts;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  {
    if (!isFunction(view)) die("Autorun expects a function as first argument");
    if (isAction(view)) die("Autorun does not accept actions since actions are untrackable");
  }

  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  view.name || "Autorun@" + getNextId() ;
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;

  if (runSync) {
    // normal autorun
    reaction = new Reaction(name, function () {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts); // debounced autorun

    var isScheduled = false;
    reaction = new Reaction(name, function () {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function () {
          isScheduled = false;
          if (!reaction.isDisposed_) reaction.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }

  function reactionRunner() {
    view(reaction);
  }

  reaction.schedule_();
  return reaction.getDisposer_();
}

var run = function run(f) {
  return f();
};

function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {
    return setTimeout(f, opts.delay);
  } : run;
}

function reaction(expression, effect, opts) {
  var _opts$name2;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  {
    if (!isFunction(expression) || !isFunction(effect)) die("First and second argument to reaction should be functions");
    if (!isPlainObject(opts)) die("Third argument of reactions should be an object");
  }

  var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  "Reaction@" + getNextId() ;
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var oldValue = undefined; // only an issue with fireImmediately

  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r = new Reaction(name, function () {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);

  function reactionRunner() {
    isScheduled = false;
    if (r.isDisposed_) return;
    var changed = false;
    r.track(function () {
      var nextValue = allowStateChanges(false, function () {
        return expression(r);
      });
      changed = firstTime || !equals(value, nextValue);
      oldValue = value;
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) effectAction(value, oldValue, r);else if (!firstTime && changed) effectAction(value, oldValue, r);
    firstTime = false;
  }

  r.schedule_();
  return r.getDisposer_();
}

function wrapErrorHandler(errorHandler, baseFn) {
  return function () {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}

var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}

function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";

  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = new Set([cb]);
  }

  return function () {
    var hookListeners = atom[listenersKey];

    if (hookListeners) {
      hookListeners["delete"](cb);

      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}

var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed"; // const IF_AVAILABLE = "ifavailable"

function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }

  var useProxies = options.useProxies,
      enforceActions = options.enforceActions;

  if (useProxies !== undefined) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }

  if (useProxies === "ifavailable") globalState.verifyProxies = true;

  if (enforceActions !== undefined) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function (key) {
    if (key in options) globalState[key] = !!options[key];
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;

  if ( globalState.disableErrorBoundaries === true) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }

  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}

function extendObservable(target, properties, annotations, options) {
  {
    if (arguments.length > 4) die("'extendObservable' expected 2-4 arguments");
    if (typeof target !== "object") die("'extendObservable' expects an object as first argument");
    if (isObservableMap(target)) die("'extendObservable' should not be used on maps, use map.merge instead");
    if (!isPlainObject(properties)) die("'extendObservabe' only accepts plain objects as second argument");
    if (isObservable(properties) || isObservable(annotations)) die("Extending an object with another observable (object) is not supported");
  } // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)


  var descriptors = getOwnPropertyDescriptors(properties);
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    ownKeys(descriptors).forEach(function (key) {
      adm.extend_(key, descriptors[key], // must pass "undefined" for { key: undefined }
      !annotations ? true : key in annotations ? annotations[key] : true);
    });
  } finally {
    endBatch();
  }

  return target;
}

function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}

function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  return result;
}

function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}

function nodeToObserverTree(node) {
  var result = {
    name: node.name_
  };
  if (hasObservers(node)) result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
  return result;
}

function unique(list) {
  return Array.from(new Set(list));
}

var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /*#__PURE__*/Object.create(Error.prototype);
function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}
var flowAnnotation = /*#__PURE__*/createFlowAnnotation("flow");
var flowBoundAnnotation = /*#__PURE__*/createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /*#__PURE__*/Object.assign(function flow(arg1, arg2) {
  // @flow
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  } // flow(fn)


  if ( arguments.length !== 1) die("Flow expects single argument with generator function");
  var generator = arg1;
  var name = generator.name || "<unnamed flow>"; // Implementation based on https://github.com/tj/co/blob/master/index.js

  var res = function res() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = undefined;
    var promise = new Promise(function (resolve, reject) {
      var stepId = 0;
      rejector = reject;

      function onFulfilled(res) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function onRejected(err) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          // an async iterator
          ret.then(next, reject);
          return;
        }

        if (ret.done) return resolve(ret.value);
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }

      onFulfilled(undefined); // kick off the process
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function () {
      try {
        if (pendingPromise) cancelPromise(pendingPromise); // Finally block can return (or yield) stuff..

        var _res = gen["return"](undefined); // eat anything that promise would do, it's cancelled!


        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise); // maybe it can be cancelled :)
        // reject our original promise

        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e); // there could be a throwing finally block
      }
    });
    return promise;
  };

  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /*#__PURE__*/createDecoratorAnnotation(flowBoundAnnotation);

function cancelPromise(promise) {
  if (isFunction(promise.cancel)) promise.cancel();
}

function flowResult(result) {
  return result; // just tricking TypeScript :)
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}

function interceptReads(thing, propOrHandler, handler) {
  var target;

  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    if ( !isStringish(propOrHandler)) return die("InterceptReads can only be used with a specific property, not with an object in general");
    target = getAdministration(thing, propOrHandler);
  } else {
    return die("Expected observable map, object or array as first array");
  }

  if ( target.dehancer !== undefined) return die("An intercept reader was already established");
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function () {
    target.dehancer = undefined;
  };
}

function intercept(thing, propOrHandler, handler) {
  if (isFunction(handler)) return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);
}

function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}

function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}

function _isComputed(value, property) {
  if (property !== undefined) {
    if (isObservableObject(value) === false) return false;
    if (!value[$mobx].values_.has(property)) return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }

  return isComputedValue(value);
}
function isComputed(value) {
  if ( arguments.length > 1) return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  if ( !isStringish(propName)) return die("isComputed expected a property name as second argument");
  return _isComputed(value, propName);
}

function _isObservable(value, property) {
  if (!value) return false;

  if (property !== undefined) {
    if ( (isObservableMap(value) || isObservableArray(value))) return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");

    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }

    return false;
  } // For first check, see #701


  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}

function isObservable(value) {
  if ( arguments.length !== 1) die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable(value);
}
function isObservableProp(value, propName) {
  if ( !isStringish(propName)) return die("expected a property name as second argument");
  return _isObservable(value, propName);
}

function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }

  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (_, index) {
      return index;
    });
  }

  die(5);
}
function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return obj[key];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return obj.get(key);
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }

  if (isObservableArray(obj)) {
    return obj.slice();
  }

  die(6);
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj[key]];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj.get(key)];
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (key, index) {
      return [index, key];
    });
  }

  die(7);
}
function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key;

    try {
      for (var _key in _values) {
        set(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }

    return;
  }

  if (isObservableObject(obj)) {
    obj[$mobx].set_(key, value);
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    if (key < 0) die("Invalid index: '" + key + "'");
    startBatch();
    if (key >= obj.length) obj.length = key + 1;
    obj[key] = value;
    endBatch();
  } else die(8);
}
function remove(obj, key) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key);
  } else if (isObservableMap(obj)) {
    obj["delete"](key);
  } else if (isObservableSet(obj)) {
    obj["delete"](key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    obj.splice(key, 1);
  } else {
    die(9);
  }
}
function has(obj, key) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key);
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  }

  die(10);
}
function get(obj, key) {
  if (!has(obj, key)) return undefined;

  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key);
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  }

  die(11);
}
function apiDefineProperty(obj, key, descriptor) {
  if (isObservableObject(obj)) {
    return obj[$mobx].defineProperty_(key, descriptor);
  }

  die(39);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }

  die(38);
}

function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction(cbOrFire)) return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);
}

function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}

function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}

function cache(map, key, value) {
  map.set(key, value);
  return value;
}

function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) return source;
  if (isObservableValue(source) || isComputedValue(source)) return toJSHelper(source.get(), __alreadySeen);

  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }

  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function (value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }

  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, new Set());

    source.forEach(function (value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }

  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, new Map());

    source.forEach(function (value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    // must be observable object
    var _res3 = cache(__alreadySeen, source, {});

    apiOwnKeys(source).forEach(function (key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
/**
 * Basically, a deep clone, so that no reactive property will exist anymore.
 */


function toJS(source, options) {
  if ( options) die("toJS no longer supports options");
  return toJSHelper(source, new Map());
}

function trace() {
  var enterBreakPoint = false;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (typeof args[args.length - 1] === "boolean") enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs(args);

  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }

  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }

  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}

function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;

    case 1:
      return getAtom(args[0]);

    case 2:
      return getAtom(args[0], args[1]);
  }
}

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */

function transaction(action, thisArg) {
  if (thisArg === void 0) {
    thisArg = undefined;
  }

  startBatch();

  try {
    return action.apply(thisArg);
  } finally {
    endBatch();
  }
}

function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") return whenPromise(predicate, arg1);
  return _when(predicate, arg1, arg2 || {});
}

function _when(predicate, effect, opts) {
  var timeoutHandle;

  if (typeof opts.timeout === "number") {
    var error = new Error("WHEN_TIMEOUT");
    timeoutHandle = setTimeout(function () {
      if (!disposer[$mobx].isDisposed_) {
        disposer();
        if (opts.onError) opts.onError(error);else throw error;
      }
    }, opts.timeout);
  }

  opts.name =  opts.name || "When@" + getNextId() ;
  var effectAction = createAction( opts.name + "-effect" , effect); // eslint-disable-next-line

  var disposer = autorun(function (r) {
    // predicate should not change state
    var cond = allowStateChanges(false, predicate);

    if (cond) {
      r.dispose();
      if (timeoutHandle) clearTimeout(timeoutHandle);
      effectAction();
    }
  }, opts);
  return disposer;
}

function whenPromise(predicate, opts) {
  if ( opts && opts.onError) return die("the options 'onError' and 'promise' cannot be combined");
  var cancel;
  var res = new Promise(function (resolve, reject) {
    var disposer = _when(predicate, resolve, _extends({}, opts, {
      onError: reject
    }));

    cancel = function cancel() {
      disposer();
      reject("WHEN_CANCELLED");
    };
  });
  res.cancel = cancel;
  return res;
}

function getAdm(target) {
  return target[$mobx];
} // Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,
// and skip either the internal values map, or the base object with its property descriptors!


var objectProxyTraps = {
  has: function has(target, name) {
    if ( globalState.trackingDerivation) warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set(target, name, value) {
    var _getAdm$set_;

    if (!isStringish(name)) return false;

    if ( !getAdm(target).values_.has(name)) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;

    {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }

    if (!isStringish(name)) return false; // null (intercepted) -> true (success)

    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty(target, name, descriptor) {
    var _getAdm$definePropert;

    {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys(target) {
    if ( globalState.trackingDerivation) warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;

  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}

function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function () {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) interceptors.splice(idx, 1);
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();

  try {
    // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950
    var interceptors = [].concat(interceptable.interceptors_ || []);

    for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      if (change && !change.type) die(14);
      if (!change) break;
    }

    return change;
  } finally {
    untrackedEnd(prevU);
  }
}

function hasListeners(listenable) {
  return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function () {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) listeners.splice(idx, 1);
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) return;
  listeners = listeners.slice();

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }

  untrackedEnd(prevU);
}

function makeObservable(target, annotations, options) {
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    var _annotations;

    // Default to decorators
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target); // Annotate

    ownKeys(annotations).forEach(function (key) {
      return adm.make_(key, annotations[key]);
    });
  } finally {
    endBatch();
  }

  return target;
} // proto[keysSymbol] = new Set<PropertyKey>()

var keysSymbol = /*#__PURE__*/Symbol("mobx-keys");
function makeAutoObservable(target, overrides, options) {
  {
    if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) die("'makeAutoObservable' can only be used for classes that don't have a superclass");
    if (isObservableObject(target)) die("makeAutoObservable can only be used on objects not already made observable");
  } // Optimization: avoid visiting protos
  // Assumes that annotation.make_/.extend_ works the same for plain objects


  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }

  var adm = asObservableObject(target, options)[$mobx]; // Optimization: cache keys on proto
  // Assumes makeAutoObservable can be called only once per object and can't be used in subclass

  if (!target[keysSymbol]) {
    var proto = Object.getPrototypeOf(target);
    var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));
    keys["delete"]("constructor");
    keys["delete"]($mobx);
    addHiddenProp(proto, keysSymbol, keys);
  }

  startBatch();

  try {
    target[keysSymbol].forEach(function (key) {
      return adm.make_(key, // must pass "undefined" for { key: undefined }
      !overrides ? true : key in overrides ? overrides[key] : true);
    });
  } finally {
    endBatch();
  }

  return target;
}

var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859

var arrayTraps = {
  get: function get(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) return adm;
    if (name === "length") return adm.getArrayLength_();

    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }

    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }

    return target[name];
  },
  set: function set(target, name, value) {
    var adm = target[$mobx];

    if (name === "length") {
      adm.setArrayLength_(value);
    }

    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      // numeric string
      adm.set_(parseInt(name), value);
    }

    return true;
  },
  preventExtensions: function preventExtensions() {
    die(15);
  }
};
var ObservableArrayAdministration = /*#__PURE__*/function () {
  // this is the prop that gets proxied, so can't replace it!
  function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name =  "ObservableArray@" + getNextId() ;
    }

    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV,  name + "[..]" );
    };
  }

  var _proto = ObservableArrayAdministration.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== undefined && values.length > 0) return values.map(this.dehancer);
    return values;
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }

    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }

    return registerListener(this, listener);
  };

  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };

  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || newLength < 0) die("Out of range: " + newLength);
    var currentLength = this.values_.length;
    if (newLength === currentLength) return;else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);

      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = undefined;
      } // No Array.fill everywhere...


      this.spliceWithArray_(currentLength, 0, newItems);
    } else this.spliceWithArray_(newLength, currentLength - newLength);
  };

  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) die(16);
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) reserveArrayBuffer(oldLength + delta + 1);
  };

  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
    var _this = this;

    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);
    if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));
    if (newItems === undefined) newItems = EMPTY_ARRAY;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) return EMPTY_ARRAY;
      deleteCount = change.removedCount;
      newItems = change.added;
    }

    newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {
      return _this.enhancer_(v, undefined);
    });

    if (this.legacyMode_ || "development" !== "production") {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified
    }

    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice_(index, newItems, res);
    return this.dehanceValues_(res);
  };

  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;

      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index, index + deleteCount);
      var oldItems = this.values_.slice(index + deleteCount);
      this.values_.length = index + newItems.length - deleteCount;

      for (var i = 0; i < newItems.length; i++) {
        this.values_[index + i] = newItems[i];
      }

      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index + newItems.length + _i] = oldItems[_i];
      }

      return res;
    }
  };

  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index,
      newValue: newValue,
      oldValue: oldValue
    } : null; // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't
    // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled

    if ( notifySpy) spyReportStart(change);
    this.atom_.reportChanged();
    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index,
      removed: removed,
      added: added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if ( notifySpy) spyReportStart(change);
    this.atom_.reportChanged(); // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe

    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.get_ = function get_(index) {
    if (index < this.values_.length) {
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index]);
    }

    console.warn( "[mobx] Out of bounds read: " + index );
  };

  _proto.set_ = function set_(index, newValue) {
    var values = this.values_;

    if (index < values.length) {
      // update at index in range
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index];

      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index,
          newValue: newValue
        });
        if (!change) return;
        newValue = change.newValue;
      }

      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;

      if (changed) {
        values[index] = newValue;
        this.notifyArrayChildUpdate_(index, newValue, oldValue);
      }
    } else if (index === values.length) {
      // add a new item
      this.spliceWithArray_(index, 0, [newValue]);
    } else {
      // out of bounds
      die(17, index, values.length);
    }
  };

  return ObservableArrayAdministration;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name =  "ObservableArray@" + getNextId() ;
  }

  if (owned === void 0) {
    owned = false;
  }

  assertProxies();
  var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
  addHiddenFinalProp(adm.values_, $mobx, adm);
  var proxy = new Proxy(adm.values_, arrayTraps);
  adm.proxy_ = proxy;

  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart(true);
    adm.spliceWithArray_(0, 0, initialValues);
    allowStateChangesEnd(prev);
  }

  return proxy;
} // eslint-disable-next-line

var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },

  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }

    var adm = this[$mobx];

    switch (arguments.length) {
      case 0:
        return [];

      case 1:
        return adm.spliceWithArray_(index);

      case 2:
        return adm.spliceWithArray_(index, deleteCount);
    }

    return adm.spliceWithArray_(index, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];

    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }

    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];

    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }

    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    // reverse by default mutates in place before returning the result
    // which makes it both a 'derivation' and a 'mutation'.
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }

    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    // sort by default mutates in place before returning the result
    // which goes against all good practices. Let's not change the array in place!
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }

    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);

    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }

    return false;
  }
};
/**
 * Wrap function from prototype
 * Without this, everything works as well, but this works
 * faster as everything works on unproxied values
 */

addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc); // map

addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc); // reduce

addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);

function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
} // Report and delegate to dehanced array


function simpleFunc(funcName) {
  return function () {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
} // Make sure callbacks recieve correct array arg #2326


function mapLikeFunc(funcName) {
  return function (callback, thisArg) {
    var _this2 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function (element, index) {
      return callback.call(thisArg, element, index, _this2);
    });
  };
} // Make sure callbacks recieve correct array arg #2326


function reduceLikeFunc(funcName) {
  return function () {
    var _this3 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_); // #2432 - reduce behavior depends on arguments.length

    var callback = arguments[0];

    arguments[0] = function (accumulator, currentValue, index) {
      return callback(accumulator, currentValue, index, _this3);
    };

    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}

var isObservableArrayAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}

var _Symbol$iterator, _Symbol$toStringTag;
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete"; // just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54
// But: https://github.com/mobxjs/mobx/issues/1556

_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;
var ObservableMap = /*#__PURE__*/function () {
  // hasMap, not hashMap >-).
  function ObservableMap(initialData, enhancer_, name_) {
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  "ObservableMap@" + getNextId() ;
    }

    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;

    if (!isFunction(Map)) {
      die(18);
    }

    this.keysAtom_ = createAtom( this.name_ + ".keys()" );
    this.data_ = new Map();
    this.hasMap_ = new Map();
    this.merge(initialData);
  }

  var _proto = ObservableMap.prototype;

  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };

  _proto.has = function has(key) {
    var _this = this;

    if (!globalState.trackingDerivation) return this.has_(key);
    var entry = this.hasMap_.get(key);

    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  this.name_ + "." + stringifyKey(key) + "?" , false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function () {
        return _this.hasMap_["delete"](key);
      });
    }

    return entry.get();
  };

  _proto.set = function set(key, value) {
    var hasKey = this.has_(key);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) return this;
      value = change.newValue;
    }

    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }

    return this;
  };

  _proto["delete"] = function _delete(key) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) return false;
    }

    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;

      if ( notifySpy) spyReportStart(_change);
      transaction(function () {
        _this2.keysAtom_.reportChanged();

        _this2.updateHasMapEntry_(key, false);

        var observable = _this2.data_.get(key);

        observable.setNewValue_(undefined);

        _this2.data_["delete"](key);
      });
      if (notify) notifyListeners(this, _change);
      if ( notifySpy) spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.updateHasMapEntry_ = function updateHasMapEntry_(key, value) {
    var entry = this.hasMap_.get(key);

    if (entry) {
      entry.setNewValue_(value);
    }
  };

  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable = this.data_.get(key);
    newValue = observable.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;
      if ( notifySpy) spyReportStart(change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, change);
      if ( notifySpy) spyReportEnd();
    }
  };

  _proto.addValue_ = function addValue_(key, newValue) {
    var _this3 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function () {
      var observable = new ObservableValue(newValue, _this3.enhancer_,  _this3.name_ + "." + stringifyKey(key) , false);

      _this3.data_.set(key, observable);

      newValue = observable.value_; // value might have been changed

      _this3.updateHasMapEntry_(key, true);

      _this3.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue: newValue
    } : null;
    if ( notifySpy) spyReportStart(change);
    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.get = function get(key) {
    if (this.has(key)) return this.dehanceValue_(this.data_.get(key).get());
    return this.dehanceValue_(undefined);
  };

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };

  _proto.values = function values() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys.next(),
            done = _keys$next.done,
            value = _keys$next.value;

        return {
          done: done,
          value: done ? undefined : self.get(value)
        };
      }
    });
  };

  _proto.entries = function entries() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys.next(),
            done = _keys$next2.done,
            value = _keys$next2.value;

        return {
          done: done,
          value: done ? undefined : [value, self.get(value)]
        };
      }
    });
  };

  _proto[_Symbol$iterator] = function () {
    return this.entries();
  };

  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  }
  /** Merge another object into this object, returns this. */
  ;

  _proto.merge = function merge(other) {
    var _this4 = this;

    if (isObservableMap(other)) {
      other = new Map(other);
    }

    transaction(function () {
      if (isPlainObject(other)) getPlainObjectKeys(other).forEach(function (key) {
        return _this4.set(key, other[key]);
      });else if (Array.isArray(other)) other.forEach(function (_ref) {
        var key = _ref[0],
            value = _ref[1];
        return _this4.set(key, value);
      });else if (isES6Map(other)) {
        if (other.constructor !== Map) die(19, other);
        other.forEach(function (value, key) {
          return _this4.set(key, value);
        });
      } else if (other !== null && other !== undefined) die(20, other);
    });
    return this;
  };

  _proto.clear = function clear() {
    var _this5 = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this5.keys()), _step2; !(_step2 = _iterator2()).done;) {
          var key = _step2.value;

          _this5["delete"](key);
        }
      });
    });
  };

  _proto.replace = function replace(values) {
    var _this6 = this;

    // Implementation requirements:
    // - respect ordering of replacement map
    // - allow interceptors to run and potentially prevent individual operations
    // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)
    // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)
    // - note that result map may differ from replacement map due to the interceptors
    transaction(function () {
      // Convert to map so we can do quick key lookups
      var replacementMap = convertToMap(values);
      var orderedData = new Map(); // Used for optimization

      var keysReportChangedCalled = false; // Delete keys that don't exist in replacement map
      // if the key deletion is prevented by interceptor
      // add entry at the beginning of the result map

      for (var _iterator3 = _createForOfIteratorHelperLoose(_this6.data_.keys()), _step3; !(_step3 = _iterator3()).done;) {
        var key = _step3.value;

        // Concurrently iterating/deleting keys
        // iterator should handle this correctly
        if (!replacementMap.has(key)) {
          var deleted = _this6["delete"](key); // Was the key removed?


          if (deleted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          } else {
            // Delete prevented by interceptor
            var value = _this6.data_.get(key);

            orderedData.set(key, value);
          }
        }
      } // Merge entries


      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;) {
        var _step4$value = _step4.value,
            _key = _step4$value[0],
            _value = _step4$value[1];

        // We will want to know whether a new key is added
        var keyExisted = _this6.data_.has(_key); // Add or update value


        _this6.set(_key, _value); // The addition could have been prevent by interceptor


        if (_this6.data_.has(_key)) {
          // The update could have been prevented by interceptor
          // and also we want to preserve existing values
          // so use value from _data map (instead of replacement map)
          var _value2 = _this6.data_.get(_key);

          orderedData.set(_key, _value2); // Was a new key added?

          if (!keyExisted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          }
        }
      } // Check for possible key order change


      if (!keysReportChangedCalled) {
        if (_this6.data_.size !== orderedData.size) {
          // If size differs, keys are definitely modified
          _this6.keysAtom_.reportChanged();
        } else {
          var iter1 = _this6.data_.keys();

          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();

          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this6.keysAtom_.reportChanged();

              break;
            }

            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      } // Use correctly ordered map


      _this6.data_ = orderedData;
    });
    return this;
  };

  _proto.toString = function toString() {
    return "[object ObservableMap]";
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };

  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if ( fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with maps.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _createClass(ObservableMap, [{
    key: "size",
    get: function get() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return "Map";
    }
  }]);

  return ObservableMap;
}(); // eslint-disable-next-line

var isObservableMap = /*#__PURE__*/createInstanceofPredicate("ObservableMap", ObservableMap);

function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map = new Map();

    for (var key in dataStructure) {
      map.set(key, dataStructure[key]);
    }

    return map;
  } else {
    return die(21, dataStructure);
  }
}

var _Symbol$iterator$1, _Symbol$toStringTag$1;
var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;
var ObservableSet = /*#__PURE__*/function () {
  function ObservableSet(initialData, enhancer, name_) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  "ObservableSet@" + getNextId() ;
    }

    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;

    if (!isFunction(Set)) {
      die(22);
    }

    this.atom_ = createAtom(this.name_);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV, name_);
    };

    if (initialData) {
      this.replace(initialData);
    }
  }

  var _proto = ObservableSet.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.clear = function clear() {
    var _this = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done;) {
          var value = _step.value;

          _this["delete"](value);
        }
      });
    });
  };

  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };

  _proto.add = function add(value) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.atom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) return this; // ideally, value = change.value would be done here, so that values can be
      // changed by interceptor. Same applies for other Set and Map api's.
    }

    if (!this.has(value)) {
      transaction(function () {
        _this2.data_.add(_this2.enhancer_(value, undefined));

        _this2.atom_.reportChanged();
      });
      var notifySpy =  isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change);
      if (notify) notifyListeners(this, _change);
      if (notifySpy && "development" !== "production") spyReportEnd();
    }

    return this;
  };

  _proto["delete"] = function _delete(value) {
    var _this3 = this;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) return false;
    }

    if (this.has(value)) {
      var notifySpy =  isSpyEnabled();
      var notify = hasListeners(this);

      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change2);
      transaction(function () {
        _this3.atom_.reportChanged();

        _this3.data_["delete"](value);
      });
      if (notify) notifyListeners(this, _change2);
      if (notifySpy && "development" !== "production") spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.has = function has(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };

  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index = nextIndex;
        nextIndex += 1;
        return index < values.length ? {
          value: [keys[index], values[index]],
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.keys = function keys() {
    return this.values();
  };

  _proto.values = function values() {
    this.atom_.reportObserved();
    var self = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.replace = function replace(other) {
    var _this4 = this;

    if (isObservableSet(other)) {
      other = new Set(other);
    }

    transaction(function () {
      if (Array.isArray(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (isES6Set(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (other !== null && other !== undefined) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    // ... 'fireImmediately' could also be true?
    if ( fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with sets.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };

  _proto.toString = function toString() {
    return "[object ObservableSet]";
  };

  _proto[_Symbol$iterator$1] = function () {
    return this.values();
  };

  _createClass(ObservableSet, [{
    key: "size",
    get: function get() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$1,
    get: function get() {
      return "Set";
    }
  }]);

  return ObservableSet;
}(); // eslint-disable-next-line

var isObservableSet = /*#__PURE__*/createInstanceofPredicate("ObservableSet", ObservableSet);

var descriptorCache = /*#__PURE__*/Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /*#__PURE__*/function () {
  function ObservableObjectAdministration(target_, values_, name_, // Used anytime annotation is not explicitely provided
  defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = new Map();
    }

    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }

    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom( this.name_ + ".keys" ); // Optimization: we use this frequently

    this.isPlainObject_ = isPlainObject(this.target_);

    if ( !isAnnotation(this.defaultAnnotation_)) {
      die("defaultAnnotation must be valid annotation");
    }

    {
      // Prepare structure for tracking which fields were already annotated
      this.appliedAnnotations_ = {};
    }
  }

  var _proto = ObservableObjectAdministration.prototype;

  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };

  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable = this.values_.get(key);

    if (observable instanceof ComputedValue) {
      observable.set(newValue);
      return true;
    } // intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: newValue
      });
      if (!change) return null;
      newValue = change.newValue;
    }

    newValue = observable.prepareNewValue_(newValue); // notify spy & observers

    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy =  isSpyEnabled();

      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;

      if ( notifySpy) spyReportStart(_change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, _change);
      if ( notifySpy) spyReportEnd();
    }

    return true;
  };

  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      // Key doesn't exist yet, subscribe for it in case it's added later
      this.has_(key);
    }

    return this.target_[key];
  }
  /**
   * @param {PropertyKey} key
   * @param {any} value
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    // Don't use .has(key) - we care about own
    if (hasProp(this.target_, key)) {
      // Existing prop
      if (this.values_.has(key)) {
        // Observable (can be intercepted)
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        // Non-observable - proxy
        return Reflect.set(this.target_, key, value);
      } else {
        // Non-observable
        this.target_[key] = value;
        return true;
      }
    } else {
      // New prop
      return this.extend_(key, {
        value: value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  } // Trap for "in"
  ;

  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      // Skip key subscription outside derivation
      return key in this.target_;
    }

    this.pendingKeys_ || (this.pendingKeys_ = new Map());
    var entry = this.pendingKeys_.get(key);

    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer,  this.name_ + "." + stringifyKey(key) + "?" , false);
      this.pendingKeys_.set(key, entry);
    }

    return entry.get();
  }
  /**
   * @param {PropertyKey} key
   * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop
   */
  ;

  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }

    if (annotation === false) {
      return;
    }

    assertAnnotable(this, annotation, key);

    if (!(key in this.target_)) {
      var _this$target_$storedA;

      // Throw on missing key, except for decorators:
      // Decorator annotations are collected from whole prototype chain.
      // When called from super() some props may not exist yet.
      // However we don't have to worry about missing prop,
      // because the decorator must have been applied to something.
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) == null ? void 0 : _this$target_$storedA[key]) {
        return; // will be annotated by subclass constructor
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }

    var source = this.target_;

    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);

      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0
        /* Cancel */
        ) return;
        if (outcome === 1
        /* Break */
        ) break;
      }

      source = Object.getPrototypeOf(source);
    }

    recordAnnotationApplied(this, annotation, key);
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }

    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }

    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);

    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }

    return outcome;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) return null;
        var newValue = change.newValue;

        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      } // Define


      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      } // Notify


      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) return null;
        value = change.newValue;
      }

      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      var observable = new ObservableValue(value, enhancer, "development" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable); // Notify (value possibly changed by ObservableValue)

      this.notifyPropertyAddition_(key, observable.value_);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: undefined
        });
        if (!change) return null;
      }

      options.name || (options.name = "development" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      this.values_.set(key, new ComputedValue(options)); // Notify

      this.notifyPropertyAddition_(key, undefined);
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    // No such prop
    if (!hasProp(this.target_, key)) {
      return true;
    } // Intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      }); // Cancelled

      if (!change) return null;
    } // Delete


    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;

      startBatch();
      var notify = hasListeners(this);
      var notifySpy = "development" !== "production" && isSpyEnabled();
      var observable = this.values_.get(key); // Value needed for spies/listeners

      var value = undefined; // Optimization: don't pull the value unless we will need it

      if (!observable && (notify || notifySpy)) {
        var _getDescriptor;

        value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;
      } // delete prop (do first, may fail)


      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      } // Allow re-annotating this field


      if ("development" !== "production") {
        delete this.appliedAnnotations_[key];
      } // Clear observable


      if (observable) {
        this.values_["delete"](key); // for computed, value is undefined

        if (observable instanceof ObservableValue) {
          value = observable.value_;
        } // Notify: autorun(() => obj[key]), see #1796


        propagateChanged(observable);
      } // Notify "keys/entries/values" observers


      this.keysAtom_.reportChanged(); // Notify "has" observers
      // "in" as it may still exist in proto

      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_); // Notify spies/listeners

      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if ("development" !== "production" && notifySpy) spyReportStart(_change2);
        if (notify) notifyListeners(this, _change2);
        if ("development" !== "production" && notifySpy) spyReportEnd();
      }
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  ;

  _proto.observe_ = function observe_(callback, fireImmediately) {
    if ( fireImmediately === true) die("`observe` doesn't support the fire immediately property for observable objects.");
    return registerListener(this, callback);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;

    var notify = hasListeners(this);
    var notifySpy =  isSpyEnabled();

    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if ( notifySpy) spyReportStart(change);
      if (notify) notifyListeners(this, change);
      if ( notifySpy) spyReportEnd();
    }

    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true); // Notify "keys/entries/values" observers

    this.keysAtom_.reportChanged();
  };

  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };

  _proto.keys_ = function keys_() {
    // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.
    // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.
    // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)
    // We choose to over-report in Object.keys(object), because:
    // - typically it's used with simple data objects
    // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };

  return ObservableObjectAdministration;
}();
function asObservableObject(target, options) {
  var _options$name;

  if ( options && isObservableObject(target)) {
    die("Options can't be provided for already observable objects.");
  }

  if (hasProp(target, $mobx)) {
    if ( !(getAdministration(target) instanceof ObservableObjectAdministration)) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:" + "\nThe target is already observable of different type." + "\nExtending builtins is not supported.");
    }

    return target;
  }

  if ( !Object.isExtensible(target)) die("Cannot make the designated object observable; it is not extensible");
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() ;
  var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);

function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}

function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }

  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;

  {
    adm.appliedAnnotations_[key] = annotation;
  } // Remove applied decorator annotation so we don't try to apply it again in subclass constructor


  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
}

function assertAnnotable(adm, annotation, key) {
  // Valid annotation
  if ( !isAnnotation(annotation)) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  /*
  // Configurable, not sealed, not frozen
  // Possibly not needed, just a little better error then the one thrown by engine.
  // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.
  if (__DEV__) {
      const configurable = getDescriptor(adm.target_, key)?.configurable
      const frozen = Object.isFrozen(adm.target_)
      const sealed = Object.isSealed(adm.target_)
      if (!configurable || frozen || sealed) {
          const fieldName = `${adm.name_}.${key.toString()}`
          const requestedAnnotationType = annotation.annotationType_
          let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`
          if (frozen) {
              error += `\nObject is frozen.`
          }
          if (sealed) {
              error += `\nObject is sealed.`
          }
          if (!configurable) {
              error += `\nproperty is not configurable.`
              // Mention only if caused by us to avoid confusion
              if (hasProp(adm.appliedAnnotations!, key)) {
                  error += `\nTo prevent accidental re-definition of a field by a subclass, `
                  error += `all annotated fields of non-plain objects (classes) are not configurable.`
              }
          }
          die(error)
      }
  }
  */
  // Not annotated


  if ( !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed." + "\nUse 'override' annotation for methods overriden by subclass.");
  }
}

/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */

var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array

var StubArray = function StubArray() {};

function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== undefined) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}

inherit(StubArray, Array.prototype); // Weex proto freeze protection was here,
// but it is unclear why the hack is need as MobX never changed the prototype
// anyway, so removed it in V6

var LegacyObservableArray = /*#__PURE__*/function (_StubArray) {
  _inheritsLoose(LegacyObservableArray, _StubArray);

  function LegacyObservableArray(initialValues, enhancer, name, owned) {
    var _this;

    if (name === void 0) {
      name =  "ObservableArray@" + getNextId() ;
    }

    if (owned === void 0) {
      owned = false;
    }

    _this = _StubArray.call(this) || this;
    var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
    adm.proxy_ = _assertThisInitialized(_this);
    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);

    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true); // @ts-ignore

      _this.spliceWithArray(0, 0, initialValues);

      allowStateChangesEnd(prev);
    }

    return _this;
  }

  var _proto = LegacyObservableArray.prototype;

  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();

    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }

    return Array.prototype.concat.apply(this.slice(), //@ts-ignore
    arrays.map(function (a) {
      return isObservableArray(a) ? a.slice() : a;
    }));
  };

  _proto[Symbol.iterator] = function () {
    var self = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        // @ts-ignore
        return nextIndex < self.length ? {
          value: self[nextIndex++],
          done: false
        } : {
          done: true,
          value: undefined
        };
      }
    });
  };

  _createClass(LegacyObservableArray, [{
    key: "length",
    get: function get() {
      return this[$mobx].getArrayLength_();
    },
    set: function set(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return "Array";
    }
  }]);

  return LegacyObservableArray;
}(StubArray);

Object.entries(arrayExtensions).forEach(function (_ref) {
  var prop = _ref[0],
      fn = _ref[1];
  if (prop !== "concat") addHiddenProp(LegacyObservableArray.prototype, prop, fn);
});

function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this[$mobx].get_(index);
    },
    set: function set(value) {
      this[$mobx].set_(index, value);
    }
  };
}

function createArrayBufferItem(index) {
  defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}

function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
      createArrayBufferItem(index);
    }

    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
reserveArrayBuffer(1000);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}

function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== undefined) die(23);
      return thing[$mobx].atom_;
    }

    if (isObservableSet(thing)) {
      return thing[$mobx];
    }

    if (isObservableMap(thing)) {
      if (property === undefined) return thing.keysAtom_;
      var observable = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable) die(25, property, getDebugName(thing));
      return observable;
    }

    if (isObservableObject(thing)) {
      if (!property) return die(26);

      var _observable = thing[$mobx].values_.get(property);

      if (!_observable) die(27, property, getDebugName(thing));
      return _observable;
    }

    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      // disposer function
      return thing[$mobx];
    }
  }

  die(28);
}
function getAdministration(thing, property) {
  if (!thing) die(29);
  if (property !== undefined) return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;
  if (isObservableMap(thing) || isObservableSet(thing)) return thing;
  if (thing[$mobx]) return thing[$mobx];
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;

  if (property !== undefined) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    // valid for arrays as well
    named = getAtom(thing);
  }

  return named.name_;
}

var toString = objectPrototype.toString;
function deepEqual(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }

  return eq(a, b, depth);
} // Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.

function eq(a, b, depth, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b; // `null` or `undefined` only equal to itself (strict comparison).

  if (a == null || b == null) return false; // `NaN`s are equivalent, but non-reflexive.

  if (a !== a) return b !== b; // Exhaust primitive checks

  var type = typeof a;
  if (!isFunction(type) && type !== "object" && typeof b != "object") return false; // Compare `[[Class]]` names.

  var className = toString.call(a);
  if (className !== toString.call(b)) return false;

  switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]": // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

    case "[object String]":
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return "" + a === "" + b;

    case "[object Number]":
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.

      return +a === 0 ? 1 / +a === 1 / b : +a === +b;

    case "[object Date]":
    case "[object Boolean]":
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;

    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);

    case "[object Map]":
    case "[object Set]":
      // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.
      // Hide this extra level by increasing the depth.
      if (depth >= 0) {
        depth++;
      }

      break;
  } // Unwrap any wrapped objects.


  a = unwrap(a);
  b = unwrap(b);
  var areArrays = className === "[object Array]";

  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.

    var aCtor = a.constructor,
        bCtor = b.constructor;

    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }

  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  } // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.


  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;

  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  } // Add the first object to the stack of traversed objects.


  aStack.push(a);
  bStack.push(b); // Recursively compare objects and arrays.

  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.

    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var keys = Object.keys(a);
    var key;
    length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.

    if (Object.keys(b).length !== length) return false;

    while (length--) {
      // Deep compare each member
      key = keys[length];
      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) return false;
    }
  } // Remove the first object from the stack of traversed objects.


  aStack.pop();
  bStack.pop();
  return true;
}

function unwrap(a) {
  if (isObservableArray(a)) return a.slice();
  if (isES6Map(a) || isObservableMap(a)) return Array.from(a.entries());
  if (isES6Set(a) || isObservableSet(a)) return Array.from(a.entries());
  return a;
}

function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}

function getSelf() {
  return this;
}

function isAnnotation(thing) {
  return (// Can be function
    thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
  );
}

/**
 * (c) Michel Weststrate 2015 - 2020
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */
["Symbol", "Map", "Set"].forEach(function (m) {
  var g = getGlobal();

  if (typeof g[m] === "undefined") {
    die("MobX requires global '" + m + "' to be available or polyfilled");
  }
});

if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  // See: https://github.com/andykog/mobx-devtools/
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: spy,
    extras: {
      getDebugName: getDebugName
    },
    $mobx: $mobx
  });
}

exports.$mobx = $mobx;
exports.FlowCancellationError = FlowCancellationError;
exports.ObservableMap = ObservableMap;
exports.ObservableSet = ObservableSet;
exports.Reaction = Reaction;
exports._allowStateChanges = allowStateChanges;
exports._allowStateChangesInsideComputed = runInAction;
exports._allowStateReadsEnd = allowStateReadsEnd;
exports._allowStateReadsStart = allowStateReadsStart;
exports._autoAction = autoAction;
exports._endAction = _endAction;
exports._getAdministration = getAdministration;
exports._getGlobalState = getGlobalState;
exports._interceptReads = interceptReads;
exports._isComputingDerivation = isComputingDerivation;
exports._resetGlobalState = resetGlobalState;
exports._startAction = _startAction;
exports.action = action;
exports.autorun = autorun;
exports.comparer = comparer;
exports.computed = computed;
exports.configure = configure;
exports.createAtom = createAtom;
exports.defineProperty = apiDefineProperty;
exports.entries = entries;
exports.extendObservable = extendObservable;
exports.flow = flow;
exports.flowResult = flowResult;
exports.get = get;
exports.getAtom = getAtom;
exports.getDebugName = getDebugName;
exports.getDependencyTree = getDependencyTree;
exports.getObserverTree = getObserverTree;
exports.has = has;
exports.intercept = intercept;
exports.isAction = isAction;
exports.isBoxedObservable = isObservableValue;
exports.isComputed = isComputed;
exports.isComputedProp = isComputedProp;
exports.isFlow = isFlow;
exports.isFlowCancellationError = isFlowCancellationError;
exports.isObservable = isObservable;
exports.isObservableArray = isObservableArray;
exports.isObservableMap = isObservableMap;
exports.isObservableObject = isObservableObject;
exports.isObservableProp = isObservableProp;
exports.isObservableSet = isObservableSet;
exports.keys = keys;
exports.makeAutoObservable = makeAutoObservable;
exports.makeObservable = makeObservable;
exports.observable = observable;
exports.observe = observe;
exports.onBecomeObserved = onBecomeObserved;
exports.onBecomeUnobserved = onBecomeUnobserved;
exports.onReactionError = onReactionError;
exports.override = override;
exports.ownKeys = apiOwnKeys;
exports.reaction = reaction;
exports.remove = remove;
exports.runInAction = runInAction;
exports.set = set;
exports.spy = spy;
exports.toJS = toJS;
exports.trace = trace;
exports.transaction = transaction;
exports.untracked = untracked;
exports.values = values;
exports.when = when;


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],25:[function(require,module,exports){
(function (global){(function (){
function t(t){for(var n=arguments.length,i=new Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];throw new Error("number"==typeof t?"[MobX] minified error nr: "+t+(i.length?" "+i.map(String).join(","):"")+". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts":"[MobX] "+t)}function n(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:xn}function i(){Vn||t("Proxy not available")}function r(t){var n=!1;return function(){if(!n)return n=!0,t.apply(this,arguments)}}function e(t){return"function"==typeof t}function o(t){switch(typeof t){case"string":case"symbol":case"number":return!0}return!1}function u(t){return null!==t&&"object"==typeof t}function s(t){var n;if(!u(t))return!1;var i=Object.getPrototypeOf(t);return null==i||(null==(n=i.constructor)?void 0:n.toString())===Nn}function f(t){var n=null==t?void 0:t.constructor;return!!n&&("GeneratorFunction"===n.name||"GeneratorFunction"===n.displayName)}function a(t,n,i){gn(t,n,{enumerable:!1,writable:!0,configurable:!0,value:i})}function c(t,n,i){gn(t,n,{enumerable:!1,writable:!1,configurable:!0,value:i})}function h(t,n){var i="isMobX"+t;return n.prototype[i]=!0,function(t){return u(t)&&!0===t[i]}}function v(t){return t instanceof Map}function l(t){return t instanceof Set}function d(t){return null===t?null:"object"==typeof t?""+t:t}function b(t,n){return _n.hasOwnProperty.call(t,n)}function p(t,n){for(var i=0;i<n.length;i++){var r=n[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function y(t,n,i){return n&&p(t.prototype,n),i&&p(t,i),t}function m(){return(m=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var i=arguments[n];for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t}).apply(this,arguments)}function w(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n}function j(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function x(t,n){(null==n||n>t.length)&&(n=t.length);for(var i=0,r=new Array(n);i<n;i++)r[i]=t[i];return r}function O(t,n){var i;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(i=function(t){if(t){if("string"==typeof t)return x(t,void 0);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?x(t,void 0):void 0}}(t))||n&&t&&"number"==typeof t.length){i&&(t=i);var r=0;return function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return(i=t[Symbol.iterator]()).next.bind(i)}function A(t){return Object.assign((function(n,i){g(n,i,t)}),t)}function g(t,n,i){b(t,Cn)||a(t,Cn,m({},t[Cn])),function(t){return"override"===t.t}(i)||(t[Cn][n]=i)}function _(t,n,i){void 0===n&&(n=Rn),void 0===i&&(i=Rn);var r=new Ln(t);return n!==Rn&&St(r,n),i!==Rn&&Mt(r,i),r}function S(t,n,i){return It(t)?t:Array.isArray(t)?$n.array(t,{name:i}):s(t)?$n.object(t,void 0,{name:i}):v(t)?$n.map(t,{name:i}):l(t)?$n.set(t,{name:i}):"function"!=typeof t||At(t)||Ct(t)?t:f(t)?Ri(t):_i(i,t)}function M(t){return t}function V(t,n){return{t:t,i:n,o:N,u:R}}function N(t,n,i,r){var e;if(null==(e=this.i)?void 0:e.bound)return null===this.u(t,n,i,!1)?0:1;if(r===t.s)return null===this.u(t,n,i,!1)?0:2;if(At(i.value))return 1;var o=k(t,this,n,i,!1);return gn(r,n,o),2}function R(t,n,i,r){var e=k(t,this,n,i);return t.h(n,e,r)}function k(t,n,i,r,e){var o,u,s,f,a;void 0===e&&(e=pi.safeDescriptors);var c,h=r.value;return(null==(o=n.i)?void 0:o.bound)&&(h=h.bind(null!=(c=t.v)?c:t.s)),{value:z(null!=(u=null==(s=n.i)?void 0:s.name)?u:i.toString(),h,null!=(f=null==(a=n.i)?void 0:a.autoAction)&&f),configurable:!e||t.l,enumerable:!1,writable:!e}}function E(t,n){return{t:t,i:n,o:T,u:C}}function T(t,n,i,r){var e;if(r===t.s)return null===this.u(t,n,i,!1)?0:2;if((null==(e=this.i)?void 0:e.bound)&&!Ct(t.s[n])&&null===this.u(t,n,i,!1))return 0;if(Ct(i.value))return 1;var o=K(t,0,0,i,!1,!1);return gn(r,n,o),2}function C(t,n,i,r){var e,o=K(t,0,0,i,null==(e=this.i)?void 0:e.bound);return t.h(n,o,r)}function K(t,n,i,r,e,o){void 0===o&&(o=pi.safeDescriptors);var u,s=r.value;return e&&(s=s.bind(null!=(u=t.v)?u:t.s)),{value:Ri(s),configurable:!o||t.l,enumerable:!1,writable:!o}}function L(t,n){return{t:t,i:n,o:I,u:P}}function I(t,n,i){return null===this.u(t,n,i,!1)?0:1}function P(t,n,i,r){return t.p(n,m({},this.i,{get:i.get,set:i.set}),r)}function D(t,n){return{t:t,i:n,o:B,u:q}}function B(t,n,i){return null===this.u(t,n,i,!1)?0:1}function q(t,n,i,r){var e,o;return t.m(n,i.value,null!=(e=null==(o=this.i)?void 0:o.enhancer)?e:S,r)}function G(t){return{t:"true",i:t,o:X,u:W}}function X(t,n,i,r){var e,o,u,s;if(i.get)return Qn.o(t,n,i,r);if(i.set){var a=z(n.toString(),i.set);return r===t.s?null===t.h(n,{configurable:!pi.safeDescriptors||t.l,set:a})?0:2:(gn(r,n,{configurable:!0,set:a}),2)}if(r!==t.s&&"function"==typeof i.value)return f(i.value)?((null==(s=this.i)?void 0:s.autoBind)?Ri.bound:Ri).o(t,n,i,r):((null==(u=this.i)?void 0:u.autoBind)?_i.bound:_i).o(t,n,i,r);var c,h=!1===(null==(e=this.i)?void 0:e.deep)?$n.ref:$n;return"function"==typeof i.value&&(null==(o=this.i)?void 0:o.autoBind)&&(i.value=i.value.bind(null!=(c=t.v)?c:t.s)),h.o(t,n,i,r)}function W(t,n,i,r){var e,o,u;return i.get?Qn.u(t,n,i,r):i.set?t.h(n,{configurable:!pi.safeDescriptors||t.l,set:z(n.toString(),i.set)},r):("function"==typeof i.value&&(null==(e=this.i)?void 0:e.autoBind)&&(i.value=i.value.bind(null!=(u=t.v)?u:t.s)),(!1===(null==(o=this.i)?void 0:o.deep)?$n.ref:$n).u(t,n,i,r))}function H(t){return t||qn}function U(t){return!0===t.deep?S:!1===t.deep?M:(n=t.defaultDecorator)&&null!=(i=null==(r=n.i)?void 0:r.enhancer)?i:S;var n,i,r}function F(t,n,i){if(!o(n))return It(t)?t:s(t)?$n.object(t,n,i):Array.isArray(t)?$n.array(t,n):v(t)?$n.map(t,n):l(t)?$n.set(t,n):"object"==typeof t&&null!==t?t:$n.box(t,n);g(t,n,Gn)}function z(t,n,i,r){function e(){return $(0,i,n,r||this,arguments)}return void 0===i&&(i=!1),e.isMobxAction=!0,ii&&(ri.value=t,Object.defineProperty(e,"name",ri)),e}function $(t,n,i,r,e){var o=J(0,n);try{return i.apply(r,e)}catch(t){throw o.j=t,t}finally{Y(o)}}function J(t,n){var i=pi.trackingDerivation,r=!n||!i;dt();var e=pi.allowStateChanges;r&&(ut(),e=Z(!0));var o={O:r,A:i,g:e,_:ft(!0),S:!1,M:0,V:ni++,N:ti};return ti=o.V,o}function Y(n){ti!==n.V&&t(30),ti=n.N,void 0!==n.j&&(pi.suppressReactionErrors=!0),tt(n.g),at(n._),bt(),n.O&&st(n.A),pi.suppressReactionErrors=!1}function Q(t,n){var i=Z(t);try{return n()}finally{tt(i)}}function Z(t){var n=pi.allowStateChanges;return pi.allowStateChanges=t,n}function tt(t){pi.allowStateChanges=t}function nt(t){return t instanceof hi}function it(t){switch(t.R){case si.k:return!1;case si.T:case si.C:return!0;case si.K:for(var n=ft(!0),i=ut(),r=t.L,e=r.length,o=0;o<e;o++){var u=r[o];if(ci(u)){if(pi.disableErrorBoundaries)u.get();else try{u.get()}catch(t){return st(i),at(n),!0}if(t.R===si.C)return st(i),at(n),!0}}return ct(t),st(i),at(n),!1}}function rt(t,n,i){var r=ft(!0);ct(t),t.I=new Array(t.L.length+100),t.P=0,t.D=++pi.runId;var e,o=pi.trackingDerivation;if(pi.trackingDerivation=t,pi.inBatch++,!0===pi.disableErrorBoundaries)e=n.call(i);else try{e=n.call(i)}catch(t){e=new hi(t)}return pi.inBatch--,pi.trackingDerivation=o,function(t){for(var n=t.L,i=t.L=t.I,r=si.k,e=0,o=t.P,u=0;u<o;u++){var s=i[u];0===s.B&&(s.B=1,e!==u&&(i[e]=s),e++),s.R>r&&(r=s.R)}for(i.length=e,t.I=null,o=n.length;o--;){var f=n[o];0===f.B&&vt(f,t),f.B=0}for(;e--;){var a=i[e];1===a.B&&(a.B=0,ht(a,t))}r!==si.k&&(t.R=r,t.q())}(t),at(r),e}function et(t){var n=t.L;t.L=[];for(var i=n.length;i--;)vt(n[i],t);t.R=si.T}function ot(t){var n=ut();try{return t()}finally{st(n)}}function ut(){var t=pi.trackingDerivation;return pi.trackingDerivation=null,t}function st(t){pi.trackingDerivation=t}function ft(t){var n=pi.allowStateReads;return pi.allowStateReads=t,n}function at(t){pi.allowStateReads=t}function ct(t){if(t.R!==si.k){t.R=si.k;for(var n=t.L,i=n.length;i--;)n[i].G=si.k}}function ht(t,n){t.X.add(n),t.G>n.R&&(t.G=n.R)}function vt(t,n){t.X.delete(n),0===t.X.size&&lt(t)}function lt(t){!1===t.W&&(t.W=!0,pi.pendingUnobservations.push(t))}function dt(){pi.inBatch++}function bt(){if(0==--pi.inBatch){mt();for(var t=pi.pendingUnobservations,n=0;n<t.length;n++){var i=t[n];i.W=!1,0===i.X.size&&(i.H&&(i.H=!1,i.onBUO()),i instanceof ai&&i.U())}pi.pendingUnobservations=[]}}function pt(t){var n=pi.trackingDerivation;return null!==n?(n.D!==t.F&&(t.F=n.D,n.I[n.P++]=t,!t.H&&pi.trackingContext&&(t.H=!0,t.onBO())),!0):(0===t.X.size&&pi.inBatch>0&&lt(t),!1)}function yt(t){t.G!==si.C&&(t.G=si.C,t.X.forEach((function(t){t.R===si.k&&t.q(),t.R=si.C})))}function mt(){pi.inBatch>0||pi.isRunningReactions||mi(wt)}function wt(){pi.isRunningReactions=!0;for(var t=pi.pendingReactions,n=0;t.length>0;){100==++n&&(console.error("[mobx] cycle in reaction: "+t[0]),t.splice(0));for(var i=t.splice(0),r=0,e=i.length;r<e;r++)i[r].$()}pi.isRunningReactions=!1}function jt(){return console.warn("[mobx.spy] Is a no-op in production builds"),function(){}}function xt(t){return function(n,i){return e(n)?z(n.name||"<unnamed action>",n,t):e(i)?z(n,i,t):o(i)?g(n,i,t?Oi:ji):o(n)?A(V(t?"autoAction":"action",{name:n,autoAction:t})):void 0}}function Ot(t){return $(0,!1,t,this,void 0)}function At(t){return e(t)&&!0===t.isMobxAction}function gt(t,n){function i(){t(o)}var r,e;void 0===n&&(n=Mn);var o,u=null!=(r=null==(e=n)?void 0:e.name)?r:"Autorun";if(n.scheduler||n.delay){var s=_t(n),f=!1;o=new yi(u,(function(){f||(f=!0,s((function(){f=!1,o.J||o.track(i)})))}),n.onError,n.requiresObservable)}else o=new yi(u,(function(){this.track(i)}),n.onError,n.requiresObservable);return o.Y(),o.Z()}function _t(t){return t.scheduler?t.scheduler:t.delay?function(n){return setTimeout(n,t.delay)}:Si}function St(t,n,i){return Vt("onBO",t,n,i)}function Mt(t,n,i){return Vt("onBUO",t,n,i)}function Vt(t,n,i,r){var o="function"==typeof r?dn(n,i):dn(n),u=e(r)?r:i,s=t+"L";return o[s]?o[s].add(u):o[s]=new Set([u]),function(){var t=o[s];t&&(t.delete(u),0===t.size&&delete o[s])}}function Nt(t,n,i,r){var e=Tn(n),o=sn(t,r)[Kn];dt();try{En(e).forEach((function(t){o.u(t,e[t],!i||!(t in i)||i[t])}))}finally{bt()}return t}function Rt(t){var n,i={name:t.tt};return t.L&&t.L.length>0&&(i.dependencies=(n=t.L,Array.from(new Set(n))).map(Rt)),i}function kt(t){var n={name:t.tt};return function(t){return t.X&&t.X.size>0}(t)&&(n.observers=Array.from(function(t){return t.X}(t)).map(kt)),n}function Et(){this.message="FLOW_CANCELLED"}function Tt(t){e(t.cancel)&&t.cancel()}function Ct(t){return!0===(null==t?void 0:t.isMobXFlow)}function Kt(t,n){if(void 0!==n){if(!1===an(t))return!1;if(!t[Kn].nt.has(n))return!1;var i=dn(t,n);return ci(i)}return ci(t)}function Lt(t,n){return!!t&&(void 0!==n?!!an(t)&&t[Kn].nt.has(n):an(t)||!!t[Kn]||In(t)||wi(t)||ci(t))}function It(t){return Lt(t)}function Pt(n){return an(n)?n[Kn].it():Hi(n)||Ji(n)?Array.from(n.keys()):un(n)?n.map((function(t,n){return n})):void t(5)}function Dt(n,i){return an(n)?n[Kn].rt(i):Hi(n)||Ji(n)?n.has(i):un(n)?i>=0&&i<n.length:void t(10)}function Bt(n){if(an(n))return n[Kn].et();t(38)}function qt(t,n,i){return t.set(n,i),i}function Gt(){t("trace() is not available in production builds");for(var n=!1,i=arguments.length,r=new Array(i),e=0;e<i;e++)r[e]=arguments[e];"boolean"==typeof r[r.length-1]&&(n=r.pop());var o=Xt(r);if(!o)return t("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");o.ot===fi.NONE&&console.log("[mobx.trace] '"+o.tt+"' tracing enabled"),o.ot=n?fi.BREAK:fi.LOG}function Xt(t){switch(t.length){case 0:return pi.trackingDerivation;case 1:return dn(t[0]);case 2:return dn(t[0],t[1])}}function Wt(t,n){void 0===n&&(n=void 0),dt();try{return t.apply(n)}finally{bt()}}function Ht(t,n,i){var r;if("number"==typeof i.timeout){var e=new Error("WHEN_TIMEOUT");r=setTimeout((function(){if(!u[Kn].J){if(u(),!i.onError)throw e;i.onError(e)}}),i.timeout)}i.name="When";var o=z("When-effect",n),u=gt((function(n){Q(!1,t)&&(n.dispose(),r&&clearTimeout(r),o())}),i);return u}function Ut(t,n){var i,r=new Promise((function(r,e){var o=Ht(t,r,m({},n,{onError:e}));i=function(){o(),e("WHEN_CANCELLED")}}));return r.cancel=i,r}function Ft(t){return t[Kn]}function zt(t){return void 0!==t.ut&&t.ut.length>0}function $t(t,n){var i=t.ut||(t.ut=[]);return i.push(n),r((function(){var t=i.indexOf(n);-1!==t&&i.splice(t,1)}))}function Jt(n,i){var r=ut();try{for(var e=[].concat(n.ut||[]),o=0,u=e.length;o<u&&((i=e[o](i))&&!i.type&&t(14),i);o++);return i}finally{st(r)}}function Yt(t){return void 0!==t.st&&t.st.length>0}function Qt(t,n){var i=t.st||(t.st=[]);return i.push(n),r((function(){var t=i.indexOf(n);-1!==t&&i.splice(t,1)}))}function Zt(t,n){var i=ut(),r=t.st;if(r){for(var e=0,o=(r=r.slice()).length;e<o;e++)r[e](n);st(i)}}function tn(t,n,r,e){void 0===r&&(r="ObservableArray"),void 0===e&&(e=!1),i();var o=new Ki(r,n,e,!1);c(o.nt,Kn,o);var u=new Proxy(o.nt,Ci);if(o.v=u,t&&t.length){var s=Z(!0);o.ft(0,0,t),tt(s)}return u}function nn(t,n){"function"==typeof Array.prototype[t]&&(Li[t]=n(t))}function rn(t){return function(){var n=this[Kn];n.at.reportObserved();var i=n.ct(n.nt);return i[t].apply(i,arguments)}}function en(t){return function(n,i){var r=this,e=this[Kn];return e.at.reportObserved(),e.ct(e.nt)[t]((function(t,e){return n.call(i,t,e,r)}))}}function on(t){return function(){var n=this,i=this[Kn];i.at.reportObserved();var r=i.ct(i.nt),e=arguments[0];return arguments[0]=function(t,i,r){return e(t,i,r,n)},r[t].apply(r,arguments)}}function un(t){return u(t)&&Di(t[Kn])}function sn(t,n){var i;if(b(t,Kn))return t;var r=null!=(i=null==n?void 0:n.name)?i:"ObservableObject",e=new Qi(t,new Map,String(r),function(t){var n;return t?null!=(n=t.defaultDecorator)?n:G(t):void 0}(n));return a(t,Kn,e),t}function fn(t){return Yi[t]||(Yi[t]={get:function(){return this[Kn].ht(t)},set:function(n){return this[Kn].vt(t,n)}})}function an(t){return!!u(t)&&Zi(t[Kn])}function cn(t,n,i){var r;null==(r=t.s[Cn])||delete r[i]}function hn(t){gn(ir.prototype,""+t,function(t){return{enumerable:!1,configurable:!0,get:function(){return this[Kn].lt(t)},set:function(n){this[Kn].dt(t,n)}}}(t))}function vn(t){if(t>tr){for(var n=tr;n<t+100;n++)hn(n);tr=t}}function ln(t,n,i){return new ir(t,n,i)}function dn(n,i){if("object"==typeof n&&null!==n){if(un(n))return void 0!==i&&t(23),n[Kn].at;if(Ji(n))return n[Kn];if(Hi(n)){if(void 0===i)return n.bt;var r=n.pt.get(i)||n.yt.get(i);return r||t(25,i,pn(n)),r}if(an(n)){if(!i)return t(26);var o=n[Kn].nt.get(i);return o||t(27,i,pn(n)),o}if(In(n)||ci(n)||wi(n))return n}else if(e(n)&&wi(n[Kn]))return n[Kn];t(28)}function bn(n,i){return n||t(29),void 0!==i?bn(dn(n,i)):In(n)||ci(n)||wi(n)||Hi(n)||Ji(n)?n:n[Kn]?n[Kn]:void t(24,n)}function pn(t,n){var i;if(void 0!==n)i=dn(t,n);else{if(At(t))return t.name;i=an(t)||Hi(t)||Ji(t)?bn(t):dn(t)}return i.tt}function yn(t,n,i){return void 0===i&&(i=-1),function t(n,i,r,o,u){if(n===i)return 0!==n||1/n==1/i;if(null==n||null==i)return!1;if(n!=n)return i!=i;var s=typeof n;if(!e(s)&&"object"!==s&&"object"!=typeof i)return!1;var f=rr.call(n);if(f!==rr.call(i))return!1;switch(f){case"[object RegExp]":case"[object String]":return""+n==""+i;case"[object Number]":return+n!=+n?+i!=+i:0==+n?1/+n==1/i:+n==+i;case"[object Date]":case"[object Boolean]":return+n==+i;case"[object Symbol]":return"undefined"!=typeof Symbol&&Symbol.valueOf.call(n)===Symbol.valueOf.call(i);case"[object Map]":case"[object Set]":r>=0&&r++}n=mn(n),i=mn(i);var a="[object Array]"===f;if(!a){if("object"!=typeof n||"object"!=typeof i)return!1;var c=n.constructor,h=i.constructor;if(c!==h&&!(e(c)&&c instanceof c&&e(h)&&h instanceof h)&&"constructor"in n&&"constructor"in i)return!1}if(0===r)return!1;r<0&&(r=-1),u=u||[];for(var v=(o=o||[]).length;v--;)if(o[v]===n)return u[v]===i;if(o.push(n),u.push(i),a){if((v=n.length)!==i.length)return!1;for(;v--;)if(!t(n[v],i[v],r-1,o,u))return!1}else{var l,d=Object.keys(n);if(v=d.length,Object.keys(i).length!==v)return!1;for(;v--;)if(!b(i,l=d[v])||!t(n[l],i[l],r-1,o,u))return!1}return o.pop(),u.pop(),!0}(t,n,i)}function mn(t){return un(t)?t.slice():v(t)||Hi(t)||l(t)||Ji(t)?Array.from(t.entries()):t}function wn(t){return t[Symbol.iterator]=jn,t}function jn(){return this}Object.defineProperty(exports,"__esModule",{value:!0});var xn={},On=Object.assign,An=Object.getOwnPropertyDescriptor,gn=Object.defineProperty,_n=Object.prototype,Sn=[];Object.freeze(Sn);var Mn={};Object.freeze(Mn);var Vn="undefined"!=typeof Proxy,Nn=Object.toString(),Rn=function(){},kn=void 0!==Object.getOwnPropertySymbols,En="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:kn?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:Object.getOwnPropertyNames,Tn=Object.getOwnPropertyDescriptors||function(t){var n={};return En(t).forEach((function(i){n[i]=An(t,i)})),n},Cn=Symbol("mobx-stored-annotations"),Kn=Symbol("mobx administration"),Ln=function(){function t(t){void 0===t&&(t="Atom"),this.tt=void 0,this.W=!1,this.H=!1,this.X=new Set,this.B=0,this.F=0,this.G=si.T,this.onBOL=void 0,this.onBUOL=void 0,this.tt=t}var n=t.prototype;return n.onBO=function(){this.onBOL&&this.onBOL.forEach((function(t){return t()}))},n.onBUO=function(){this.onBUOL&&this.onBUOL.forEach((function(t){return t()}))},n.reportObserved=function(){return pt(this)},n.reportChanged=function(){dt(),yt(this),bt()},n.toString=function(){return this.tt},t}(),In=h("Atom",Ln),Pn={identity:function(t,n){return t===n},structural:function(t,n){return yn(t,n)},default:function(t,n){return Object.is?Object.is(t,n):t===n?0!==t||1/t==1/n:t!=t&&n!=n},shallow:function(t,n){return yn(t,n,1)}},Dn=A({t:"override",o:function(){return 0},u:function(){t("'"+this.t+"' can only be used with 'makeObservable'")}}),Bn=G(),qn={deep:!0,name:void 0,defaultDecorator:void 0,proxy:!0};Object.freeze(qn);var Gn=D("observable"),Xn=D("observable.ref",{enhancer:M}),Wn=D("observable.shallow",{enhancer:function(t,n,i){return null==t||an(t)||un(t)||Hi(t)||Ji(t)?t:Array.isArray(t)?$n.array(t,{name:i,deep:!1}):s(t)?$n.object(t,void 0,{name:i,deep:!1}):v(t)?$n.map(t,{name:i,deep:!1}):l(t)?$n.set(t,{name:i,deep:!1}):void 0}}),Hn=D("observable.struct",{enhancer:function(t,n){return yn(t,n)?n:t}}),Un=A(Gn);Object.assign(F,Un);var Fn,zn,$n=On(F,{box:function(t,n){var i=H(n);return new oi(t,U(i),i.name,!0,i.equals)},array:function(t,n){var i=H(n);return(!1===pi.useProxies||!1===i.proxy?ln:tn)(t,U(i),i.name)},map:function(t,n){var i=H(n);return new Wi(t,U(i),i.name)},set:function(t,n){var i=H(n);return new $i(t,U(i),i.name)},object:function(t,n,r){return Nt(!1===pi.useProxies||!1===(null==r?void 0:r.proxy)?sn({},r):function(t,n){var r,e;return i(),null!=(e=(r=(t=sn(t,n))[Kn]).v)?e:r.v=new Proxy(t,ki)}({},r),t,n)},ref:A(Xn),shallow:A(Wn),deep:Un,struct:A(Hn)}),Jn=L("computed"),Yn=L("computed.struct",{equals:Pn.structural}),Qn=function(t,n){if(o(n))return g(t,n,Jn);if(s(t))return A(L("computed",t));var i=s(n)?n:{};return i.get=t,i.name||(i.name=t.name||""),new ai(i)};Object.assign(Qn,Jn),Qn.struct=A(Yn);var Zn,ti=0,ni=1,ii=null!=(Fn=null==(zn=An((function(){}),"name"))?void 0:zn.configurable)&&Fn,ri={value:"action",configurable:!0,writable:!1,enumerable:!1};Zn=Symbol.toPrimitive;var ei,oi=function(t){function n(n,i,r,e,o){var u;return void 0===r&&(r="ObservableValue"),void 0===o&&(o=Pn.default),(u=t.call(this,r)||this).enhancer=void 0,u.tt=void 0,u.equals=void 0,u.wt=!1,u.ut=void 0,u.st=void 0,u.jt=void 0,u.dehancer=void 0,u.enhancer=i,u.tt=r,u.equals=o,u.jt=i(n,void 0,r),u}w(n,t);var i=n.prototype;return i.dehanceValue=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.set=function(t){(t=this.xt(t))!==pi.UNCHANGED&&this.Ot(t)},i.xt=function(t){if(zt(this)){var n=Jt(this,{object:this,type:Ti,newValue:t});if(!n)return pi.UNCHANGED;t=n.newValue}return t=this.enhancer(t,this.jt,this.tt),this.equals(this.jt,t)?pi.UNCHANGED:t},i.Ot=function(t){var n=this.jt;this.jt=t,this.reportChanged(),Yt(this)&&Zt(this,{type:Ti,object:this,newValue:t,oldValue:n})},i.get=function(){return this.reportObserved(),this.dehanceValue(this.jt)},i.At=function(t){return $t(this,t)},i.gt=function(t,n){return n&&t({observableKind:"value",debugObjectName:this.tt,object:this,type:Ti,newValue:this.jt,oldValue:void 0}),Qt(this,t)},i.raw=function(){return this.jt},i.toJSON=function(){return this.get()},i.toString=function(){return this.tt+"["+this.jt+"]"},i.valueOf=function(){return d(this.get())},i[Zn]=function(){return this.valueOf()},n}(Ln),ui=h("ObservableValue",oi);ei=Symbol.toPrimitive;var si,fi,ai=function(){function n(n){this.R=si.T,this.L=[],this.I=null,this.H=!1,this.W=!1,this.X=new Set,this.B=0,this.D=0,this.F=0,this.G=si.k,this.P=0,this.jt=new hi(null),this.tt=void 0,this._t=void 0,this.St=!1,this.Mt=!1,this.derivation=void 0,this.Vt=void 0,this.ot=fi.NONE,this.Nt=void 0,this.Rt=void 0,this.kt=void 0,this.Et=void 0,this.onBOL=void 0,this.onBUOL=void 0,n.get||t(31),this.derivation=n.get,this.tt=n.name||"ComputedValue",n.set&&(this.Vt=z("ComputedValue-setter",n.set)),this.Rt=n.equals||(n.compareStructural||n.struct?Pn.structural:Pn.default),this.Nt=n.context,this.kt=!!n.requiresReaction,this.Et=!!n.keepAlive}var i=n.prototype;return i.q=function(){!function(t){t.G===si.k&&(t.G=si.K,t.X.forEach((function(t){t.R===si.k&&(t.R=si.K,t.q())})))}(this)},i.onBO=function(){this.onBOL&&this.onBOL.forEach((function(t){return t()}))},i.onBUO=function(){this.onBUOL&&this.onBUOL.forEach((function(t){return t()}))},i.get=function(){if(this.St&&t(32,this.tt,this.derivation),0!==pi.inBatch||0!==this.X.size||this.Et){if(pt(this),it(this)){var n=pi.trackingContext;this.Et&&!n&&(pi.trackingContext=this),this.trackAndCompute()&&function(t){t.G!==si.C&&(t.G=si.C,t.X.forEach((function(n){n.R===si.K?n.R=si.C:n.R===si.k&&(t.G=si.k)})))}(this),pi.trackingContext=n}}else it(this)&&(this.Tt(),dt(),this.jt=this.Ct(!1),bt());var i=this.jt;if(nt(i))throw i.cause;return i},i.set=function(n){if(this.Vt){this.Mt&&t(33,this.tt),this.Mt=!0;try{this.Vt.call(this.Nt,n)}finally{this.Mt=!1}}else t(34,this.tt)},i.trackAndCompute=function(){var t=this.jt,n=this.R===si.T,i=this.Ct(!0),r=n||nt(t)||nt(i)||!this.Rt(t,i);return r&&(this.jt=i),r},i.Ct=function(t){this.St=!0;var n,i=Z(!1);if(t)n=rt(this,this.derivation,this.Nt);else if(!0===pi.disableErrorBoundaries)n=this.derivation.call(this.Nt);else try{n=this.derivation.call(this.Nt)}catch(t){n=new hi(t)}return tt(i),this.St=!1,n},i.U=function(){this.Et||(et(this),this.jt=void 0)},i.gt=function(t,n){var i=this,r=!0,e=void 0;return gt((function(){var o=i.get();if(!r||n){var u=ut();t({observableKind:"computed",debugObjectName:i.tt,type:Ti,object:i,newValue:o,oldValue:e}),st(u)}r=!1,e=o}))},i.Tt=function(){},i.toString=function(){return this.tt+"["+this.derivation.toString()+"]"},i.valueOf=function(){return d(this.get())},i[ei]=function(){return this.valueOf()},n}(),ci=h("ComputedValue",ai);!function(t){t[t.T=-1]="NOT_TRACKING_",t[t.k=0]="UP_TO_DATE_",t[t.K=1]="POSSIBLY_STALE_",t[t.C=2]="STALE_"}(si||(si={})),function(t){t[t.NONE=0]="NONE",t[t.LOG=1]="LOG",t[t.BREAK=2]="BREAK"}(fi||(fi={}));var hi=function(t){this.cause=void 0,this.cause=t},vi=["mobxGuid","spyListeners","enforceActions","computedRequiresReaction","reactionRequiresObservable","observableRequiresReaction","allowStateReads","disableErrorBoundaries","runId","UNCHANGED","useProxies"],li=function(){this.version=6,this.UNCHANGED={},this.trackingDerivation=null,this.trackingContext=null,this.runId=0,this.mobxGuid=0,this.inBatch=0,this.pendingUnobservations=[],this.pendingReactions=[],this.isRunningReactions=!1,this.allowStateChanges=!1,this.allowStateReads=!0,this.enforceActions=!0,this.spyListeners=[],this.globalReactionErrorHandlers=[],this.computedRequiresReaction=!1,this.reactionRequiresObservable=!1,this.observableRequiresReaction=!1,this.disableErrorBoundaries=!1,this.suppressReactionErrors=!1,this.useProxies=!0,this.verifyProxies=!1,this.safeDescriptors=!0},di=!0,bi=!1,pi=function(){var i=n();return i.__mobxInstanceCount>0&&!i.__mobxGlobals&&(di=!1),i.__mobxGlobals&&i.__mobxGlobals.version!==(new li).version&&(di=!1),di?i.__mobxGlobals?(i.__mobxInstanceCount+=1,i.__mobxGlobals.UNCHANGED||(i.__mobxGlobals.UNCHANGED={}),i.__mobxGlobals):(i.__mobxInstanceCount=1,i.__mobxGlobals=new li):(setTimeout((function(){bi||t(35)}),1),new li)}(),yi=function(){function t(t,n,i,r){void 0===t&&(t="Reaction"),void 0===r&&(r=!1),this.tt=void 0,this.Kt=void 0,this.Lt=void 0,this.It=void 0,this.L=[],this.I=[],this.R=si.T,this.B=0,this.D=0,this.P=0,this.J=!1,this.Pt=!1,this.Dt=!1,this.Bt=!1,this.ot=fi.NONE,this.tt=t,this.Kt=n,this.Lt=i,this.It=r}var n=t.prototype;return n.q=function(){this.Y()},n.Y=function(){this.Pt||(this.Pt=!0,pi.pendingReactions.push(this),mt())},n.isScheduled=function(){return this.Pt},n.$=function(){if(!this.J){dt(),this.Pt=!1;var t=pi.trackingContext;if(pi.trackingContext=this,it(this)){this.Dt=!0;try{this.Kt()}catch(t){this.qt(t)}}pi.trackingContext=t,bt()}},n.track=function(t){if(!this.J){dt(),this.Bt=!0;var n=pi.trackingContext;pi.trackingContext=this;var i=rt(this,t,void 0);pi.trackingContext=n,this.Bt=!1,this.Dt=!1,this.J&&et(this),nt(i)&&this.qt(i.cause),bt()}},n.qt=function(t){var n=this;if(this.Lt)this.Lt(t,this);else{if(pi.disableErrorBoundaries)throw t;pi.suppressReactionErrors||console.error("[mobx] uncaught error in '"+this+"'",t),pi.globalReactionErrorHandlers.forEach((function(i){return i(t,n)}))}},n.dispose=function(){this.J||(this.J=!0,this.Bt||(dt(),et(this),bt()))},n.Z=function(){var t=this.dispose.bind(this);return t[Kn]=this,t},n.toString=function(){return"Reaction["+this.tt+"]"},n.trace=function(t){void 0===t&&(t=!1),Gt(this,t)},t}(),mi=function(t){return t()},wi=h("Reaction",yi),ji=V("action"),xi=V("action.bound",{bound:!0}),Oi=V("autoAction",{autoAction:!0}),Ai=V("autoAction.bound",{autoAction:!0,bound:!0}),gi=xt(!1);Object.assign(gi,ji);var _i=xt(!0);Object.assign(_i,Oi),gi.bound=A(xi),_i.bound=A(Ai);var Si=function(t){return t()},Mi=0;Et.prototype=Object.create(Error.prototype);var Vi=E("flow"),Ni=E("flow.bound",{bound:!0}),Ri=Object.assign((function(t,n){if(o(n))return g(t,n,Vi);var i=t,r=i.name||"<unnamed flow>",u=function(){var t,n=this,o=arguments,u=++Mi,s=gi(r+" - runid: "+u+" - init",i).apply(n,o),f=void 0,a=new Promise((function(n,i){function o(t){var n;f=void 0;try{n=gi(r+" - runid: "+u+" - yield "+h++,s.next).call(s,t)}catch(t){return i(t)}c(n)}function a(t){var n;f=void 0;try{n=gi(r+" - runid: "+u+" - yield "+h++,s.throw).call(s,t)}catch(t){return i(t)}c(n)}function c(t){if(!e(null==t?void 0:t.then))return t.done?n(t.value):(f=Promise.resolve(t.value)).then(o,a);t.then(c,i)}var h=0;t=i,o(void 0)}));return a.cancel=gi(r+" - runid: "+u+" - cancel",(function(){try{f&&Tt(f);var n=s.return(void 0),i=Promise.resolve(n.value);i.then(Rn,Rn),Tt(i),t(new Et)}catch(n){t(n)}})),a};return u.isMobXFlow=!0,u}),Vi);Ri.bound=A(Ni);var ki={has:function(t,n){return Ft(t).rt(n)},get:function(t,n){return Ft(t).lt(n)},set:function(t,n,i){var r;return!!o(n)&&(null==(r=Ft(t).dt(n,i,!0))||r)},deleteProperty:function(t,n){var i;return!!o(n)&&(null==(i=Ft(t).Gt(n,!0))||i)},defineProperty:function(t,n,i){var r;return null==(r=Ft(t).h(n,i))||r},ownKeys:function(t){return Ft(t).et()},preventExtensions:function(){t(13)}},Ei=Symbol("mobx-keys"),Ti="update",Ci={get:function(t,n){var i=t[Kn];return n===Kn?i:"length"===n?i.Xt():"string"!=typeof n||isNaN(n)?b(Li,n)?Li[n]:t[n]:i.lt(parseInt(n))},set:function(t,n,i){var r=t[Kn];return"length"===n&&r.Wt(i),"symbol"==typeof n||isNaN(n)?t[n]=i:r.dt(parseInt(n),i),!0},preventExtensions:function(){t(15)}},Ki=function(){function n(t,n,i,r){void 0===t&&(t="ObservableArray"),this.Ht=void 0,this.Ut=void 0,this.at=void 0,this.nt=[],this.ut=void 0,this.st=void 0,this.Ft=void 0,this.dehancer=void 0,this.v=void 0,this.zt=0,this.Ht=i,this.Ut=r,this.at=new Ln(t),this.Ft=function(t,i){return n(t,i,"ObservableArray[..]")}}var i=n.prototype;return i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.ct=function(t){return void 0!==this.dehancer&&t.length>0?t.map(this.dehancer):t},i.At=function(t){return $t(this,t)},i.gt=function(t,n){return void 0===n&&(n=!1),n&&t({observableKind:"array",object:this.v,debugObjectName:this.at.tt,type:"splice",index:0,added:this.nt.slice(),addedCount:this.nt.length,removed:[],removedCount:0}),Qt(this,t)},i.Xt=function(){return this.at.reportObserved(),this.nt.length},i.Wt=function(n){("number"!=typeof n||n<0)&&t("Out of range: "+n);var i=this.nt.length;if(n!==i)if(n>i){for(var r=new Array(n-i),e=0;e<n-i;e++)r[e]=void 0;this.ft(i,0,r)}else this.ft(n,i-n)},i.Jt=function(n,i){n!==this.zt&&t(16),this.zt+=i,this.Ut&&i>0&&vn(n+i+1)},i.ft=function(t,n,i){var r=this,e=this.nt.length;if(void 0===t?t=0:t>e?t=e:t<0&&(t=Math.max(0,e+t)),n=1===arguments.length?e-t:null==n?0:Math.max(0,Math.min(n,e-t)),void 0===i&&(i=Sn),zt(this)){var o=Jt(this,{object:this.v,type:"splice",index:t,removedCount:n,added:i});if(!o)return Sn;n=o.removedCount,i=o.added}if(i=0===i.length?i:i.map((function(t){return r.Ft(t,void 0)})),this.Ut){var u=i.length-n;this.Jt(e,u)}var s=this.Yt(t,n,i);return 0===n&&0===i.length||this.Qt(t,i,s),this.ct(s)},i.Yt=function(t,n,i){var r;if(i.length<1e4)return(r=this.nt).splice.apply(r,[t,n].concat(i));var e=this.nt.slice(t,t+n),o=this.nt.slice(t+n);this.nt.length=t+i.length-n;for(var u=0;u<i.length;u++)this.nt[t+u]=i[u];for(var s=0;s<o.length;s++)this.nt[t+i.length+s]=o[s];return e},i.Zt=function(t,n,i){var r=!this.Ht&&!1,e=Yt(this),o=e||r?{observableKind:"array",object:this.v,type:Ti,debugObjectName:this.at.tt,index:t,newValue:n,oldValue:i}:null;this.at.reportChanged(),e&&Zt(this,o)},i.Qt=function(t,n,i){var r=!this.Ht&&!1,e=Yt(this),o=e||r?{observableKind:"array",object:this.v,debugObjectName:this.at.tt,type:"splice",index:t,removed:i,added:n,removedCount:i.length,addedCount:n.length}:null;this.at.reportChanged(),e&&Zt(this,o)},i.lt=function(t){if(t<this.nt.length)return this.at.reportObserved(),this.$t(this.nt[t]);console.warn("[mobx.array] Attempt to read an array index ("+t+") that is out of bounds ("+this.nt.length+"). Please check length first. Out of bound indices will not be tracked by MobX")},i.dt=function(n,i){var r=this.nt;if(n<r.length){var e=r[n];if(zt(this)){var o=Jt(this,{type:Ti,object:this.v,index:n,newValue:i});if(!o)return;i=o.newValue}(i=this.Ft(i,e))!==e&&(r[n]=i,this.Zt(n,i,e))}else n===r.length?this.ft(n,0,[i]):t(17,n,r.length)},n}(),Li={clear:function(){return this.splice(0)},replace:function(t){var n=this[Kn];return n.ft(0,n.nt.length,t)},toJSON:function(){return this.slice()},splice:function(t,n){for(var i=arguments.length,r=new Array(i>2?i-2:0),e=2;e<i;e++)r[e-2]=arguments[e];var o=this[Kn];switch(arguments.length){case 0:return[];case 1:return o.ft(t);case 2:return o.ft(t,n)}return o.ft(t,n,r)},spliceWithArray:function(t,n,i){return this[Kn].ft(t,n,i)},push:function(){for(var t=this[Kn],n=arguments.length,i=new Array(n),r=0;r<n;r++)i[r]=arguments[r];return t.ft(t.nt.length,0,i),t.nt.length},pop:function(){return this.splice(Math.max(this[Kn].nt.length-1,0),1)[0]},shift:function(){return this.splice(0,1)[0]},unshift:function(){for(var t=this[Kn],n=arguments.length,i=new Array(n),r=0;r<n;r++)i[r]=arguments[r];return t.ft(0,0,i),t.nt.length},reverse:function(){return pi.trackingDerivation&&t(37,"reverse"),this.replace(this.slice().reverse()),this},sort:function(){pi.trackingDerivation&&t(37,"sort");var n=this.slice();return n.sort.apply(n,arguments),this.replace(n),this},remove:function(t){var n=this[Kn],i=n.ct(n.nt).indexOf(t);return i>-1&&(this.splice(i,1),!0)}};nn("concat",rn),nn("flat",rn),nn("includes",rn),nn("indexOf",rn),nn("join",rn),nn("lastIndexOf",rn),nn("slice",rn),nn("toString",rn),nn("toLocaleString",rn),nn("every",en),nn("filter",en),nn("find",en),nn("findIndex",en),nn("flatMap",en),nn("forEach",en),nn("map",en),nn("some",en),nn("reduce",on),nn("reduceRight",on);var Ii,Pi,Di=h("ObservableArrayAdministration",Ki),Bi={},qi="add";Ii=Symbol.iterator,Pi=Symbol.toStringTag;var Gi,Xi,Wi=function(){function n(n,i,r){void 0===i&&(i=S),void 0===r&&(r="ObservableMap"),this.Ft=void 0,this.tt=void 0,this[Kn]=Bi,this.pt=void 0,this.yt=void 0,this.bt=void 0,this.ut=void 0,this.st=void 0,this.dehancer=void 0,this.Ft=i,this.tt=r,e(Map)||t(18),this.bt=_("ObservableMap.keys()"),this.pt=new Map,this.yt=new Map,this.merge(n)}var i=n.prototype;return i.rt=function(t){return this.pt.has(t)},i.has=function(t){var n=this;if(!pi.trackingDerivation)return this.rt(t);var i=this.yt.get(t);if(!i){var r=i=new oi(this.rt(t),M,"ObservableMap.key?",!1);this.yt.set(t,r),Mt(r,(function(){return n.yt.delete(t)}))}return i.get()},i.set=function(t,n){var i=this.rt(t);if(zt(this)){var r=Jt(this,{type:i?Ti:qi,object:this,newValue:n,name:t});if(!r)return this;n=r.newValue}return i?this.tn(t,n):this.nn(t,n),this},i.delete=function(t){var n=this;if(zt(this)&&!Jt(this,{type:"delete",object:this,name:t}))return!1;if(this.rt(t)){var i=Yt(this),r=i?{observableKind:"map",debugObjectName:this.tt,type:"delete",object:this,oldValue:this.pt.get(t).jt,name:t}:null;return Wt((function(){n.bt.reportChanged(),n.in(t,!1),n.pt.get(t).Ot(void 0),n.pt.delete(t)})),i&&Zt(this,r),!0}return!1},i.in=function(t,n){var i=this.yt.get(t);i&&i.Ot(n)},i.tn=function(t,n){var i=this.pt.get(t);if((n=i.xt(n))!==pi.UNCHANGED){var r=Yt(this),e=r?{observableKind:"map",debugObjectName:this.tt,type:Ti,object:this,oldValue:i.jt,name:t,newValue:n}:null;i.Ot(n),r&&Zt(this,e)}},i.nn=function(t,n){var i=this;Wt((function(){var r=new oi(n,i.Ft,"ObservableMap.key",!1);i.pt.set(t,r),n=r.jt,i.in(t,!0),i.bt.reportChanged()}));var r=Yt(this);r&&Zt(this,r?{observableKind:"map",debugObjectName:this.tt,type:qi,object:this,name:t,newValue:n}:null)},i.get=function(t){return this.has(t)?this.$t(this.pt.get(t).get()):this.$t(void 0)},i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.keys=function(){return this.bt.reportObserved(),this.pt.keys()},i.values=function(){var t=this,n=this.keys();return wn({next:function(){var i=n.next(),r=i.done;return{done:r,value:r?void 0:t.get(i.value)}}})},i.entries=function(){var t=this,n=this.keys();return wn({next:function(){var i=n.next(),r=i.done,e=i.value;return{done:r,value:r?void 0:[e,t.get(e)]}}})},i[Ii]=function(){return this.entries()},i.forEach=function(t,n){for(var i,r=O(this);!(i=r()).done;){var e=i.value;t.call(n,e[1],e[0],this)}},i.merge=function(n){var i=this;return Hi(n)&&(n=new Map(n)),Wt((function(){s(n)?function(t){var n=Object.keys(t);if(!kn)return n;var i=Object.getOwnPropertySymbols(t);return i.length?[].concat(n,i.filter((function(n){return _n.propertyIsEnumerable.call(t,n)}))):n}(n).forEach((function(t){return i.set(t,n[t])})):Array.isArray(n)?n.forEach((function(t){return i.set(t[0],t[1])})):v(n)?(n.constructor!==Map&&t(19,n),n.forEach((function(t,n){return i.set(n,t)}))):null!=n&&t(20,n)})),this},i.clear=function(){var t=this;Wt((function(){ot((function(){for(var n,i=O(t.keys());!(n=i()).done;)t.delete(n.value)}))}))},i.replace=function(n){var i=this;return Wt((function(){for(var r,e=function(n){if(v(n)||Hi(n))return n;if(Array.isArray(n))return new Map(n);if(s(n)){var i=new Map;for(var r in n)i.set(r,n[r]);return i}return t(21,n)}(n),o=new Map,u=!1,f=O(i.pt.keys());!(r=f()).done;){var a=r.value;if(!e.has(a))if(i.delete(a))u=!0;else{var c=i.pt.get(a);o.set(a,c)}}for(var h,l=O(e.entries());!(h=l()).done;){var d=h.value,b=d[0],p=d[1],y=i.pt.has(b);if(i.set(b,p),i.pt.has(b)){var m=i.pt.get(b);o.set(b,m),y||(u=!0)}}if(!u)if(i.pt.size!==o.size)i.bt.reportChanged();else for(var w=i.pt.keys(),j=o.keys(),x=w.next(),A=j.next();!x.done;){if(x.value!==A.value){i.bt.reportChanged();break}x=w.next(),A=j.next()}i.pt=o})),this},i.toString=function(){return"[object ObservableMap]"},i.toJSON=function(){return Array.from(this)},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},y(n,[{key:"size",get:function(){return this.bt.reportObserved(),this.pt.size}},{key:Pi,get:function(){return"Map"}}]),n}(),Hi=h("ObservableMap",Wi),Ui={};Gi=Symbol.iterator,Xi=Symbol.toStringTag;var Fi,zi,$i=function(){function n(n,i,r){void 0===i&&(i=S),void 0===r&&(r="ObservableSet"),this.tt=void 0,this[Kn]=Ui,this.pt=new Set,this.at=void 0,this.st=void 0,this.ut=void 0,this.dehancer=void 0,this.Ft=void 0,this.tt=r,e(Set)||t(22),this.at=_(this.tt),this.Ft=function(t,n){return i(t,n,r)},n&&this.replace(n)}var i=n.prototype;return i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.clear=function(){var t=this;Wt((function(){ot((function(){for(var n,i=O(t.pt.values());!(n=i()).done;)t.delete(n.value)}))}))},i.forEach=function(t,n){for(var i,r=O(this);!(i=r()).done;){var e=i.value;t.call(n,e,e,this)}},i.add=function(t){var n=this;if(zt(this)&&!Jt(this,{type:qi,object:this,newValue:t}))return this;if(!this.has(t)){Wt((function(){n.pt.add(n.Ft(t,void 0)),n.at.reportChanged()}));var i=Yt(this);i&&Zt(this,i?{observableKind:"set",debugObjectName:this.tt,type:qi,object:this,newValue:t}:null)}return this},i.delete=function(t){var n=this;if(zt(this)&&!Jt(this,{type:"delete",object:this,oldValue:t}))return!1;if(this.has(t)){var i=Yt(this),r=i?{observableKind:"set",debugObjectName:this.tt,type:"delete",object:this,oldValue:t}:null;return Wt((function(){n.at.reportChanged(),n.pt.delete(t)})),i&&Zt(this,r),!0}return!1},i.has=function(t){return this.at.reportObserved(),this.pt.has(this.$t(t))},i.entries=function(){var t=0,n=Array.from(this.keys()),i=Array.from(this.values());return wn({next:function(){var r=t;return t+=1,r<i.length?{value:[n[r],i[r]],done:!1}:{done:!0}}})},i.keys=function(){return this.values()},i.values=function(){this.at.reportObserved();var t=this,n=0,i=Array.from(this.pt.values());return wn({next:function(){return n<i.length?{value:t.$t(i[n++]),done:!1}:{done:!0}}})},i.replace=function(n){var i=this;return Ji(n)&&(n=new Set(n)),Wt((function(){Array.isArray(n)||l(n)?(i.clear(),n.forEach((function(t){return i.add(t)}))):null!=n&&t("Cannot initialize set from "+n)})),this},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},i.toJSON=function(){return Array.from(this)},i.toString=function(){return"[object ObservableSet]"},i[Gi]=function(){return this.values()},y(n,[{key:"size",get:function(){return this.at.reportObserved(),this.pt.size}},{key:Xi,get:function(){return"Set"}}]),n}(),Ji=h("ObservableSet",$i),Yi=Object.create(null),Qi=function(){function n(t,n,i,r){void 0===n&&(n=new Map),void 0===r&&(r=Bn),this.s=void 0,this.nt=void 0,this.tt=void 0,this.rn=void 0,this.bt=void 0,this.st=void 0,this.ut=void 0,this.v=void 0,this.l=void 0,this.en=void 0,this.on=void 0,this.s=t,this.nt=n,this.tt=i,this.rn=r,this.bt=new Ln("ObservableObject.keys"),this.l=s(this.s)}var i=n.prototype;return i.ht=function(t){return this.nt.get(t).get()},i.vt=function(t,n){var i=this.nt.get(t);if(i instanceof ai)return i.set(n),!0;if(zt(this)){var r=Jt(this,{type:Ti,object:this.v||this.s,name:t,newValue:n});if(!r)return null;n=r.newValue}if((n=i.xt(n))!==pi.UNCHANGED){var e=Yt(this),o=e?{type:Ti,observableKind:"object",debugObjectName:this.tt,object:this.v||this.s,oldValue:i.jt,name:t,newValue:n}:null;i.Ot(n),e&&Zt(this,o)}return!0},i.lt=function(t){return pi.trackingDerivation&&!b(this.s,t)&&this.rt(t),this.s[t]},i.dt=function(t,n,i){return void 0===i&&(i=!1),b(this.s,t)?this.nt.has(t)?this.vt(t,n):i?Reflect.set(this.s,t,n):(this.s[t]=n,!0):this.u(t,{value:n,enumerable:!0,writable:!0,configurable:!0},this.rn,i)},i.rt=function(t){if(!pi.trackingDerivation)return t in this.s;this.on||(this.on=new Map);var n=this.on.get(t);return n||(n=new oi(t in this.s,M,"ObservableObject.key?",!1),this.on.set(t,n)),n.get()},i.o=function(n,i){if(!0===i&&(i=this.rn),!1!==i){if(!(n in this.s)){var r;if(null==(r=this.s[Cn])?void 0:r[n])return;t(1,i.t,this.tt+"."+n.toString())}for(var e=this.s;e&&e!==_n;){var o=An(e,n);if(o){var u=i.o(this,n,o,e);if(0===u)return;if(1===u)break}e=Object.getPrototypeOf(e)}cn(this,0,n)}},i.u=function(t,n,i,r){if(void 0===r&&(r=!1),!0===i&&(i=this.rn),!1===i)return this.h(t,n,r);var e=i.u(this,t,n,r);return e&&cn(this,0,t),e},i.h=function(t,n,i){void 0===i&&(i=!1);try{dt();var r=this.Gt(t);if(!r)return r;if(zt(this)){var e=Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:n.value});if(!e)return null;var o=e.newValue;n.value!==o&&(n=m({},n,{value:o}))}if(i){if(!Reflect.defineProperty(this.s,t,n))return!1}else gn(this.s,t,n);this.un(t,n.value)}finally{bt()}return!0},i.m=function(t,n,i,r){void 0===r&&(r=!1);try{dt();var e=this.Gt(t);if(!e)return e;if(zt(this)){var o=Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:n});if(!o)return null;n=o.newValue}var u=fn(t),s={configurable:!pi.safeDescriptors||this.l,enumerable:!0,get:u.get,set:u.set};if(r){if(!Reflect.defineProperty(this.s,t,s))return!1}else gn(this.s,t,s);var f=new oi(n,i,"ObservableObject.key",!1);this.nt.set(t,f),this.un(t,f.jt)}finally{bt()}return!0},i.p=function(t,n,i){void 0===i&&(i=!1);try{dt();var r=this.Gt(t);if(!r)return r;if(zt(this)&&!Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:void 0}))return null;n.name||(n.name="ObservableObject.key"),n.context=this.v||this.s;var e=fn(t),o={configurable:!pi.safeDescriptors||this.l,enumerable:!1,get:e.get,set:e.set};if(i){if(!Reflect.defineProperty(this.s,t,o))return!1}else gn(this.s,t,o);this.nt.set(t,new ai(n)),this.un(t,void 0)}finally{bt()}return!0},i.Gt=function(t,n){if(void 0===n&&(n=!1),!b(this.s,t))return!0;if(zt(this)&&!Jt(this,{object:this.v||this.s,name:t,type:"remove"}))return null;try{var i,r;dt();var e,o=Yt(this),u=this.nt.get(t),s=void 0;if(!u&&o&&(s=null==(e=An(this.s,t))?void 0:e.value),n){if(!Reflect.deleteProperty(this.s,t))return!1}else delete this.s[t];u&&(this.nt.delete(t),u instanceof oi&&(s=u.jt),yt(u)),this.bt.reportChanged(),null==(i=this.on)||null==(r=i.get(t))||r.set(t in this.s),o&&o&&Zt(this,{type:"remove",observableKind:"object",object:this.v||this.s,debugObjectName:this.tt,oldValue:s,name:t})}finally{bt()}return!0},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},i.un=function(t,n){var i,r,e=Yt(this);e&&e&&Zt(this,e?{type:qi,observableKind:"object",debugObjectName:this.tt,object:this.v||this.s,name:t,newValue:n}:null),null==(i=this.on)||null==(r=i.get(t))||r.set(!0),this.bt.reportChanged()},i.et=function(){return this.bt.reportObserved(),En(this.s)},i.it=function(){return this.bt.reportObserved(),Object.keys(this.s)},n}(),Zi=h("ObservableObjectAdministration",Qi),tr=0,nr=function(){};Fi=nr,zi=Array.prototype,Object.setPrototypeOf?Object.setPrototypeOf(Fi.prototype,zi):void 0!==Fi.prototype.__proto__?Fi.prototype.__proto__=zi:Fi.prototype=zi;var ir=function(t){function n(n,i,r,e){var o;void 0===r&&(r="ObservableArray"),void 0===e&&(e=!1),o=t.call(this)||this;var u=new Ki(r,i,e,!0);if(u.v=j(o),c(j(o),Kn,u),n&&n.length){var s=Z(!0);o.spliceWithArray(0,0,n),tt(s)}return o}w(n,t);var i=n.prototype;return i.concat=function(){this[Kn].at.reportObserved();for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return Array.prototype.concat.apply(this.slice(),n.map((function(t){return un(t)?t.slice():t})))},i[Symbol.iterator]=function(){var t=this,n=0;return wn({next:function(){return n<t.length?{value:t[n++],done:!1}:{done:!0,value:void 0}}})},y(n,[{key:"length",get:function(){return this[Kn].Xt()},set:function(t){this[Kn].Wt(t)}},{key:Symbol.toStringTag,get:function(){return"Array"}}]),n}(nr);Object.entries(Li).forEach((function(t){var n=t[0];"concat"!==n&&a(ir.prototype,n,t[1])})),vn(1e3);var rr=_n.toString;["Symbol","Map","Set"].forEach((function(i){void 0===n()[i]&&t("MobX requires global '"+i+"' to be available or polyfilled")})),"object"==typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__&&__MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({spy:jt,extras:{getDebugName:pn},$mobx:Kn}),exports.$mobx=Kn,exports.FlowCancellationError=Et,exports.ObservableMap=Wi,exports.ObservableSet=$i,exports.Reaction=yi,exports._allowStateChanges=Q,exports._allowStateChangesInsideComputed=Ot,exports._allowStateReadsEnd=at,exports._allowStateReadsStart=ft,exports._autoAction=_i,exports._endAction=Y,exports._getAdministration=bn,exports._getGlobalState=function(){return pi},exports._interceptReads=function(t,n,i){var r;return Hi(t)||un(t)||ui(t)?r=bn(t):an(t)&&(r=bn(t,n)),r.dehancer="function"==typeof n?n:i,function(){r.dehancer=void 0}},exports._isComputingDerivation=function(){return null!==pi.trackingDerivation},exports._resetGlobalState=function(){var t=new li;for(var n in t)-1===vi.indexOf(n)&&(pi[n]=t[n]);pi.allowStateChanges=!pi.enforceActions},exports._startAction=J,exports.action=gi,exports.autorun=gt,exports.comparer=Pn,exports.computed=Qn,exports.configure=function(i){!0===i.isolateGlobalState&&function(){if((pi.pendingReactions.length||pi.inBatch||pi.isRunningReactions)&&t(36),bi=!0,di){var i=n();0==--i.__mobxInstanceCount&&(i.__mobxGlobals=void 0),pi=new li}}();var r,e,o=i.useProxies,u=i.enforceActions;if(void 0!==o&&(pi.useProxies="always"===o||"never"!==o&&"undefined"!=typeof Proxy),"ifavailable"===o&&(pi.verifyProxies=!0),void 0!==u){var s="always"===u?"always":"observed"===u;pi.enforceActions=s,pi.allowStateChanges=!0!==s&&"always"!==s}["computedRequiresReaction","reactionRequiresObservable","observableRequiresReaction","disableErrorBoundaries","safeDescriptors"].forEach((function(t){t in i&&(pi[t]=!!i[t])})),pi.allowStateReads=!pi.observableRequiresReaction,i.reactionScheduler&&(r=i.reactionScheduler,e=mi,mi=function(t){return r((function(){return e(t)}))})},exports.createAtom=_,exports.defineProperty=function(n,i,r){if(an(n))return n[Kn].h(i,r);t(39)},exports.entries=function(n){return an(n)?Pt(n).map((function(t){return[t,n[t]]})):Hi(n)?Pt(n).map((function(t){return[t,n.get(t)]})):Ji(n)?Array.from(n.entries()):un(n)?n.map((function(t,n){return[n,t]})):void t(7)},exports.extendObservable=Nt,exports.flow=Ri,exports.flowResult=function(t){return t},exports.get=function(n,i){if(Dt(n,i))return an(n)?n[Kn].lt(i):Hi(n)?n.get(i):un(n)?n[i]:void t(11)},exports.getAtom=dn,exports.getDebugName=pn,exports.getDependencyTree=function(t,n){return Rt(dn(t,n))},exports.getObserverTree=function(t,n){return kt(dn(t,n))},exports.has=Dt,exports.intercept=function(t,n,i){return e(i)?function(t,n,i){return bn(t,n).At(i)}(t,n,i):function(t,n){return bn(t).At(n)}(t,n)},exports.isAction=At,exports.isBoxedObservable=ui,exports.isComputed=function(t){return Kt(t)},exports.isComputedProp=function(t,n){return Kt(t,n)},exports.isFlow=Ct,exports.isFlowCancellationError=function(t){return t instanceof Et},exports.isObservable=It,exports.isObservableArray=un,exports.isObservableMap=Hi,exports.isObservableObject=an,exports.isObservableProp=function(t,n){return Lt(t,n)},exports.isObservableSet=Ji,exports.keys=Pt,exports.makeAutoObservable=function(t,n,i){if(s(t))return Nt(t,t,n,i);var r=sn(t,i)[Kn];if(!t[Ei]){var e=Object.getPrototypeOf(t),o=new Set([].concat(En(t),En(e)));o.delete("constructor"),o.delete(Kn),a(e,Ei,o)}dt();try{t[Ei].forEach((function(t){return r.o(t,!n||!(t in n)||n[t])}))}finally{bt()}return t},exports.makeObservable=function(t,n,i){var r=sn(t,i)[Kn];dt();try{null!=n||(n=function(t){return b(t,Cn)||a(t,Cn,m({},t[Cn])),t[Cn]}(t)),En(n).forEach((function(t){return r.o(t,n[t])}))}finally{bt()}return t},exports.observable=$n,exports.observe=function(t,n,i,r){return e(i)?function(t,n,i,r){return bn(t,n).gt(i,r)}(t,n,i,r):function(t,n,i){return bn(t).gt(n,i)}(t,n,i)},exports.onBecomeObserved=St,exports.onBecomeUnobserved=Mt,exports.onReactionError=function(t){return pi.globalReactionErrorHandlers.push(t),function(){var n=pi.globalReactionErrorHandlers.indexOf(t);n>=0&&pi.globalReactionErrorHandlers.splice(n,1)}},exports.override=Dn,exports.ownKeys=Bt,exports.reaction=function(t,n,i){function r(){if(l=!1,!p.J){var n=!1;p.track((function(){var i=Q(!1,(function(){return t(p)}));n=v||!b(s,i),d=s,s=i})),(v&&i.fireImmediately||!v&&n)&&a(s,d,p),v=!1}}var e;void 0===i&&(i=Mn);var o,u,s,f=null!=(e=i.name)?e:"Reaction",a=gi(f,i.onError?(o=i.onError,u=n,function(){try{return u.apply(this,arguments)}catch(t){o.call(this,t)}}):n),c=!i.scheduler&&!i.delay,h=_t(i),v=!0,l=!1,d=void 0,b=i.compareStructural?Pn.structural:i.equals||Pn.default,p=new yi(f,(function(){v||c?r():l||(l=!0,h(r))}),i.onError,i.requiresObservable);return p.Y(),p.Z()},exports.remove=function(n,i){an(n)?n[Kn].Gt(i):Hi(n)||Ji(n)?n.delete(i):un(n)?("number"!=typeof i&&(i=parseInt(i,10)),n.splice(i,1)):t(9)},exports.runInAction=Ot,exports.set=function n(i,r,e){if(2!==arguments.length||Ji(i))an(i)?i[Kn].dt(r,e):Hi(i)?i.set(r,e):Ji(i)?i.add(r):un(i)?("number"!=typeof r&&(r=parseInt(r,10)),r<0&&t("Invalid index: '"+r+"'"),dt(),r>=i.length&&(i.length=r+1),i[r]=e,bt()):t(8);else{dt();var o=r;try{for(var u in o)n(i,u,o[u])}finally{bt()}}},exports.spy=jt,exports.toJS=function(t){return function t(n,i){if(null==n||"object"!=typeof n||n instanceof Date||!It(n))return n;if(ui(n)||ci(n))return t(n.get(),i);if(i.has(n))return i.get(n);if(un(n)){var r=qt(i,n,new Array(n.length));return n.forEach((function(n,e){r[e]=t(n,i)})),r}if(Ji(n)){var e=qt(i,n,new Set);return n.forEach((function(n){e.add(t(n,i))})),e}if(Hi(n)){var o=qt(i,n,new Map);return n.forEach((function(n,r){o.set(r,t(n,i))})),o}var u=qt(i,n,{});return Bt(n).forEach((function(r){_n.propertyIsEnumerable.call(n,r)&&(u[r]=t(n[r],i))})),u}(t,new Map)},exports.trace=Gt,exports.transaction=Wt,exports.untracked=ot,exports.values=function(n){return an(n)?Pt(n).map((function(t){return n[t]})):Hi(n)?Pt(n).map((function(t){return n.get(t)})):Ji(n)?Array.from(n.values()):un(n)?n.slice():void t(6)},exports.when=function(t,n,i){return 1===arguments.length||n&&"object"==typeof n?Ut(t,n):Ht(t,n,i||{})};


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],26:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],27:[function(require,module,exports){
assert.notEqual = notEqual
assert.notOk = notOk
assert.equal = equal
assert.ok = assert

module.exports = assert

function equal (a, b, m) {
  assert(a == b, m) // eslint-disable-line eqeqeq
}

function notEqual (a, b, m) {
  assert(a != b, m) // eslint-disable-line eqeqeq
}

function notOk (t, m) {
  assert(!t, m)
}

function assert (t, m) {
  if (!t) throw new Error(m || 'AssertionError')
}

},{}],28:[function(require,module,exports){
var assert = require('assert')

var safeExternalLink = /(noopener|noreferrer) (noopener|noreferrer)/
var protocolLink = /^[\w-_]+:/

module.exports = href

function href (cb, root) {
  assert.notEqual(typeof window, 'undefined', 'nanohref: expected window to exist')

  root = root || window.document

  assert.equal(typeof cb, 'function', 'nanohref: cb should be type function')
  assert.equal(typeof root, 'object', 'nanohref: root should be type object')

  window.addEventListener('click', function (e) {
    if ((e.button && e.button !== 0) ||
      e.ctrlKey || e.metaKey || e.altKey || e.shiftKey ||
      e.defaultPrevented) return

    var anchor = (function traverse (node) {
      if (!node || node === root) return
      if (node.localName !== 'a' || node.href === undefined) {
        return traverse(node.parentNode)
      }
      return node
    })(e.target)

    if (!anchor) return

    if (window.location.protocol !== anchor.protocol ||
        window.location.hostname !== anchor.hostname ||
        window.location.port !== anchor.port ||
      anchor.hasAttribute('data-nanohref-ignore') ||
      anchor.hasAttribute('download') ||
      (anchor.getAttribute('target') === '_blank' &&
        safeExternalLink.test(anchor.getAttribute('rel'))) ||
      protocolLink.test(anchor.getAttribute('href'))) return

    e.preventDefault()
    cb(anchor)
  })
}

},{"assert":27}],29:[function(require,module,exports){
(function (global){(function (){
!function(){function t(){this.table=new Uint16Array(16),this.t=new Uint16Array(288)}function f(f,v){this.source=f,this.sourceIndex=0,this.tag=0,this.v=0,this.M=v,this.J=0,this.o=new t,this.u=new t}var v=new t,b=new t,M=new Uint8Array(30),J=new Uint16Array(30),r=new Uint8Array(30),e=new Uint16Array(30),a=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),n=new t,i=new Uint8Array(320);function o(t,f,v,b){var M,J;for(M=0;M<v;++M)t[M]=0;for(M=0;M<30-v;++M)t[M+v]=M/v|0;for(J=b,M=0;M<30;++M)f[M]=J,J+=1<<t[M]}var s=new Uint16Array(16);function u(t,f,v,b){var M,J;for(M=0;M<16;++M)t.table[M]=0;for(M=0;M<b;++M)t.table[f[v+M]]++;for(t.table[0]=0,J=0,M=0;M<16;++M)s[M]=J,J+=t.table[M];for(M=0;M<b;++M)f[v+M]&&(t.t[s[f[v+M]]++]=M)}function c(t){t.v--||(t.tag=t.source[t.sourceIndex++],t.v=7);var f=1&t.tag;return t.tag>>>=1,f}function h(t,f,v){if(!f)return v;for(;t.v<24;)t.tag|=t.source[t.sourceIndex++]<<t.v,t.v+=8;var b=t.tag&65535>>>16-f;return t.tag>>>=f,t.v-=f,b+v}function d(t,f){for(;t.v<24;)t.tag|=t.source[t.sourceIndex++]<<t.v,t.v+=8;var v=0,b=0,M=0,J=t.tag;do{b=2*b+(1&J),J>>>=1,++M,v+=f.table[M],b-=f.table[M]}while(b>=0);return t.tag=J,t.v-=M,f.t[v+b]}function w(t,f,v){var b,M,J,r,e,o;for(b=h(t,5,257),M=h(t,5,1),J=h(t,4,4),r=0;r<19;++r)i[r]=0;for(r=0;r<J;++r){var s=h(t,3,0);i[a[r]]=s}for(u(n,i,0,19),e=0;e<b+M;){var c=d(t,n);switch(c){case 16:var w=i[e-1];for(o=h(t,2,3);o;--o)i[e++]=w;break;case 17:for(o=h(t,3,3);o;--o)i[e++]=0;break;case 18:for(o=h(t,7,11);o;--o)i[e++]=0;break;default:i[e++]=c}}u(f,i,0,b),u(v,i,b,M)}function l(t,f,v){for(;;){var b,a,n,i,o=d(t,f);if(256===o)return 0;if(o<256)t.M[t.J++]=o;else for(b=h(t,M[o-=257],J[o]),a=d(t,v),i=n=t.J-h(t,r[a],e[a]);i<n+b;++i)t.M[t.J++]=t.M[i]}}function y(t){for(var f,v;t.v>8;)t.sourceIndex--,t.v-=8;if((f=256*(f=t.source[t.sourceIndex+1])+t.source[t.sourceIndex])!==(65535&~(256*t.source[t.sourceIndex+3]+t.source[t.sourceIndex+2])))return-3;for(t.sourceIndex+=4,v=f;v;--v)t.M[t.J++]=t.source[t.sourceIndex++];return t.v=0,0}!function(t,f){var v;for(v=0;v<7;++v)t.table[v]=0;for(t.table[7]=24,t.table[8]=152,t.table[9]=112,v=0;v<24;++v)t.t[v]=256+v;for(v=0;v<144;++v)t.t[24+v]=v;for(v=0;v<8;++v)t.t[168+v]=280+v;for(v=0;v<112;++v)t.t[176+v]=144+v;for(v=0;v<5;++v)f.table[v]=0;for(f.table[5]=32,v=0;v<32;++v)f.t[v]=v}(v,b),o(M,J,4,3),o(r,e,2,1),M[28]=0,J[28]=258;var p,Q,O=O;function g(){}O=module;for(var A=new Uint8Array(123),S=25;S>=0;--S)A[48+S]=52+S,A[65+S]=S,A[97+S]=26+S;A[43]=62,A[47]=63,O.wasm=function(t,M){var J,r,e=new f(t,new Uint8Array(116210));do{switch(J=c(e),h(e,2,0)){case 0:r=y(e);break;case 1:r=l(e,v,b);break;case 2:w(e,e.o,e.u),r=l(e,e.o,e.u);break;default:r=-3}if(0!==r)throw Error("Data error")}while(!J);return e.J<e.M.length?"function"==typeof e.M.slice?e.M.slice(0,e.J):e.M.subarray(0,e.J):e.M}((t=>{const f=new Uint8Array(72374);let v,b=!1,M=0;for(let J=0;J<72374;J++)v=t.charCodeAt(J),13!==v&&10!==v&&(61!==v||b?(b&&(b=!1,v-=64),f[M++]=v<42&&v>0?v+214:v-42):b=!0);return f.subarray(0,M)})("5GQ0]-\f-.N2L^\",DJow@1+8z\b?mu[?||<~t\\?&(\t$GVv!h'[Wss^~^H|{sr,AX!{|kz}5?\\~]o(, v:ydXoIWtat=@\t!]p'QsWp|^#la\b=}u N_re__)]\\{e=@^WMwPiSu \b&&^yYN\tt3u\tQ\\O\"^h)DsUQDmWNKzMGh=@bIAyvx)\f|iH~6|bz=@\vvR:Dk6S!\by+l\v=M'#&du\tA=@=J%'#\tGy9%\tGy$\"+Yao$3yvPey*=JSR1;su(u4d7=Mfq[}/w{C:Wpr0^?EWL4P/:K7oWg5+&l$\"-dW[(!:,\"1BA-D>v9?_X7sI?gT2H,,``iDw3]h.$\"ndGl*Xfz?-uUd^[>'A!-{U<\fD<7-Sl/Un,Im:0rd*\v6wo\b>l]!Ia/mygN=MT)7(\b\by=@n_k}w%\tBYgUJw9#`!`8_0j{'Q(aouz:B#Lr[a2Y\\uK[aP`qp$=@&uoK5hy})&pTt|xJ&@@BD>9QQ%Do%=}ipqWi=@vH'=@\v`UzE`?A7\v[7tcR6=@Zs5/)V0^jl[B~E7=@gK4!.x\fl8uX'Y2~%nx\\i>*Zmu+wt_\b'$*d/(|.1aByUk{_L7j!^'\v+B,LS@W1Z:iFX\"\faT)|\bxY=@\vv9Z:ECFZP:eg\byYTXHb/r(e\f(&h{%[Q$$H4=J+3=@Ufl.S.V7%-s;!MwO;99VQ}o0Qf'uH 7%ADq#L,dSt9dQ=Jo:a\\+:=@]]s7_O2.bD=@ka.kU_EU!jfB\\@H^`lwu{\"s1NvlR`B8o2GK?Wna0G9l?6~1k#Rj_\v\".*z@<}@/3{w^|iMi$}n'>y$MyK?($x\t\\rD~@VQg.g}p\bOn0F!S)])=J8)_(;x-Ng1OFi_eN<N_?S_y\bXhv-H(\"e!qi[\\cf*km&s sk*wZjCfhq=}qw3RE\fgQ~7Y1dW.hgI'IL'jv:i%6=}=J=@5m9 _7*xdeCD\tw!5l]u +]% -/z(wKTp\"9+Mpb3EJD:P`C=@'Z8]$_D^KxibTC:9')*sISw|RoY//lBD@EXlPr1[N].EsI$'8l_7^n;gIP^n!bw.WYS)BMvP~zRQ|s\bgBW('L{iTI8rnp\tvxX[@h\f;0GlB6g^NGLX-;]N?AQ>_({=JVc$^=@=}-g)prks=M6}c}t=}tn\vK=M,9*N0[=@VP=}RuR)\t$=}Q(&f>@7qXrH?1=}pU-wj_k!#Nx?\f{gqVKF;_7aoN&)/l}C3\\RF_k3}roXkRV^No;2@6ql8J%pibIlFDW[K\t?1(%N3>#?&lao;UACrtf-O\fpm2=}M7}rizfx7!V)#)\f$\"6(&CU\bj[+\\>lFRl5&VE w1o*Tx=M6tz~Z+=@t`iwS[|\v$]QK\t#qYA4j^v\f|@Y!=Jab8hZ`.\t=}$\bpft+t[ZwY=}|Z`=JSZo*;HYQ\tY~tomWp<sy.KfVo-)\"cv,m71@Tt<!5~Xt\boS9_VN=MY{M&WA>uelA{[A1~Yb\bAvQ#K-=@n,{`R^9Xuvb$n}o7~K?b\"N[ZLsIEG#!}F\bv%5Qks;<A=MDct_H\v<JB)=@RPM\b$C'pJ0;m3B70t:QwvPvO(am_FloprqJ\\v=@Rt=}W=}]pY\fs]M$|x4>\vd5`\bdvPV3zn#58_gHzZ]ch gxe?k:QaVo\v=Mn7S\\g8/}Dd.g>V=}:9uoJ -Z74|=}=}@~=})FvdSIlc-=JwHpZM14,W<vI(Eh\\GSzsD-y; >=Mcw,Oh?Ns@DR0\"fV}{Up_\"Lw{qxH@t1Jyu:WLC*D;<b({5=@ZI=}a#hX\fUP`)K348\faI?hYYQ,.2G6nCN#@|\"^gWoS8>6aG@Y4=Jpl=J?9^R}dPv=}NUt7YZKV`#Y@_Fv{.Dc *A}G#}TV`\v jgAU+#4WEsxIPjld?BFC,rX/{@7qA=Mo{v5\b^5;9d0#WJwsg1=}-~U=MD@_fi=}=@axqjT36>Cvw8+\\I+Aed]yE*.[2vf/B]%-0 Q,^?E'i\b(0e]j5~=@H=}?XPRm!=MUPIH6?0;]TB;]!L5Y\\ex/+#|7(LkIZ\\6=}s[=}K=@\vp\vj=Md2E]H52l\f>=M:\"7A?Dz2V8$`H]#/O30Al\fpk4kM0.dwcMz=Jstse#=J@s.`g{YJfc\fm)a)c$'fZV.+1)=@}&X.Nc#Dl>'j8B<=M{ak8Y#lL{Vr!caFHO]S{pZ_\tO$i24U\\l|a=}e)$Q2,YOoM1qxAav|]9x8^CX#U$\b!`;q\tII+v[FqjFY7[A%kq\b:7mTQ\\fjm=@DoN+[T6=J<H7j4TpI-%vK\fl\")d[F@:7ZO't-}=MCp=@bH-wwz>p(;D*2S,\tV&\\r0Z3P{9R`gVR2e02*o,]G7\f1&=@+Y_F>T\feKC=M`e.N\bZb7;Mx@b\v9aU=}|9\vv&K#q+L5aj\t'\tO$t>Q4{>;`,ZV.\tHH|W.]b1GG@lzeU)W9\tI`?1a?\"aY}k9x:J1ph+l.d\t$=}.F@ex7skBR9@>S'R1g'LHtP&0Y`L|Smr\\\\Emz^aR\t1-6B#oyX\f(P9_IC=J+\t]$dW94hxc ''\b&0sS\"\\:u*`=@oiA`Hgwa0V*\vuYDuQ{*;_t=M'od9WXE=Ji>2S.\\O+2/xuX\\EwLx\taZ3#k!U=@E=@8\tL\f=MFX)gf`qVFX)bzWeqEJf0{k g9=@$,Q\fY\bfCQHs=J=}t}Y$wYVg''=@A-'Yxee|,U\\F[SKKPosPNT6xzN^QM`\vGQ&$c\\=JSc+7Bd|\t4J#q=MqY\bQ_/7SgeZ}\\\"ae2N-mA\te6cR^]OLH`Z[xENii\tW6mr];^IznY-d0&[{XjM=MN.X=JM+-!)q0b&]S?+[t.BKLXvjXa1\fP~MJX=MmzZ i:pN7Us9WMERv$<D\"REZmE&#@=J1^+G3@OvIt\bd>';G/P`YX{\t]Nk)4a-p|0EpOp7E>IAaL-\v9Jj['Ti;.k6Ov30#pH;7x>tb[D)\b3W99#0z5%$tFO[X&;xzLdT#8ra;rTZQHW=}}=@4]NR9-RlD#cT%B=JY]Nt%CcR[/n_cc^S!KAMe1}'/D@u\fu,uR6~CRy\f!C>DI1WZG&T\tuHK)!{Fi4R\tp{W*=JQV #=}.I=@0{. 8a c^!$p\vG9YK.P(WV]>\v9uTZ}V2xzW=Jtki*9D#\"!:_,Y7{z;aj.kb-l%+qC3Tvt}9h+5/U3MmuS\b3Rj)L\f2B =M.BY1/x3G$XK33=J5KYx|u=Mg'^-keKTl@*a?w=}HMFcz=};I/BTw=}9c:MFH(O\bA@*q\f=M=}C9Z{P,~UiB%kJ#j=@*=}X\tVL\"4iq_a530dw=}A@t/&pQ&%b^.~C\vca5wg\vt6=@XB|S/}lf5Dw<kW]xZ:m%51=}H^Lt\t+1?/s\tK AnPA$c\v[T`%29bU( <Hw*O=MUGPewr>hE=MKWR%qH<G`OseJ#n}\t\\043i=}@$@6l\t^@VM:PmD\feGW?VSPBsGbtU3[Sky=}j\f*cDcEG01kMM?wJ5Tp=}d?x&5d,PhhR`pLxeRZ\t&A\f3:>'q/NoVC/ U''9\b>\baj=}&=@JK|>S{V%KB\"xqFkb|SZ$w/%\t4A~t8[&7DDq\f=}S{J)tsBU\t;<yZw&4/<!l,3>>(_FVP?H#()'#,fK3IC`&i?JZye%]S=M(=JfB8*#C6{Kd<yCdK\"kwJ4?# \fgW#=@do{nISvUO[JR@A3S=}T(~G+tzNCo8/@Za4@}\"lKJ{;>?`=MFxqb}=M6REQ \bs\vf\b;\fgoE\v:hZDKDfJ~y\f/M?!+}{m/@@; *cY\v=}=M=MK\v=};3jqApJ4_\t4N7l\vC|y;Y\t~UZ/2M1YG3HCHn\"%=};9l=@Ql0m7/<b_4)`8oSH~c%$=JfEn=Mw/@bB*%BF=JZB@-Htt|os-^Ew->\t+94=}6V>*`|I'm\\@OB838_*u-XF/[V|}\\SeHg2X'cWvbA[o(b.5$in5x]gU}~V:;R)ZR0\t|X#q9\\\tuiu&d#[#'^1s1M`hi? Sp=@k=@;=@1a^`k9$&LHAQ/@T|Q~yI=J^Hi:Qb\b'rgh`|S'H#.[=M\v$e\f]epI5'ZH!q\fWUGa\bp#>?\bKjm[Zbpt45r<\vfX4l\f=M{[]Bho;=}2uCaR+q#[J\bo:!\bw99Sm;=@48s%J[o6JZWun7-^<.O4Nk):q{pB}\"AG;K\"'getUEGJ9`ms  \ftY[C?1n@Rk=}HAE0{&p&#$7h[|n WP2aRA#7;>?\bm<%[Z~M5*8[\to)SVUb=M<f7eAVdQ*{UV3/BiM=Mvl+=@Z5tPI[0/&4}\fb>\\t|Kr[I=J;Rd#KWe]\\~}p!,{yw Z&K9#5lQFPy(R;F^0Uv#s}_{Ra=JRqGH`[r2ucQ/}\fTUW=MU\vwgME:wnliBMXQ*A=@bXV1nqG=JLu>(dX'&@Pz-:#X7nh>TuM9Y=Mz1O<=@VsE\vvl2<>A{!xuB8z{8{\"XK_.22DXO5C34bA8ebP@n{'<JJi$tv}MK!=@^Ye'>%\tE%>'A\fH}kO9TPL4=}|3m7o}\bm3%UI$^'hQj`fY8 2``V NpO6 <Toc!i6g?Hxe|=@R%=}gfA\b^=JJ'g`NWClEJr\fOdq[5Q2wx9&e886j=JiB9\fW}rSmyv['RM$O l=M~DxZn=M!_=}^y]ex++diTK`*=M7=J%omN\\_ye%oNTRtL 7gt2=J?@G\tF_Q0uG`2U1\b5\v(\b@z?I.3b3Cm$iFs%14<cv'xm>D=@KC<=}$D0D,j:A.P_2>^ J$,k: \f0+h.z[Nlxz}Hx=MG#8K W}$}S%?^M&,^DRzxoQ6V%0\bNkIeHnld*4V+F\vp`D:3k}P\\M]@l(K>=}3,:=@k?/\f!=}k=}a$J=MqXWmF4BMLvP!Ly^\vwQLC$?\bnbPqvmpWZ=@i6ftAkaAaRoRln6\b%=Jb,>t=}w}z73bJ \b,c(1.EgIG:0{M1f7W/G*+/[4z<\"J,(N2)AUT`Z&H/$C1<%#e.|v?TI7A`}oz^uknl3\"?W^h0NNl!?ovS>5i>=M}7f}QvX]85I``!|_dSC=}(mXk^3JF'\fD}4b+'m26!bPF |CD(%=@Z<As: _\vd&[aX?fV=J=}rW\"Zb/8Gu}&C[${`(El\v=@c|L]S25 p1B\"oQ[=JRwqJ#'r.gf=}=J$\bpo2I=@8HZdlnar~y1Xk#0j>Ncob[N8=@\b(U4cGd'Z\vk'S##7E:ZrdYW~PSq%Fqe^G6*|,x_;M;LZJKp:lV*`\b%]\"xrI\"eQ;=}CF=M\v &(=}(=@i?un9;M{x>\bq<KBf=}=@(=Jgf}]F{#,w~y#fVN3@\t;}Q\foOx9}>I Fv3M{b.FBoTwI=M<iZ`$XVOa7Sk\t4>?4\\=J+{o#<si=JZ|=MmSFZTfQK\tKEjtWv#rtUV#x]b}U}s!|=}nv44'xQ(r&NwWG\f> \ts\\j*@Ul%g\v?qcI}z=M$0r}9\fVvU_\"?~=M%}tWUNum[!smQk\fu&&TYZsLA%g% F<P{a6x\\5~u.}SU_\b7\b4eLWy=@-7AOVXtSJgr${^=J#*S\"f$6 cJp5tMONSVErlEUoV<\bHWHQIDegEo]O?0fy}(s/`V-7B`1Q}cwqtiPPEr0RtXn=}]$\"*v@{B~F[D?.v,A#=M-7|sgQzp\b=Jq\f(\f99__?=JKI=J^=JrG=}{SSV9#s=}\f>qY6hfa5O!_rhYs<\bU#y'iX!S%qT,Cps[Mr>E<- --$+%\bvk/of=}\tm7B GV1J=}`xju87.\f0nYF!SaARi]Gbiu61=MDu/Y,\t<l.^[<|^L4Nu=MO}$GULo\\aFbM>H=@;SMFgft~b471M1Ph\":`=M2>v\t'&lU)K&u( hY`T!=JK(li9j\t\"N\fQP`\\0O3[SG94t+AlsdJSaDf;y+pINuW_h_1qvX\\\";IbG+bn,3Hv8ZZYAbd0|W+=}2\\O>%.k3C6E4c)_tEY7=Jdxn.rUm{{nrD=}AuL!T\\k&pFiV%b0r=Js,WRJJyZkFOu-YM\bR@OQosJu4Y7 iH\v=M\"sP/|*t@JS](Lm\v=JD40_4'\\/O$c8ebDtio7%8R8$OJz0Sk>8f$^~$Ue:90ufDg4no6/Gq%\fny$Rhh0N[vJH[:4&{4K YR?gZ.f\f=J7q)!r>!&\v)`wTCsObE#XW>EZAhqw=@,PF{6 k%8v#V|QTL.&XDX\bn4!8Cia3yE(F/su-\"eC7zXG~bP\"__#,\"mufudi$V'=}K=M\va>xjLISt+6~c0GyW*OHj:hWK<U<L=}iQKHC\tqq>=}I7-k+&V)m?4.rMM&RumVq;'V}DJcmQ\"RH9Qh\fc7[O#iJJ?\b~wxe3c(TgEP^T2;6\\mY6V]d=@^J0W0\b^}9F[cn7e=MHpSjkvf5a=M[AoUW`sKv@=@bc,7&YX=}zW'C.t'9B.(j24h.2?=@].?hU=@m\"1^H0BvH!&'znK'Vw#i[\"Qbm?f]\fl/($\bYHCa H#!#?I)d#y||HC#39y88y8y]Q\vQ5)3Q=}#}\v&b\"=}Blscv/U}\"7-f$$h}uY ^')y&ZQbK(\tv^r#9sc&\tawa bi'$)w=}28J+x|a#fLg~9=@HAD'Cp^44`C?n(MP}|\bI-=M2`5i=@=@%Q=Jl~\tCE+d3[)m#@F0B \v\b\b^+@(\v|%K\f6~a{C^9hRx&&a~-ptk-\fTTzDpu=}25+zG|-#{\t\v]_RrJuF\fSaX]p#:t\f)$$d&+g\vX eP|f(LP%v;+&4p=}\f=}/mz8%:8#1m&}C=@b>34Q4@QQ'=}$88CDH\"7]ih=M=@xi CE-l9:<th6|NVw`^V{\\r=M=}*G=Moqa,uQFgZ+td,f'NF#'Oox=@ lv=M$!jl/|F8@%u<=@!,uNURB2V=}qoQUKg$SbT@6k\t1e;W],!5CSJ]`7n\"A?buDc@/Mq\b-`cXQc;-xg;[Bw6@0qo7k4=}*\"6j=J=},H\fa(]qo[f!'Afo{\"y4m7k7~?$G1l&rdwtww=}0-_.]O8+Q9?p_9;@ULB7cf#%P)>$=@jC'cI2\\8(.=M\bkdvF}H=}z\"6C\v1D=M+}3P%*;!t\bTho>%p9a1<\f\fL=Md:~\t[#08U1P82vd{l.@#NQ)]fqBlin\t;,1?O~f.H0!8^v\v\"\f0]$=M4T}YE]hy@=MRo[\\J+Jb\\d\bL2v%jChr\tQ1jcV]=@_GR\f_\ti>=}b-fMK=}\tD?\t\tj54Csdy#i^X}!@*)=}a#l8-\fq+9JLS_=@)K/e=}$_]]B+$M\\v\f/c Z;iJ!cLA/r<T\tlOnwBBq\\=J JHy~R)a1R8q*gJR&uF1z&Y#*}lC_=}fn:yv88`|<1N:i\v]l&DMWDg2u 0&JPONG`+EpA<a7(\bN=}Hhb>\\4KZ<GJqh|5O|.1{H^s%RX33yjvhc)\fQ\"&@s8h'*sr;sK=MQy^\\f9hM=MPPFZW\tKs)c;\f`\t$u~YTD,I\tX=MJ'\vse\tC5E\f)=MPH9bL~GPal1@*8Ot;5U}=@E2;6i=JT$7fdI=}6ucc*\\R+D\b*\v2G9BSUu&z9Uh`D=MHS]dd;=}uWOn=}<02eeWu76#,PWYc{%NP,hBx0(2'<zh=}bVht|2\tU6r4]I\tMMG=@X=M_Z\t?aRH-u S\vR77c#_DHvT.TE(6O[e0=}=Ms8C@dJ0R\b=MtlJv7u8w\bs\"XqN52GzWgP*0x(UX^GDS8sERr9pSHk(?6YX*GgNZB?O.E\\3c9iQq=} RH\\Y3\"iNl/LQ9~\b9gbI\v@\vs\\spw{ym*~\bH{MsVdr\t[ }o9Kw/D1(@^=}(xUcnhKT5=@y3c=}yu82{J=@=M4!ZF9,K_-fThF#1<Ba@tDh`\\]x~~I\f=J:*;K:& Q/C6Qv0o\fe?bBN&|s3O<6341K1mCmCiQM=J<:z3s1:g.<gS8?%AmU>S\vJ5`la-B$Q=J(L;?gle7cm`V;rF%+hG\b:Nc6U|L2Aq'CFfQi>nRc%=@[lxCi8~sW'L*5$2/Hh\b5r$RQ,egF=M,-9>-e8K2l6EzXb;~jZ,,~=}[R\v`y.o)a)f\t_`,@8K)\bmal08c,>|vh9w*Ap^\"Z&~ u?=MY3}6r\vktgKn\\LA]I5Uq{c\f~/9_-q\"`6{_\tLO0\\\\+:(\vt;r\"&#\\_oc1=Mpf\"8L\bswRZl=JKtG|^ZYZT4N;6&ZM1.sA=J+\vJ@]8,76)M0|CV\vcj=M)g\\F7(_\\6{PEDi{i?yGj6tY[-k/\vBR[sp7`;?8Ax!|k]X\\6=}Ze:\b\tDi_u/b}P=@X!l%H&uC5\"A+tDD\v62dlffd,>=@\\\"{y\\Tzq>F6a(;W/e,bu^K17m\"=}5eAQN\tjfGE>9slN*p7Y|^z?NlOd>2=@tS\\V~%oQ9 u\bO? <=@;o4.rS&I=@V#8GYFStv'{>\v&>OEi:&;r&Rwn7ZdnOisPxu=J&=}*O^ExzbWI-lV[TC^;Q|Lg=}7>C)\f1K/Lj':#-wfA8\f~c,C'5a\ta=Mf \":8xl<v2swGQ+l2|,/FboX;n7=M@KO@uEplU`<t%)!=MKLX\b)'q0^ZKN8?\vrWzl(j$qaS\fWl)J&o4};0HSV'\"Ju'p^[fcwlkqFMjVNiU;=@DsJ~'wf7h\t,wJ]8gCakWAAV?+gu<5y4|9Wp|D`S7e9>XzR+U2Y7vduwb=}|ev5BMMrO~2+k}=Jbs(z7T+{Ro;?#?Qn+ya|b:kG[M*.U\f_[[r]=@*\"p-=J+Rl~=JT@mLao@q 8yP!4HzC$0jFko:_GK0x<F% g =@_T8=J>D!Knk7?8#-/c\\AI%\"@b)T$T8UW^2OwUMqo~qQ)v7HS[qk|A WD=JWb`dw\\,Nk'TjdB5X|X+6hZ#^@:).tyV/=M7RUOS|vk\vo!ub1=M&oR)E\v@1\\a{d\"${Ac_U+zCtb?d\v=}TJ4H4\\p=}> J'iLBu6=}~v}=}&$+lopHRM|~>}%w0.FAa\\n=@;X8x ?u=J\f2\\G=}3QQ&tkvNd<N\vX4U]$r!;lN/RF7@c.Ti!*F\b1>=}A!~g?55.\"i)O%Ohd(*\\ZIsP3Sj\vR3?a&vG8k}1\"'\"=JJLh@ *~=JQ-,Ur\b)!\tZ0#\\Hm'oQ1X\v\v+N!xcbk[?F\v=J3#d.Cb!|SAKH<)?f*&-B[D?OdXBK\tr2\tWkVdEEges>M`tf>;Bh3J\\NR4Yk'+1R&-,4I}m:`gw'P^tRc9\t=@14FtcI*Ufn\";Z\b1?&4>\vIm=MK\\jMGN;.Avq>=M_9Q&mGKL/{.W`5(-g=}d}sX=@%I['\v,Tn:1?^k+I!'6OIMQ3Z/R66ooF<Yy=MS53u[\\[To+Vi-`#XZ!SZZl SS|7S!;G)hK2\"i8xx=@EAAqezN=}(Du -=}^|m}t+rm+^?`a094vS-ExVR?&j`*kn)NCM =@K>-e~{abXW)pC\\R`'HR6iS&Q?X{=M\t|\fp?rMe7\vq48%2y'Qcj\bB=}\"RDq#!f1dIK4IHIW\v=McGUMbS9\bFU|EN4;H7B=J{SL?sGBKM6P{OmX&\\3B4m\tXHi-!%\"/G\b=M\fIQGaUy\"*\"Z$nTd^@Im{\bR f=JQc>S_,1rOQ^_?g1BHO{K\be;8Hp\"`dJw`*5}u%=McpQJ=}=JKzFJgR;Cj\"~e|;\f2\"=MnV]b/?H p\\\t6qP4j2da-{\t#*p o=JuOpklMbcToXc_/D;3cp!He`jp~.`loI>Y!?vWJ|nCV$;prHP<t'-o;WI!w~aOynsg}E$O6S\tPn;*_bDE*T.f/K~\f\v*&Xc=}a0>+\f|xbZ=}BIobQ!4FkQA=}NA\v~4GgN=@w\b.}LWWFr`*0)-|}%K')f\"!X+.M\bQ+#7u@s0Odnp5HZSL1\t\"'#Qn=MMe*z5x5'\b8~^5Zbu 3?IF2y#5i]LPwSimf\\f=M9Q:=M7`],Pe%d%&6Ms'u2'7w\vR{lvl7{mA5nY*i[\tfv\t\"[Z/ac=}>K,YUF_)}@<F1~[H=Jq^p#.Vt3[+=Jfc^8h6E^+:\\;'A[3Ow&+rV,maEbK `{@mM=}XX(V!s8K;.!*=MEm=M<aQr\v=}$Aof;rX8FR<:9!=J9.y\bW*vo]\t=Jjf!JpIqS<0RYb)[.f02b)=@q+^H7ehO~\\^$NF=J(;'\b\\!cO^N`}!8i\t-q\\KI'\vgiYQQf\"Z\\}c9#'b\"nH%-Igc`k'dHm&)M\tS8&Wh>=MeS9Nuk,w=}r+eFZv*!GX\\s~J1N5i]\v.Q+HzjJ?l)TpY9D3-3ouP%[5z^5i\t2\\6*\\*^\tnKR7k1sona0m=JJ-.uko:\\Z\\ \bo_#w\fI!Nuoe2G\b-q.<lp@/9!5}D\fl8n1G~,tsV\b@k=M+bEzqHsV2U!tsyRk?jK-K24NlEB>TR3LgZqL\\gnlk8B:Bi\vT1F/>3Qc76@FCz4sEP~l[y.=JISdjLE}W! HfC?BZnR^0{\\=MT1=@m6/uFmQ\\fT2Rih8m6j6\b\tJ>L{$[#0E]kD\v\v=M/m2qN*d2=@Ax\td?PK*M!esiUoOuZhu)Xk2*oq(U-jc+\fL50h>vl#*o=J9=MZ(jZm;{P3nWI'wEzi?|h\v$6sFyKH8\b+\\OGp7Gpbhq=J1ok\b;OhlI.E_S,7ssK3SknUUo`r&U[?8T95@?0}VW4o[KvRT4EJrWCSryePVhqfv0\"j=}Z/D,Dgq:p+ x{zJ;kS*INf@QP\"SS1\blSZb\t,4:i/\fv*bd8)_a~qcRO*Zl=J\"Z.r2g=@/(67P=M8Kv44\tQ1mU=J2bBJ:Z0*qC5~`1?'.9X$B\\\\*~~1L~k'XO-v1o=Mz2>(h=JFq)\b%nWe.RD \f-=@WFR\tw|=@;\f5.pPE`jT}jax*{kd3Q=J\bry=M3t{5N,X@!WMx%O>\v.X$E=}oMLM)(:F{~_ByixhITIzC^\"2;mco%^>\fQ\\8:&QK\b.O}R]lI,'&f!/U7]]U>ok7aJk/MDlc/4CuP:u:od}:Q2E$nhrJ$nhi3hd|g%U3<iZg&m(D^sB_yo\v6RX$NCS([aj{43[}%=M Vv8~g:Y7wkT 5\\xpB'Ejd<7'tF#,=@\b[eF>qI]#-$5U*pie\fqJYMld=M\\D\fZmkA*4]:!}e7W=}Jq#\bo}A0|v\bze{.evIz#d?\"8Qg?DEhxEz~Ihw<>\brVjc$GfSpQr~a1pcoeB&vaJI`Pb\\=}}@_M>OU1w/8t(7F||\tjMG((dj&YP?5.r_hf=}L^Bx&C:'.OWT/-GUy>=Jru/4\\H ldke7=@XCt@&z^V_mex]P9'r}%@f6%r}g+$uh\\&o5AL?G0n?gZu@n9O'3r>6g}jZv{g]\bI%\bwov\\\\8r>@,F)rEBw$jJ \b;A\vJ\vBRi\"p y`CMK3w#I6KJCy9\"%9k]\t*>2l(ZY*&Z#@t=MKWgAlx?=JdG2{a&Ec&LBO9\fOp=@=@wE]~5@bsBa~\bYY[fsO[p}-i uf#e\tkCw|E ldSZtGD6\fq0-2=}zjO$6/tHC?]*>VzXE\\_C]f$\tQ=@R3n=JcNl{dM!F[3=@Mq'o\"zcXsh~\b!'t%66Uu`Fps|u\t\\p0p'A1rK8N/oYFh.%=J*3TB=@^Rk~+9:=@~x51C_^jx%gH#AL|r{FY}\f.gPkd)p!b\vAau~+00\t%rWCD=J.\tXC|QgK\b3bB&0+L]YObn\fy- iIqfW=M%HcyF\tGW)uGpUOc\b2#v/8znJqoJk|0<JhdoYTBo\bBnT]=Jw8Q^@JJX\\%{<\b{MSxV4x94XdK _H6];b.v/7\vLydlL=}%DIv3\vYd8~j/.7S3% &/_ ;!A[)Y&PU=@o7<>r'=MHi?B{L%%#q8sxh`gmb\fNC!wD_\t/\veE^7^(_eyI\ta4H~3Ea(Y6=J9=MuOx\b8\"qL'Pk\boDV++M.U\"yuG8\fV4W2PAS'GHi5ma~bq#\vna;+SvAW)S}7B|N`pV\\/1h,\tQ7>=@C{t@lw&X{G\\;SB^p\tR'}5y=MxmP9dOvp6.7I5Fy5|XMN[/i^O&3ND-=@s=@gXbdXw`Jtj1aiE3x%+*awlC-L6-!>=MfvX73QwR(e`D\b5@KePQFl[T&q >eomY{HtyY~p:4`wP.Oc!}_fr=M\fK~z8vcy-o\b/%a=J\\\fuvxu5=JC9g+vkue'F9`(=Mgza~fTvAC_|x:Pw)peoeq6bd]%@Fs>/\"6A\\#`D=@kcStiM[mj)\t'b=}:nb4fc{24[N)]@EXqouaTyHe\"K<{0@\fs'#s*!{M%f=MQvx)h,|XixpRo^w\"c,uw`Sr-P/FnEq\bukj1_ajw]=M;L?x/rt\"PhQ^A$D< oWe\"<].OJ[|w=J|}(hy8\vx/AFO1LMZP/\\N\t|lcWmLs*mwBXDd;z2+=@\tRU=}N,W>W\b#GY=@LGb(tQ{|i4MMND+&Ay`HI#=@\\mV\v=@M%nIc=@t`E8'+M9{O=}NS\bixWeC (*LG}\"<B\v33m>vH6Y^^lG?\"?\"?\"?\"?\"=MuE@uE@6g&@e_S/nNWT'1>r=@7Jq!|q\\#x=M.Nr.=MPp..=M.3Y0r.*U/0TLJ&=Jq=@vj6e\f3d3.&r.=M3PM_=}hG`fy%D\t`3@_+t9JAtZuM/WON}C_O?t'KF9>Z=}^A3!c31>@%2~[L0n\b/v8\v}4-y@8qeyX)h_Bc >9hap\bNB_{>LWqg;_ .enUF@,uM'.Eo%w\t+Ah]9PA9=}!&**<r=}(\\6*%BRdH{c:<5I/aeq\bm(&:@bT&(\v)I(RU/Sgcz|dY79.Ehh|7w[01dvQ!=@V\f^[}*va=}B5x\b5>7qc~Z!ppS8JDw~q9Ev.SD/L;P=}9rRRW=@&/id<pi<1ld5+LR<f\b(\b(&#)]qBWR^#3FQ#*eZfIEN+Zbq40WTOQ~VNRLaMaN\b&5E}&6D1Njbq;7]+aB=J}<\"\\YqE|fmSA\\i2~.V2gAjse3BOfO=}Bl,\t[X;U:d^l\b@=@O/}u[/OV$[3W6h{[@0vC|;'g52~^'#u1<=MaHXXc_Y_N$'E}l:EG&Yf]u%QDa\"'\t#,J`OwKN9=@i\t\bz8E~\vvbe\t=@n&zup>+5%y$SwC9\\LcIOU@8:U=J*k=M{5=Jsj=JBlg3xo{>XZ+*wEe*z5pEuUq+z=MR'%/z`~=M,<\fo\"v=J\bVz&*@\\.s04BE&Laf?4g--ZAh[yZJ<aJ!` %B\tNFz\t3W#'rXqlwEAy.d.6fd{go4P=}%gR+!6ww$;W3_I=@/D4v#wI+jt!XZM]J/f3|jc(#`mjL!'zdj {gGq=ME9ZdLz6k0nZ9 parsH4[8w 9w}VQ~kf\b=J4*I.qO;DLucP:4brd_9Am&Ishjm\b<hO2s:=}\v=Jqofr\t\v(Pf|e$;&qTnV\"&J_VLskYw7\bnj?5M\"mT1w=M2p95&4hYbRFq;F5X|GfIxGJnlI`e9L;{c\"7b>^e3\bt- F0O\f}(Q\vboUME;r6n74[W+Q,?$z)(QmvUK\tn\vrUWXZlPy'Z;[ysf\b-rmo\v[V6dVAw\"y[<Rh!sL@fuBGoEO\\v1DO\b<=@noH\bzP8L9`nBVDb'C&.^su:o\v:\fonHOFh|@ l>dl6[>=@4OdvS885h5#>Sl\"^x}XZW0dO\\EF]YAj~^:&$x@rl9\v\\Gbyhfx<C@E'&M-=}jB9''4)4/[/\v/zb--~dSL0.ya'4x\\/25/X*\v(AE=M#Q1rCF`whuJS)pqX0`\b=@AcUOj+FE<m z`\t#mUW&::zo*vh#3c2'pt\tRoQ%&<&J\"lu(,2+O4S1w.\tI7rRVcxJtt(%VLIbiA$,|xD!![xMorLtYQqw85S3tuz,T\"dF>F8QzrlYscOX=}BF<=@-+@|EjyN|9*\tm<9{.c(\t,iIHr^'KC:`*U;gM=MHf.UIwrqhTPf',HOA\tB=@M\\0=J8]:;|LI_>au(@WdlY>;X@UaI.71@;WeXRu,S4{!R-_n0H6`XvMz=@ftdUEq/KPL=M=Jg2ZE?T\tA:L\fLY)gt?}-%QI$~N5=}nry`/H;1WH(T9Y#rRg'Yx5|RFGy~;v\b~YF=}\f:/KP+xb%]Qr0,Nw.*:{ {ZD,h`vfFcFL=J,lFx|]D\\l;Z@i*q@Qmpu<nq\\|Z\v/ :~JNAN;rNY1w:R\fw3en}T#G1L_Q]\"8jTnT\bABldFKr|0TMr7~?l>t\\=M=}bz~{5t#1Thy>>JyB+>$W},#U,9UTp3g=Jyw=@~_z<#lIfuSgQ\vFaoJVwUfBdh*%eX5Dlvl$?t2jlSUoYy<+{qkwYAbE cXr;L{ ?,{]nT&d}#U3]vjhc\bjk0V0iLB@St];i57>7?]0W=}=JRQd[Tnk^5<'BzR X_RTm[P &X\vH!y0yAsg@~#{+JK\tU=Mn=@HuNwc`4>XM<[72w!&atHt=}e:3$ap'?r~)'z7~i~r*~WjO/CA;^TZ;j=}w$|\b:5em\\s-CfFE>,6?=}4$\\7flOVz7D=JdM6TH8=M=@VTzN,{)Uf<H7=}?%8y@X:V\b*&?-X{Wgnf9fw5^Wf->\f%\\\fGe=MG[9vlK3YCYs_{VX15y=}bI,N]]e/o&.(<)YP#.GSI5--@'Mm~9QSLt&h [A.2-Mp&=}fRl0G<=MJ)]I~5i#3+!Tr<VQujn2=MWs]ltSGY[T/sV 9O[_ 0f'q^SV>W3\t`z\v^\"@#q:st,><g_Th\\BUi]2&<=}f${Dx;c2=}dZh` |8^LNB6wMn-d\vE0/N>%838?L$$ck=JouE-j1p=}b$;>SzZwv\b$zX[Ep/M|hs4{_'n`oph5Rc9p7O9R(5yq}*n6~vQFc\\Dtngo=@;gp^*?uEKsMn#3L=MJ<\tE[qdLfTq|VK-=}\b}OTLIy1pe_V>MUwW5bV+Cwr+\\t\f<{SyxT}qzPbM'ya9?u>+gNRb04~OYy*e3|nwP/!1k(m.S\"*q>r(\v=J0h*It%lB#ZLwkD}ELQgTakC6Q_v n#z9ks)q^2iH8wj6z4F7(^0C5?S\v^\\t\bycQzYrE\t4%am\t%;T}!R=M?\"KU-Jjp&6=MaXD34XQD {{-dOGt-y;0wp#T7cga;\\RL=M=Jw2E/6HJ2Qj)LX<fE-!u*O 5TfOvU&=J!TMEy=@Sr{L1e\\C\"}WsHL}-t5SwFDXQ}8:n8*t2p+=MxW &19J=@-N00e+{\fdxtR/.=J?AiW$,.g0uTJjFk,lxrt8YEI\\uSz+?n5}1E915p[&W.c@@J7U);=JH.T-b$UEJyET=ME=M+#%h//29;!l~{#Y\f2]M!s%N)m[zC9HeoRi^+nhI_RBS^a^E2lD<xiwf!i1=MRK=}oO>oe(%{5-\"q\v\"N-N#_xH6>8)aK\vzcH?m2[e5KSdr1EX}f`!=JG<k9\v}mrT_&!jO5!&Ky-{K$uhzW$q[Xc1_!\\z#UC\f;P\",=@p'6pDa)G&}+|aDt)XU4q8{4k\b\t ej\"h>A(b ib<=M[P=J.][yd3jp+bsp)ud:wjhaCg82{s6\f\\Jxe\"[41CJ_~$\"}O$R:h\b0Cm=J:=}4&'%] RY~kFg-j1MN9=@-fO?=@j/j3T-P}2OAX-MxLi{6.xSMsv]:r-5Dvjs\\\\x>4k\b]5O=}SS*E>TPanSS\"W =@na^36M|MI}~SO\f^cQJEzq3GC\\5l=M26>SE0jMD?+{F}x=M3p;Z7=@o=J=Jt@*Rl=@^/=}\f\bHPD=@)TjY=}|k@W0<oNv$X><pdCwxt4y1\t=}1@Y]N'D]Rg]9)^qf(t>IJJNl,@-No)_z=ML=JJP:8ky\"Y:vT!Hzk!=MgJQB^o[w=}4SL7`~,;&^Ca`TYkQyPxjs\v-9k^<mPo0=}t=J(h-gjR88q\f0L\f]jz\\#v^oar**#S\b\bJ!c3lmuT{Ot4f<O\f\t 5h[`1|x%w{p=}kVPS=J,BvU=@t:UJCzkx\bXr\f\f\v83{:\bM1W\vu:;ouR)\fZ&?\tVX.AavB5r\fG:A6~Sz\f=}ON3~4A\f3hbV<A7@BSzz,+g=@2T<0`/RHJ=}k~8Z=}5dNwl\f=@r}o|f5(*OyUYM.\fM$]es7ZbIe2&7,lNAenWJHtugYkW'R,sz/<\bsfLNm58v'd&\bS^Y`\v\vmz`g.\"_nB5[=}`FK(Y^w5)4N\b^[nGi}Q<:6n/J,B+h8\fZ=MFHb~D,T5\v1cmJ+Jc(^fsR0fx.=}9nC=M{EC.S}!8I@0Qy4\bH&&@+xpnz@U]\fxizE, BX1y\fo-qMOZ6?-%bK;m4c2974con=@#s+S\"a/'v%&\tYH5+\\crc2dC\\W|+(wSIq8f2%aE:3;NJ8G{n1*i11}Lv7N2Q!J%#Fo G4};4dE\"im_UPeh/R[7#S&pmM=@*z4`JSQ\vDYH-Zj6o])\t~{EGC|{bU6D\brgdu%<\"eL\f~Pv@. Lsf-j=@-B57<=}*6\v1-0-$\vO8WJ3=@7JO1]O~[D\tF1<`FC,A]/B>(>rO=J\b0S=JzSuFsJ;9cFJa$8(,v1}[\v?K|f1qj8L/9=@ B^%S#o^jLS,FL;3hf=@%w|E}0Q`L#-_`)=JI\fa3m5D=@u&?]R\tN[xyM$)!{.IZdm\bcMN.??kzj<N2OVRl[1~@0=}?Jc)%\b9!$WKO\\.k_KE3B19pk\vlqWfj'07;xT*U/X$-FsVI251@ux=Jew &jSy|%EXZ\"!Oe[%&Tsol\b zZ2?N^plvQ90B>:5{RWf3~cx+.sr@`J<bY`TvB1isd.VRfQGrj$l:im:av8J\tR<!M?H7sM9dK|>2C`J=}\v)])}xEYL=J6[#(Fb_Aq<,\b/Csq_\\vcUq~Q5=J`fOn-C5<05\vNvs0D<6(:C1[\f=@3@bQ/dtogy#&U8':<o\fM+\f`N>{jYc>u/g+>HFp!L\t0U=ME+QH5J!N|C0}TR1w.?\vbNE/tTve8GX~;fJzer2&\"O7y=}Sau8 X-V)d\f/]kCEUKt6E(_W_=M\\}OCVv=@$[0p=}\bKh9s*T<\\1s(OP\v~3[NO`5JgsVz:y6\bp&)Z{!\\8|Na+EY=}0uAV\f.uVLV)yMQuZxLU2gN 5xzgLGNv6{Z\"{)><t*\fO&)\b\firE')9h6MxPJ&byAoq}')\"t(-2\\=Jk=}UwW+*ckBriLhH[N_S4Tzn\"M\vOM=JmI[=J)k\f@V1+|5'Al+)N*M;xLV6GDSW@zJtx,t@LTinU9uOmQ!~)P'sfDvUZf&ZLi)@@S\f[cQ:tbM\\6TnD)D`O6~g|\\7=}^faGL3$A}>OL<F$=JsQ!=MIQC\f4%=MN)QP)y6pjiHl=Jr,=@`AZX0L)#Jv&w)Pk$N)E42]1\\+g_\f3N=}KGB#.SNcc1:T&_ T7[>s=M\f?Hb::G<\\S+5/K;7f1/r|1+6X+AT=}qQCN}_@\fq05/mr|}J<=}2Y,u-6h</W-3Fa9RS\"{i0KH.\fNrOXBW=@:|}r$i0u.))zKs))]m=MUT9m[]#v>A/ MRR,J5r1@ge,r][/]IpzOdp6a<DTn@.;BP)WQ=MXsmoLk~DnQprQ~5PPmca\v4SHk|-u?uf6O\f(\\`Y9R7VB-=JT\fZ^1}tbP:aw=MJKSC[/Q1v5=J&`:V~~3;9G{@b7?%V\f[MPMa8dY=@?~YcL{KWNxP&ZT.].l=J=}SqjM10/e|OGk8,=Mx/G#Q-CFw+J'vFc=J=}kRE6s?*x/4\vE =};eO`WyuG<e@r!+w26CR4/{Ojz1^2PPx\\F}gq\\kKrr\f9rIns:Q5bzuwi\\wWP4+P&;?~=MsB5L~_\f.(LFmj+=J5,j.'cu,s*JkT<n\tr_JB~jr\fEJHmLGK^gmHwAB<YFkF+ZbKOIB.[sNN5!;@U]q`|?L\f\fY)L\bvz\vW$kquY}8'BnAkjI0E3j)k^2RkDCo2VNI\vF&\\Zqn&=}8>wFjM07+_i9Y,N2MoQs+tf,p1N:{[C|`:d|Or_\v7NfEKjvb,S0;&zX3|=M,-rIa~8J\\=J+}X$LO5$z>BK\vo73be{8s5kw}{,7^Ta1 xLAiJoo ]L7=}|{9-\\iDN7r{j=@j _d%_>~-$lHH>z8[\ffycJ;$R=J<X'yd@<)\t\\ZT,MNuw+).5[(q'=@n'n/n5@z(Yt<l*16][:pxO$)D*Uz8M=@u,E}194kd&M(7l.q]-m\t1vG\f,jb}{E?M7=}a9&K0O\fC2YLEFDu1pe0VBR[xvhVxV0]@9X1\fsV.OhXO<\\^h)4H1t/)aM3CQ>5)[\fK=MPY:y=}q{8m10q0=@c\tTCI=Mp@\vPZkQmfp\v=J@TneGi>.{T4\\:#Y=MS>yxpi|st4f6:3t%%h|\vFF9(}/c5>7AN9&!{>mb_.)tts! r!&(MOQY-/n4H\"-!pFsOLC(%ApXQ/'%pqqx l!XHVk+SRo:=MH'A%R_TY'QqzRG9%|$H/?M{\voIa:obxw]![zW\"^S5i%=@;\t\\\\w]\thOuguo}i|x-#?)!Lt ^m\thSt,e5sygL%(OC=}*$!1&Y7atrw#)l]aTtqKJ ]iywSiHx=J\"Uh.WeYgt$'h&$U_92RPiw\b_cs3\td=Mn=Mp5&hCX]\\Z\t)\b3md'=@FqmM'c?t?>/A\"(z\bV|h|uzlI!!\"]%~\t\t5G$#QSE'hi%9h%C$7(\\#Ab!HiD) G7GGe888~1i4Z=@|Nz?I;Na{{f(\"wUxsIeTLydRy{Qf2E~x\\'%4p) yt`dh01_VIm1'$h&lHz+^u!(%~7`i$(^PB'>>h)0>nI'\bSez\v/i4>(GR}O%uvCbMuSUB#w\\-|i(A%HG!=@Iawj\f\f}jjyefY~vmQY\t\tSE<zQ$'ny=J}OkPw=J5?hxX`C%pbflEBbh(935;BeQ3/5\fIqP/=JG#_71XC0pwT'gkh\v/Uf_Z!\t=M|XfZ:Bidp3`(50[=JFd)ePW\t\vq]\vOD7%-MYuUY4=}\v,-q,w^94\fLfu\"OqYh%vs_e:Y?X>\fUzFr\b;&>RP/afo=@};>a?'t\"=JKA5Yc%=My=J1\bmSF|V9!4M?\f5@(y(Jy.m(TU_#>P\"&|f*#'`|KA>=JC!#6'ta>#c&Ri4tt/H0#P3UUR\",|4IS_Q.yb\b<!058QkiUFFw8{UA-f5[:VR,(UC5Hf%SR~ojA,\vk+Obi\vKwpe\vHH\b\t^>$z\v\v\bT/M6%~Cg\\~b3~%'!Xdttv!j15mw7oV=@O[\t=J=J\f=J_tNiuuu9F<B:QOJvj(?IiS++%Ig'%=Mi&$Mq9'hi(%9ii$=J>I\twi)\t\t\by'KhEVG&f?Q1gI8=J8\bIM1eNBh^msmQOZWI1H7KE=J%po=}FV9 01mfEt-r6h0|8\b\fhZ\")q{c.mp+,#R},JGKY\bOge!K\vcF&4;Tx5DC[w}qI^1B{G?})\"7wHzG[(U;{g#17}u[]b\vq`IbAc(\b]taHg\t(~=}R'Dp'gPAY&d@'glQ=@jf(b27Ed{;^`id8tY%I>PqI63Gb M]&yh#fCC{~X !D\v[OiSb9RUhRb646y\\S)\vq_5;=Mi}kifS$LtKUfA_gt{DP-5V\"66Bz[Npx\v=JgZN\\K!iR3(i@QuVDxSm<tBh\"~@T=@T@g,A0\bzf3xRU<RQ(wbDItRSV~fIWz7Ed\t7O@(WYmr(f/i#\t-1/>5\\^=JE??`5rX4\vSh_YvDR\fj\vR0\"Y#fs@\b,N4KNgTgZYs(\\:\by|~|N@^#TTptQ;c/f26z-wTt3[tts\\WO9k1JlN1i&g)zZitwF/,ls]*bD0y,=JL4aE]f6)03MQVrJyDt\tNN\t3&M);)n>P6JcOIc&kw:W&Z!,z$vb)bqD?TY$\f;(Tw~+rA/k>)* MLnfF+dm3$N,xi.S}\\\fNoU\tMmb`TLR?4nM/1Zs\fi\v7=@@OO6B\f$(\fmhVeWK,cC! _mxH4&5nAh!=J>,&1xwU=@r|{M\\x<\"^Rrjtz_q8!#OC-=J!u=@N=@GthPcZJ*u=J$=@CC{S9=@?yu\t[}%#q^AWS4P@wo&=@2S\fL\"!1!:e9(!>8\ty9\v8(c<Kf@G\bAVu_=J6S28T<G87(j87amdIIk8u'&\\x;iz#i;/20tChbL7gaHkBz|U=@3,,`qxi?|Iy1[R'/\tIX1BCD2E/zY <!T(Z%_DSpmw'`7$!aXH's\\9CNGd>5\b^qQ9le\\[d3tF=MjC9( \bG`bev!*}g7?OWuEdj}YQmV\"pi=}6f$BTU?y=J`A<dj,=JroFU(9e)\t]a9ZEx$f)\b'n<'U}'0ST6A\t#K^tqUI\bV4{9ava~Lk.{mQWv{QT=M~g|$Nj'ihty$\v^'@T~!T8hgN]' &y=}O8Y4hc1~2{ (.yigd\\=@leR\\;\\+9F'[j$ ^p}(Xs732\tKNF8'GCx/<D&syj ((\"=J0r?c|5EEt$Ny\t\b^ot}Af~\b!`wJ-pv&)[xDMgdJt-=@\\eI`Y~OYMO 1hB^AhrLh+ SH|JqQRjg8aaNc:X&# =}Dg&(\td.k]7I0,_#\v <%hAr_7V$#p?g.-&mqydQz_aLlgwrU&gS) ^VNW'\fx#bi9ExsF)C3JrgTpOj6'=MF!FJ7\t*um6!@imp+oR36|Tib~VtyqRU=JdJH;Ny'N\tZ..r}?K2{jRuiQ->5`89jj\f/\t]QSGC)$))Y<+R+Z+V+P+U+P+D0:tZo;oC*+R=}\\?o+REJeJ:31*i.]UJJJyj.Z/L*/+*7-4/D3>0>8^0R4Fz6jIR8Rb\bP,,-*+w0/u4;2.MjLTj]FzGj@,W04FOzgDj`,04r_Pj -G.d6>ba~0M,*0duX,044GPej!H*g,,>cuj\b-.$6/E9JBe(*+~G*#-k-pk=}u:oJJ_J7JWJGJgJ-JMJ=}J]J|++*+c*c,Tl*JkjB3.KIAI2z:z2Zzjj\vj+;fzFnQ\b;Llxpx\"nn\b/CSad=}l*.*kuAr5j{8@F*re5>418WY|**-2jO*Pq.9tz1+h,G(rG*fk0+kj$}**C*T*\"l=M<*2*\v@06C9,BJR*Q^3*XA*M*72=J^,@41+-u/-r#k-*~*uZR.d8$.>6$U+JI=J[3je;j02r0k\f0\\.,=JH.=JX.=J:**e*H*3U5+l|*O*H*8U.=J+=J,A,F.=Jh,=JeeE=JJ9**P*A`QA9G*Aq2B.;?d6'F*@D70f, ,r\b/\b+j\f?*y+A+O**\fg.O.5w$h0g,;vH[00C0KW\v=JH3\vd5\"+m(\vz{~kOt*2Ew}#uW*=MQ&v}\tk15$(|~StBP8Zt{>TwIu}D\\RnIkiVoA|Zjql~VcWcvlcZ,jw|$>RmHq\v{Lyhy?tYuj\v,8|ItFRS}=}W}\t~DnmS#\b>743^jW@}Hd~5Gt3g,H$hj0D|7S#p\b4]N_Yp\vM~5*un\v=@~7$F\v1t\bI\vr(~=}dTDj0AA%1|~\ta\fovNKO:$|iIN2JE69R{Qh8$2t(Btn>h@p}&=MSPv*(Q{S^\tNJ<MS9m:95D9puG=J1,kpJ\t^t}Z86=}>Yx},dsjU|#~Tx_|~XjpI]zeGR\bpQU_\f3Se'q7\fmrFm=M+>Y\\n#?{|@| z=MTPk_x%rt(zWhq/^IucyoG^yl}|GP|]|5MlDRO)6ykXDKwv_V%V(< m{0QY=MVk{r'2mfW=MK!F#3?,<>=ME?D'S\" \\O9qhy!d4d..h=@TU=}R7~fCT\\?5~szY9FWs!G?6p(\tO\bdq$fK>m\tp.\"1`=@xeg7?\t[kq~\\06r1l30pU\\peMSEAzA)T}G;_OQI8!|k(>@{zXz`A{BQrdd]&8Pbv#bm=MHrQ.)lR=@`)V&s4'=M#I\tK#)SxTc\bj]\b0yp5fBh!K, gy=M=@k87=M#3:A$c`4S!GS!\bLh2-@lEw}=}?o7J<0$Tk58}S\t&+T$GI'pCg=M$\f[|qGu8o'XL8I<w{ |s-l_G#s=M|FG\vf3m=@b\"s?x=@10cr}DRr2#VYg~6o~4}pW9~=M_4m\v4!NpiTwi<mxmw5i7!?e\\s'n^RthL3\t#=J%A5\v-A`n/Co`@<C|PRpfvE`wW!Xg\"d!dwt3|l\\1ys9^W2{H??u%gk\tP-!r{} ^87y;uP9WC|].d\\W}hU].4NnDQ AdO'}\fzL!SIt}-WP1LOESVbKhbj6?}M/OkqD`.6_a~QTYecdn\"{,19_{KHYRQW\"iaQE}g_otlBe5MGh1$l$Tu5PQpDYI=Js\\NY]OhdL^2\b\t\b&cQnve&c7U~k!<Stq%qAd 3>\tNHESi [ \b9g9Zo\bEEg''8$~Z&z\vMlYoB%z=@Yfd=}as=Mb8nZbRX\f]UXtH^ZcZ7]\f9][=}cSVc({6f(\"%|N8{0GPCP57YjR3k\"+r?_MZO],lK_+ujN=}{~KG=MR%&Ft4Hv=@M*oRn@aGOR~}ToPk#~c[jT?/=}[Lx?Uoh;fYln;k8=}oI;?K#h;60A-^\\Pu-VJf>+9*.L*l-+w$UlJy;(.\t=J!]b):\t<UL^)^2_@n22;;Tv<;LGJlo2~?\b4/X~?)4>Xj|Uz4,`jUT&F/XTq##F=@Xq\bi\\>6Vm9C&-u|zfu^|Nc?/I`l=}\v~nTOr3?-n[5Wpo};TTl2?zK5Fl'*#Yj4+'q%~%W9zHa/=}J\v>NXk8JFN<wpPM}$q`l{`dSp_QVhn0OP\\R6h3Qka\f>YcDf?~^4Ghvnxn{'Qq\\Ns)rLGsjo\v3R f~=}pb,d+wjE=MlVD!g0d[MDZ8nmYDpKR^}Nnk(U;n.ZF\v2E\bpB$a4xIqEM{NZ.f,\bN^F7g6gB6oL{o2$?J[W2g5n!-;2Id.3jXH+i\vm?'t)1vk!:c>K=}6k5DoKu{izy=Jfz]e7&k!jNIg:WoA!*Eg*]g3#I cwq}9jH8 4$8m8LAW_pO=@R<_jC4]m[!=}DM~zKh7hxZg`sA=@kWdR_sEf4o0<'m{T_$T=M\\$\"Ln,-IO\fDyH4jeRL{8oJ?6<pTz>Im7=JQ\bG){%6]WTZP\t\\789h]51@F'p\ta=@=})l)v8=}C&e%8SaY{Y]U\t\fYZ[m\\y]Iy[`[dsii3cbGgcbW\bHa[m\\x]5D\\hX^Z+a[5\\]uBEB%lha3ubap{HD\\}CQ,p}`E[!au=}=@{=}Bk6v>f54J*&9~[[=M\\mCiS\t\"O]5VPlmH6~g=}ZARZ;Vgd!4'>h%VUF-\vk\v\f58;v$P@\v4UtA3W>B:=@\bS=}0@x@v>:HG;N~SyLPAOMf\"&wq/yC'|\t\f=J19\bpGI\t\\n\"=}y=}x\b\fmY)Qdi[cDGx+`\v(c`#xo^Q\t#1Y(%~ oAY2M\ba9=JA=M\\uM\t)H|{P[/ b7 H`7hDwq *=@j =J{R!0'(;(9b=@J_[_# yM8wQ'TnT\b \vv7eW%kG\t`8SHYK%[3RCOOWrQe=M^k0e{GI w%c1m]A |=}#@=@SC\v!}Au p& =J`=@!=@{X\b%I=MivHaWEY=Mu #=@'E\\'x$-i!&)k\f=M>{q=M|>HD)N\"g&F 2pg/hBUIX?DOctCr=Ja%n}40\b-Y=@t@ZyEU=Jq|FI\\Usi-*X]shpb;(B=JywoS\\c6u4L_`@5\fhGXay1\t6c\f'=}h37c{*/f\tj&p:p1ja'79\f=JH\"Q=}%\b\v\"a%:aQ6H#=JGA'i&m*(#f*F6Q,EJaU2{7k2`.yB6_G=MfV>\f(M2\vZ<`q\vEp\vAZ_DI\veFI<\to=JQ$[rO<o> ]DiI)=M\bbfbKLDS[\"$BO@\v\"C%w{P=J3YW8bf(PPE3W;UQ\fl<d3!t_\f\\9qt=J3S\"TQB\f~pT8v^f]G\b=M<Wu\\OC6fPaa=}9qd\vVfW5A=MQ'\\i\\(\\`\"ZCYcFDb4a4hf/AP9Iux\v]#bNJI=M{7*m/\"p+H*'Rm5lf}K\b:A\vo\";d>Mf_BU8W&[`TOb.gRD}TbYTT=@he?i#f?)=@U3(i>YS}q6d\v\\6V_qbC[=M\"V8=Ma\f?b,i~=J?p/tU1?4ztn_fnZ2A;]LFyyLf=M2qLf(25\tL&&2a(<\v=M2#5L7y%`k?$\tJl=MXz;;RloPqq:HJlo7/XN4pRqMdR^6ToHG8xo)<.Rp9@\vr;V^5l+$c*?q+#\f%fi_9d/De/of0k%^~`Y5P|8/z2\"`f{'^^yTd e/[Srn^#~\\nONJ;7\tFg+sF>[Aqi=MzL4Dks;'^d6?lOpgM\t\vZ^!z)Dp7p=}I1y:~Q*v'^9nhM'QOaN%JTt+ryCIDF{i>/E%3`RDnd5Yr3[B*gqaSgw1G2p\bD\tjTD&q\b\v4WWt0sIl?+^\\I[d\\YhdCyvm7{=MO}4H\\[ wIZI\\pI=Jy]}x\\6c^)ZedU=}Q\\fBnD]I\\zS=M1}z.y]3;N5,=MBOU3=MX}/6u[;x{$Ve~ubl'z\v{\voA4-}5C9\v,MS\vr\b3K\bHIVDA\"$=}g\v#5vm=M\tw=@ Km{^\f<' ['e-EDCioZa6EcN=@o9Q\\`?xs8T'=@hf8`AgDFGC@=@C`P'fzg F\bK8\f=ME# yY&&`i{D'dfHk+ET+6R\v>s/e }e=M/_WsE(QMh8\\B\b#3<5-5Qg`#WHF&'Z$3*5=@9\v1=MA}Q<Cf<\vhbYh9&*VWA0\vrK.iG8[9\f*.@8He1'f~aF\fo=JMNc<E\f=M\"=J,%U@`HYb+@vM+\to=}<B*L8tY}q{DX7r=MPC\"6&Px \vob\\xhCFM1\tx[4]kh4p+\t}SURLL[BITO\"\b<TuXwxP\\>gYT\v\\F6ye{lc8}q=M?,DT=M4&=Mu/X;eY;@L;XR ;\tTIq}Ib`\"GY2c>L^}tFo\t4/<bJ|p9WqA=J\\mST.C\tTpf\vz,-5,^L`In_4o4c\v`]{J-uqMS$nsl=}RP8q6>Hf@VnpJ$R\v2&bR:1(,I`1\"SZunwrjJxr;wq/d\b>_p6`yjwGt~mf>zVUF-%X#=@C'y\vI)`MY\\yy]cyZ!I(]X\\=@ZAZG[q9vy[bD(yeZD]kv~^{#;\v=M_iU3yFSYu%[=}{Bn=@wM.\txU^x@`|2EdUXG8TEXf@Sf]\t8`Y: 19dXm/Yls(9(a]Hh\"F)5obDH=MK=@8Cu_aG(\"\"6'/IH_2)m=MD0If%]=M=J,J2H=Ml(37[r LD\f=Mb=M}yP\fK\"\"Z?i\tP\"6F]=}}P=M&d4@/:YuVdBe=JOTXIW~,U\v4/8n~;hmA)9L*Z/.Uu;!M6Yo\tt;$9m4`n5(>>b3Y=Jr%bNnL\f;tpJ3Q|De ?l#R*O=@ltM{{h:((\\\bFvf=@x<[G[|vO&=}V^%{\v=}yP_\t&$,Q1@F=@M_ x=@Rc$;e &IZ!n8S\f8h=@1FCH9C]IR3NYFsc=M3ch+vw]|&sPF`C/2)^XulI>X4IRTo\"Q;()@&S`{A/W1=}dShj&)>9-8q)&\ted [#Z=M>d()\b[*yF/g$@F))o\bQ+X-17 @\\2#$#16364^HSE<>\\\"{n:b[_gM]etk{so33SC4uTa5+MOvSc\va=J\b\"i(vSmY\b((I_5>c =@(\"g=}![/@e&eXg!a^#x'hEh)=}~Y$'&d& t$RaZQ8\f=MG\b'm2rL^O=J% ;'e3G=Ju\vGWmA#M$eN\f=}$t=J(xdrEe!FimMWbAy<^C9/=}$Nj+>wv7?6}W/d*z]*A!gTmZIXkg?VH5u(\b(CA~*8*Cz'ci8Dx}e[v$4s}<J$xo12*smr_mQ.2}fIlbk,^ZY4=}ZWgCNW^9\f]XljG8?lpd.Pd%+5+Z)5'\tuk.DuJ=MH=Msl>pAn,FkfHl\tK,VnKJ=MO=}j~VghuUkfs5}lnRV@4[Dt@=@:H.HiJ=@=JJg01,$`.LJ7Wfm&;V 2 |tx]-V\\+l<}^ng_q7mzwYEAXLU_\bq {z1o{$BGwGt{=@7wjbJ8zzDq!{;X.|`r,aC9KtX,TC+PVgS?I:DLh@:aFa`(:+MwQ+\b\"-nrGZ;C-Ll^?kdF^f$P* -71mIbxj+tiKfn`:Dok:My,T:4PQ#6M:lyG&-Q\v#/NRe3+g^hTFL$3kpP^A: ;\fRTl`e;K3nr=MkL$4d4N\b,GHY=MR=@w7WmiG?.!|:%VT$TSk(P\bI{\fBS\t/@yl4aK\t@7S\fw!{rF_p@0Zg=}hHHEIYumTm`ngCuOar\fQ=@eH\"m5$ Q&T|=J>ABx\fT/i<?31;\\(_DT<=@0M`(Fd\ve0Pi.S]&6;,!=J=JuC6pd 5\f7X\"J.\vBc6:\v.@kDBlP;-:=};+m:3m\b:;m;Cm\b;+m:3reDm;Cm;*-Y:.-:2-:K=JK0\\}6B*[+C/-\\JE0k66BK0\\J}6jB[+G56.0jq+e6:0jZ@-dkBc68o0<\\B+6Z0j[`-dkC6*0Z+v0-B?K0-K6<,Zu2B_K8- k6>,P[EZ+\bvc!3QO!=}3s.NhIi|H|h||9IYiyL9LILYLiLyLLL9.ni2:<'KO$nuEXi.ni3c/<'OO$vueX19AIQYa8qylMg6kLeesHrrr\brHsss\bsCrrrrCsss392Y2y22222293Y3y333336Vv6Vv8:Jdk2?]n8;LdoB_n!8<NdsRn8=}Pdwbn!302@2P2`2p222222222=@22 203@3P3`3p333\tF3O!QNgJk:s&7N#L|QsrP\v9dyiXNsv3)<#WO=M|QusX9Qn3<'\f4rurLyKns<'TsrP1=@`yIWN.sv3(<WO\"Pu=JsXI#$/wJb6$OwKbF$owL\tbV$wMIcf$wNcv$wOc$wP\tc$wQIb /wRb OwSb owT\tb wUIc wVc&@v=}6%swQBP;63%2%3s2s(juZvyZvmZvqZvuZvyZv\"kZv\"mZv\"oZv\"qZv\"sZv\"uZv\"wZv\"yZvkZvmZvoZvqZvsZvuZvwZvyZv1ZAi.n2;6=}MBP$qi.ni3<6=}'OBP$vZveZ19AIQYaiqyN ^MsD<umP\brHO h|0sUESj=JmNMfqb\b<Hu$UF6N'Cx`np(8QeLmsWi0;sGm(BnN'_x!8t$<G!bOdV9wjkZLKBqc;s$F 20O'@r/=J|o0kL1\\j]W+yP?*w=JaL=M*x41\"u40`|.:3HU:_Fte/3rr,/<51C0|/(:_2&gu=M/U>`j\\0fi1!pq;2+{M\"d@?M=J7-(JMFj=JA0>,Ho=J{'Q0.n0\th{=J0AT:Rwo1:\"\"z)N\"!e\"c(=J1[6DY6?=JvP/9^.i\"s`,h8(:8(=J+|1,y2o6A1\"{F=Jg9J/)3L,=}O8&NBfO>+aP-6#z9afVl/|yZ,1kD5[@m0Nc:6.p_k+Jry9D,|NgkJebVr:L4N^0/C,S*\"J7YNgrRDN1F-*=JJ:t*G0?*q1-y]8B=JfG\"4+xo+J\fAF1P;]TOk)3E}3[e%=Jl\vT@*FZ/H=}t5-JO_RG1^|lzpRFB0 tm6J7-*#80x\\@=Moacx5 jnNzX*G+8+?,cj+W,Q#.=@)m#GT}*#~GCeL>''?!!4!eH~=M[bOZyH|eTu\"Lp/oId>,,#5Az\tQ\tVTmSm53C[X~\t\b\b/-u%GRHZ}0t#?xEG>cvn\t=JC-~X];<Z=@?7_H{d^oI\\n~Phb\brp\v-51[@4jup@g^P-Cj%/vLc4L<|=J3*Ab\t\vl=Mmpq IP(=J+W\foP^\bg\\DCC =@4\\h{%VF?1dr15`fPbgxWHZe/asL~}_t`h3#GVn\b5gAYh] q)f[8\fE9(\"xk/X'R\v0)'d=J|Ot&#C&Yt$)$aI04=@EPM?=@^Em-l)>@%=@_Uq\t&%>>XRm5I=J\fQIRW/1:]K${~t&N$Kt,kMdIgi_\f cc^\vc$yy\ta6sPO840)$bbc@$hDfOi`g!8TIia\\CY`{.2t4}`PMUekp=}'lHn9#&ruA`|$Iw Z`{\"3!,=My{\\i)h(#\fxFi't`W)oP/`3}c/!eG4;hXD\bp8B$\f'oM-S4/_m\\AeNd\"Fgx]<Z<%=MD_Mw\"Wdp8=@{XHH=My9XH)ehC_X#w$\bMq9(~\t\f=Mw!W=M^E|8n-h@ET7irk#@(o%)=JG)\v\t<]`@BU=@9}8hR]<GUB| q$0E\t=@{M,\tW'$wj9u`)d =JQaFUbEE%-u\t}Io5<~@C#%&Y3 l#yG=}7Wp5486>)PSPalQh%Cq@F=@=}!uQ{Y=@(+St1\fHY2sah\f\ve.v/IPovb~\t\fCDuVw'%A97IBq/7t'|=}IFv_V5KxjoyT<r=Mjg#^~#'rl=MHUU@4-)sx)=J$]4z`|'=M,^)Ic_Zyzgu7q\"? \t7P%!icrrT`V$S=@c%K&p=MX\"7YgS=};'|U{.&pAHp-xU>~N)\b#y_Mov;BN%$$9\t\"w1i`7}A\b(cc,<@_or/b(\\w=}7xu\b\tij5`w:g[uYf[\v+m\t]?Pf\"P  |u=J9muy'x$GQvAYYYhV=@WY76Hq\vn#=MV7<NA~#tA~\tbi\tw?51E3x)J\b#eq|-&C@\t9d\b1V,5fQ AW&8?[E>a}B'v=JhA)Yr92)=@d\tD(wiW_=}.xi=@`/v(f9Q(=}c^R6%#9AcaX'\\P^!yOi7=Mt!xRSP\fXg9S{w^]Y7|}Pgn?=}_tu\fs|8QBF3)aq^0nGZK184=@' h5wA#627]~{wZ7a\vXTq$Wtb=J[p=}hu3bc(E&D=MsHe\b[(Ii%by)\bK7a\\=M\tH&6H &z#+ae`W' UhF=M'uv\tEuT8%=J(\t\"\bD$e&%\\(\t\bG){ \b\tXuZ%$>/aV3[ Q0=}p*AyaiCDe97X=@z\b?x']y>#PE_%(mfcK\t\f&M0`_9H\v\vMu$YW=MW)$-!Ai^%Ad)#@^pie8%x\t&_#Wh{@dcG!`Ey\"6(h=M1Gv=}7OPg}8ge;#|bHd\\\"ZxIr#P&)U#=}'h8I&IdT\vg'=}%\f)RQ](x]Vy%_Ub\\ HEG_HXTf<%]Qt>'E9(`M3BNT\\Y\t/h(@ (5dd\v+iY%:$'`h\\d/W'!afpKf?quodYhy^=@af\f&W(Hj=M$]Mqgd!H_P\vbXa[+;IIQ'=JiPeW_lOQ+CQo\vM?vvi}!\v)fa'TJT=@M~yTaXt\vsmO\f>%h@g)s9}9=@ts\\_X\bB/YK\"=J\t)r}N%=@}xa=M(!?W=MS<'n>[&#=MPsa%}x5=@s\b!P~T\" 9TPXB>c=}`}eH6UX!W'k&pMM7)|a#(7@Y&p''D\\YUEyaKq{%G5)vmz@@Uz\f@Le>/Ny\\&3gCO5,Rl\t'uDP|;KNk=J8f(=J;ZWJ*Du>QFfsS@=J/CImh(kOe\"E=}Ax9P<L@!Je\vS&\v&+ReL%h1*\v1*[iT|j(x=}E($bE`,sAJ\vuOB563||/cghGLH2vfhz;DlwM#eb?2QUX*i=MG71TzygYBlH]d&{yCq|DB]btuI=M(3&k3~=@=Ja\fp7Sz9=MPc=M@,*=@\vTG-gk3P7L'1ksLc\f~ uGhF.z\\c*rZv'\vk53U\"nO=@|\"L,D{Hj;(Lg\v2y y-\t|)(`N[\\a[4_2h#41i|-_Wjw642Bq:TFQ0{-=Mx/#g\tekaq2=}=M9QsBFpcvV^VZ42=M@UV=@,k\tl>h]aLub99<,FZr4A|?`v2'R=@chV*#}U=MK'`)\\?|g=}It;Oy=@#k_+F~<=}tE*!6TP9jVL]U4]vv>:=}\\_B4gI6+H, ,'ZB\"=@;FJpv<U=@ wPcU#Y3@<=@%t~ta6D;PASn/;HQz!9)G70$\"Ad=MOdb?\vvkpR\\@UQO=@\v8{GG$}b>jOn(\"H1HiQ~Nzhp<\"r\"]8.:w@+$Y !5jHE1HBy~M*HVf&;WSk`5gxQ\\h&A$iQOu\"JpksQa$HmO5y)pyj|Hmfc55\fK=@B\f5t3J?C6pQa\v3#{-R1x<UStv'D\b/\b=JqZF3NwDE\f?xf{K7p;qJ|^gNnF:(\vk3N_mYI/2abmeQHN\\59sTB=MNz/U\ved$xIo!o\v}{mIh6`=M>0PVQ_&7ac%n'J\tq_ z+tBP_kV)q`]=Mhuvy/a7Vw\b=M{>RhiIvt\"[AS}Mo?EG~DLO!<2g'4 Whga0#{Afq\tc-!]$%6p)}j}=@w1pA?A/`nc(U5T&I2Ov_xz9=Mj.SQ.Bf=@jP,t#)h8uCS(.>^#Sh5h=JpJQL[c<sZzO`y=JL-/<I=}\b\f6dKXR`Z5.3Wg7EHHA\tDIa=@YHt1/nR=}GQ[=@8g^{M\\aOd6=@B{*n&Lhe' \b>Dr7Q=J:=@)Qq'v\\6]Idg0_,209~]Y}8ViS}x_\t(d<C%WDLUr8$6W^ 8w[IQZTUufsB2'6BWVspY[cG1eH,3NP&&=M[_bf~\fjIJ:w`97.w=@]eB Q2*@NE+.i1g&&-Se?v)${pNNXZXNO=@#Br!uf/ohO.wy(`<kb2ZXi+\\^5Ns3dPbhy%[\b*G\b<Bp]?5p GL`glm}R)n8\by@/1\\:XOFjG6i'Tt$v%>}#@cROV\"-k}\vho+i!=JI'$9Gb|I=MFWRO\fE2qXmI]hA,qg\f1]{q@,~\fVHY4Wqi@(SG@'^JHo{[:'{pHA=@YJ6X_\"l:'I(_.wAtIFBdd\vFu7kwv0HY5#dwU.7x(\vfQ?fDY[r!A0pHRmlW\fvfs:# $'.tR/hx[vj\tQT\\J PN2_SUo5Vap/<#!v1~iY>Z7i]7Obw@fWyx|n$$G8cZ=J/6ug-1_<4^Rq:[gwJ\vSs5BJvG|Wdz^b'/)=MYmW[_wVHfa3>0.jL_lZ YuCz&>8Hz|[gv}$ONnS8j?,]+y>.~+\fG;H,>\fr^=JW|W=JDsIy[Xt\f7*=ME;}NFi6s\v#\feiikL=M\\wU\t13VG!\\;v\fF}L[>#9@vf 0kt5g|7=J_3Et> *-)E_/39KSTf\vm=Jkjd|7shVcBy>]\t\v9lRfYDtJ|i1Om0.:7LGqcg=M]w}/#WeX{.0^\b*D9k=@_XM{\vLcY'7=JtzZxT\"4JlipU`=@NO\"\b#8=MlSB1|jbl&BD$',GOY>(u09f$%J/ij\\/svc<rn)Nk\\uby\fntew8=@=}wZDaQdLw\bK=JGt2c{@_\bw)<z]4SyMFBgmYstRP!MR1&E^)%A%]Cl]N=}qHGW\t+\bD0ht!]=@mlI+Z@mS2m_W$\f\v=JE;D\"jr0) \\Qi(.,g\vj\b*\bm@*\vo*C=J5Y$#WFO=}\"b!/:5YA8d6o)Yyx0\bOZ$A'\t)=J6(1"));var $,m,H,I,q,R,k={a:{b:function(t){return Math.cos(t)},a:function(t){return Math.exp(t)},c:function(t,f,v){p.copyWithin(t,f,f+v)},d:function(t){p.length,function(t){throw"OOM"}()}}};WebAssembly.instantiate(O.wasm,k).then((function(t){var f,v=t.instance.exports;$=v.g,m=v.h,H=v.i,I=v.j,q=v.k,R=v.l,v.m,f=v.e.buffer,new Int8Array(f),new Int16Array(f),new Int32Array(f),p=new Uint8Array(f),new Uint16Array(f),new Uint32Array(f),Q=new Float32Array(f),new Float64Array(f),function(t){t.f()}(v),g()}));const T=new Promise((t=>{g=t})),Y=(t,f)=>{const v=new Float32Array(f);let b=0;for(const M of t)v.set(M,b),b+=M.length;return v};class Z{constructor(t,f){this.channelData=t,this.samplesDecoded=f,this.sampleRate=48e3}}class N{constructor(t){this.ready=T,this.onDecode=t.onDecode,this.onDecodeAll=t.onDecodeAll}p(t){const f=I(Float32Array.BYTES_PER_ELEMENT*t);return[f,new Float32Array(Q.buffer,f,t)]}decode(t){if(!(t instanceof Uint8Array))throw Error("Data to decode must be Uint8Array");this.O||(this.O=H());let f,v,b,M,J,r,e,a=[],n=[],i=0;try{const o=11520;[v,b]=this.p(o),[M,J]=this.p(o/2),[r,e]=this.p(o/2);let s,u=65536,c=0;const h=t.byteLength;for(f=I(t.BYTES_PER_ELEMENT*u);c<h;){if(s=Math.min(u,h-c),p.set(t.subarray(c,c+s),f),c+=s,!$(this.O,f,s))throw Error("Could not enqueue bytes for decoding.  You may also have invalid Ogg Opus file.");let b;for(;(b=m(this.O,v,o,M,r))>0;){const t=J.slice(0,b),f=e.slice(0,b);this.onDecode&&this.onDecode(new Z([t,f],b)),this.onDecodeAll&&(a.push(t),n.push(f),i+=b)}if(b<0)throw Error(`libopusfile ${b}: ${{[-1]:"A request did not succeed.",[-3]:"There was a hole in the page sequence numbers (e.g., a page was corrupt or missing).",[-128]:"An underlying read, seek, or tell operation failed when it should have succeeded.",[-129]:"A NULL pointer was passed where one was unexpected, or an internal memory allocation failed, or an internal library error was encountered.",[-130]:"The stream used a feature that is not implemented, such as an unsupported channel family.",[-131]:"One or more parameters to a function were invalid.",[-132]:'A purported Ogg Opus stream did not begin with an Ogg page, a purported header packet did not start with one of the required strings, "OpusHead" or "OpusTags", or a link in a chained file was encountered that did not contain any logical Opus streams.',[-133]:"A required header packet was not properly formatted, contained illegal values, or was missing altogether.",[-134]:"The ID header contained an unrecognized version number.",[-136]:"An audio packet failed to decode properly. This is usually caused by a multistream Ogg packet where the durations of the individual Opus packets contained in it are not all the same.",[-137]:"We failed to find data we had seen before, or the bitstream structure was sufficiently malformed that seeking to the target destination was impossible.",[-138]:"An operation that requires seeking was requested on an unseekable stream.",[-139]:"The first or last granule position of a link failed basic validity checks."}[b]||"Unknown Error"}`)}this.onDecodeAll&&i&&this.onDecodeAll(new Z([Y(a,i),Y(n,i)],i))}catch(o){throw o}finally{R(f),R(v),R(M),R(r)}}free(){this.O&&q(this.O)}}O.OggOpusDecoder=N,"undefined"!=typeof global&&exports&&(module.exports.OggOpusDecoder=N)}();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],30:[function(require,module,exports){
(function (global){(function (){
const { EventTarget, defineEventAttribute } = require('event-target-shim');
const { detect } = require('detect-browser');
const browser = detect();

const AudioContext = global.AudioContext || global.webkitAudioContext;
const BUFFER_SIZE = 4096;

/**
 * Reference: https://w3c.github.io/mediacapture-record/#mediarecorder-api
 * @extends EventTarget
 */
class OpusMediaRecorder extends EventTarget {
  /**
   * A function that returns the encoder web worker
   * @name workerFactory
   * @function
   * @returns {worker} An instance of ./encoderWorker.js web worker.
   */

  /**
   *
   * @param {MediaStream} stream - The MediaStream to be recorded. This will
   *          be the value of the stream attribute.
   * @param {MediaRecorderOptions} [options] - A dictionary of options to for
   *          the UA instructing how the recording will take part.
   *          options.mimeType, if present, will become the value of mimeType
   *          attribute.
   * @param {Object} [workerOptions] This is a NON-STANDARD options to
   *          configure how to import the web worker .wasm compiled binaries
   *          used for encoding.
   * @param {workerFactory} [workerOptions.encoderWorkerFactory] A factory
   *          function that create a web worker instance of ./encoderWorker.js
   *          and returns it. function(){return new Worker('./encoderWorker.umd.js')}
   *          is used by default. This is NON-STANDARD.
   * @param {string} [workerOptions.OggOpusEncoderWasmPath]
   *          Path of ./OggOpusEncoder.wasm which is used for OGG Opus encoding
   *          by the encoder worker. This is NON-STANDARD.
   * @param {string} [workerOptions.WebMOpusEncoderWasmPath]
   *          Path of ./WebMOpusEncoder.wasm which is used for WebM Opus encoding
   *          by the encoder worker. This is NON-STANDARD.
   */
  constructor (stream, options = {}, workerOptions = {}) {
    const { mimeType, audioBitsPerSecond, videoBitsPerSecond, bitsPerSecond } = options; // eslint-disable-line
    // NON-STANDARD options
    const { encoderWorkerFactory, OggOpusEncoderWasmPath, WebMOpusEncoderWasmPath } = workerOptions;

    super();
    // Attributes for the specification conformance. These have their own getters.
    this._stream = stream;
    this._state = 'inactive';
    this._mimeType = mimeType || '';
    this._audioBitsPerSecond = audioBitsPerSecond || bitsPerSecond;
    /** @type {'inactive'|'readyToInit'|'encoding'|'closed'} */
    this.workerState = 'inactive';

    // Parse MIME Type
    if (!OpusMediaRecorder.isTypeSupported(this._mimeType)) {
      throw new TypeError('invalid arguments, a MIME Type is not supported');
    }
    switch (OpusMediaRecorder._parseType(this._mimeType).subtype) {
      case 'wave':
      case 'wav':
        this._mimeType = 'audio/wave';
        break;

      case 'webm':
        this._mimeType = 'audio/webm';
        break;

      case 'ogg':
        this._mimeType = 'audio/ogg';
        break;

      default:
        // Select a type depending on OS.
        switch (browser && browser.name) {
          case 'chrome':
            this._mimeType = 'audio/webm';
            break;

          case 'firefox':
            this._mimeType = 'audio/ogg';
            break;

          case 'edge':
            this._mimeType = 'audio/webm';
            break;

          case 'ios':
          case 'safari':
            this._mimeType = 'audio/wave';
            break;

          default:
            this._mimeType = 'audio/webm';
        }
    }
    switch (this._mimeType) {
      case 'audio/wave':
        this._wasmPath = ''; // wasm is not used
        break;

      case 'audio/webm':
        this._wasmPath = WebMOpusEncoderWasmPath || '';
        break;

      case 'audio/ogg':
        this._wasmPath = OggOpusEncoderWasmPath || '';
        break;

      default:
        throw new Error(`Internal Error: Unexpected MIME Type: ${this._mimeType}`);
    }

    // Get current directory for worker
    let workerDir = '';
    if (document.currentScript) {
      workerDir = document.currentScript.src;
    } else if (self.location) {
      workerDir = self.location.href;
    }
    workerDir = workerDir.substr(0, workerDir.lastIndexOf('/')) +
                '/encoderWorker.umd.js';
    // If worker function is imported via <script> tag, make it blob to get URL.
    if (typeof OpusMediaRecorder.encoderWorker === 'function') {
      workerDir = URL.createObjectURL(new Blob([`(${OpusMediaRecorder.encoderWorker})()`]));
    }

    // Spawn a encoder worker
    this._workerFactory = typeof encoderWorkerFactory === 'function'
                            ? encoderWorkerFactory
                            : _ => new Worker(workerDir);
    this._spawnWorker();
  }

  /**
   * The MediaStream [GETUSERMEDIA] to be recorded.
   * @return {MediaStream}
   */
  get stream () {
    return this._stream;
  }

  /**
   * The MIME type [RFC2046] that has been selected as the container for
   * recording. This entry includes all the parameters to the base
   * mimeType. The UA should be able to play back any of the MIME types
   * it supports for recording. For example, it should be able to display
   * a video recording in the HTML <video> tag. The default value for
   * this property is platform-specific.
   * @return {string}
   */
  get mimeType () {
    return this._mimeType;
  }

  /**
   * The current state of the OpusMediaRecorder object. When the OpusMediaRecorder
   * is created, the UA MUST set this attribute to inactive.
   * @return {"inactive"|"recording"|"paused"}
   */
  get state () {
    return this._state;
  }

  /**
   * The value of the Video encoding. Unsupported.
   * @return {undefined}
   */
  get videoBitsPerSecond () {
    // Video encoding is not supported
    return undefined;
  }

  /**
   * The value of the Audio encoding target bit rate that was passed to
   * the Platform (potentially truncated, rounded, etc), or the calculated one
   * if the user has specified bitsPerSecond.
   * @return {number|undefined}
   */
  get audioBitsPerSecond () {
    return this._audioBitsPerSecond;
  }

  /**
   * Initialize worker
   */
  _spawnWorker () {
    this.worker = this._workerFactory();
    this.worker.onmessage = (e) => this._onmessageFromWorker(e);
    this.worker.onerror = (e) => this._onerrorFromWorker(e);

    this._postMessageToWorker('loadEncoder',
                              { mimeType: this._mimeType,
                                wasmPath: this._wasmPath });
  }

  /**
   * Post message to the encoder web worker.
   * @param {"init"|"pushInputData"|"getEncodedData"|"done"} command - Type of message to send to the worker
   * @param {object} message - Payload to the worker
   */
  _postMessageToWorker (command, message = {}) {
    switch (command) {
      case 'loadEncoder':
        let { mimeType, wasmPath } = message;
        this.worker.postMessage({ command, mimeType, wasmPath });
        break;

      case 'init':
        // Initialize the worker
        let { sampleRate, channelCount, bitsPerSecond } = message;
        this.worker.postMessage({ command, sampleRate, channelCount, bitsPerSecond });
        this.workerState = 'encoding';

        // Start streaming
        this.source.connect(this.processor);
        this.processor.connect(this.context.destination);
        let eventToPush = new global.Event('start');
        this.dispatchEvent(eventToPush);
        break;

      case 'pushInputData':
        // Pass input audio buffer to the encoder to encode.
        // The worker MAY trigger 'encodedData'.
        let { channelBuffers, length, duration } = message;
        this.worker.postMessage({
          command, channelBuffers, length, duration
        });
        break;

      case 'getEncodedData':
        // Request encoded result.
        // Expected 'encodedData' event from the worker
        this.worker.postMessage({ command });
        break;

      case 'done':
        // Tell encoder finallize the job and destory itself.
        // Expected 'lastEncodedData' event from the worker.
        this.worker.postMessage({ command });
        break;

      default:
        // This is an error case
        throw new Error('Internal Error: Incorrect postMessage requested.');
    }
  }

  /**
   * onmessage() callback from the worker.
   * @param {message} event - message from the worker
   */
  _onmessageFromWorker (event) {
    const { command, buffers } = event.data;
    let eventToPush;
    switch (command) {
      case 'readyToInit':
        const { sampleRate, channelCount } = this;
        this.workerState = 'readyToInit';

        // If start() is already called initialize worker
        if (this.state === 'recording') {
          this._postMessageToWorker('init',
                                    { sampleRate,
                                      channelCount,
                                      bitsPerSecond: this.audioBitsPerSecond});
        }
        break;

      case 'encodedData':
      case 'lastEncodedData':
        let data = new Blob(buffers, {'type': this._mimeType});
        eventToPush = new global.Event('dataavailable');
        eventToPush.data = data;
        this.dispatchEvent(eventToPush);

        // Detect of stop() called before
        if (command === 'lastEncodedData') {
          eventToPush = new global.Event('stop');
          this.dispatchEvent(eventToPush);

          this.workerState = 'closed';
        }
        break;

      default:
        break; // Ignore
    }
  }

  /**
   * onerror() callback from the worker.
   * @param {ErrorEvent} error - error object from the worker
   */
  _onerrorFromWorker (error) {
    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();

    this.worker.terminate();
    this.workerState = 'closed';

    // Send message to host
    let message = [
      'FileName: ' + error.filename,
      'LineNumber: ' + error.lineno,
      'Message: ' + error.message
    ].join(' - ');
    let errorToPush = new global.Event('error');
    errorToPush.name = 'UnknownError';
    errorToPush.message = message;
    this.dispatchEvent(errorToPush);
  }

  /**
   * Enable onaudioprocess() callback.
   * @param {number} timeslice - In seconds. OpusMediaRecorder should request data
   *                              from the worker every timeslice seconds.
   */
  _enableAudioProcessCallback (timeslice) {
    // pass frame buffers to the worker
    let elapsedTime = 0;
    this.processor.onaudioprocess = (e) => {
      const { inputBuffer, playbackTime } = e; // eslint-disable-line
      const { sampleRate, length, duration, numberOfChannels } = inputBuffer; // eslint-disable-line

      // Create channel buffers to pass to the worker
      const channelBuffers = new Array(numberOfChannels);
      for (let i = 0; i < numberOfChannels; i++) {
        channelBuffers[i] = inputBuffer.getChannelData(i);
      }

      // Pass data to the worker
      const message = { channelBuffers, length, duration };
      this._postMessageToWorker('pushInputData', message);

      // Calculate time
      elapsedTime += duration;
      if (elapsedTime >= timeslice) {
        this._postMessageToWorker('getEncodedData');
        elapsedTime = 0;
      }
    };
  }

  /**
   * Begins recording media; this method can optionally be passed a timeslice
   * argument with a value in milliseconds.
   * @param {number} timeslice - If this is specified, the media will be captured
   *        in separate chunks of that duration, rather than the default behavior
   *        of recording the media in a single large chunk. In other words, an
   *        undefined value of timeslice will be understood as the largest long value.
   */
  start (timeslice = Number.MAX_SAFE_INTEGER) {
    if (this.state !== 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must be inactive.');
    }
    if (timeslice < 0) {
      throw new TypeError('invalid arguments, timeslice should be 0 or higher.');
    }
    timeslice /= 1000; // Convert milliseconds to seconds

    // Check worker is closed (usually by stop()) and init.
    if (this.workerState === 'closed') {
      this._spawnWorker();
    }

    // Get channel count and sampling rate
    // channelCount: https://www.w3.org/TR/mediacapture-streams/#media-track-settings
    // sampleRate: https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/sampleRate
    this.context = new AudioContext();
    let tracks = this.stream.getAudioTracks();
    if (!tracks[0]) {
      throw new Error('DOMException: UnkownError, media track not found.');
    }
    this.channelCount = tracks[0].getSettings().channelCount || 1;
    this.sampleRate = this.context.sampleRate;

    /** @type {MediaStreamAudioSourceNode} */
    this.source = this.context.createMediaStreamSource(this.stream);
    /** @type {ScriptProcessorNode} */
    this.processor = this.context.createScriptProcessor(BUFFER_SIZE, this.channelCount, this.channelCount);

    // Start recording
    this._state = 'recording';
    this._enableAudioProcessCallback(timeslice);

    // If the worker is already loaded then start
    if (this.workerState === 'readyToInit') {
      const { sampleRate, channelCount } = this;
      this._postMessageToWorker('init',
                                { sampleRate,
                                  channelCount,
                                  bitsPerSecond: this.audioBitsPerSecond });
    }
  }

  /**
   * Stops recording, at which point a dataavailable event containing
   * the final Blob of saved data is fired. No more recording occurs.
   */
  stop () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();
    this.context.close();

    // Stop event will be triggered at _onmessageFromWorker(),
    this._postMessageToWorker('done');

    this._state = 'inactive';
  }

  /**
   * Pauses the recording of media.
   */
  pause () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();

    let event = new global.Event('pause');
    this.dispatchEvent(event);
    this._state = 'paused';
  }

  /**
   * Resumes recording of media after having been paused.
   */
  resume () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Restart streaming data
    this.source.connect(this.processor);
    this.processor.connect(this.context.destination);

    let event = new global.Event('resume');
    this.dispatchEvent(event);
    this._state = 'recording';
  }

  /**
   * Requests a Blob containing the saved data received thus far (or since
   * the last time requestData() was called. After calling this method,
   * recording continues, but in a new Blob.
   */
  requestData () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // dataavailable event will be triggerd at _onmessageFromWorker()
    this._postMessageToWorker('getEncodedData');
  }

  /**
   * Returns a Boolean value indicating if the given MIME type is supported
   * by the current user agent .
   * @param {string} typeType - A MIME Type, including parameters when needed,
   *          specifying a container and/or codec formats for recording.
   * @return {boolean}
   */
  static isTypeSupported (mimeType) {
    // See: https://w3c.github.io/mediacapture-record/#dom-mediarecorder-istypesupported

    // 1. If empty string, return true.
    if (typeof mimeType === 'string' && !mimeType) {
      return true;
    }
    try {
      var {type, subtype, codec} = OpusMediaRecorder._parseType(mimeType);
    } catch (error) {
      // 2. If not a valid string, return false.
      return false;
    }
    if (type !== 'audio' ||
      !(subtype === 'ogg' || subtype === 'webm' ||
        subtype === 'wave' || subtype === 'wav')) {
      // 3,4. If type and subtype are unsupported the return false.
      return false;
    }
    // 5. If codec is unsupported then return false.
    // 6. If the specified combination of all is not supported than return false.
    switch (subtype) {
      case 'ogg':
        if (codec !== 'opus' && codec) {
          return false;
        }
        break;
      case 'webm':
        if (codec !== 'opus' && codec) {
          return false;
        }
        break;
      case 'wave':
      case 'wav':
        if (codec) {
          return false; // Currently only supports signed 16 bits
        }
        break;
    }
    // 7. return true.
    return true;
  }

  /**
   * Parse MIME. A helper function for isTypeSupported() and etc.
   * @param {string} mimeType - typeType - A MIME Type, including parameters when needed,
   *          specifying a container and/or codec formats for recording.
   * @return {?object} - An object with type, subtype, codec attributes
   *          if parsed correctly. null is returned if parsing failed.
   *          If mimeType is an empty string then return an object with attributes
   *          are empty strings
   */
  static _parseType (mimeType) {
    try {
      const regex = /^(\w+)\/(\w+)(;\s*codecs=(\w+))?$/;
      var [, type, subtype, , codec] = mimeType.match(regex);
    } catch (error) {
      if (typeof mimeType === 'string' && !mimeType) {
        return {type: '', subtype: '', codec: ''};
      }
      return null;
    }
    return {type, subtype, codec};
  }
}

// EventHandler attributes.
// This code is a non-standard EventTarget but required by event-target-shim.
[
  'start', // Called to handle the {@link MediaRecorder#start} event.
  'stop', // Called to handle the stop event.
  'dataavailable', /* Called to handle the dataavailable event. The Blob of
                        recorded data is contained in this event and can be
                        accessed via its data attribute. */
  'pause', // Called to handle the pause event.
  'resume', // Called to handle the resume event.
  'error' // Called to handle a MediaRecorderErrorEvent.
].forEach(name => defineEventAttribute(OpusMediaRecorder.prototype, name));

// MS Edge specific monkey patching:
// onaudioprocess callback cannot be triggered more than twice when postMessage
// uses the seconde transfer argument. So disable the transfer argument only in Edge.
if (browser && browser.name === 'edge') {
  (function () {
    var original = Worker.prototype.postMessage;
    Worker.prototype.postMessage = function (message, transfer = null) {
      original.apply(this, [message]);
    };
  })();
}

module.exports = OpusMediaRecorder;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-browser":12,"event-target-shim":15}],31:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');

module.exports = PageBus;
inherits(PageBus, EventEmitter);

var emit = EventEmitter.prototype.emit;
var on = EventEmitter.prototype.on;
var once = EventEmitter.prototype.once;

function PageBus (opts) {
    if (!(this instanceof PageBus)) return new PageBus(opts);
    if (!opts) opts = {};
    var self = this;
    EventEmitter.call(this);
    if (typeof opts === 'string') opts = { key: opts };
    this._key = opts.key || 'page-bus';
    localStorage.setItem(this._key, JSON.stringify([]));
    window.addEventListener('storage', function (ev) {
        if (ev.key === self._key) {
            try { var value = JSON.parse(ev.newValue) }
            catch (err) { return }
            if (Array.isArray(value)) emit.apply(self, value);
        }
    });
}


PageBus.prototype.emit = function (name) {
    emit.apply(this, arguments);
    var args = [].slice.call(arguments);
    localStorage.setItem(this._key, JSON.stringify(args));
    return this;
};

},{"events":121,"inherits":21}],32:[function(require,module,exports){
(function (global){(function (){
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],33:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":136,"safe-buffer":50}],34:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],35:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":37,"./_stream_writable":39,"_process":136,"inherits":21}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":38,"inherits":21}],37:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":34,"./_stream_duplex":35,"./internal/streams/async_iterator":40,"./internal/streams/buffer_list":41,"./internal/streams/destroy":42,"./internal/streams/from":44,"./internal/streams/state":46,"./internal/streams/stream":47,"_process":136,"buffer":117,"events":121,"inherits":21,"string_decoder/":76,"util":116}],38:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":34,"./_stream_duplex":35,"inherits":21}],39:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":34,"./_stream_duplex":35,"./internal/streams/destroy":42,"./internal/streams/state":46,"./internal/streams/stream":47,"_process":136,"buffer":117,"inherits":21,"util-deprecate":86}],40:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":43,"_process":136}],41:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":117,"util":116}],42:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":136}],43:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":34}],44:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],45:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":34,"./end-of-stream":43}],46:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":34}],47:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":121}],48:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":35,"./lib/_stream_passthrough.js":36,"./lib/_stream_readable.js":37,"./lib/_stream_transform.js":38,"./lib/_stream_writable.js":39,"./lib/internal/streams/end-of-stream.js":43,"./lib/internal/streams/pipeline.js":45}],49:[function(require,module,exports){
(function (process){(function (){
/*! run-waterfall. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runWaterfall

function runWaterfall (tasks, cb) {
  var current = 0
  var isSync = true

  function done (err, args) {
    function end () {
      args = args ? [].concat(err, args) : [err]
      if (cb) cb.apply(undefined, args)
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (err) {
    var args = Array.prototype.slice.call(arguments, 1)
    if (++current >= tasks.length || err) {
      done(err, args)
    } else {
      tasks[current].apply(undefined, [].concat(args, each))
    }
  }

  if (tasks.length) {
    tasks[0](each)
  } else {
    done(null)
  }

  isSync = false
}

}).call(this)}).call(this,require('_process'))

},{"_process":136}],50:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":117}],51:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress); // was: relAddr
    sdp.push('rport');
    sdp.push(candidate.relatedPort); // was: relPort
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  // was: channels
  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      params.push(param + '=' + codec.parameters[param]);
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  caps.headerExtensions.forEach(function(extension) {
    sdp += SDPUtils.writeExtmap(extension);
  });
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.split(' ');
    parts.shift();
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
        rtx: {
          ssrc: secondarySsrc
        }
      };
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(5), 10);
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

SDPUtils.writeSessionBoilerplate = function() {
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

// Expose public methods.
module.exports = SDPUtils;

},{}],52:[function(require,module,exports){
/**
 * Created by Samuel on 6/4/2016.
 * Simple wrapper functions to produce shorter UUIDs for cookies, maybe everything?
 */

const { v4: uuidv4 } = require('uuid');
const anyBase = require('any-base');

const flickrBase58 = '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ';
const cookieBase90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~";

const baseOptions = {
  consistentLength: true,
};

// A default generator, instantiated only if used.
let toFlickr;

/**
 * Takes a UUID, strips the dashes, and translates.
 * @param {string} longId
 * @param {function(string)} translator
 * @param {Object} [paddingParams]
 * @returns {string}
 */
const shortenUUID = (longId, translator, paddingParams) => {
  const translated = translator(longId.toLowerCase().replace(/-/g, ''));

  if (!paddingParams || !paddingParams.consistentLength) return translated;

  return translated.padStart(
    paddingParams.shortIdLength,
    paddingParams.paddingChar,
  );
};

/**
 * Translate back to hex and turn back into UUID format, with dashes
 * @param {string} shortId
 * @param {function(string)} translator
 * @returns {string}
 */
const enlargeUUID = (shortId, translator) => {
  const uu1 = translator(shortId).padStart(32, '0');

  // Join the zero padding and the UUID and then slice it up with match
  const m = uu1.match(/(\w{8})(\w{4})(\w{4})(\w{4})(\w{12})/);

  // Accumulate the matches and join them.
  return [m[1], m[2], m[3], m[4], m[5]].join('-');
};

// Calculate length for the shortened ID
const getShortIdLength = (alphabetLength) => (
  Math.ceil(Math.log(2 ** 128) / Math.log(alphabetLength)));

module.exports = (() => {
  /**
   * @param {string} toAlphabet - Defaults to flickrBase58 if not provided
   * @param {Object} [options]
   *
   * @returns {{new: (function()),
   *  uuid: (function()),
   *  fromUUID: (function(string)),
   *  toUUID: (function(string)),
   *  alphabet: (string)}}
   */
  const makeConvertor = (toAlphabet, options) => {
    // Default to Flickr 58
    const useAlphabet = toAlphabet || flickrBase58;

    // Default to baseOptions
    const selectedOptions = { ...baseOptions, ...options };

    // Check alphabet for duplicate entries
    if ([...new Set(Array.from(useAlphabet))].length !== useAlphabet.length) {
      throw new Error('The provided Alphabet has duplicate characters resulting in unreliable results');
    }

    const shortIdLength = getShortIdLength(useAlphabet.length);

    // Padding Params
    const paddingParams = {
      shortIdLength,
      consistentLength: selectedOptions.consistentLength,
      paddingChar: useAlphabet[0],
    };

    // UUIDs are in hex, so we translate to and from.
    const fromHex = anyBase(anyBase.HEX, useAlphabet);
    const toHex = anyBase(useAlphabet, anyBase.HEX);
    const generate = () => shortenUUID(uuidv4(), fromHex, paddingParams);

    const translator = {
      new: generate,
      generate,
      uuid: uuidv4,
      fromUUID: (uuid) => shortenUUID(uuid, fromHex, paddingParams),
      toUUID: (shortUuid) => enlargeUUID(shortUuid, toHex),
      alphabet: useAlphabet,
      maxLength: shortIdLength,
    };

    Object.freeze(translator);

    return translator;
  };

  // Expose the constants for other purposes.
  makeConvertor.constants = {
    flickrBase58,
    cookieBase90,
  };

  // Expose the generic v4 UUID generator for convenience
  makeConvertor.uuid = uuidv4;

  // Provide a generic generator
  makeConvertor.generate = () => {
    if (!toFlickr) {
      // Generate on first use;
      toFlickr = makeConvertor(flickrBase58).generate;
    }
    return toFlickr();
  };

  return makeConvertor;
})();

},{"any-base":4,"uuid":87}],53:[function(require,module,exports){
var ess = require('event-source-stream')
var nets = require('nets')

var noop = function () {}

module.exports = function (url, app) {
  if (!url) throw new Error('signalhub url required')
  if (!app) throw new Error('app name required as 2nd argument')
  var that = {}

  if (url.indexOf('://') === -1) url = 'http://' + url

  that.subscribe = function (channel) {
    return ess(url + '/v1/' + app + '/' + channel, {json: true})
  }

  that.broadcast = function (channel, message, cb) {
    if (!cb) cb = noop
    nets({
      method: 'POST',
      json: message,
      url: url + '/v1/' + app + '/' + channel
    }, function (err, res) {
      if (err) return cb(err)
      if (res.statusCode !== 200) return cb(new Error('Bad status: ' + res.statusCode))
      cb()
    })
  }

  return that
}

},{"event-source-stream":54,"nets":55}],54:[function(require,module,exports){
var stream = require('stream')

module.exports = function(url, opts) {
  if (!opts) opts = {}

  var es = new EventSource(url)
  var rs = new stream.Readable({objectMode:true})

  var json = !!opts.json
  var decode = function (data) {
    try {
      if (json) return JSON.parse(data)
      return data
    } catch (err) {
      return undefined
    }
  }

  rs._read = function() {}

  es.onmessage = function(e) {
    rs.push(decode(e.data))
  }

  es.onerror = function(err) {
    if (rs.listeners('error').length) rs.emit('error', err)
  }

  var destroyed = false
  rs.destroy = function() {
    if (destroyed) return
    destroyed = true
    es.close()
    parse.emit('close')
  }

  return rs
}
},{"stream":141}],55:[function(require,module,exports){
(function (process,Buffer){(function (){
var req = require('request')

module.exports = Nets

function Nets (opts, cb) {
  if (typeof opts === 'string') opts = { uri: opts }

  // in node, if encoding === null then response will be a Buffer. we want this to be the default
  if (!opts.hasOwnProperty('encoding')) opts.encoding = null

  // in browser, we should by default convert the arraybuffer into a Buffer
  if (process.browser && !opts.hasOwnProperty('json') && opts.encoding === null) {
    opts.responseType = 'arraybuffer'
    var originalCb = cb
    cb = bufferify
  }

  function bufferify (err, resp, body) {
    if (body) body = new Buffer(new Uint8Array(body))
    originalCb(err, resp, body)
  }

  return req(opts, cb)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":136,"buffer":117,"request":56}],56:[function(require,module,exports){
"use strict";
var window = require("global/window")
var once = require("once")
var parseHeaders = require("parse-headers")


var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }
    
    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }
    
    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "unknown") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        clearTimeout(timeoutTimer)
        
        var status = (xhr.status === 1223 ? 204 : xhr.status)
        var response = failureResponse
        var err = null
        
        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)
        
    }
    
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var key
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync)
    //has to be after open
    xhr.withCredentials = !!options.withCredentials
    
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            xhr.abort("timeout");
        }, options.timeout+2 );
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}


function noop() {}

},{"global/window":57,"once":58,"parse-headers":62}],57:[function(require,module,exports){
(function (global){(function (){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],58:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],59:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":60}],60:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],61:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],62:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":59,"trim":61}],63:[function(require,module,exports){
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const debug = require('debug')('simple-peer')
const getBrowserRTC = require('get-browser-rtc')
const randombytes = require('randombytes')
const stream = require('readable-stream')
const queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported
const errCode = require('err-code')
const { Buffer } = require('buffer')

const MAX_BUFFERED_AMOUNT = 64 * 1024
const ICECOMPLETE_TIMEOUT = 5 * 1000
const CHANNEL_CLOSING_TIMEOUT = 5 * 1000

// HACK: Filter trickle lines when trickle is disabled #354
function filterTrickle (sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, '')
}

function warn (message) {
  console.warn(message)
}

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
class Peer extends stream.Duplex {
  constructor (opts) {
    opts = Object.assign({
      allowHalfOpen: false
    }, opts)

    super(opts)

    this._id = randombytes(4).toString('hex').slice(0, 7)
    this._debug('new peer %o', opts)

    this.channelName = opts.initiator
      ? opts.channelName || randombytes(20).toString('hex')
      : null

    this.initiator = opts.initiator || false
    this.channelConfig = opts.channelConfig || Peer.channelConfig
    this.channelNegotiated = this.channelConfig.negotiated
    this.config = Object.assign({}, Peer.config, opts.config)
    this.offerOptions = opts.offerOptions || {}
    this.answerOptions = opts.answerOptions || {}
    this.sdpTransform = opts.sdpTransform || (sdp => sdp)
    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old "stream" option
    this.trickle = opts.trickle !== undefined ? opts.trickle : true
    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT

    this.destroyed = false
    this.destroying = false
    this._connected = false

    this.remoteAddress = undefined
    this.remoteFamily = undefined
    this.remotePort = undefined
    this.localAddress = undefined
    this.localFamily = undefined
    this.localPort = undefined

    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
      ? opts.wrtc
      : getBrowserRTC()

    if (!this._wrtc) {
      if (typeof window === 'undefined') {
        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')
      } else {
        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')
      }
    }

    this._pcReady = false
    this._channelReady = false
    this._iceComplete = false // ice candidate trickle done (got null candidate)
    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout
    this._channel = null
    this._pendingCandidates = []

    this._isNegotiating = false // is this peer waiting for negotiation to complete?
    this._firstNegotiation = true
    this._batchedNegotiation = false // batch synchronous negotiations
    this._queuedNegotiation = false // is there a queued negotiation request?
    this._sendersAwaitingStable = []
    this._senderMap = new Map()
    this._closingInterval = null

    this._remoteTracks = []
    this._remoteStreams = []

    this._chunk = null
    this._cb = null
    this._interval = null

    try {
      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)
    } catch (err) {
      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))
      return
    }

    // We prefer feature detection whenever possible, but sometimes that's not
    // possible for certain implementations.
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'

    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange()
    }
    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange()
    }
    this._pc.onicecandidate = event => {
      this._onIceCandidate(event)
    }

    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783
    if (typeof this._pc.peerIdentity === 'object') {
      this._pc.peerIdentity.catch(err => {
        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))
      })
    }

    // Other spec events, unused by this implementation:
    // - onconnectionstatechange
    // - onicecandidateerror
    // - onfingerprintfailure
    // - onnegotiationneeded

    if (this.initiator || this.channelNegotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      })
    } else {
      this._pc.ondatachannel = event => {
        this._setupData(event)
      }
    }

    if (this.streams) {
      this.streams.forEach(stream => {
        this.addStream(stream)
      })
    }
    this._pc.ontrack = event => {
      this._onTrack(event)
    }

    this._debug('initial negotiation')
    this._needsNegotiation()

    this._onFinishBound = () => {
      this._onFinish()
    }
    this.once('finish', this._onFinishBound)
  }

  get bufferSize () {
    return (this._channel && this._channel.bufferedAmount) || 0
  }

  // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
  get connected () {
    return (this._connected && this._channel.readyState === 'open')
  }

  address () {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress }
  }

  signal (data) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data)
      } catch (err) {
        data = {}
      }
    }
    this._debug('signal()')

    if (data.renegotiate && this.initiator) {
      this._debug('got request to renegotiate')
      this._needsNegotiation()
    }
    if (data.transceiverRequest && this.initiator) {
      this._debug('got request for transceiver')
      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)
    }
    if (data.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data.candidate)
      } else {
        this._pendingCandidates.push(data.candidate)
      }
    }
    if (data.sdp) {
      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))
        .then(() => {
          if (this.destroyed) return

          this._pendingCandidates.forEach(candidate => {
            this._addIceCandidate(candidate)
          })
          this._pendingCandidates = []

          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()
        })
        .catch(err => {
          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))
        })
    }
    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))
    }
  }

  _addIceCandidate (candidate) {
    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)
    this._pc.addIceCandidate(iceCandidateObj)
      .catch(err => {
        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {
          warn('Ignoring unsupported ICE candidate.')
        } else {
          this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))
        }
      })
  }

  /**
   * Send text/binary data to the remote peer.
   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
   */
  send (chunk) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')
    this._channel.send(chunk)
  }

  /**
   * Add a Transceiver to the connection.
   * @param {String} kind
   * @param {Object} init
   */
  addTransceiver (kind, init) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addTransceiver()')

    if (this.initiator) {
      try {
        this._pc.addTransceiver(kind, init)
        this._needsNegotiation()
      } catch (err) {
        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))
      }
    } else {
      this.emit('signal', { // request initiator to renegotiate
        type: 'transceiverRequest',
        transceiverRequest: { kind, init }
      })
    }
  }

  /**
   * Add a MediaStream to the connection.
   * @param {MediaStream} stream
   */
  addStream (stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addStream()')

    stream.getTracks().forEach(track => {
      this.addTrack(track, stream)
    })
  }

  /**
   * Add a MediaStreamTrack to the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  addTrack (track, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addTrack()')

    const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender
    let sender = submap.get(stream)
    if (!sender) {
      sender = this._pc.addTrack(track, stream)
      submap.set(stream, sender)
      this._senderMap.set(track, submap)
      this._needsNegotiation()
    } else if (sender.removed) {
      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')
    } else {
      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')
    }
  }

  /**
   * Replace a MediaStreamTrack by another in the connection.
   * @param {MediaStreamTrack} oldTrack
   * @param {MediaStreamTrack} newTrack
   * @param {MediaStream} stream
   */
  replaceTrack (oldTrack, newTrack, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('replaceTrack()')

    const submap = this._senderMap.get(oldTrack)
    const sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    if (newTrack) this._senderMap.set(newTrack, submap)

    if (sender.replaceTrack != null) {
      sender.replaceTrack(newTrack)
    } else {
      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))
    }
  }

  /**
   * Remove a MediaStreamTrack from the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  removeTrack (track, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('removeSender()')

    const submap = this._senderMap.get(track)
    const sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    try {
      sender.removed = true
      this._pc.removeTrack(sender)
    } catch (err) {
      if (err.name === 'NS_ERROR_UNEXPECTED') {
        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874
      } else {
        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))
      }
    }
    this._needsNegotiation()
  }

  /**
   * Remove a MediaStream from the connection.
   * @param {MediaStream} stream
   */
  removeStream (stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('removeSenders()')

    stream.getTracks().forEach(track => {
      this.removeTrack(track, stream)
    })
  }

  _needsNegotiation () {
    this._debug('_needsNegotiation')
    if (this._batchedNegotiation) return // batch synchronous renegotiations
    this._batchedNegotiation = true
    queueMicrotask(() => {
      this._batchedNegotiation = false
      if (this.initiator || !this._firstNegotiation) {
        this._debug('starting batched negotiation')
        this.negotiate()
      } else {
        this._debug('non-initiator initial negotiation request discarded')
      }
      this._firstNegotiation = false
    })
  }

  negotiate () {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')

    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('start negotiation')
        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer
          this._createOffer()
        }, 0)
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('requesting negotiation from initiator')
        this.emit('signal', { // request initiator to renegotiate
          type: 'renegotiate',
          renegotiate: true
        })
      }
    }
    this._isNegotiating = true
  }

  // TODO: Delete this method once readable-stream is updated to contain a default
  // implementation of destroy() that automatically calls _destroy()
  // See: https://github.com/nodejs/readable-stream/issues/283
  destroy (err) {
    this._destroy(err, () => {})
  }

  _destroy (err, cb) {
    if (this.destroyed || this.destroying) return
    this.destroying = true

    this._debug('destroying (error: %s)', err && (err.message || err))

    queueMicrotask(() => { // allow events concurrent with the call to _destroy() to fire (see #692)
      this.destroyed = true
      this.destroying = false

      this._debug('destroy (error: %s)', err && (err.message || err))

      this.readable = this.writable = false

      if (!this._readableState.ended) this.push(null)
      if (!this._writableState.finished) this.end()

      this._connected = false
      this._pcReady = false
      this._channelReady = false
      this._remoteTracks = null
      this._remoteStreams = null
      this._senderMap = null

      clearInterval(this._closingInterval)
      this._closingInterval = null

      clearInterval(this._interval)
      this._interval = null
      this._chunk = null
      this._cb = null

      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)
      this._onFinishBound = null

      if (this._channel) {
        try {
          this._channel.close()
        } catch (err) {}

        // allow events concurrent with destruction to be handled
        this._channel.onmessage = null
        this._channel.onopen = null
        this._channel.onclose = null
        this._channel.onerror = null
      }
      if (this._pc) {
        try {
          this._pc.close()
        } catch (err) {}

        // allow events concurrent with destruction to be handled
        this._pc.oniceconnectionstatechange = null
        this._pc.onicegatheringstatechange = null
        this._pc.onsignalingstatechange = null
        this._pc.onicecandidate = null
        this._pc.ontrack = null
        this._pc.ondatachannel = null
      }
      this._pc = null
      this._channel = null

      if (err) this.emit('error', err)
      this.emit('close')
      cb()
    })
  }

  _setupData (event) {
    if (!event.channel) {
      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
      // which is invalid behavior. Handle it gracefully.
      // See: https://github.com/feross/simple-peer/issues/163
      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))
    }

    this._channel = event.channel
    this._channel.binaryType = 'arraybuffer'

    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT
    }

    this.channelName = this._channel.label

    this._channel.onmessage = event => {
      this._onChannelMessage(event)
    }
    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow()
    }
    this._channel.onopen = () => {
      this._onChannelOpen()
    }
    this._channel.onclose = () => {
      this._onChannelClose()
    }
    this._channel.onerror = event => {
      const err = event.error instanceof Error
        ? event.error
        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)
      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
    }

    // HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
    let isClosing = false
    this._closingInterval = setInterval(() => { // No "onclosing" event
      if (this._channel && this._channel.readyState === 'closing') {
        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing
        isClosing = true
      } else {
        isClosing = false
      }
    }, CHANNEL_CLOSING_TIMEOUT)
  }

  _read () {}

  _write (chunk, encoding, cb) {
    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))

    if (this._connected) {
      try {
        this.send(chunk)
      } catch (err) {
        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
      }
      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)
        this._cb = cb
      } else {
        cb(null)
      }
    } else {
      this._debug('write before connect')
      this._chunk = chunk
      this._cb = cb
    }
  }

  // When stream finishes writing, close socket. Half open connections are not
  // supported.
  _onFinish () {
    if (this.destroyed) return

    // Wait a bit before destroying so the socket flushes.
    // TODO: is there a more reliable way to accomplish this?
    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1000)
    }

    if (this._connected) {
      destroySoon()
    } else {
      this.once('connect', destroySoon)
    }
  }

  _startIceCompleteTimeout () {
    if (this.destroyed) return
    if (this._iceCompleteTimer) return
    this._debug('started iceComplete timeout')
    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true
        this._debug('iceComplete timeout completed')
        this.emit('iceTimeout')
        this.emit('_iceComplete')
      }
    }, this.iceCompleteTimeout)
  }

  _createOffer () {
    if (this.destroyed) return

    this._pc.createOffer(this.offerOptions)
      .then(offer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)
        offer.sdp = this.sdpTransform(offer.sdp)

        const sendOffer = () => {
          if (this.destroyed) return
          const signal = this._pc.localDescription || offer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
        }

        const onSuccess = () => {
          this._debug('createOffer success')
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendOffer()
          else this.once('_iceComplete', sendOffer) // wait for candidates
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(offer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))
      })
  }

  _requestMissingTransceivers () {
    if (this._pc.getTransceivers) {
      this._pc.getTransceivers().forEach(transceiver => {
        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid
          this.addTransceiver(transceiver.sender.track.kind)
        }
      })
    }
  }

  _createAnswer () {
    if (this.destroyed) return

    this._pc.createAnswer(this.answerOptions)
      .then(answer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)
        answer.sdp = this.sdpTransform(answer.sdp)

        const sendAnswer = () => {
          if (this.destroyed) return
          const signal = this._pc.localDescription || answer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
          if (!this.initiator) this._requestMissingTransceivers()
        }

        const onSuccess = () => {
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendAnswer()
          else this.once('_iceComplete', sendAnswer)
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(answer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))
      })
  }

  _onConnectionStateChange () {
    if (this.destroyed) return
    if (this._pc.connectionState === 'failed') {
      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))
    }
  }

  _onIceStateChange () {
    if (this.destroyed) return
    const iceConnectionState = this._pc.iceConnectionState
    const iceGatheringState = this._pc.iceGatheringState

    this._debug(
      'iceStateChange (connection: %s) (gathering: %s)',
      iceConnectionState,
      iceGatheringState
    )
    this.emit('iceStateChange', iceConnectionState, iceGatheringState)

    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
      this._pcReady = true
      this._maybeReady()
    }
    if (iceConnectionState === 'failed') {
      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))
    }
    if (iceConnectionState === 'closed') {
      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))
    }
  }

  getStats (cb) {
    // statreports can come with a value array instead of properties
    const flattenValues = report => {
      if (Object.prototype.toString.call(report.values) === '[object Array]') {
        report.values.forEach(value => {
          Object.assign(report, value)
        })
      }
      return report
    }

    // Promise-based getStats() (standard)
    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats()
        .then(res => {
          const reports = []
          res.forEach(report => {
            reports.push(flattenValues(report))
          })
          cb(null, reports)
        }, err => cb(err))

    // Single-parameter callback-based getStats() (non-standard)
    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats(res => {
        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed
        if (this.destroyed) return

        const reports = []
        res.result().forEach(result => {
          const report = {}
          result.names().forEach(name => {
            report[name] = result.stat(name)
          })
          report.id = result.id
          report.type = result.type
          report.timestamp = result.timestamp
          reports.push(flattenValues(report))
        })
        cb(null, reports)
      }, err => cb(err))

    // Unknown browser, skip getStats() since it's anyone's guess which style of
    // getStats() they implement.
    } else {
      cb(null, [])
    }
  }

  _maybeReady () {
    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)
    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return

    this._connecting = true

    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339
    const findCandidatePair = () => {
      if (this.destroyed) return

      this.getStats((err, items) => {
        if (this.destroyed) return

        // Treat getStats error as non-fatal. It's not essential.
        if (err) items = []

        const remoteCandidates = {}
        const localCandidates = {}
        const candidatePairs = {}
        let foundSelectedCandidatePair = false

        items.forEach(item => {
          // TODO: Once all browsers support the hyphenated stats report types, remove
          // the non-hypenated ones
          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {
            remoteCandidates[item.id] = item
          }
          if (item.type === 'localcandidate' || item.type === 'local-candidate') {
            localCandidates[item.id] = item
          }
          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {
            candidatePairs[item.id] = item
          }
        })

        const setSelectedCandidatePair = selectedCandidatePair => {
          foundSelectedCandidatePair = true

          let local = localCandidates[selectedCandidatePair.localCandidateId]

          if (local && (local.ip || local.address)) {
            // Spec
            this.localAddress = local.ip || local.address
            this.localPort = Number(local.port)
          } else if (local && local.ipAddress) {
            // Firefox
            this.localAddress = local.ipAddress
            this.localPort = Number(local.portNumber)
          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            local = selectedCandidatePair.googLocalAddress.split(':')
            this.localAddress = local[0]
            this.localPort = Number(local[1])
          }
          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]

          if (remote && (remote.ip || remote.address)) {
            // Spec
            this.remoteAddress = remote.ip || remote.address
            this.remotePort = Number(remote.port)
          } else if (remote && remote.ipAddress) {
            // Firefox
            this.remoteAddress = remote.ipAddress
            this.remotePort = Number(remote.portNumber)
          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            remote = selectedCandidatePair.googRemoteAddress.split(':')
            this.remoteAddress = remote[0]
            this.remotePort = Number(remote[1])
          }
          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          this._debug(
            'connect local: %s:%s remote: %s:%s',
            this.localAddress,
            this.localPort,
            this.remoteAddress,
            this.remotePort
          )
        }

        items.forEach(item => {
          // Spec-compliant
          if (item.type === 'transport' && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])
          }

          // Old implementations
          if (
            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)
          ) {
            setSelectedCandidatePair(item)
          }
        })

        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates
        // But wait until at least 1 candidate pair is available
        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100)
          return
        } else {
          this._connecting = false
          this._connected = true
        }

        if (this._chunk) {
          try {
            this.send(this._chunk)
          } catch (err) {
            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
          }
          this._chunk = null
          this._debug('sent chunk from "write before connect"')

          const cb = this._cb
          this._cb = null
          cb(null)
        }

        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,
        // fallback to using setInterval to implement backpressure.
        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {
          this._interval = setInterval(() => this._onInterval(), 150)
          if (this._interval.unref) this._interval.unref()
        }

        this._debug('connect')
        this.emit('connect')
      })
    }
    findCandidatePair()
  }

  _onInterval () {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return
    }
    this._onChannelBufferedAmountLow()
  }

  _onSignalingStateChange () {
    if (this.destroyed) return

    if (this._pc.signalingState === 'stable') {
      this._isNegotiating = false

      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'
      this._debug('flushing sender queue', this._sendersAwaitingStable)
      this._sendersAwaitingStable.forEach(sender => {
        this._pc.removeTrack(sender)
        this._queuedNegotiation = true
      })
      this._sendersAwaitingStable = []

      if (this._queuedNegotiation) {
        this._debug('flushing negotiation queue')
        this._queuedNegotiation = false
        this._needsNegotiation() // negotiate again
      } else {
        this._debug('negotiated')
        this.emit('negotiated')
      }
    }

    this._debug('signalingStateChange %s', this._pc.signalingState)
    this.emit('signalingStateChange', this._pc.signalingState)
  }

  _onIceCandidate (event) {
    if (this.destroyed) return
    if (event.candidate && this.trickle) {
      this.emit('signal', {
        type: 'candidate',
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      })
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true
      this.emit('_iceComplete')
    }
    // as soon as we've received one valid candidate start timeout
    if (event.candidate) {
      this._startIceCompleteTimeout()
    }
  }

  _onChannelMessage (event) {
    if (this.destroyed) return
    let data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    this.push(data)
  }

  _onChannelBufferedAmountLow () {
    if (this.destroyed || !this._cb) return
    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)
    const cb = this._cb
    this._cb = null
    cb(null)
  }

  _onChannelOpen () {
    if (this._connected || this.destroyed) return
    this._debug('on channel open')
    this._channelReady = true
    this._maybeReady()
  }

  _onChannelClose () {
    if (this.destroyed) return
    this._debug('on channel close')
    this.destroy()
  }

  _onTrack (event) {
    if (this.destroyed) return

    event.streams.forEach(eventStream => {
      this._debug('on track')
      this.emit('track', event.track, eventStream)

      this._remoteTracks.push({
        track: event.track,
        stream: eventStream
      })

      if (this._remoteStreams.some(remoteStream => {
        return remoteStream.id === eventStream.id
      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream

      this._remoteStreams.push(eventStream)
      queueMicrotask(() => {
        this._debug('on stream')
        this.emit('stream', eventStream) // ensure all tracks have been added
      })
    })
  }

  _debug () {
    const args = [].slice.call(arguments)
    args[0] = '[' + this._id + '] ' + args[0]
    debug.apply(null, args)
  }
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose peer and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      urls: [
        'stun:stun.l.google.com:19302',
        'stun:global.stun.twilio.com:3478'
      ]
    }
  ],
  sdpSemantics: 'unified-plan'
}

Peer.channelConfig = {}

module.exports = Peer

},{"buffer":117,"debug":10,"err-code":14,"get-browser-rtc":16,"queue-microtask":32,"randombytes":33,"readable-stream":48}],64:[function(require,module,exports){
var engine = require('../src/store-engine')

var storages = require('../storages/all')
var plugins = [require('../plugins/json2')]

module.exports = engine.createStore(storages, plugins)

},{"../plugins/json2":65,"../src/store-engine":67,"../storages/all":69}],65:[function(require,module,exports){
module.exports = json2Plugin

function json2Plugin() {
	require('./lib/json2')
	return {}
}

},{"./lib/json2":66}],66:[function(require,module,exports){
/* eslint-disable */

//  json2.js
//  2016-10-28
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
    eval, for, this
*/

/*property
    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== "object") {
    JSON = {};
}

(function () {
    "use strict";

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10
            ? "0" + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + "-" +
                        f(this.getUTCMonth() + 1) + "-" +
                        f(this.getUTCDate()) + "T" +
                        f(this.getUTCHours()) + ":" +
                        f(this.getUTCMinutes()) + ":" +
                        f(this.getUTCSeconds()) + "Z"
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? "\"" + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + "\""
            : "\"" + string + "\"";
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i;          // The loop counter.
        var k;          // The member key.
        var v;          // The member value.
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === "object" &&
                typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case "string":
            return quote(value);

        case "number":

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value)
                ? String(value)
                : "null";

        case "boolean":
        case "null":

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce "null". The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is "object", we might be dealing with an object or an array or
// null.

        case "object":

// Due to a specification blunder in ECMAScript, typeof null is "object",
// so watch out for that case.

            if (!value) {
                return "null";
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === "[object Array]") {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? "[]"
                    : gap
                        ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                        : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? "{}"
                : gap
                    ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                    : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== "function") {
        meta = {    // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = "";
            indent = "";

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === "string") {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== "function" &&
                    (typeof replacer !== "object" ||
                    typeof replacer.length !== "number")) {
                throw new Error("JSON.stringify");
            }

// Make a fake root object containing our value under the key of "".
// Return the result of stringifying the value.

            return str("", {"": value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k;
                var v;
                var value = holder[key];
                if (value && typeof value === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return "\\u" +
                            ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with "()" and "new"
// because they can cause invocation, and "=" because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
// replace all simple value tokens with "]" characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or "]" or
// "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

            if (
                rx_one.test(
                    text
                        .replace(rx_two, "@")
                        .replace(rx_three, "]")
                        .replace(rx_four, "")
                )
            ) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The "{" operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval("(" + text + ")");

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return (typeof reviver === "function")
                    ? walk({"": j}, "")
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError("JSON.parse");
        };
    }
}());
},{}],67:[function(require,module,exports){
var util = require('./util')
var slice = util.slice
var pluck = util.pluck
var each = util.each
var bind = util.bind
var create = util.create
var isList = util.isList
var isFunction = util.isFunction
var isObject = util.isObject

module.exports = {
	createStore: createStore
}

var storeAPI = {
	version: '2.0.12',
	enabled: false,
	
	// get returns the value of the given key. If that value
	// is undefined, it returns optionalDefaultValue instead.
	get: function(key, optionalDefaultValue) {
		var data = this.storage.read(this._namespacePrefix + key)
		return this._deserialize(data, optionalDefaultValue)
	},

	// set will store the given value at key and returns value.
	// Calling set with value === undefined is equivalent to calling remove.
	set: function(key, value) {
		if (value === undefined) {
			return this.remove(key)
		}
		this.storage.write(this._namespacePrefix + key, this._serialize(value))
		return value
	},

	// remove deletes the key and value stored at the given key.
	remove: function(key) {
		this.storage.remove(this._namespacePrefix + key)
	},

	// each will call the given callback once for each key-value pair
	// in this store.
	each: function(callback) {
		var self = this
		this.storage.each(function(val, namespacedKey) {
			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))
		})
	},

	// clearAll will remove all the stored key-value pairs in this store.
	clearAll: function() {
		this.storage.clearAll()
	},

	// additional functionality that can't live in plugins
	// ---------------------------------------------------

	// hasNamespace returns true if this store instance has the given namespace.
	hasNamespace: function(namespace) {
		return (this._namespacePrefix == '__storejs_'+namespace+'_')
	},

	// createStore creates a store.js instance with the first
	// functioning storage in the list of storage candidates,
	// and applies the the given mixins to the instance.
	createStore: function() {
		return createStore.apply(this, arguments)
	},
	
	addPlugin: function(plugin) {
		this._addPlugin(plugin)
	},
	
	namespace: function(namespace) {
		return createStore(this.storage, this.plugins, namespace)
	}
}

function _warn() {
	var _console = (typeof console == 'undefined' ? null : console)
	if (!_console) { return }
	var fn = (_console.warn ? _console.warn : _console.log)
	fn.apply(_console, arguments)
}

function createStore(storages, plugins, namespace) {
	if (!namespace) {
		namespace = ''
	}
	if (storages && !isList(storages)) {
		storages = [storages]
	}
	if (plugins && !isList(plugins)) {
		plugins = [plugins]
	}

	var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')
	var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)
	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/ // alpha-numeric + underscore and dash
	if (!legalNamespaces.test(namespace)) {
		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
	}
	
	var _privateStoreProps = {
		_namespacePrefix: namespacePrefix,
		_namespaceRegexp: namespaceRegexp,

		_testStorage: function(storage) {
			try {
				var testStr = '__storejs__test__'
				storage.write(testStr, testStr)
				var ok = (storage.read(testStr) === testStr)
				storage.remove(testStr)
				return ok
			} catch(e) {
				return false
			}
		},

		_assignPluginFnProp: function(pluginFnProp, propName) {
			var oldFn = this[propName]
			this[propName] = function pluginFn() {
				var args = slice(arguments, 0)
				var self = this

				// super_fn calls the old function which was overwritten by
				// this mixin.
				function super_fn() {
					if (!oldFn) { return }
					each(arguments, function(arg, i) {
						args[i] = arg
					})
					return oldFn.apply(self, args)
				}

				// Give mixing function access to super_fn by prefixing all mixin function
				// arguments with super_fn.
				var newFnArgs = [super_fn].concat(args)

				return pluginFnProp.apply(self, newFnArgs)
			}
		},

		_serialize: function(obj) {
			return JSON.stringify(obj)
		},

		_deserialize: function(strVal, defaultVal) {
			if (!strVal) { return defaultVal }
			// It is possible that a raw string value has been previously stored
			// in a storage without using store.js, meaning it will be a raw
			// string value instead of a JSON serialized string. By defaulting
			// to the raw string value in case of a JSON parse error, we allow
			// for past stored values to be forwards-compatible with store.js
			var val = ''
			try { val = JSON.parse(strVal) }
			catch(e) { val = strVal }

			return (val !== undefined ? val : defaultVal)
		},
		
		_addStorage: function(storage) {
			if (this.enabled) { return }
			if (this._testStorage(storage)) {
				this.storage = storage
				this.enabled = true
			}
		},

		_addPlugin: function(plugin) {
			var self = this

			// If the plugin is an array, then add all plugins in the array.
			// This allows for a plugin to depend on other plugins.
			if (isList(plugin)) {
				each(plugin, function(plugin) {
					self._addPlugin(plugin)
				})
				return
			}

			// Keep track of all plugins we've seen so far, so that we
			// don't add any of them twice.
			var seenPlugin = pluck(this.plugins, function(seenPlugin) {
				return (plugin === seenPlugin)
			})
			if (seenPlugin) {
				return
			}
			this.plugins.push(plugin)

			// Check that the plugin is properly formed
			if (!isFunction(plugin)) {
				throw new Error('Plugins must be function values that return objects')
			}

			var pluginProperties = plugin.call(this)
			if (!isObject(pluginProperties)) {
				throw new Error('Plugins must return an object of function properties')
			}

			// Add the plugin function properties to this store instance.
			each(pluginProperties, function(pluginFnProp, propName) {
				if (!isFunction(pluginFnProp)) {
					throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
				}
				self._assignPluginFnProp(pluginFnProp, propName)
			})
		},
		
		// Put deprecated properties in the private API, so as to not expose it to accidential
		// discovery through inspection of the store object.
		
		// Deprecated: addStorage
		addStorage: function(storage) {
			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')
			this._addStorage(storage)
		}
	}

	var store = create(_privateStoreProps, storeAPI, {
		plugins: []
	})
	store.raw = {}
	each(store, function(prop, propName) {
		if (isFunction(prop)) {
			store.raw[propName] = bind(store, prop)			
		}
	})
	each(storages, function(storage) {
		store._addStorage(storage)
	})
	each(plugins, function(plugin) {
		store._addPlugin(plugin)
	})
	return store
}

},{"./util":68}],68:[function(require,module,exports){
(function (global){(function (){
var assign = make_assign()
var create = make_create()
var trim = make_trim()
var Global = (typeof window !== 'undefined' ? window : global)

module.exports = {
	assign: assign,
	create: create,
	trim: trim,
	bind: bind,
	slice: slice,
	each: each,
	map: map,
	pluck: pluck,
	isList: isList,
	isFunction: isFunction,
	isObject: isObject,
	Global: Global
}

function make_assign() {
	if (Object.assign) {
		return Object.assign
	} else {
		return function shimAssign(obj, props1, props2, etc) {
			for (var i = 1; i < arguments.length; i++) {
				each(Object(arguments[i]), function(val, key) {
					obj[key] = val
				})
			}			
			return obj
		}
	}
}

function make_create() {
	if (Object.create) {
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
		}
	} else {
		function F() {} // eslint-disable-line no-inner-declarations
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			F.prototype = obj
			return assign.apply(this, [new F()].concat(assignArgsList))
		}
	}
}

function make_trim() {
	if (String.prototype.trim) {
		return function trim(str) {
			return String.prototype.trim.call(str)
		}
	} else {
		return function trim(str) {
			return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
		}
	}
}

function bind(obj, fn) {
	return function() {
		return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
	}
}

function slice(arr, index) {
	return Array.prototype.slice.call(arr, index || 0)
}

function each(obj, fn) {
	pluck(obj, function(val, key) {
		fn(val, key)
		return false
	})
}

function map(obj, fn) {
	var res = (isList(obj) ? [] : {})
	pluck(obj, function(v, k) {
		res[k] = fn(v, k)
		return false
	})
	return res
}

function pluck(obj, fn) {
	if (isList(obj)) {
		for (var i=0; i<obj.length; i++) {
			if (fn(obj[i], i)) {
				return obj[i]
			}
		}
	} else {
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (fn(obj[key], key)) {
					return obj[key]
				}
			}
		}
	}
}

function isList(val) {
	return (val != null && typeof val != 'function' && typeof val.length == 'number')
}

function isFunction(val) {
	return val && {}.toString.call(val) === '[object Function]'
}

function isObject(val) {
	return val && {}.toString.call(val) === '[object Object]'
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],69:[function(require,module,exports){
module.exports = [
	// Listed in order of usage preference
	require('./localStorage'),
	require('./oldFF-globalStorage'),
	require('./oldIE-userDataStorage'),
	require('./cookieStorage'),
	require('./sessionStorage'),
	require('./memoryStorage')
]

},{"./cookieStorage":70,"./localStorage":71,"./memoryStorage":72,"./oldFF-globalStorage":73,"./oldIE-userDataStorage":74,"./sessionStorage":75}],70:[function(require,module,exports){
// cookieStorage is useful Safari private browser mode, where localStorage
// doesn't work but cookies do. This implementation is adopted from
// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

var util = require('../src/util')
var Global = util.Global
var trim = util.trim

module.exports = {
	name: 'cookieStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var doc = Global.document

function read(key) {
	if (!key || !_has(key)) { return null }
	var regexpStr = "(?:^|.*;\\s*)" +
		escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
		"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"
	return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
}

function each(callback) {
	var cookies = doc.cookie.split(/; ?/g)
	for (var i = cookies.length - 1; i >= 0; i--) {
		if (!trim(cookies[i])) {
			continue
		}
		var kvp = cookies[i].split('=')
		var key = unescape(kvp[0])
		var val = unescape(kvp[1])
		callback(val, key)
	}
}

function write(key, data) {
	if(!key) { return }
	doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/"
}

function remove(key) {
	if (!key || !_has(key)) {
		return
	}
	doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/"
}

function clearAll() {
	each(function(_, key) {
		remove(key)
	})
}

function _has(key) {
	return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
}

},{"../src/util":68}],71:[function(require,module,exports){
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'localStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

function localStorage() {
	return Global.localStorage
}

function read(key) {
	return localStorage().getItem(key)
}

function write(key, data) {
	return localStorage().setItem(key, data)
}

function each(fn) {
	for (var i = localStorage().length - 1; i >= 0; i--) {
		var key = localStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return localStorage().removeItem(key)
}

function clearAll() {
	return localStorage().clear()
}

},{"../src/util":68}],72:[function(require,module,exports){
// memoryStorage is a useful last fallback to ensure that the store
// is functions (meaning store.get(), store.set(), etc will all function).
// However, stored values will not persist when the browser navigates to
// a new page or reloads the current page.

module.exports = {
	name: 'memoryStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var memoryStorage = {}

function read(key) {
	return memoryStorage[key]
}

function write(key, data) {
	memoryStorage[key] = data
}

function each(callback) {
	for (var key in memoryStorage) {
		if (memoryStorage.hasOwnProperty(key)) {
			callback(memoryStorage[key], key)
		}
	}
}

function remove(key) {
	delete memoryStorage[key]
}

function clearAll(key) {
	memoryStorage = {}
}

},{}],73:[function(require,module,exports){
// oldFF-globalStorage provides storage for Firefox
// versions 6 and 7, where no localStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldFF-globalStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var globalStorage = Global.globalStorage

function read(key) {
	return globalStorage[key]
}

function write(key, data) {
	globalStorage[key] = data
}

function each(fn) {
	for (var i = globalStorage.length - 1; i >= 0; i--) {
		var key = globalStorage.key(i)
		fn(globalStorage[key], key)
	}
}

function remove(key) {
	return globalStorage.removeItem(key)
}

function clearAll() {
	each(function(key, _) {
		delete globalStorage[key]
	})
}

},{"../src/util":68}],74:[function(require,module,exports){
// oldIE-userDataStorage provides storage for Internet Explorer
// versions 6 and 7, where no localStorage, sessionStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldIE-userDataStorage',
	write: write,
	read: read,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var storageName = 'storejs'
var doc = Global.document
var _withStorageEl = _makeIEStorageElFunction()
var disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./) // MSIE 9.x, MSIE 10.x

function write(unfixedKey, data) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.setAttribute(fixedKey, data)
		storageEl.save(storageName)
	})
}

function read(unfixedKey) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	var res = null
	_withStorageEl(function(storageEl) {
		res = storageEl.getAttribute(fixedKey)
	})
	return res
}

function each(callback) {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		for (var i=attributes.length-1; i>=0; i--) {
			var attr = attributes[i]
			callback(storageEl.getAttribute(attr.name), attr.name)
		}
	})
}

function remove(unfixedKey) {
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.removeAttribute(fixedKey)
		storageEl.save(storageName)
	})
}

function clearAll() {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		storageEl.load(storageName)
		for (var i=attributes.length-1; i>=0; i--) {
			storageEl.removeAttribute(attributes[i].name)
		}
		storageEl.save(storageName)
	})
}

// Helpers
//////////

// In IE7, keys cannot start with a digit or contain certain chars.
// See https://github.com/marcuswestin/store.js/issues/40
// See https://github.com/marcuswestin/store.js/issues/83
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
function fixKey(key) {
	return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___')
}

function _makeIEStorageElFunction() {
	if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
		return null
	}
	var scriptTag = 'script',
		storageOwner,
		storageContainer,
		storageEl

	// Since #userData storage applies only to specific paths, we need to
	// somehow link our data to a specific path.  We choose /favicon.ico
	// as a pretty safe option, since all browsers already make a request to
	// this URL anyway and being a 404 will not hurt us here.  We wrap an
	// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
	// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
	// since the iframe access rules appear to allow direct access and
	// manipulation of the document element, even for a 404 page.  This
	// document can be used instead of the current document (which would
	// have been limited to the current path) to perform #userData storage.
	try {
		/* global ActiveXObject */
		storageContainer = new ActiveXObject('htmlfile')
		storageContainer.open()
		storageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src="/favicon.ico"></iframe>')
		storageContainer.close()
		storageOwner = storageContainer.w.frames[0].document
		storageEl = storageOwner.createElement('div')
	} catch(e) {
		// somehow ActiveXObject instantiation failed (perhaps some special
		// security settings or otherwse), fall back to per-path storage
		storageEl = doc.createElement('div')
		storageOwner = doc.body
	}

	return function(storeFunction) {
		var args = [].slice.call(arguments, 0)
		args.unshift(storageEl)
		// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
		// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
		storageOwner.appendChild(storageEl)
		storageEl.addBehavior('#default#userData')
		storageEl.load(storageName)
		storeFunction.apply(this, args)
		storageOwner.removeChild(storageEl)
		return
	}
}

},{"../src/util":68}],75:[function(require,module,exports){
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'sessionStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
}

function sessionStorage() {
	return Global.sessionStorage
}

function read(key) {
	return sessionStorage().getItem(key)
}

function write(key, data) {
	return sessionStorage().setItem(key, data)
}

function each(fn) {
	for (var i = sessionStorage().length - 1; i >= 0; i--) {
		var key = sessionStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return sessionStorage().removeItem(key)
}

function clearAll() {
	return sessionStorage().clear()
}

},{"../src/util":68}],76:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":50}],77:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":78,"./_stream_writable":80,"_process":136,"core-util-is":9,"inherits":21}],78:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this)}).call(this,require('_process'))

},{"_process":136,"buffer":117,"core-util-is":9,"events":121,"inherits":21,"isarray":81,"stream":141,"string_decoder/":82}],79:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":77,"core-util-is":9,"inherits":21}],80:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this)}).call(this,require('_process'))

},{"./_stream_duplex":77,"_process":136,"buffer":117,"core-util-is":9,"inherits":21,"stream":141}],81:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],82:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":117}],83:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":79}],84:[function(require,module,exports){
(function (process){(function (){
var Transform = require('readable-stream/transform')
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

},{"_process":136,"readable-stream/transform":83,"util":161,"xtend":111}],85:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":117}],86:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":89,"./parse.js":90,"./stringify.js":94,"./v1.js":95,"./v3.js":96,"./v4.js":98,"./v5.js":99,"./validate.js":100,"./version.js":101}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":100}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":100}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":92,"./stringify.js":94}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":88,"./v35.js":97}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":90,"./stringify.js":94}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":92,"./stringify.js":94}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":93,"./v35.js":97}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":91}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":100}],102:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

// Shimming starts here.
(function() {
  // Utils.
  var logging = require('./utils').log;
  var browserDetails = require('./utils').browserDetails;
  // Export to the adapter global object visible in the browser.
  module.exports.browserDetails = browserDetails;
  module.exports.extractVersion = require('./utils').extractVersion;
  module.exports.disableLog = require('./utils').disableLog;

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'opera': // fallthrough as it uses chrome shims
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection) {
        logging('Chrome shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = chromeShim;

      chromeShim.shimGetUserMedia();
      chromeShim.shimMediaStream();
      chromeShim.shimSourceObject();
      chromeShim.shimPeerConnection();
      chromeShim.shimOnTrack();
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection) {
        logging('Firefox shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = firefoxShim;

      firefoxShim.shimGetUserMedia();
      firefoxShim.shimSourceObject();
      firefoxShim.shimPeerConnection();
      firefoxShim.shimOnTrack();
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection) {
        logging('MS edge shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = edgeShim;

      edgeShim.shimGetUserMedia();
      edgeShim.shimPeerConnection();
      break;
    case 'safari':
      if (!safariShim) {
        logging('Safari shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = safariShim;

      safariShim.shimGetUserMedia();
      break;
    default:
      logging('Unsupported browser!');
  }
})();

},{"./chrome/chrome_shim":103,"./edge/edge_shim":105,"./firefox/firefox_shim":107,"./safari/safari_shim":109,"./utils":110}],103:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var logging = require('../utils.js').log;
var browserDetails = require('../utils.js').browserDetails;

var chromeShim = {
  shimMediaStream: function() {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function() {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          var self = this;
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var event = new Event('track');
              event.track = te.track;
              event.receiver = {track: te.track};
              event.streams = [e.stream];
              self.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
  },

  shimSourceObject: function() {
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimPeerConnection: function() {
    // The RTCPeerConnection object.
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      // Translate iceTransportPolicy to iceTransports,
      // see https://code.google.com/p/webrtc/issues/detail?id=4869
      logging('PeerConnection');
      if (pcConfig && pcConfig.iceTransportPolicy) {
        pcConfig.iceTransports = pcConfig.iceTransportPolicy;
      }

      var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints);
      var origGetStats = pc.getStats.bind(pc);
      pc.getStats = function(selector, successCallback, errorCallback) {
        var self = this;
        var args = arguments;

        // If selector is a function then we are in the old style stats so just
        // pass back the original getStats format to avoid breaking old users.
        if (arguments.length > 0 && typeof selector === 'function') {
          return origGetStats(selector, successCallback);
        }

        var fixChromeStats_ = function(response) {
          var standardReport = {};
          var reports = response.result();
          reports.forEach(function(report) {
            var standardStats = {
              id: report.id,
              timestamp: report.timestamp,
              type: report.type
            };
            report.names().forEach(function(name) {
              standardStats[name] = report.stat(name);
            });
            standardReport[standardStats.id] = standardStats;
          });

          return standardReport;
        };

        // shim getStats with maplike support
        var makeMapStats = function(stats, legacyStats) {
          var map = new Map(Object.keys(stats).map(function(key) {
            return[key, stats[key]];
          }));
          legacyStats = legacyStats || stats;
          Object.keys(legacyStats).forEach(function(key) {
            map[key] = legacyStats[key];
          });
          return map;
        };

        if (arguments.length >= 2) {
          var successCallbackWrapper_ = function(response) {
            args[1](makeMapStats(fixChromeStats_(response)));
          };

          return origGetStats.apply(this, [successCallbackWrapper_,
              arguments[0]]);
        }

        // promise-support
        return new Promise(function(resolve, reject) {
          if (args.length === 1 && typeof selector === 'object') {
            origGetStats.apply(self, [
              function(response) {
                resolve(makeMapStats(fixChromeStats_(response)));
              }, reject]);
          } else {
            // Preserve legacy chrome stats only on legacy access of stats obj
            origGetStats.apply(self, [
              function(response) {
                resolve(makeMapStats(fixChromeStats_(response),
                    response.result()));
              }, reject]);
          }
        }).then(successCallback, errorCallback);
      };

      return pc;
    };
    window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;

    // wrap static methods. Currently just generateCertificate.
    if (webkitRTCPeerConnection.generateCertificate) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return webkitRTCPeerConnection.generateCertificate;
        }
      });
    }

    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = webkitRTCPeerConnection.prototype[method];
      webkitRTCPeerConnection.prototype[method] = function() {
        var self = this;
        if (arguments.length < 1 || (arguments.length === 1 &&
            typeof arguments[0] === 'object')) {
          var opts = arguments.length === 1 ? arguments[0] : undefined;
          return new Promise(function(resolve, reject) {
            nativeMethod.apply(self, [resolve, reject, opts]);
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = webkitRTCPeerConnection.prototype[method];
            webkitRTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var self = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(self, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = webkitRTCPeerConnection.prototype[method];
          webkitRTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                RTCIceCandidate : RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        RTCPeerConnection.prototype.addIceCandidate;
    RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
};


// Expose public methods.
module.exports = {
  shimMediaStream: chromeShim.shimMediaStream,
  shimOnTrack: chromeShim.shimOnTrack,
  shimSourceObject: chromeShim.shimSourceObject,
  shimPeerConnection: chromeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils.js":110,"./getusermedia":104}],104:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var logging = require('../utils.js').log;

// Expose public methods.
module.exports = function() {
  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && constraints.audio) {
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile, where it defaults to "user".
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode)) {
        delete constraints.video.facingMode;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          // Look for "back" in label, or use last cam (typically back cam).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var back = devices.find(function(d) {
              return d.label.toLowerCase().indexOf('back') !== -1;
            }) || (devices.length && devices[devices.length - 1]);
            if (back) {
              constraints.video.deviceId = face.exact ? {exact: back.deviceId} :
                                                        {ideal: back.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        ConstraintNotSatisfiedError: 'OverconstrainedError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        onError(shimError_(e));
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                      kind: kinds[device.kind],
                      deviceId: device.id,
                      groupId: ''};
            }));
          });
        });
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":110}],105:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');
var browserDetails = require('../utils').browserDetails;

var edgeShim = {
  shimPeerConnection: function() {
    if (window.RTCIceGatherer) {
      // ORTC defines an RTCIceCandidate object but no constructor.
      // Not implemented in Edge.
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      // ORTC does not have a session description object but
      // other browsers (i.e. Chrome) that will support both PC and ORTC
      // in the future might have this defined already.
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed.
      var origMSTEnabled = Object.getOwnPropertyDescriptor(
          MediaStreamTrack.prototype, 'enabled');
      Object.defineProperty(MediaStreamTrack.prototype, 'enabled', {
        set: function(value) {
          origMSTEnabled.set.call(this, value);
          var ev = new Event('enabled');
          ev.enabled = value;
          this.dispatchEvent(ev);
        }
      });
    }

    window.RTCPeerConnection = function(config) {
      var self = this;

      var _eventTarget = document.createDocumentFragment();
      ['addEventListener', 'removeEventListener', 'dispatchEvent']
          .forEach(function(method) {
            self[method] = _eventTarget[method].bind(_eventTarget);
          });

      this.onicecandidate = null;
      this.onaddstream = null;
      this.ontrack = null;
      this.onremovestream = null;
      this.onsignalingstatechange = null;
      this.oniceconnectionstatechange = null;
      this.onnegotiationneeded = null;
      this.ondatachannel = null;

      this.localStreams = [];
      this.remoteStreams = [];
      this.getLocalStreams = function() {
        return self.localStreams;
      };
      this.getRemoteStreams = function() {
        return self.remoteStreams;
      };

      this.localDescription = new RTCSessionDescription({
        type: '',
        sdp: ''
      });
      this.remoteDescription = new RTCSessionDescription({
        type: '',
        sdp: ''
      });
      this.signalingState = 'stable';
      this.iceConnectionState = 'new';
      this.iceGatheringState = 'new';

      this.iceOptions = {
        gatherPolicy: 'all',
        iceServers: []
      };
      if (config && config.iceTransportPolicy) {
        switch (config.iceTransportPolicy) {
          case 'all':
          case 'relay':
            this.iceOptions.gatherPolicy = config.iceTransportPolicy;
            break;
          case 'none':
            // FIXME: remove once implementation and spec have added this.
            throw new TypeError('iceTransportPolicy "none" not supported');
          default:
            // don't set iceTransportPolicy.
            break;
        }
      }
      this.usingBundle = config && config.bundlePolicy === 'max-bundle';

      if (config && config.iceServers) {
        // Edge does not like
        // 1) stun:
        // 2) turn: that does not have all of turn:host:port?transport=udp
        // 3) turn: with ipv6 addresses
        var iceServers = JSON.parse(JSON.stringify(config.iceServers));
        this.iceOptions.iceServers = iceServers.filter(function(server) {
          if (server && server.urls) {
            var urls = server.urls;
            if (typeof urls === 'string') {
              urls = [urls];
            }
            urls = urls.filter(function(url) {
              return (url.indexOf('turn:') === 0 &&
                  url.indexOf('transport=udp') !== -1 &&
                  url.indexOf('turn:[') === -1) ||
                  (url.indexOf('stun:') === 0 &&
                    browserDetails.version >= 14393);
            })[0];
            return !!urls;
          }
          return false;
        });
      }
      this._config = config;

      // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
      // everything that is needed to describe a SDP m-line.
      this.transceivers = [];

      // since the iceGatherer is currently created in createOffer but we
      // must not emit candidates until after setLocalDescription we buffer
      // them in this array.
      this._localIceCandidatesBuffer = [];
    };

    window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {
      var self = this;
      var sections = SDPUtils.splitSections(self.localDescription.sdp);
      // FIXME: need to apply ice candidates in a way which is async but
      // in-order
      this._localIceCandidatesBuffer.forEach(function(event) {
        var end = !event.candidate || Object.keys(event.candidate).length === 0;
        if (end) {
          for (var j = 1; j < sections.length; j++) {
            if (sections[j].indexOf('\r\na=end-of-candidates\r\n') === -1) {
              sections[j] += 'a=end-of-candidates\r\n';
            }
          }
        } else if (event.candidate.candidate.indexOf('typ endOfCandidates')
            === -1) {
          sections[event.candidate.sdpMLineIndex + 1] +=
              'a=' + event.candidate.candidate + '\r\n';
        }
        self.localDescription.sdp = sections.join('');
        self.dispatchEvent(event);
        if (self.onicecandidate !== null) {
          self.onicecandidate(event);
        }
        if (!event.candidate && self.iceGatheringState !== 'complete') {
          var complete = self.transceivers.every(function(transceiver) {
            return transceiver.iceGatherer &&
                transceiver.iceGatherer.state === 'completed';
          });
          if (complete) {
            self.iceGatheringState = 'complete';
          }
        }
      });
      this._localIceCandidatesBuffer = [];
    };

    window.RTCPeerConnection.prototype.getConfiguration = function() {
      return this._config;
    };

    window.RTCPeerConnection.prototype.addStream = function(stream) {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      this.localStreams.push(clonedStream);
      this._maybeFireNegotiationNeeded();
    };

    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var idx = this.localStreams.indexOf(stream);
      if (idx > -1) {
        this.localStreams.splice(idx, 1);
        this._maybeFireNegotiationNeeded();
      }
    };

    window.RTCPeerConnection.prototype.getSenders = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpSender;
      })
      .map(function(transceiver) {
        return transceiver.rtpSender;
      });
    };

    window.RTCPeerConnection.prototype.getReceivers = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpReceiver;
      })
      .map(function(transceiver) {
        return transceiver.rtpReceiver;
      });
    };

    // Determines the intersection of local and remote capabilities.
    window.RTCPeerConnection.prototype._getCommonCapabilities =
        function(localCapabilities, remoteCapabilities) {
          var commonCapabilities = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: []
          };
          localCapabilities.codecs.forEach(function(lCodec) {
            for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
              var rCodec = remoteCapabilities.codecs[i];
              if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
                  lCodec.clockRate === rCodec.clockRate) {
                // number of channels is the highest common number of channels
                rCodec.numChannels = Math.min(lCodec.numChannels,
                    rCodec.numChannels);
                // push rCodec so we reply with offerer payload type
                commonCapabilities.codecs.push(rCodec);

                // determine common feedback mechanisms
                rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
                  for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
                    if (lCodec.rtcpFeedback[j].type === fb.type &&
                        lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                      return true;
                    }
                  }
                  return false;
                });
                // FIXME: also need to determine .parameters
                //  see https://github.com/openpeer/ortc/issues/569
                break;
              }
            }
          });

          localCapabilities.headerExtensions
              .forEach(function(lHeaderExtension) {
                for (var i = 0; i < remoteCapabilities.headerExtensions.length;
                     i++) {
                  var rHeaderExtension = remoteCapabilities.headerExtensions[i];
                  if (lHeaderExtension.uri === rHeaderExtension.uri) {
                    commonCapabilities.headerExtensions.push(rHeaderExtension);
                    break;
                  }
                }
              });

          // FIXME: fecMechanisms
          return commonCapabilities;
        };

    // Create ICE gatherer, ICE transport and DTLS transport.
    window.RTCPeerConnection.prototype._createIceAndDtlsTransports =
        function(mid, sdpMLineIndex) {
          var self = this;
          var iceGatherer = new RTCIceGatherer(self.iceOptions);
          var iceTransport = new RTCIceTransport(iceGatherer);
          iceGatherer.onlocalcandidate = function(evt) {
            var event = new Event('icecandidate');
            event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

            var cand = evt.candidate;
            var end = !cand || Object.keys(cand).length === 0;
            // Edge emits an empty object for RTCIceCandidateComplete
            if (end) {
              // polyfill since RTCIceGatherer.state is not implemented in
              // Edge 10547 yet.
              if (iceGatherer.state === undefined) {
                iceGatherer.state = 'completed';
              }

              // Emit a candidate with type endOfCandidates to make the samples
              // work. Edge requires addIceCandidate with this empty candidate
              // to start checking. The real solution is to signal
              // end-of-candidates to the other side when getting the null
              // candidate but some apps (like the samples) don't do that.
              event.candidate.candidate =
                  'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';
            } else {
              // RTCIceCandidate doesn't have a component, needs to be added
              cand.component = iceTransport.component === 'RTCP' ? 2 : 1;
              event.candidate.candidate = SDPUtils.writeCandidate(cand);
            }

            // update local description.
            var sections = SDPUtils.splitSections(self.localDescription.sdp);
            if (event.candidate.candidate.indexOf('typ endOfCandidates')
                === -1) {
              sections[event.candidate.sdpMLineIndex + 1] +=
                  'a=' + event.candidate.candidate + '\r\n';
            } else {
              sections[event.candidate.sdpMLineIndex + 1] +=
                  'a=end-of-candidates\r\n';
            }
            self.localDescription.sdp = sections.join('');

            var complete = self.transceivers.every(function(transceiver) {
              return transceiver.iceGatherer &&
                  transceiver.iceGatherer.state === 'completed';
            });

            // Emit candidate if localDescription is set.
            // Also emits null candidate when all gatherers are complete.
            switch (self.iceGatheringState) {
              case 'new':
                self._localIceCandidatesBuffer.push(event);
                if (end && complete) {
                  self._localIceCandidatesBuffer.push(
                      new Event('icecandidate'));
                }
                break;
              case 'gathering':
                self._emitBufferedCandidates();
                self.dispatchEvent(event);
                if (self.onicecandidate !== null) {
                  self.onicecandidate(event);
                }
                if (complete) {
                  self.dispatchEvent(new Event('icecandidate'));
                  if (self.onicecandidate !== null) {
                    self.onicecandidate(new Event('icecandidate'));
                  }
                  self.iceGatheringState = 'complete';
                }
                break;
              case 'complete':
                // should not happen... currently!
                break;
              default: // no-op.
                break;
            }
          };
          iceTransport.onicestatechange = function() {
            self._updateConnectionState();
          };

          var dtlsTransport = new RTCDtlsTransport(iceTransport);
          dtlsTransport.ondtlsstatechange = function() {
            self._updateConnectionState();
          };
          dtlsTransport.onerror = function() {
            // onerror does not set state to failed by itself.
            dtlsTransport.state = 'failed';
            self._updateConnectionState();
          };

          return {
            iceGatherer: iceGatherer,
            iceTransport: iceTransport,
            dtlsTransport: dtlsTransport
          };
        };

    // Start the RTP Sender and Receiver for a transceiver.
    window.RTCPeerConnection.prototype._transceive = function(transceiver,
        send, recv) {
      var params = this._getCommonCapabilities(transceiver.localCapabilities,
          transceiver.remoteCapabilities);
      if (send && transceiver.rtpSender) {
        params.encodings = transceiver.sendEncodingParameters;
        params.rtcp = {
          cname: SDPUtils.localCName
        };
        if (transceiver.recvEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
        }
        transceiver.rtpSender.send(params);
      }
      if (recv && transceiver.rtpReceiver) {
        // remove RTX field in Edge 14942
        if (transceiver.kind === 'video'
            && transceiver.recvEncodingParameters) {
          transceiver.recvEncodingParameters.forEach(function(p) {
            delete p.rtx;
          });
        }
        params.encodings = transceiver.recvEncodingParameters;
        params.rtcp = {
          cname: transceiver.cname
        };
        if (transceiver.sendEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
        }
        transceiver.rtpReceiver.receive(params);
      }
    };

    window.RTCPeerConnection.prototype.setLocalDescription =
        function(description) {
          var self = this;
          var sections;
          var sessionpart;
          if (description.type === 'offer') {
            // FIXME: What was the purpose of this empty if statement?
            // if (!this._pendingOffer) {
            // } else {
            if (this._pendingOffer) {
              // VERY limited support for SDP munging. Limited to:
              // * changing the order of codecs
              sections = SDPUtils.splitSections(description.sdp);
              sessionpart = sections.shift();
              sections.forEach(function(mediaSection, sdpMLineIndex) {
                var caps = SDPUtils.parseRtpParameters(mediaSection);
                self._pendingOffer[sdpMLineIndex].localCapabilities = caps;
              });
              this.transceivers = this._pendingOffer;
              delete this._pendingOffer;
            }
          } else if (description.type === 'answer') {
            sections = SDPUtils.splitSections(self.remoteDescription.sdp);
            sessionpart = sections.shift();
            var isIceLite = SDPUtils.matchPrefix(sessionpart,
                'a=ice-lite').length > 0;
            sections.forEach(function(mediaSection, sdpMLineIndex) {
              var transceiver = self.transceivers[sdpMLineIndex];
              var iceGatherer = transceiver.iceGatherer;
              var iceTransport = transceiver.iceTransport;
              var dtlsTransport = transceiver.dtlsTransport;
              var localCapabilities = transceiver.localCapabilities;
              var remoteCapabilities = transceiver.remoteCapabilities;

              var rejected = mediaSection.split('\n', 1)[0]
                  .split(' ', 2)[1] === '0';

              if (!rejected && !transceiver.isDatachannel) {
                var remoteIceParameters = SDPUtils.getIceParameters(
                    mediaSection, sessionpart);
                if (isIceLite) {
                  var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                  .map(function(cand) {
                    return SDPUtils.parseCandidate(cand);
                  })
                  .filter(function(cand) {
                    return cand.component === '1';
                  });
                  // ice-lite only includes host candidates in the SDP so we can
                  // use setRemoteCandidates (which implies an
                  // RTCIceCandidateComplete)
                  if (cands.length) {
                    iceTransport.setRemoteCandidates(cands);
                  }
                }
                var remoteDtlsParameters = SDPUtils.getDtlsParameters(
                    mediaSection, sessionpart);
                if (isIceLite) {
                  remoteDtlsParameters.role = 'server';
                }

                if (!self.usingBundle || sdpMLineIndex === 0) {
                  iceTransport.start(iceGatherer, remoteIceParameters,
                      isIceLite ? 'controlling' : 'controlled');
                  dtlsTransport.start(remoteDtlsParameters);
                }

                // Calculate intersection of capabilities.
                var params = self._getCommonCapabilities(localCapabilities,
                    remoteCapabilities);

                // Start the RTCRtpSender. The RTCRtpReceiver for this
                // transceiver has already been started in setRemoteDescription.
                self._transceive(transceiver,
                    params.codecs.length > 0,
                    false);
              }
            });
          }

          this.localDescription = {
            type: description.type,
            sdp: description.sdp
          };
          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-local-offer');
              break;
            case 'answer':
              this._updateSignalingState('stable');
              break;
            default:
              throw new TypeError('unsupported type "' + description.type +
                  '"');
          }

          // If a success callback was provided, emit ICE candidates after it
          // has been executed. Otherwise, emit callback after the Promise is
          // resolved.
          var hasCallback = arguments.length > 1 &&
            typeof arguments[1] === 'function';
          if (hasCallback) {
            var cb = arguments[1];
            window.setTimeout(function() {
              cb();
              if (self.iceGatheringState === 'new') {
                self.iceGatheringState = 'gathering';
              }
              self._emitBufferedCandidates();
            }, 0);
          }
          var p = Promise.resolve();
          p.then(function() {
            if (!hasCallback) {
              if (self.iceGatheringState === 'new') {
                self.iceGatheringState = 'gathering';
              }
              // Usually candidates will be emitted earlier.
              window.setTimeout(self._emitBufferedCandidates.bind(self), 500);
            }
          });
          return p;
        };

    window.RTCPeerConnection.prototype.setRemoteDescription =
        function(description) {
          var self = this;
          var stream = new MediaStream();
          var receiverList = [];
          var sections = SDPUtils.splitSections(description.sdp);
          var sessionpart = sections.shift();
          var isIceLite = SDPUtils.matchPrefix(sessionpart,
              'a=ice-lite').length > 0;
          this.usingBundle = SDPUtils.matchPrefix(sessionpart,
              'a=group:BUNDLE ').length > 0;
          sections.forEach(function(mediaSection, sdpMLineIndex) {
            var lines = SDPUtils.splitLines(mediaSection);
            var mline = lines[0].substr(2).split(' ');
            var kind = mline[0];
            var rejected = mline[1] === '0';
            var direction = SDPUtils.getDirection(mediaSection, sessionpart);

            var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:');
            if (mid.length) {
              mid = mid[0].substr(6);
            } else {
              mid = SDPUtils.generateIdentifier();
            }

            // Reject datachannels which are not implemented yet.
            if (kind === 'application' && mline[2] === 'DTLS/SCTP') {
              self.transceivers[sdpMLineIndex] = {
                mid: mid,
                isDatachannel: true
              };
              return;
            }

            var transceiver;
            var iceGatherer;
            var iceTransport;
            var dtlsTransport;
            var rtpSender;
            var rtpReceiver;
            var sendEncodingParameters;
            var recvEncodingParameters;
            var localCapabilities;

            var track;
            // FIXME: ensure the mediaSection has rtcp-mux set.
            var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
            var remoteIceParameters;
            var remoteDtlsParameters;
            if (!rejected) {
              remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
                  sessionpart);
              remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
                  sessionpart);
              remoteDtlsParameters.role = 'client';
            }
            recvEncodingParameters =
                SDPUtils.parseRtpEncodingParameters(mediaSection);

            var cname;
            // Gets the first SSRC. Note that with RTX there might be multiple
            // SSRCs.
            var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
                .map(function(line) {
                  return SDPUtils.parseSsrcMedia(line);
                })
                .filter(function(obj) {
                  return obj.attribute === 'cname';
                })[0];
            if (remoteSsrc) {
              cname = remoteSsrc.value;
            }

            var isComplete = SDPUtils.matchPrefix(mediaSection,
                'a=end-of-candidates', sessionpart).length > 0;
            var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                .map(function(cand) {
                  return SDPUtils.parseCandidate(cand);
                })
                .filter(function(cand) {
                  return cand.component === '1';
                });
            if (description.type === 'offer' && !rejected) {
              var transports = self.usingBundle && sdpMLineIndex > 0 ? {
                iceGatherer: self.transceivers[0].iceGatherer,
                iceTransport: self.transceivers[0].iceTransport,
                dtlsTransport: self.transceivers[0].dtlsTransport
              } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);

              if (isComplete) {
                transports.iceTransport.setRemoteCandidates(cands);
              }

              localCapabilities = RTCRtpReceiver.getCapabilities(kind);

              // filter RTX until additional stuff needed for RTX is implemented
              // in adapter.js
              localCapabilities.codecs = localCapabilities.codecs.filter(
                  function(codec) {
                    return codec.name !== 'rtx';
                  });

              sendEncodingParameters = [{
                ssrc: (2 * sdpMLineIndex + 2) * 1001
              }];

              rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);

              track = rtpReceiver.track;
              receiverList.push([track, rtpReceiver]);
              // FIXME: not correct when there are multiple streams but that is
              // not currently supported in this shim.
              stream.addTrack(track);

              // FIXME: look at direction.
              if (self.localStreams.length > 0 &&
                  self.localStreams[0].getTracks().length >= sdpMLineIndex) {
                var localTrack;
                if (kind === 'audio') {
                  localTrack = self.localStreams[0].getAudioTracks()[0];
                } else if (kind === 'video') {
                  localTrack = self.localStreams[0].getVideoTracks()[0];
                }
                if (localTrack) {
                  rtpSender = new RTCRtpSender(localTrack,
                      transports.dtlsTransport);
                }
              }

              self.transceivers[sdpMLineIndex] = {
                iceGatherer: transports.iceGatherer,
                iceTransport: transports.iceTransport,
                dtlsTransport: transports.dtlsTransport,
                localCapabilities: localCapabilities,
                remoteCapabilities: remoteCapabilities,
                rtpSender: rtpSender,
                rtpReceiver: rtpReceiver,
                kind: kind,
                mid: mid,
                cname: cname,
                sendEncodingParameters: sendEncodingParameters,
                recvEncodingParameters: recvEncodingParameters
              };
              // Start the RTCRtpReceiver now. The RTPSender is started in
              // setLocalDescription.
              self._transceive(self.transceivers[sdpMLineIndex],
                  false,
                  direction === 'sendrecv' || direction === 'sendonly');
            } else if (description.type === 'answer' && !rejected) {
              transceiver = self.transceivers[sdpMLineIndex];
              iceGatherer = transceiver.iceGatherer;
              iceTransport = transceiver.iceTransport;
              dtlsTransport = transceiver.dtlsTransport;
              rtpSender = transceiver.rtpSender;
              rtpReceiver = transceiver.rtpReceiver;
              sendEncodingParameters = transceiver.sendEncodingParameters;
              localCapabilities = transceiver.localCapabilities;

              self.transceivers[sdpMLineIndex].recvEncodingParameters =
                  recvEncodingParameters;
              self.transceivers[sdpMLineIndex].remoteCapabilities =
                  remoteCapabilities;
              self.transceivers[sdpMLineIndex].cname = cname;

              if ((isIceLite || isComplete) && cands.length) {
                iceTransport.setRemoteCandidates(cands);
              }
              if (!self.usingBundle || sdpMLineIndex === 0) {
                iceTransport.start(iceGatherer, remoteIceParameters,
                    'controlling');
                dtlsTransport.start(remoteDtlsParameters);
              }

              self._transceive(transceiver,
                  direction === 'sendrecv' || direction === 'recvonly',
                  direction === 'sendrecv' || direction === 'sendonly');

              if (rtpReceiver &&
                  (direction === 'sendrecv' || direction === 'sendonly')) {
                track = rtpReceiver.track;
                receiverList.push([track, rtpReceiver]);
                stream.addTrack(track);
              } else {
                // FIXME: actually the receiver should be created later.
                delete transceiver.rtpReceiver;
              }
            }
          });

          this.remoteDescription = {
            type: description.type,
            sdp: description.sdp
          };
          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-remote-offer');
              break;
            case 'answer':
              this._updateSignalingState('stable');
              break;
            default:
              throw new TypeError('unsupported type "' + description.type +
                  '"');
          }
          if (stream.getTracks().length) {
            self.remoteStreams.push(stream);
            window.setTimeout(function() {
              var event = new Event('addstream');
              event.stream = stream;
              self.dispatchEvent(event);
              if (self.onaddstream !== null) {
                window.setTimeout(function() {
                  self.onaddstream(event);
                }, 0);
              }

              receiverList.forEach(function(item) {
                var track = item[0];
                var receiver = item[1];
                var trackEvent = new Event('track');
                trackEvent.track = track;
                trackEvent.receiver = receiver;
                trackEvent.streams = [stream];
                self.dispatchEvent(event);
                if (self.ontrack !== null) {
                  window.setTimeout(function() {
                    self.ontrack(trackEvent);
                  }, 0);
                }
              });
            }, 0);
          }
          if (arguments.length > 1 && typeof arguments[1] === 'function') {
            window.setTimeout(arguments[1], 0);
          }
          return Promise.resolve();
        };

    window.RTCPeerConnection.prototype.close = function() {
      this.transceivers.forEach(function(transceiver) {
        /* not yet
        if (transceiver.iceGatherer) {
          transceiver.iceGatherer.close();
        }
        */
        if (transceiver.iceTransport) {
          transceiver.iceTransport.stop();
        }
        if (transceiver.dtlsTransport) {
          transceiver.dtlsTransport.stop();
        }
        if (transceiver.rtpSender) {
          transceiver.rtpSender.stop();
        }
        if (transceiver.rtpReceiver) {
          transceiver.rtpReceiver.stop();
        }
      });
      // FIXME: clean up tracks, local streams, remote streams, etc
      this._updateSignalingState('closed');
    };

    // Update the signaling state.
    window.RTCPeerConnection.prototype._updateSignalingState =
        function(newState) {
          this.signalingState = newState;
          var event = new Event('signalingstatechange');
          this.dispatchEvent(event);
          if (this.onsignalingstatechange !== null) {
            this.onsignalingstatechange(event);
          }
        };

    // Determine whether to fire the negotiationneeded event.
    window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =
        function() {
          // Fire away (for now).
          var event = new Event('negotiationneeded');
          this.dispatchEvent(event);
          if (this.onnegotiationneeded !== null) {
            this.onnegotiationneeded(event);
          }
        };

    // Update the connection state.
    window.RTCPeerConnection.prototype._updateConnectionState = function() {
      var self = this;
      var newState;
      var states = {
        'new': 0,
        closed: 0,
        connecting: 0,
        checking: 0,
        connected: 0,
        completed: 0,
        failed: 0
      };
      this.transceivers.forEach(function(transceiver) {
        states[transceiver.iceTransport.state]++;
        states[transceiver.dtlsTransport.state]++;
      });
      // ICETransport.completed and connected are the same for this purpose.
      states.connected += states.completed;

      newState = 'new';
      if (states.failed > 0) {
        newState = 'failed';
      } else if (states.connecting > 0 || states.checking > 0) {
        newState = 'connecting';
      } else if (states.disconnected > 0) {
        newState = 'disconnected';
      } else if (states.new > 0) {
        newState = 'new';
      } else if (states.connected > 0 || states.completed > 0) {
        newState = 'connected';
      }

      if (newState !== self.iceConnectionState) {
        self.iceConnectionState = newState;
        var event = new Event('iceconnectionstatechange');
        this.dispatchEvent(event);
        if (this.oniceconnectionstatechange !== null) {
          this.oniceconnectionstatechange(event);
        }
      }
    };

    window.RTCPeerConnection.prototype.createOffer = function() {
      var self = this;
      if (this._pendingOffer) {
        throw new Error('createOffer called while there is a pending offer.');
      }
      var offerOptions;
      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
        offerOptions = arguments[0];
      } else if (arguments.length === 3) {
        offerOptions = arguments[2];
      }

      var tracks = [];
      var numAudioTracks = 0;
      var numVideoTracks = 0;
      // Default to sendrecv.
      if (this.localStreams.length) {
        numAudioTracks = this.localStreams[0].getAudioTracks().length;
        numVideoTracks = this.localStreams[0].getVideoTracks().length;
      }
      // Determine number of audio and video tracks we need to send/recv.
      if (offerOptions) {
        // Reject Chrome legacy constraints.
        if (offerOptions.mandatory || offerOptions.optional) {
          throw new TypeError(
              'Legacy mandatory/optional constraints not supported.');
        }
        if (offerOptions.offerToReceiveAudio !== undefined) {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
        if (offerOptions.offerToReceiveVideo !== undefined) {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
      if (this.localStreams.length) {
        // Push local streams.
        this.localStreams[0].getTracks().forEach(function(track) {
          tracks.push({
            kind: track.kind,
            track: track,
            wantReceive: track.kind === 'audio' ?
                numAudioTracks > 0 : numVideoTracks > 0
          });
          if (track.kind === 'audio') {
            numAudioTracks--;
          } else if (track.kind === 'video') {
            numVideoTracks--;
          }
        });
      }
      // Create M-lines for recvonly streams.
      while (numAudioTracks > 0 || numVideoTracks > 0) {
        if (numAudioTracks > 0) {
          tracks.push({
            kind: 'audio',
            wantReceive: true
          });
          numAudioTracks--;
        }
        if (numVideoTracks > 0) {
          tracks.push({
            kind: 'video',
            wantReceive: true
          });
          numVideoTracks--;
        }
      }

      var sdp = SDPUtils.writeSessionBoilerplate();
      var transceivers = [];
      tracks.forEach(function(mline, sdpMLineIndex) {
        // For each track, create an ice gatherer, ice transport,
        // dtls transport, potentially rtpsender and rtpreceiver.
        var track = mline.track;
        var kind = mline.kind;
        var mid = SDPUtils.generateIdentifier();

        var transports = self.usingBundle && sdpMLineIndex > 0 ? {
          iceGatherer: transceivers[0].iceGatherer,
          iceTransport: transceivers[0].iceTransport,
          dtlsTransport: transceivers[0].dtlsTransport
        } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);

        var localCapabilities = RTCRtpSender.getCapabilities(kind);
        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
        localCapabilities.codecs.forEach(function(codec) {
          // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
          // by adding level-asymmetry-allowed=1
          if (codec.name === 'H264' &&
              codec.parameters['level-asymmetry-allowed'] === undefined) {
            codec.parameters['level-asymmetry-allowed'] = '1';
          }
        });

        var rtpSender;
        var rtpReceiver;

        // generate an ssrc now, to be used later in rtpSender.send
        var sendEncodingParameters = [{
          ssrc: (2 * sdpMLineIndex + 1) * 1001
        }];
        if (track) {
          rtpSender = new RTCRtpSender(track, transports.dtlsTransport);
        }

        if (mline.wantReceive) {
          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);
        }

        transceivers[sdpMLineIndex] = {
          iceGatherer: transports.iceGatherer,
          iceTransport: transports.iceTransport,
          dtlsTransport: transports.dtlsTransport,
          localCapabilities: localCapabilities,
          remoteCapabilities: null,
          rtpSender: rtpSender,
          rtpReceiver: rtpReceiver,
          kind: kind,
          mid: mid,
          sendEncodingParameters: sendEncodingParameters,
          recvEncodingParameters: null
        };
      });
      if (this.usingBundle) {
        sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      tracks.forEach(function(mline, sdpMLineIndex) {
        var transceiver = transceivers[sdpMLineIndex];
        sdp += SDPUtils.writeMediaSection(transceiver,
            transceiver.localCapabilities, 'offer', self.localStreams[0]);
      });

      this._pendingOffer = transceivers;
      var desc = new RTCSessionDescription({
        type: 'offer',
        sdp: sdp
      });
      if (arguments.length && typeof arguments[0] === 'function') {
        window.setTimeout(arguments[0], 0, desc);
      }
      return Promise.resolve(desc);
    };

    window.RTCPeerConnection.prototype.createAnswer = function() {
      var self = this;

      var sdp = SDPUtils.writeSessionBoilerplate();
      if (this.usingBundle) {
        sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.isDatachannel) {
          sdp += 'm=application 0 DTLS/SCTP 5000\r\n' +
              'c=IN IP4 0.0.0.0\r\n' +
              'a=mid:' + transceiver.mid + '\r\n';
          return;
        }
        // Calculate intersection of capabilities.
        var commonCapabilities = self._getCommonCapabilities(
            transceiver.localCapabilities,
            transceiver.remoteCapabilities);

        sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,
            'answer', self.localStreams[0]);
      });

      var desc = new RTCSessionDescription({
        type: 'answer',
        sdp: sdp
      });
      if (arguments.length && typeof arguments[0] === 'function') {
        window.setTimeout(arguments[0], 0, desc);
      }
      return Promise.resolve(desc);
    };

    window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
      if (!candidate) {
        this.transceivers.forEach(function(transceiver) {
          transceiver.iceTransport.addRemoteCandidate({});
        });
      } else {
        var mLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < this.transceivers.length; i++) {
            if (this.transceivers[i].mid === candidate.sdpMid) {
              mLineIndex = i;
              break;
            }
          }
        }
        var transceiver = this.transceivers[mLineIndex];
        if (transceiver) {
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return;
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component !== '1') {
            return;
          }
          // A dirty hack to make samples work.
          if (cand.type === 'endOfCandidates') {
            cand = {};
          }
          transceiver.iceTransport.addRemoteCandidate(cand);

          // update the remoteDescription.
          var sections = SDPUtils.splitSections(this.remoteDescription.sdp);
          sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()
              : 'a=end-of-candidates') + '\r\n';
          this.remoteDescription.sdp = sections.join('');
        }
      }
      if (arguments.length > 1 && typeof arguments[1] === 'function') {
        window.setTimeout(arguments[1], 0);
      }
      return Promise.resolve();
    };

    window.RTCPeerConnection.prototype.getStats = function() {
      var promises = [];
      this.transceivers.forEach(function(transceiver) {
        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
            'dtlsTransport'].forEach(function(method) {
              if (transceiver[method]) {
                promises.push(transceiver[method].getStats());
              }
            });
      });
      var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
          arguments[1];
      return new Promise(function(resolve) {
        // shim getStats with maplike support
        var results = new Map();
        Promise.all(promises).then(function(res) {
          res.forEach(function(result) {
            Object.keys(result).forEach(function(id) {
              results.set(id, result[id]);
              results[id] = result[id];
            });
          });
          if (cb) {
            window.setTimeout(cb, 0, results);
          }
          resolve(results);
        });
      });
    };
  }
};

// Expose public methods.
module.exports = {
  shimPeerConnection: edgeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":110,"./getusermedia":106,"sdp":51}],106:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

// Expose public methods.
module.exports = function() {
  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],107:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var browserDetails = require('../utils').browserDetails;

var firefoxShim = {
  shimOnTrack: function() {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
  },

  shimSourceObject: function() {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function() {
    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = mozRTCSessionDescription;
      window.RTCIceCandidate = mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                RTCIceCandidate : RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        RTCPeerConnection.prototype.addIceCandidate;
    RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    if (browserDetails.version < 48) {
      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        var map = new Map();
        Object.keys(stats).forEach(function(key) {
          map.set(key, stats[key]);
          map[key] = stats[key];
        });
        return map;
      };

      var nativeGetStats = RTCPeerConnection.prototype.getStats;
      RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) {
        return nativeGetStats.apply(this, [selector || null])
          .then(function(stats) {
            return makeMapStats(stats);
          })
          .then(onSucc, onErr);
      };
    }
  }
};

// Expose public methods.
module.exports = {
  shimOnTrack: firefoxShim.shimOnTrack,
  shimSourceObject: firefoxShim.shimSourceObject,
  shimPeerConnection: firefoxShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":110,"./getusermedia":108}],108:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logging = require('../utils').log;
var browserDetails = require('../utils').browserDetails;

// Expose public methods.
module.exports = function() {
  var shimError_ = function(e) {
    return {
      name: {
        SecurityError: 'NotAllowedError',
        PermissionDeniedError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    console.warn('navigator.getUserMedia has been replaced by ' +
                 'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":110}],109:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var safariShim = {
  // TODO: DrAlex, should be here, double check against LayoutTests
  // shimOnTrack: function() { },

  // TODO: once the back-end for the mac port is done, add.
  // TODO: check for webkitGTK+
  // shimPeerConnection: function() { },

  shimGetUserMedia: function() {
    navigator.getUserMedia = navigator.webkitGetUserMedia;
  }
};

// Expose public methods.
module.exports = {
  shimGetUserMedia: safariShim.shimGetUserMedia
  // TODO
  // shimOnTrack: safariShim.shimOnTrack,
  // shimPeerConnection: safariShim.shimPeerConnection
};

},{}],110:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;

// Utility methods.
var utils = {
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  extractVersion: function(uastring, expr, pos) {
    var match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function() {
    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    // Firefox.
    if (navigator.mozGetUserMedia) {
      result.browser = 'firefox';
      result.version = this.extractVersion(navigator.userAgent,
          /Firefox\/([0-9]+)\./, 1);

    // all webkit-based browsers
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now
      if (window.webkitRTCPeerConnection) {
        result.browser = 'chrome';
        result.version = this.extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/([0-9]+)\./, 2);

      // Safari or unknown webkit-based
      // for the time being Safari has support for MediaStreams but not webRTC
      } else {
        // Safari UA substrings of interest for reference:
        // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)
        // - safari UI version:        Version/9.0.3 (unique to Safari)
        // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)
        //
        // if the webkit version and safari UI webkit versions are equals,
        // ... this is a stable version.
        //
        // only the internal webkit version is important today to know if
        // media streams are supported
        //
        if (navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
          result.browser = 'safari';
          result.version = this.extractVersion(navigator.userAgent,
            /AppleWebKit\/([0-9]+)\./, 1);

        // unknown webkit-based browser
        } else {
          result.browser = 'Unsupported webkit-based browser ' +
              'with GUM support but no WebRTC support.';
          return result;
        }
      }

    // Edge.
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
      result.browser = 'edge';
      result.version = this.extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);

    // Default fallthrough: not supported.
    } else {
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};

// Export.
module.exports = {
  log: utils.log,
  disableLog: utils.disableLog,
  browserDetails: utils.detectBrowser(),
  extractVersion: utils.extractVersion
};

},{}],111:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],112:[function(require,module,exports){
var bus = require('page-bus')
var short = require('short-uuid')
var id = short().generate()
var emitters = {}
var names = []
var meta = bus({key: '_meta_'})
var join = bus({key: '_join_'})
var self = bus({key: id})
var swarm = {} // ids
var count = 0

join.emit('data', {id: id})

join.on('data', e => {
  if(e.id == id) return
  let em = swarm[e.id] = bus({key: e.id})
  count++
  if(Math.random() <= 1 / Math.pow(count, 2)) return
  else em.emit('data', {events: names, swamrm: Object.keys(swarm)})
})

self.on('data', e => {
  e.events.forEach(ev => {
    if(!emitters[e.name]) {
      var emitter = emitters[e.name] = bus({key:e.name})
    }
  })
  e.swarm.forEach(s => {
    if(!swarm[s]) swarm[s] = bus({key: s})
  })
 count = swarm.length
})

meta.on('data', e => {
  if(!emitters[e.name]) emitters[e.name] = bus({key:e.name})
})

module.exports = {on, once, emit}

function on(name, fn){
  if(!emitters[name]) {
    names.push(name)
    meta.emit('data', {name: name})
    setTimeout(e => on(name, fn), 0)
  }  
  else {
    emitters[name].on(name, fn)
  }
}

function once(name, fn){
  if(!emitters[name]) {
    meta.emit('data', {name: name})
    setTimeout(e => on(name, fn), 0)
  }  
  else emitters[name].once(name, fn)
}

function emit(name, data){
  if(!emitters[name]) {
    meta.emit('data', {name: name})
    setTimeout(e => emit(name, data, 0))
  }  
  else emitters[name].emit(name, data)
}

},{"page-bus":31,"short-uuid":52}],113:[function(require,module,exports){
(function (process,setImmediate){(function (){
var ms2s = 1.0 / 1000.0;
var ns2ms = 1.0 / 1000000.0
var ns2s = 1e-9

module.exports = T

function T(){
	if(!process.hrtime){ // browser fill

		process.hrtime = function(){

			if(arguments.length){
				arguments[1] = new Date().getTime();
				arguments[0] =  arguments[1] - millies(arguments[0])
			}

			else {
				arguments[0] = new Date().getTime();
			}
			
			return [parseInt(arguments[0] * ms2s), parseInt(((arguments[0] * ms2s) % 1) / ns2s)];
			
		}
	}
  if(!(this instanceof T)) return new T();
  var self = this;
  self.start = self.last = self.beat = process.hrtime();
  self.x = []
  self.end = []
  self.beats =  []
  self.averageSetSize = 333
  self.threshold = 1e6 // 10,000,000 ns ( 10 ms )
  self.skip = false
};

T.prototype.sinceBegin = function(){
  return process.hrtime(this.start)
};

T.prototype.sinceLast = function(){
  this.x = process.hrtime(this.last)
  this.last = process.hrtime()
  return this.x
}

T.prototype.sinceLastNS = function(){
  return nanos(this.sinceLast())
};

T.prototype.sinceBeginNS = function(){
  return nanos(this.sinceBegin())
};

T.prototype.avg = function(){
  var ns = nanos(this.sinceLast())
  this.beats.push(ns);
  this.beats = this.beats.splice(-this.averageSetSize)
  return avg(this.beats);
};

T.prototype.everyS = function(s, fn, go){
	this.every(s * 1e9, fn, go)
}

T.prototype.every = function(ns, fn, go){

  var self = new T();
  var timer = new T();

  var inter = ns || 0
    , fn = fn || function(t,c){c()}
    ;   
      
  function tick(){

    var ns = nanos(self.sinceLast());
//  unnecessary cuz no longer trying to optimize in loop()
//    self.beats.push(ns);
    loop()

  };

  function loop(){
    var d = inter - (nanos(process.hrtime()) - nanos(self.beat));

    if(d < 10000) {
      tock()
    }

    else if(self.skip) {
     setImmediate(loop)
    }

    else if(d < self.threshold) {
      // under the threshold, its nextTicks until the interval is up
      self.skip = true; setImmediate(loop) 
    }

    else {
      if(false && self.beats.length > 9) {
        var r = self.beats.length / self.averageSetSize;
        self.threshold = avg(self.beats) * .45 * r * 2
      }

      // for future reference:
      // console.log(avg(self.beats), self.beats.length, 'threshold = ' + self.threshold)

      self.skip = false; 
      setTimeout(loop, self.threshold / 1e6)
    }
  };

  function tock(){
    self.beat = process.hrtime();
    self.skip = false;
    fn(tick, nanos(timer.sinceLast()))
  };
  
  if(go) tock()

  else loop()

}

function millies(arr){
	return (arr[0] * 1e3) + (arr[1] * ns2ms)
}

function nanos(arr){
  return arr[0] * 1e9 + arr[1]
}

function add(a, b){
  var ns = a[1] + b[1];
  b[0] += a[0];
  b[1] = ns % 1e9;
  if(ns !== b[1]) b[0]++;
  return b
};

function avg(){

  return Array.prototype.slice.call(arguments[0]).reduce(function(a,i){return a += i },0) / arguments[0].length

}

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":136,"timers":157}],114:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],115:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],116:[function(require,module,exports){

},{}],117:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":115,"buffer":117,"ieee754":130}],118:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":119,"get-intrinsic":125}],119:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":124,"get-intrinsic":125}],120:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":125}],121:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],122:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],123:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],124:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":123}],125:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":124,"has":129,"has-symbols":126}],126:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":127}],127:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],128:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":127}],129:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":124}],130:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],131:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],132:[function(require,module,exports){
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":118,"has-tostringtag/shams":128}],133:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],134:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":128}],135:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":114,"call-bind/callBound":118,"es-abstract/helpers/getOwnPropertyDescriptor":120,"foreach":122,"has-tostringtag/shams":128}],136:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],137:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],138:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],139:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":137,"./encode":138}],140:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"buffer":117,"dup":50}],141:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":121,"inherits":131,"readable-stream/lib/_stream_duplex.js":143,"readable-stream/lib/_stream_passthrough.js":144,"readable-stream/lib/_stream_readable.js":145,"readable-stream/lib/_stream_transform.js":146,"readable-stream/lib/_stream_writable.js":147,"readable-stream/lib/internal/streams/end-of-stream.js":151,"readable-stream/lib/internal/streams/pipeline.js":153}],142:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],143:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":145,"./_stream_writable":147,"_process":136,"inherits":131}],144:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./_stream_transform":146,"dup":36,"inherits":131}],145:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":142,"./_stream_duplex":143,"./internal/streams/async_iterator":148,"./internal/streams/buffer_list":149,"./internal/streams/destroy":150,"./internal/streams/from":152,"./internal/streams/state":154,"./internal/streams/stream":155,"_process":136,"buffer":117,"events":121,"inherits":131,"string_decoder/":156,"util":116}],146:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"../errors":142,"./_stream_duplex":143,"dup":38,"inherits":131}],147:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":142,"./_stream_duplex":143,"./internal/streams/destroy":150,"./internal/streams/state":154,"./internal/streams/stream":155,"_process":136,"buffer":117,"inherits":131,"util-deprecate":158}],148:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":151,"_process":136}],149:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"buffer":117,"dup":41,"util":116}],150:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":136}],151:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"../../../errors":142,"dup":43}],152:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],153:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../../../errors":142,"./end-of-stream":151,"dup":45}],154:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"../../../errors":142,"dup":46}],155:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"events":121}],156:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76,"safe-buffer":140}],157:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":136,"timers":157}],158:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],159:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],160:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":132,"is-generator-function":134,"is-typed-array":135,"which-typed-array":162}],161:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))

},{"./support/isBuffer":159,"./support/types":160,"_process":136,"inherits":131}],162:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":114,"call-bind/callBound":118,"es-abstract/helpers/getOwnPropertyDescriptor":120,"foreach":122,"has-tostringtag/shams":128,"is-typed-array":135}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uL2pzeW50aC1maWxlLXNhbXBsZS9pbmRleC5qcyIsIi4uL2pzeW50aC1taWMvc3RyZWFtLmpzIiwiL2hvbWUvam9obm55L3Byb2plY3RzL3AycGNvbnNlbnQvaG9zdC5qcyIsIm5vZGVfbW9kdWxlcy9hbnktYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hbnktYmFzZS9zcmMvY29udmVydGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jsb2ItdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItc3BsaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2xhc3MtbGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9kZXRlY3QtYnJvd3Nlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb21yZWFkeS9yZWFkeS5qcyIsIm5vZGVfbW9kdWxlcy9lcnItY29kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudC10YXJnZXQtc2hpbS9kaXN0L2V2ZW50LXRhcmdldC1zaGltLmpzIiwibm9kZV9tb2R1bGVzL2dldC1icm93c2VyLXJ0Yy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXRpZHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0dXNlcm1lZGlhL2dldHVzZXJtZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbWluaW1pc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9ieC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vYngvZGlzdC9tb2J4LmNqcy5kZXZlbG9wbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9tb2J4L2Rpc3QvbW9ieC5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmFub2Fzc2VydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vaHJlZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vZ2ctb3B1cy1kZWNvZGVyL2Rpc3Qvb2dnLW9wdXMtZGVjb2Rlci5taW4uanMiLCJub2RlX21vZHVsZXMvb3B1cy1tZWRpYS1yZWNvcmRlci9PcHVzTWVkaWFSZWNvcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYWdlLWJ1cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9xdWV1ZS1taWNyb3Rhc2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9ydW4td2F0ZXJmYWxsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NkcC9zZHAuanMiLCJub2RlX21vZHVsZXMvc2hvcnQtdXVpZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxodWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9ldmVudC1zb3VyY2Utc3RyZWFtL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9kaXN0L3N0b3JlLmxlZ2FjeS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9wbHVnaW5zL2pzb24yLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3BsdWdpbnMvbGliL2pzb24yLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3NyYy9zdG9yZS1lbmdpbmUuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvYWxsLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL2Nvb2tpZVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvbG9jYWxTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL21lbW9yeVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvb2xkRkYtZ2xvYmFsU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zdG9yYWdlcy9vbGRJRS11c2VyRGF0YVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvc2Vzc2lvblN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL3Rocm91Z2gyLmpzIiwibm9kZV9tb2R1bGVzL3RvLWFycmF5YnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9tZDUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvbmlsLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvcmVnZXguanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9zaGExLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjEuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YzLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92MzUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3Y0LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92NS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2FkYXB0ZXJfY29yZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY2hyb21lL2Nocm9tZV9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9jaHJvbWUvZ2V0dXNlcm1lZGlhLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9lZGdlL2VkZ2Vfc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZWRnZS9nZXR1c2VybWVkaWEuanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2ZpcmVmb3gvZmlyZWZveF9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9maXJlZm94L2dldHVzZXJtZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvc2FmYXJpL3NhZmFyaV9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzaGFyZWRFbWl0dGVyLmpzIiwiLi4vc2luY2Utd2hlbi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9oYXMtdG9zdHJpbmd0YWcvc2hhbXMuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNO0VBQ3hCLE1BQU0sa0JBQWtCLE1BQU0sYUFBYSxJQUFJLE1BQU0sbUJBQW1CO0VBQ3hFLElBQUksTUFBTTtFQUNWLElBQUksSUFBSSxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQzlCLElBQUksS0FBSyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7RUFDNUIsSUFBSSxNQUFNLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztFQUNwQyxHQUFHLEtBQUssQ0FBQyxjQUFjLEVBQUUsS0FBSztJQUM1QixPQUFPLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDZCxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUs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RUFBRSxLQUFLLENBQUMsRUFBRSxxQkFBcUI7Ozs7TUFJdkMsRUFBRSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUM7S0FDaEIsQ0FBQztJQUNGO0NBQ0gsQ0FBQzs7Ozs7O0FDM29CRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy92QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pzTEE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNDQTtBQUNBOzs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNubUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1aENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Q5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNubUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8vIGhhbmRsZXMgYXVkaW8gZmlsZXMgYW5kIHJhdywgbW9ubywgYXVkaW8gYnVmZmVyc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbnRleHQsIGJ1ZmYsIGNiKXtcbiAgXG4gIHZhciBuYW1lID0gYnVmZi5jb25zdHJ1Y3Rvci5uYW1lXG4gIC8vaWYoTWF0aC5yYW5kb20oKSA8IC4wNSkgY29uc29sZS5sb2coYnVmZilcbiAgaWYobmFtZSA9PSAnQXJyYXlCdWZmZXInKXtcbiAgICBjb250ZXh0LmRlY29kZUF1ZGlvRGF0YShidWZmKS50aGVuKGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgdmFyIHNvdXJjZSA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKClcbiAgICAgIHNvdXJjZS5idWZmZXIgPSBkYXRhXG4vKiAgICAgIHZhciBnYWluID0gY29udGV4dC5jcmVhdGVHYWluKClcbiAgICAgIGdhaW4uY2hhbm5lbENvdW50ID0gMVxuICAgICAgZ2Fpbi5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0J1xuICAgICAgZ2Fpbi5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSAnc3BlYWtlcnMnXG4gICAgICBzb3VyY2UuY29ubmVjdChnYWluKVxuICAgICAgc291cmNlLl9jb25uZWN0ID0gc291cmNlLmNvbm5lY3RcbiAgICAgIHNvdXJjZS5jb25uZWN0ID0gZ2Fpbi5jb25uZWN0XG4gKi8gICAgIGNiKG51bGwsIHNvdXJjZSkgXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKXtjYihlcnIsIG51bGwpfSlcblx0XG4gIH1lbHNlIGlmKG5hbWUgPT0gJ0FycmF5Jyl7XG4gIFxuICAgIHZhciBzb3VyY2UgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgXG4gICAgdmFyIGJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlQnVmZmVyKDIsIGJ1ZmZbMF0ubGVuZ3RoLCBjb250ZXh0LnNhbXBsZVJhdGUpXG5cbiAgICB0cnl7IC8vIG5ld1xuICAgICAgYnVmZmVyLmNvcHlUb0NoYW5uZWwoYnVmZlswXSwgMCwgMClcbiAgICAgIGJ1ZmZlci5jb3B5VG9DaGFubmVsKGJ1ZmZbMV0sIDEsIDApXG5cbiAgICB9Y2F0Y2goZXJyKXsgLy8gb2xkXG4gICAgICAvL2J1ZmZlci5nZXRDaGFubmVsRGF0YSgwKS5zZXQoYnVmZilcbiAgICB9XG4gICAgXG4gICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICBcbiAgICAvKlxuICAgIHZhciBnYWluID0gY29udGV4dC5jcmVhdGVHYWluKClcbiAgICBnYWluLmNoYW5uZWxDb3VudCA9IDJcbiAgICBnYWluLmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnXG4gICAgZ2Fpbi5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSAnc3BlYWtlcnMnXG4gICAgc291cmNlLmdhaW4gPSBnYWluXG4gICAgc291cmNlLmNvbm5lY3QoZ2FpbilcbiAgICBzb3VyY2UuX2Nvbm5lY3QgPSBzb3VyY2UuY29ubmVjdFxuICAgIHNvdXJjZS5jb25uZWN0ID0gZ2Fpbi5jb25uZWN0XG4gICAgaWYoY2IpIGNiKG51bGwsIHNvdXJjZSlcbiAgICAqL1xuICAgIHJldHVybiBzb3VyY2VcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtYXN0ZXIsIHN0cmVhbSl7XG4gICAgdmFyIG5vZGUgPSBtYXN0ZXIuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKVxuICAgIHZhciBnYWluID0gbWFzdGVyLmNyZWF0ZUdhaW4oKVxuICAgIGdhaW4uY2hhbm5lbENvdW50ID0gMVxuICAgIGdhaW4uY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCdcbiAgICBnYWluLiBjaGFubmVsSW50ZXJwcmV0YXRpb24gPSAnc3BlYWtlcnMnXG4gICAgbm9kZS5jb25uZWN0KGdhaW4pXG4gICAgcmV0dXJuIGdhaW5cbn1cbiIsIlxucmVxdWlyZSgnZG9tcmVhZHknKShyZSA9PiB7XG4gIGNvbnN0IFdlYkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dFxuICB2YXIgbWFzdGVyIFxuICB2YXIgaCA9IHJlcXVpcmUoJ2h5cGVyc2NyaXB0JylcbiAgdmFyIHVpID0gcmVxdWlyZSgnZ2V0aWRzJykoKVxuICB2YXIgYnVzID0gcmVxdWlyZSgnLi9zaGFyZWRFbWl0dGVyJylcbiAgYnVzLm9uY2UoJ2lmcmFtZUxvYWRlZCcsIGUgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUpXG4gICAgYnVzLmVtaXQoJ3BvbmcnLCB7Z29hdDogMX0pXG4gICAgYnVzLm9uKCdjbG9jaycsIGUgPT4gY29uc29sZS5sb2coZSkpXG4gIH0pXG4gIC8vdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4uL2lmcmFtYXJmaScpXG4gIC8vdmFyIHBlZXJpbmcgPSBpZnJhbWUocmVxdWlyZSgnLi9wZWVyaW5nLmpzJykpXG4gIC8vdWkucGVlcmluZy5hcHBlbmRDaGlsZChwZWVyaW5nKVxuICB2YXIgZnMgPSByZXF1aXJlKCdmcycpXG4gIHZhciBQZWVyID0gcmVxdWlyZSgnc2ltcGxlLXBlZXInKVxuICB2YXIgc2lnbmFsaHViID0gcmVxdWlyZSgnc2lnbmFsaHViJylcbiAgY29uc3Qge21ha2VBdXRvT2JzZXJ2YWJsZSwgIGF1dG9ydW59ID0gcmVxdWlyZSgnbW9ieCcpXG4gIGNvbnN0IHNob3J0ID0gcmVxdWlyZSgnc2hvcnQtdXVpZCcpO1xuICBjb25zdCB0b2EgPSByZXF1aXJlKCd0by1hcnJheWJ1ZmZlcicpXG4gIGNvbnN0IGJ0b2IgPSByZXF1aXJlKCdibG9iLXRvLWJ1ZmZlcicpXG4gIGNvbnN0IHRocnUgPSByZXF1aXJlKCd0aHJvdWdoMicpXG4gIHZhciBzdG9yZSA9IHJlcXVpcmUoJ3N0b3JlJylcbiAgY29uc3QgVGltZSA9IHJlcXVpcmUoJy4uL3NpbmNlLXdoZW4nKVxuICB2YXIgam1pYyA9IHJlcXVpcmUoJy4uL2pzeW50aC1taWMvc3RyZWFtJylcbiAgdmFyIHNhbXBsZXIgPSByZXF1aXJlKCcuLi9qc3ludGgtZmlsZS1zYW1wbGUnKVxuICB2YXIgbWVkaWEgXG4gIHZhciBydW5wID1yZXF1aXJlKCdydW4td2F0ZXJmYWxsJylcbiAgdmFyIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKVxuICB2YXIgbmFuYSA9IHJlcXVpcmUoJ25hbm9ocmVmJylcbiAgdmFyIG1pbmltaXN0ID0gcmVxdWlyZSgnbWluaW1pc3QnKVxuICB2YXIgYXJndiA9IG1pbmltaXN0KHByb2Nlc3MuYXJndiwge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGhvc3Q6ICdmb2xrc3RhY2suY29tJyxcbiAgICAgIHBvcnQ6IDgwLFxuICAgICAgcHJvdG9jb2w6ICdodHRwcydcbiAgICB9XG4gIH0pXG4gIHZhciBkZWJ1YiA9IHNpZ25hbGh1YignaHR0cHM6Ly9mb2xrc3RhY2suY29tOjgwJywgJ2RlYnVnJylcbiAgLy92YXIgcmV0PWRlYnViLnN1YnNjcmliZSgncmV0dXJuJylcblxuICB2YXIgYXBwIFxuICBfbG9nID0gZSA9PntcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2codHlwZW9mIGUsIGUpXG4gICAgICB1aS5kZWJ1Zy5hcHBlbmRDaGlsZChoKCdwJywgZS50b1N0cmluZygpKSkgICAgXG4gICAgICBkZWJ1Yi5icm9hZGNhc3QoJ2RlYnVnJywgSlNPTi5zdHJpbmdpZnkoZSkpXG4gIH1cblxuICB3aW5kb3cuc3RvcmUgPSBzdG9yZVxuXG4gIHJ1bnAoW2luaXRTdGF0ZSwgaW5pdFVJXSwgKGVyciwgYXBwKT0+e1xuICAgIGFwcCA9IGFwcFxuXG4gICAgdWkuaW5pdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgIF9sb2coJ2luaXQnKVxuXG4gICAgICB0cnl7XG4gICAgICAgIHJ1bnAoW2NhcHR1cmVTb3VyY2UsIGNhcHR1cmVTaW5rLCBjYXB0dXJlTmV0d29yaywgaW5pdEF1ZGlvLCBpbml0Q2FzdChhcHApXS5yZXZlcnNlKCksIChlcnIsIGFwcCk9PntcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIsIGFwcClcbiAgICAgICAgICAvL2FwcC5hdWRpby5zb3VyY2VTdHJlYW0ucGlwZShhcHAuYXVkaW8uc2lua1N0cmVhbSkgLy8gaGVoXG4gICAgICAgICAgaWYoYXBwLnNlc3Npb24uYnJvYWRjYXN0aW5nKSB7XG4gICAgICAgICAgICBhcHAubmV0d29yay5kaXN0YW5jZSA9IDFcbi8vICAgICAgICAgICAgYXBwLm5ldHdvcmsuc291cmNlU3RyZWFtID0gYXBwLmF1ZGlvLnNvdXJjZVN0cmVhbVxuICAgICAgICAgICAgYXBwLm5ldHdvcmsuaXNTZWVrV29ydGh5KClcbiAgICAgICAgICAgIGFwcC5uZXR3b3JrLmFsbG93Q2FsbHMoYXBwLnNlc3Npb24uc3RyZWFtKVxuICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGFwcC5uZXR3b3JrLnNvdXJjZVNlZWsoKVxuICAgICAgfSl9IGNhdGNoIChlcnIpe1xuICAgICAgICBfbG9nKGVycilcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICB9KVxuXG4gIHZhciBhZWwgPSB1aS5wbGF5ZXJcbiAgdmFyIG1pbWUgPSAnYXVkaW8vb2dnO2NvZGVjcz1vcHVzJ1xuXG5cbiAgZnVuY3Rpb24gaW5pdFN0YXRlKGNiKXtcblxuICAgIGNsYXNzIEFwcCB7XG4gICAgXG4gICAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLm1pYyA9IDEvMlxuICAgICAgICB0aGlzLm1vbml0b3IgPSAwXG4gICAgICAgIHRoaXMuY2FsbCA9IDEvMlxuICAgICAgICB0aGlzLnRyYWNrID0gMS8yXG4gICAgICAgIHRoaXMucXVhbGl0eSA9IDY0MDAwXG4gICAgICAgIHRoaXMudXBkYXRlID0gbnVsbFxuICAgICAgICBtYWtlQXV0b09ic2VydmFibGUodGhpcylcbiAgICAgIH1cblxuICAgICAgc2V0R2FpbihkaWFsLCB2YWx1ZSl7XG4gICAgICAgIHRoaXNbZGlhbF0gPSB2YWx1ZVxuICAgICAgICB0aGlzLnVwZGF0ZSA9IFtkaWFsLCB2YWx1ZV1cbiAgICAgIH1cbiAgICBcbiAgICB9XG5cbiAgICBjb25zdCBhcHAgPSBuZXcgQXBwXG4gICAgYnVzLm9uKCdhcHBTdGF0ZUNoYW5nZScsIGUgPT57XG4gICAgICBhcHAuc2V0R2FpbihlWzBdLCBlWzFdKVxuICAgIH0pXG4gICAgdmFyIHNlc3Npb24gPSBzdG9yZS5nZXQoJ3Nlc3Npb24nKVxuICAgIGlmKCFzZXNzaW9uKSBzZXNzaW9uID0ge2lkOiBzaG9ydCgpLmdlbmVyYXRlKCkuc3BsaXQoKS5yZXZlcnNlKCkuam9pbigpLnNsaWNlKDAsMTEpfVxuICAgIHNlc3Npb24uYnJvYWRjYXN0aW5nID0gdHJ1ZVxuICAgIHZhciBxID0gcXMucGFyc2Uod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKSlcbiAgICBpZihxLnN0cmVhbSkge1xuICAgICAgc2Vzc2lvbi5zdHJlYW0gPSBxLnN0cmVhbVxuICAgICAgc2Vzc2lvbi5icm9hZGNhc3RpbmcgPSBmYWxzZSBcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzZXNzaW9uLnN0cmVhbSA9IHNlc3Npb24uc3RyZWFtIHx8IHNob3J0KCkuZ2VuZXJhdGUoKS5zcGxpdCgpLnJldmVyc2UoKS5qb2luKCkuc2xpY2UoMCwxMSlcbiAgICB9XG5cbiAgICBhcHAuc2Vzc2lvbiA9IHNlc3Npb25cbiAgICBzdG9yZS5zZXQoJ3Nlc3Npb24nLCBzZXNzaW9uKVxuICAgIGNvbnNvbGUubG9nKGFwcClcbiAgICBjYihudWxsLCBhcHApXG4gIH1cblxuICBmdW5jdGlvbiBpbml0QXVkaW8oYXBwLCBjYil7XG4gICAgY29uc3QgYXVkaW8gPSB7fVxuICAgIHZhciBPcHVzTWVkaWFSZWNvcmRlciA9IHJlcXVpcmUoJ29wdXMtbWVkaWEtcmVjb3JkZXInKSBcbiAgICB3aW5kb3cuTWVkaWFSZWNvcmRlciA9IE9wdXNNZWRpYVJlY29yZGVyO1xuICAgIG1hc3RlciA9IG5ldyBXZWJBdWRpb0NvbnRleHQoe3NhbXBsZVJhdGU6IDQ4MDAwfSlcbiAgICBhdWRpby5tYXN0ZXIgPSBtYXN0ZXJcbiAgICBhdWRpby5icm9hZGNhc3RtaXhlciA9IG1hc3Rlci5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpXG4gICAgYXVkaW8uY2FsbG1peGVyID0gbWFzdGVyLmNyZWF0ZUNoYW5uZWxNZXJnZXIoMilcbiAgICBhdWRpby5icm9hZGNhc3RzdHJlYW0gPSBtYXN0ZXIuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpXG4gICAgYXVkaW8uY2FsbHN0cmVhbSA9IG1hc3Rlci5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKClcbiAgICBhdWRpby5tb25pdG9yID0gbWFzdGVyLmNyZWF0ZUdhaW4oKVxuICAgIGF1ZGlvLm1pYyA9IG1hc3Rlci5jcmVhdGVHYWluKClcbiAgICBhdWRpby5jYWxsID0gbWFzdGVyLmNyZWF0ZUdhaW4oKVxuICAgIGF1ZGlvLnRyYWNrbWl4ZXIgPSBtYXN0ZXIuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKVxuICAgIGF1ZGlvLnRyYWNrID0gbWFzdGVyLmNyZWF0ZUdhaW4oKVxuICAgIGF1ZGlvLnRyYWNrbWl4ZXIuY29ubmVjdChhdWRpby50cmFjaylcblxuICAgIGF1ZGlvLmJyb2FkY2FzdG1peGVyLmNvbm5lY3QoYXVkaW8uYnJvYWRjYXN0c3RyZWFtKVxuICAgIC8vYXVkaW8uYnJvYWRjYXN0bWl4ZXIuY29ubmVjdChhdWRpby5tb25pdG9yKVxuXG4gICAgYXVkaW8uY2FsbG1peGVyLmNvbm5lY3QoYXVkaW8uY2FsbHN0cmVhbSlcbiAgICAvL2F1ZGlvLmNhbGxtaXhlci5jb25uZWN0KGF1ZGlvLm1vbml0b3IpXG5cblxuICAgIGF1ZGlvLm1pYy5jb25uZWN0KGF1ZGlvLm1vbml0b3IpXG4gICAgYXVkaW8uY2FsbC5jb25uZWN0KGF1ZGlvLm1vbml0b3IpXG4gICAgYXVkaW8udHJhY2suY29ubmVjdChhdWRpby5tb25pdG9yKVxuICAgIGF1ZGlvLm1vbml0b3IuY29ubmVjdChtYXN0ZXIuZGVzdGluYXRpb24pXG5cbiAgICBhdWRpby5taWMuY29ubmVjdChhdWRpby5icm9hZGNhc3RtaXhlcilcbiAgICBhdWRpby50cmFjay5jb25uZWN0KGF1ZGlvLmJyb2FkY2FzdG1peGVyKVxuICAgIGF1ZGlvLmNhbGwuY29ubmVjdChhdWRpby5icm9hZGNhc3RtaXhlcilcblxuICAgIGF1ZGlvLm1pYy5jb25uZWN0KGF1ZGlvLmNhbGxtaXhlcilcbiAgICBhdWRpby50cmFjay5jb25uZWN0KGF1ZGlvLmNhbGxtaXhlcilcblxuICAgIGF1ZGlvLmJyb2FkY2FzdG1peGVyLmNvbm5lY3QoYXVkaW8uYnJvYWRjYXN0c3RyZWFtKVxuICAgIGF1ZGlvLmNhbGxtaXhlci5jb25uZWN0KGF1ZGlvLmNhbGxzdHJlYW0pXG4gICAgXG4gICAgY29uc3Qgd29ya2VyT3B0aW9ucyA9IHtcbiAgICAgIGVuY29kZXJXb3JrZXJGYWN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFVNRCBzaG91bGQgYmUgdXNlZCBpZiB5b3UgZG9uJ3QgdXNlIGEgd2ViIHdvcmtlciBidW5kbGVyIGZvciB0aGlzLlxuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcih0b2IoZnMucmVhZEZpbGVTeW5jKCcuL3B1YmxpYy9zdGF0aWMvZW5jb2Rlcldvcmtlci51bWQuanMnKSkpXG4gICAgICB9LFxuICAgICAgT2dnT3B1c0VuY29kZXJXYXNtUGF0aDogdG9iKGZzLnJlYWRGaWxlU3luYygnLi9wdWJsaWMvc3RhdGljL09nZ09wdXNFbmNvZGVyLndhc20nKSksXG4gICAgICBXZWJNT3B1c0VuY29kZXJXYXNtUGF0aDogdG9iKGZzLnJlYWRGaWxlU3luYygnLi9wdWJsaWMvc3RhdGljL1dlYk1PcHVzRW5jb2Rlci53YXNtJykpXG4gICAgfTtcblxuICAgIGF1ZGlvLmJyb2FkY2FzdGVuY29kZXIgPSBuZXcgTWVkaWFSZWNvcmRlcihhdWRpby5icm9hZGNhc3RzdHJlYW0uc3RyZWFtLCB7YXVkaW9CaXRzUGVyU2Vjb25kOjY0MDAwLCBtaW1lVHlwZTptaW1lfSwgd29ya2VyT3B0aW9ucylcbiAgICBhdWRpby5jYWxsZW5jb2RlciA9IG5ldyBNZWRpYVJlY29yZGVyKGF1ZGlvLmNhbGxzdHJlYW0uc3RyZWFtLCB7YXVkaW9CaXRzUGVyU2Vjb25kOjY0MDAwLCBtaW1lVHlwZTptaW1lfSwgd29ya2VyT3B0aW9ucylcblxuICAgIGF1ZGlvLmJyb2FkY2FzdGVuY29kZXIuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIGUgPT4ge1xuICAgICAgYnRvYihlLmRhdGEsIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgICAvL2J1ZnIucHVzaChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgICAvL2FwcC5hdWRpby5kZWNvZGVyLmRlY29kZShidWYpICAgICBcbiAgICAgICAgYXBwLm5ldHdvcmsuYnJvYWRjYXN0KGJ1ZilcbiAgICAgICAgLy9zdHJTcmMud3JpdGUoYnVmKVxuICAgICAgfSlcblxuICAgIH0pXG5cbiAgICBhdWRpby5jYWxsZW5jb2Rlci5hZGRFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgZSA9PiB7XG4gICAgICBidG9iKGUuZGF0YSwgKGVyciwgYnVmKSA9PiB7XG4gICAgICAgIC8vYnVmci5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgICAgIGFwcC5hdWRpby5kZWNvZGVyLmRlY29kZShidWYpICAgICBcbiAgICAgICAgLy9hcHAubmV0d29yay5zZW5kKGJ1ZilcbiAgICAgICAgLy9zdHJTcmMud3JpdGUoYnVmKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgXG4gICAgYXVkaW8uYnJvYWRjYXN0ZW5jb2Rlci5zdGFydCgxMDAwKVxuXG4gICAgYXV0b3J1bigoKT0+e1xuICAgICAgaWYoYXBwLnVwZGF0ZSkge1xuICAgICAgICBhdWRpb1thcHAudXBkYXRlWzBdXS5nYWluLnZhbHVlID0gTWF0aC5tYXgoMCwgYXBwLnVwZGF0ZVsxXSkvLy5tb25pdG9yXG4gICAgICB9IFxuICAgIH0pXG5cbiAgICBfbG9nKGBtZWRpYVJlY29yZGVyIGFkZGVkPyAkeyghIWF1ZGlvLmJyb2FkY2FzdGVuY29kZXIpfWApXG5cbiAgICBhcHAuYXVkaW8gPSBhdWRpb1xuICAgIG1hc3Rlci5yZXN1bWUoKVxuICAgIGNiKG51bGwsIGFwcClcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRVSShhcHAsIGNiKXtcblxuICAgIHVpLmxpdmVsaW5rLmlubmVyVGV4dCA9ICdodHRwczovL2dhYnIudmVyY2VsLmFwcD9zdHJlYW09JythcHAuc2Vzc2lvbi5zdHJlYW1cbiAgICB1aS5jb3B5YnV0dG9uLm9uY2hhbmdlID0gZSA9PiB7XG4gICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh1aS5saW5rLmlubmVyVGV4dClcbiAgICB9XG4gICAgdWkucmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgIGFwcC5uZXR3b3JrLmluaXRDYWxsKGFwcC5zZXNzaW9uLnN0cmVhbSlcbiAgICB9KVxuICAgIHVpLmZpbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhlLnRhcmdldC5maWxlc1swXSlcbiAgICAgIHZhciBhID0gaCgnYXVkaW8uaW52ZXJ0Jywge2NvbnRyb2xzOiB0cnVlLCBzcmMgOiBVUkwuY3JlYXRlT2JqZWN0VVJMKGUudGFyZ2V0LmZpbGVzWzBdKX0pXG4gICAgICB1aS50cmFja3MuYXBwZW5kQ2hpbGQoYSlcbiAgICAgIHZhciBjPSBhcHAuYXVkaW8ubWFzdGVyLmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShhKVxuICAgICAgY29uc29sZS5sb2coYSlcbiAgICAgIGMuY29ubmVjdChhcHAuYXVkaW8udHJhY2ttaXhlcilcbiAgICAgIGJ0b2IoZS50YXJnZXQuZmlsZXNbMF0sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgICBzYW1wbGVyKGFwcC5hdWRpby5tYXN0ZXIsIGJ1Zi5idWZmZXIsIChlcnIsIG5vZGUpID0+e1xuICAgICAgICAgIC8vbm9kZS5jb25uZWN0KGFwcC5hdWRpby5tYXN0ZXIuZGVzdGluYXRpb24pXG4gICAgICAgICAgLy9ub2RlLnN0YXJ0KDApXG4gICAgICAgIH0pICAgICAgXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICA7W10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9cmFuZ2VdJyksIGUgPT4ge1xuICAgICAgZS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGV2ID0+IHtcbiAgICAgICAgYnVzLmVtaXQoJ2FwcFN0YXRlQ2hhbmdlJywgW2V2LnRhcmdldC5uYW1lLCBOdW1iZXIoZXYudGFyZ2V0LnZhbHVlKV0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICA7W10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW11dGVdJyksIGUgPT4ge1xuICAgICAgZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBldiA9PiB7XG4gICAgICAgIGJ1cy5lbWl0KCdhcHBTdGF0ZUNoYW5nZScsIFtldi50YXJnZXQuZGF0YXNldC5tdXRlLCAtIGFwcFtldi50YXJnZXQuZGF0YXNldC5tdXRlXV0pXG4gICAgICB9KVxuICAgIH0pXG5cblxuICAgIHVpLm1vbml0b3JSYW5nZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0LnZhbHVlKVxuICAgICAgLy9idXMuZW1pdCgnYXBwU3RhdGVDaGFuZ2UnLCBbJ21vbml0b3InLCBOdW1iZXIoZS50YXJnZXQudmFsdWUpXSlcbiAgICAgIC8vYXBwLnNldEdhaW4oJ21vbml0b3InLCBOdW1iZXIoZS50YXJnZXQudmFsdWUpKVxuICAgIH0pXG5cbiAgICBjYihudWxsLGFwcClcblxuICB9XG5cblxuICBmdW5jdGlvbiBpbml0Q2FzdChhcHApe1xuICBcbiAgICByZXR1cm4gZnVuY3Rpb24oY2Ipe1xuICAgICAgX2xvZygnc3RhdGVJbml0JylcbiAgICAgIGNiKG51bGwsIGFwcClcbiAgICBcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2FwdHVyZU5ldHdvcmsoYXBwLCBjYikge1xuICAgIHZhciBuZXR3b3JrID0gbmV3IE5ldHdvcmsoYXBwLCBhcmd2LnByb3RvY29sICsgJzovLycgKyBhcmd2Lmhvc3QgKyAnOicgKyBhcmd2LnBvcnQpXG4gICAgX2xvZygnbmV0Q2FwJylcbiAgICBhcHAubmV0d29yayA9IG5ldHdvcmtcblxuICAgIGNiKG51bGwsIGFwcClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhcHR1cmVTb3VyY2UgKGFwcCwgY2IpIHtcbiAgICAvLyBUT0RPIHNvdXJjZSBpcyBlaXRoZXIgdGhlIG1lZGlhc3RyZWFtIG9yIGEgcGVlciBjb25uZWN0aW9uXG4gICAgXG4gICAgaWYodHJ1ZSB8fCBhcHAuc2Vzc2lvbi5icm9hZGNhc3Rpbmcpe1xuICAgICAgYWRkTWVkaWEoKGVyciwgc3RyZWFtKSA9PntcbiAgICAgICAgX2xvZyhgbWVkaWFTdHJlYW0gYWRkZWQ/ICR7KCEhc3RyZWFtKX1gKVxuICAgICAgICBfbG9nKGBtZWRpYVN0cmVhbSBlcnJvcj8gJHsoZXJyKX1gKVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGVycilcbiAgICAgICAgY29uc29sZS5sb2coc3RyZWFtKVxuXG4gICAgICAgIGNvbnN0IG1pYyA9IGFwcC5hdWRpby5tYXN0ZXIuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKSBcbiAgICAgICAgbWljLmNvbm5lY3QoYXBwLmF1ZGlvLm1pYylcblxuICAgICAgICBhcHAuYXVkaW8ubWVkaWFzdHJlYW0gPSBzdHJlYW1cbiAgICAgICAgYXBwLmF1ZGlvLm1pY25vZGUgPSBtaWNcbiAgICBcbiAgICAgICAgLypcbiAgICAgICAgdmFyIGJ1ZnIgPSBbXVxuICAgICAgICBhcHAuYXVkaW8uYnVmZmVyID0gYnVmclxuICAgICAgICBjb25zdCBzdHJTcmMgPSB0aHJ1KChiLCByLCBjYik9PntcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzb3VyY2UnLCBiKVxuICAgICAgICAgIGNiKG51bGwsIGIpXG4gICAgICAgIH0sZT0+e1xuICAgICAgICAgIGNvbnNvbGUubG9nKGUpXG4gICAgICAgIH0gKVxuICAgICAgICBhcHAuYXVkaW8uc291cmNlU3RyZWFtID0gc3RyU3JjXG4gICAgICAgICovXG4gICAgICAgIC8vIGRvIHNhbWUgZm9yIGhvc3QgbW9uaXRvcmluZzpcbiAgICAgICAgLy9mb3IodmFyIHNtaXRoIGluIHBob25lYm9vaykgbWVkaWFTdHJlYW0ucGlwZShwaG9uZWJvb2tbc21pdGhdKSBcbiAgICAgICAgLy91aS5tb25pdG9yLnNyY09iamVjdCA9IHN0cmVhbS8vID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pICAgICAgXG4gICAgICAgIC8vIERlbGV0ZSB0aGUgZW5jb2RlciB3aGVuIGZpbmlzaGVkIHdpdGggaXQgKEVtc2NyaXB0ZW4gZG9lcyBub3QgYXV0b21hdGljYWxseSBjYWxsIEMrKyBvYmplY3QgZGVzdHJ1Y3RvcnMpXG4gICAgICAgIC8vZW5jb2Rlci5kZWxldGUoKTtcbiAgICAgICBfbG9nKCdzb3VyY2VDYXAnKVxuICAgICAgICBjYihlcnIsIGFwcClcbiAgICAgICAgXG4gICAgICBcbiAgICAgIH0pXG4gICAgfVxuXG5cblxuXG4gIH1cblxuICBmdW5jdGlvbiBjYXB0dXJlU2luayhhcHAsIGNiKXtcbiAgICB2YXIge09nZ09wdXNEZWNvZGVyfSA9IHJlcXVpcmUoJ29nZy1vcHVzLWRlY29kZXInKVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3NtKGxvZyl7XG4gICAgXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IE9nZ09wdXNEZWNvZGVyKHtvbkRlY29kZSwgb25EZWNvZGVBbGx9KVxuXG4gICAgICBmdW5jdGlvbiBvbkRlY29kZSAoKSB7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRGVjb2RlQWxsICh7Y2hhbm5lbERhdGEsIHNhbXBsZXNEZWNvZGVkLCBzYW1wbGVSYXRlfSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGFubmVsJykvL2NoYW5uZWxEYXRhKVxuICAgICAgICBsZXQgc2FtID0gc2FtcGxlcihhcHAuYXVkaW8ubWFzdGVyLCBjaGFubmVsRGF0YSlcbiAgICAgICAgc2FtLmNvbm5lY3QoYXBwLmF1ZGlvLm1hc3Rlci5kZXN0aW5hdGlvbilcbiAgICAgICAgc2FtLnN0YXJ0KDApXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGRlY29kZXIucmVhZHlcblxuICAgICAgY29uc3Qgc2lua1N0cmVhbSA9IHRocnUoKGJ1ZiwgZW5jLCBjYikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnc2luaycsIGJ1ZilcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoYnVmKVxuICAgICAgICBjYigpXG4gICAgICB9LCBlID0+e1xuICAgICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgXG4gICAgICB9KVxuXG4gICAgICB2YXIgc2lua1N0YXRlID0ge1xuICAgICAgICBzaW5rOiBzaW5rU3RyZWFtLFxuICAgICAgfVxuXG4gICAgICBsb2coKVxuICAgICAgYXBwLmF1ZGlvLmRlY29kZXIgPSBkZWNvZGVyXG4gICAgICBhcHAuYXVkaW8uc2lua1N0cmVhbSA9IHNpbmtTdHJlYW1cbiAgICAgIF9sb2coJ3NpbmtDYXAnKVxuICAgICAgY2IobnVsbCwgYXBwKVxuICAgICAgXG4gICAgfVxuXG5cbiAgICB3c20oZnVuY3Rpb24oKXtjb25zb2xlLmxvZygnV0FTTScpfSlcblxuICB9XG5cblxuXG4gIGZ1bmN0aW9uIHRvYihidWYpe1xuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtuZXcgQnVmZmVyKGJ1ZikuYnVmZmVyXSwge3R5cGU6ICdhcHBsaWNhdGlvbi93YXNtJ30pKVxuICB9XG4gICBcbiAgdmFyIHBlZXJzID0ge31cblxuICAvL3VpLmFkZE1pYy5vbmNsaWNrID0gZSA9PiBhZGRNZWRpYSgpXG5cbiAgZnVuY3Rpb24gbXV0ZSh0b3JmKXtcbiAgICBtaWNTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdG9yZlxuICB9XG5cblxuICB2YXIgY29ubmVjdGluZyA9IHt9XG4gIGZ1bmN0aW9uIGluaXRCcm9hZGNhc3QoKXtcbiAgICAvLyBzb3VyY2UgY2FwIHRoZW4gYnJvYWRjYXN0XG4gICAgc2Vzc2lvbi5icm9hZGNhc3RJZCA9IHNob3J0KCkuZ2VuZXJhdGUoKVxuICAgIHNlc3Npb3MuZGlzdGFuY2UgPSAwXG4gICAgc2Vzc2lvbi5tYXhDb25uZWN0aW9ucyA9IDIwXG4gICAgc2Vzc2lvbi5vZmZlcnNPdXQgPSAwXG4gICAgLy8gYmUgc2Vla2FibGUgd2hlbi4uXG4gICAgc2Vla2FibGUoc2Vzc2lvbilcbiAgICByZXR1cm4gc2Vzc2lvblxuICB9XG5cblxuXG4gIGNsYXNzIE5ldHdvcmsgeyBcblxuICAgIGNvbnN0cnVjdG9yKGFwcCwgYWRkcil7XG4gICAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgICAgLy9jb25zb2xlLmxvZyhzdGF0ZSwgYWRkcilcbiAgICAgIHRoaXMuaHViID0gc2lnbmFsaHViKGFkZHIsIGFwcC5zZXNzaW9uLnN0cmVhbSlcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGFwcC5zZXNzaW9uLnN0cmVhbVxuICAgICAgdGhpcy5pZCA9IGFwcC5zZXNzaW9uLmlkXG4gICAgICB0aGlzLnN0YXRlID0gYXBwLnN0YXRlXG4gICAgICB0aGlzLmNvbm5lY3Rpb25zID0ge31cbiAgICAgIHRoaXMuaHVicyA9IHt9IFxuICAgICAgdGhpcy5wZWVycyA9IHt9XG4gICAgICB0aGlzLmNhbGxlcnMgPSB7fVxuICAgICAgdGhpcy5jb25uZWN0aW5nID0ge31cbiAgICAgIHRoaXMuZGlzdGFuY2UgPSAxXG4gICAgICB0aGlzLm9mZmVyc091dCA9IDBcbiAgICAgIHRoaXMubWF4Q29ubmVjdGlvbnMgPSA0IC8vIHN0YXJ0IGxvdywgdGVzdCBoaWdoLCBhbHNvIGhlbHBzIHNwcmVhZCBlYXJseSBwY2FzdCB0ZXN0aW5nXG4gICAgICB0aGlzLmR1cmF0aW9uID0gbnVsbCAvLyBzaW5jZS13aGVuXG4gICAgICB0aGlzLmNoYW5uZWxzID0ge31cbiAgICAgIHRoaXMuZHVyYXRpb24gPSBuZXcgVGltZVxuICAgICAgdGhpcy5zaW5rU3RyZWFtID0gdGhydShidWYgPT4ge1xuICAgICAgICBmb3IodmFyIG4gaW4gdGhpcy5wZWVycyl7XG4gICAgICAgICAgbGV0IHAgPSB0aGlzLnBlZXJzW25dXG4gICAgICAgICAgaWYocC53cml0YWJsZSkgcC53cml0ZShidWYpXG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uIGNsb3NlKCl7fSlcbiAgICB9XG5cbiAgICBicm9hZGNhc3QoYnVmKXtcbiAgICAgIGZvcih2YXIgbiBpbiB0aGlzLnBlZXJzKSB0aGlzLnBlZXJzW25dLndyaXRlKGJ1ZilcbiAgICB9XG5cbiAgICBzZW5kKGJ1Zil7XG4gICAgICBmb3IodmFyIG4gaW4gdGhpcy5jYWxsZXJzKSB0aGlzLmNhbGxlcnNbbl0ud3JpdGUoYnVmKVxuICAgIH1cblxuICAgIGxvZygpe1xuICAgICAgY29uc29sZS5sb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH1cblxuICAgIGNsb3NlUGVlclNpZ25hbChhZGRyKXtcbiAgICAgIHRoaXMuaHViLnVuc3Vic2NyaWJlKGFkZHIpXG4gICAgICAvL2RlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW2FkZHJdXG4gICAgfVxuXG4gICAgZGlzYWxsb3dDYWxscyhpZCl7XG4gICAgICB0aGlzLmh1Yi51bnN1YnNjcmliZSgnY2FsbGVyOicraWQpXG4gICAgfVxuXG4gICAgYWxsb3dDYWxscyhpZCl7XG4gICAgICBsZXQgY2FsbHMgPSB0aGlzLmh1Yi5zdWJzY3JpYmUoJ2NhbGxlcjonK2lkKVxuICAgICAgY2FsbHMub24oJ2RhdGEnLCBtc2c9PntcbiAgICAgICAgbXNnPUpTT04ucGFyc2UobXNnKVxuICAgICAgICBidXMuZW1pdCgnY2FsbGVyJywgbXNnKVxuICAgICAgfSlcbiAgICAgIGJ1cy5vbignY2FsbCcsIG1zZyA9PntcbiAgICAgICAgdGhpcy5jYWxsRGlyZWN0KG1zZy5wZWVySWQpXG4gICAgICB9KVxuXG4gICAgfVxuXG4gICAgaW5pdENhbGwoaWQpe1xuICAgICAgXG4gICAgICB0aGlzLmh1Yi5icm9hZGNhc3QoJ2NhbGxlcjonK2lkLCB7cGVlcklkOiB0aGlzLmlkfSlcbiAgICAgIGxldCBwZWVyID0gdGhpcy5pbml0Q29ubmVjdChpZCwgZmFsc2UsIHRoaXMuaWQpXG4gICAgICBwZWVyLm9uY2UoJ2Nvbm5lY3RlZCcsIGUgPT57XG4gICAgICAgIHRoaXMuY2FsbGVyc1tpZF0gPSBwZWVyXG4gICAgICAgIGJ1cy5lbWl0KCdDYWxsIFNvdXJjZSBDYXB0dXJlZCcsIHBlZXIpXG5cbiAgICAgIH0pXG4gICAgICBcbiAgICAgIFxuICAgIH1cblxuICAgIGNhbGxEaXJlY3QoaWQpe1xuICAgICAgbGV0IHBlZXIgPSB0aGlzLmluaXRDb25uZWN0KGlkLCB0cnVlLCB0aGlzLmlkKVxuICAgICAgcGVlci5vbmNlKCdjb25uZWN0ZWQnLCBlID0+e1xuICAgICAgICB0aGlzLmNhbGxlcnNbaWRdID0gcGVlclxuICAgICAgICBidXMuZW1pdCgnQ2FsbCBTb3VyY2UgQ2FwdHVyZWQnLCBwZWVyKVxuXG4gICAgICB9KVxuICAgIH1cblxuICAgIHNvdXJjZVNlZWsoKXsgLy8gaWQgZm9yIGEgcGVlciBzdHJlYW1cbiAgICAgIHZhciBzZWxmID0gdGhpcyBcbiAgICAgIGxldCBtYXNrID0gc2hvcnQoKS5nZW5lcmF0ZSgpXG4gICAgICBsZXQgb2ZmZXJpbmdzID0gdGhpcy5odWIuc3Vic2NyaWJlKG1hc2spXG4gICAgICB2YXIgYmVzdCA9IDAvL0luZmluaXR5XG4gICAgICB2YXIgY2hvc2VuXG4gICAgICB2YXIgc3RhcnQgPSBuZXcgVGltZVxuICAgICAgb2ZmZXJpbmdzLm9uKCdkYXRhJywgb2ZmZXIgPT4ge1xuICAgICAgICBvZmZlciA9IEpTT04ucGFyc2Uob2ZmZXIpXG4gICAgICAgIF9sb2cob2ZmZXIpXG4gICAgICAgIGxldCBzY29yZSA9ICgxIC8gb2ZmZXIuZGlzdGFuY2UpICogb2ZmZXIuZHVyYXRpb25cbiAgICAgICAgaWYoc2NvcmUgPiBiZXN0KSB7XG4gICAgICAgICAgYmVzdCA9IHNjb3JlIC8vb2ZmZXIuZGlzdGFuY2VcbiAgICAgICAgICBjaG9zZW4gPSBvZmZlclxuICAgICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhjaG9zZW4pXG4gICAgICB9KVxuICAgICAgbGV0IHQwID0gc2V0VGltZW91dChlID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGNob3NlbilcbiAgICAgICAgaWYoY2hvc2VuKSB7XG4gICAgLy8gICAgICB0aGlzLmh1Yi51bnN1YnNjcmliZShtYXNrKVxuICAgICAgICAgIC8vIGRvIGNob3NlblxuICAgICAgICAgIGJ1cy5lbWl0KCdzb3VyY2VQZWVySWRDYXB0dXJlZCcsIGNob3Nlbi5wZWVySWQpXG4gICAgICAgICAgLy9zZWxmLnNvdXJjZUNhcChjaG9zZW4pXG4gICAgICAgICAgbGV0IHBlZXIgPSB0aGlzLmluaXRDb25uZWN0KGNob3Nlbi5wZWVySWQsIHRydWUsIG1hc2spXG4gICAgICAgICAgcGVlci5vbmNlKCdjb25uZWN0JywgZSA9PiB7XG4gICAgICAgICAgICBidXMuZW1pdCgnc291cmNlUGVlckNhcHR1cmVkJywgcGVlcilcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBjaG9zZW4uZGlzdGFuY2UgKyAxXG4gICAgICAgICAgICB0aGlzLnNvdXJjZVN0cmVhbSA9IHBlZXJcbiAgICAgICAgICAgIHBlZXIub24oJ2RhdGEnLCBidWYgPT4ge1xuICAgICAgICAgICAgICBhcHAuYXVkaW8uZGVjb2Rlci5kZWNvZGUoYnVmKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF9sb2coJ1NvdXJjZSBQZWVyIENhcHR1cmVkLicpXG5cbiAgICAgICAgICB9KVxuICAgICAgICAgIHBlZXIub24oJ2Nsb3NlJywgZSA9PiB7XG4gICAgICAgICAgICBfbG9nKCdTb3VyY2UgUGVlciBDbG9zZWQnKVxuXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbG9nKCdFcnI6IE5vIHNvdXJjZSBwZWVyIGZvdW5kLicpICAgIFxuICAgICAgICB9XG4gICAgICB9LCAxMzAwMClcbiAgICAgIFxuXG4gICAgICB0aGlzLmh1Yi5icm9hZGNhc3QoJ3NvdXJjZScsIFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcGVlcklkOiBtYXNrXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICBcbiAgICB9XG5cbiAgICBzZXQgc291cmNlU3RyZWFtKHN0cmVhbSl7XG4gICAgICB0aGlzLl9zb3VyY2VTdHJlYW0gPSBzdHJlYW1cbiAgICAgIHRoaXMuZHVyYXRpb24gPSBuZXcgVGltZSgpXG4gICAgICAvL3N0cmVhbS5waXBlKHRoaXMuc2lua1N0cmVhbSlcbiAgICAgIC8vc3RyZWFtLnBpcGUoYXBwLmF1ZGlvLnNpbmtTdHJlYW0pXG4gICAgfVxuXG4gICAgZ2V0IHNvdXJjZVN0cmVhbSgpe1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZVN0cmVhbVxuICAgIH1cblxuICAgIHVuc2Vla2FibGUoc2Vzc2lvbil7XG4gICAgICBpZihzZXNpb24pIHRoaXMuaHViLnVuc3Vic2NyaWJlKHNlc3Npb24pXG4gICAgfVxuXG4gICAgaXNTZWVrV29ydGh5KCl7XG4gICAgICBsZXQgciA9IHRoaXMub2ZmZXJzT3V0IDwgdGhpcy5tYXhDb25uZWN0aW9uc1xuICAgICAgbGV0IHMgPSB0aGlzLm1heENvbm5lY3Rpb25zID4gT2JqZWN0LmtleXModGhpcy5jb25uZWN0aW9ucykubGVuZ3RoICBcbiAgICAgIGxldCBxID0gciAmJiBzIFxuICAgICAgdGhpcy5fc2Vla2FibGUgPSBxXG4gICAgICBpZihxKSB7XG4gICAgICAgIHRoaXMuc291cmNlciA9IHRoaXMuaHViLnN1YnNjcmliZSgnc291cmNlJylcbiAgICAgICAgdGhpcy5zb3VyY2VyLm9uKCdkYXRhJywgbXNnID0+IHRoaXMuc2Vla2FibGUoSlNPTi5wYXJzZShtc2cpKSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZih0aGlzLnNvdXJjZXIpIHRoaXMuc291cmNlci5jbG9zZSgpXG4gICAgICAgIFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3NlZWthYmxlXG4gICAgfVxuXG4gICAgc2V0c3ViKGlkKXtcbiAgICAgIGlmKHRoaXMuaHVic1tpZF0pIHJldHVybiB0aGlzLmh1YnNbaWRdXG4gICAgICBlbHNlIHRoaXMuaHVic1tpZF0gPSB0aGlzLmh1Yi5zdWJzY3JpYmUoaWQpXG4gICAgfVxuICAgIGdldHN1YihpZCl7XG4gICAgICByZXR1cm4gdGhpcy5odWJzW2lkXVxuICAgIH1cblxuICAgIHVuc3ViKGlkKXtcbiAgICAgIGlmKHRoaXMuaHVic1tpZF0pIHtcbiAgICAgICAgdGhpcy5odWIudW5zdWJzY3JpYmUoaWQpIFxuICAgICAgICBkZWxldGUgdGhpcy5odWJzW2lkXSBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVrYWJsZShtc2cpeyBcbiAgICBfbG9nKG1zZylcbiAgICAgIGxldCBzZWxmID0gdGhpc1xuICAgICAgaWYoZmFsc2UpIHJldHVybiAvLyB8fCBNYXRoLnJhbmRvbSgpIDwgMSAvIE1hdGgucG93KHNlbGYuZGlzdGFuY2UsIDIpKSByZXR1cm5cbiAgICAgIGVsc2V7XG4gICAgICAgIHNlbGYub2ZmZXJzT3V0ICs9IDFcbiAgICAgICAgc2V0VGltZW91dChlPT57XG4gICAgICAgICAgdGhpcy5vZmZlcnNPdXQtLVxuICAgICAgICAgIC8vdGhpcy5kaXNuaXQobXNnLnBlZXJJZCwgbWFzaylcbiAgICAgICAgfSwgMTExMSozKVxuICAgICAgICBsZXQgbWFzayA9IHNob3J0KCkuZ2VuZXJhdGUoKVxuICAgICAgICBsZXQgcGVlciA9IHRoaXMuaW5pdENvbm5lY3QobXNnLnBlZXJJZCwgZmFsc2UsIG1hc2spXG4gICAgICAgIHBlZXIub25jZSgnY29ubmVjdCcsIGUgPT57XG4gICAgICAgICAgc2VsZi5wZWVyc1ttc2cucGVlcklkXSA9IHBlZXJcbiAgICAgICAgfSlcbiAgICAgICAgcGVlci5vbmNlKCdjbG9zZScsIGUgPT57XG4gICAgICAgICAgZGVsZXRlIHNlbGYucGVlcnNbbXNnLnBlZXJJZF1cbiAgICAgICAgICBzZWxmLmlzU2Vla1dvcnRoeSgpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuaHViLmJyb2FkY2FzdChtc2cucGVlcklkLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcGVlcklkOiBtYXNrLFxuICAgICAgICAgIHRvOiBtc2cucGVlcklkLFxuICAgICAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLnNpbmNlQmVnaW5OUygpXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIGRpc25pdChpZCwgbWFzayl7XG4gICAgICAvL2RlbGV0ZSB0aGlzLmNvbm5lY3RpbmdbaWRdXG4gICAgICAvL3RoaXMuaHViLnVuc3Vic2NyaWJlKG1hc2spXG4gICAgfVxuXG4gICAgaW5pdENvbm5lY3QoaWQsIGluaXQsIG1hc2spe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICBsZXQgcGlwZSA9IHRoaXMuaHViLnN1YnNjcmliZShtYXNrKVxuICAgICAgdmFyIGNhbGxlciA9IG5ldyBQZWVyKHtpbml0aWF0b3I6IGluaXQsIHRyaWNrbGU6IGZhbHNlLCBvYmplY3RNb2RlOiBmYWxzZX0pXG4gICAgICB0aGlzLmNvbm5lY3RpbmdbaWRdID0gY2FsbGVyXG4gICAgICBwaXBlLm9uKCdlcnJvcicsIGUgPT4gY29uc29sZS5sb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKSlcbiAgICAgIHBpcGUub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgICAgLy8gY2FsbGVySURcbiAgICAgICAgdmFyIHBlZXIgPSBzZWxmLmNvbm5lY3RpbmdbZGF0YS5wZWVySWRdXG4gICAgICAgIHBlZXIuc2lnbmFsKGRhdGEuc2lnbmFsKVxuICAgICAgICBwZWVyLm9uY2UoJ2Nvbm5lY3QnLCBlID0+IHtcbiAgICAgICAgICAvLyBjbG9zZSBtYXNrIGh1YlxuICAgICAgICB9KVxuICAgICAgICAvL3VpLmNhbGxlcnMuYXBwZW5kQ2hpbGQoaCgnZGl2LmNhbGxlcicsIGgoJ2J1dHRvbi5jb25uZWN0JywgYENvbm5lY3QgdG8gJHtkYXRhLm5hbWUgfHwgZnJvbX1gLCB7b25jbGljazogX2Nvbm5lY3R9KSkpICBcbiAgICAgIH0pXG4gICAgICBjYWxsZXIuX2RlYnVnID0gY29uc29sZS5sb2dcbiAgICAgIGNhbGxlci5vbignc2lnbmFsJywgc2lnID0+IHRoaXMuaHViLmJyb2FkY2FzdChpZCwgSlNPTi5zdHJpbmdpZnkoe3BlZXJJZDogbWFzaywgdG86IGlkLCBzaWduYWw6IHNpZyB9KSkpXG4gICAgICBjYWxsZXIub25jZSgnY29ubmVjdCcsIGUgPT4ge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zW2lkXSA9IGNhbGxlclxuICAgICAgICB0aGlzLmNvbm5lY3RpbmdbaWRdID0gbnVsbFxuICAgICAgICBjb25zb2xlLmxvZyhgY29ubmVjdGVkIHRvICR7T2JqZWN0LmtleXModGhpcy5jb25uZWN0aW9ucykubGVuZ3RofSBwZWVyc2ApXG4gICAgICB9KVxuICAgICAgY2FsbGVyLm9uKCdjbG9zZScsIGUgPT4ge1xuICAgICAgICB0aGlzLmRpc25pdChpZCwgbWFzaylcbiAgICAgIH0pXG4gICAgICBjYWxsZXIub24oJ2Vycm9yJywgZSA9PiBjb25zb2xlLmxvZyhlKSlcbiAgICAgIHJldHVybiBjYWxsZXJcbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE1lZGlhKGNiLCBhdWRpbz10cnVlLCB2aWRlbz1mYWxzZSl7XG4gICAgdmFyIGdhbSA9IHJlcXVpcmUoJ2dldHVzZXJtZWRpYScpXG4gICAgLy8gV2ViIHdvcmtlciBhbmQgLndhc20gY29uZmlndXJhdGlvbi4gTm90ZTogVGhpcyBpcyBOT1QgYSBwYXJ0IG9mIFczQyBzdGFuZGFyZC5cbiAgICBfbG9nKGBnZXRVc2VyTWVkaWE/ICR7ISFnYW19YClcbiAgICBnYW0oe3ZpZGVvLCBhdWRpb30sIGZ1bmN0aW9uKGVyciwgc3RyZWFtKXtcbiAgICAgIC8vY29uc29sZS5sb2coc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkpXG5cblxuICAgICAgY2IoZXJyLCBzdHJlYW0pXG4gICAgfSlcbiAgIH0gICAgXG59KVxuIiwidmFyIENvbnZlcnRlciA9IHJlcXVpcmUoJy4vc3JjL2NvbnZlcnRlcicpO1xuXG4vKipcbiAqIEZ1bmN0aW9uIGdldCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFscGhhYmV0IGFuZCByZXR1cm4gY29udmVydCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBzcmNBbHBoYWJldFxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGRzdEFscGhhYmV0XG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9uKG51bWJlcnxBcnJheSl9XG4gKi9cbmZ1bmN0aW9uIGFueUJhc2Uoc3JjQWxwaGFiZXQsIGRzdEFscGhhYmV0KSB7XG4gICAgdmFyIGNvbnZlcnRlciA9IG5ldyBDb252ZXJ0ZXIoc3JjQWxwaGFiZXQsIGRzdEFscGhhYmV0KTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXl9IG51bWJlclxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuY29udmVydChudW1iZXIpO1xuICAgIH1cbn07XG5cbmFueUJhc2UuQklOID0gJzAxJztcbmFueUJhc2UuT0NUID0gJzAxMjM0NTY3JztcbmFueUJhc2UuREVDID0gJzAxMjM0NTY3ODknO1xuYW55QmFzZS5IRVggPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbm1vZHVsZS5leHBvcnRzID0gYW55QmFzZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHNyY0FscGhhYmV0XG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gZHN0QWxwaGFiZXRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb252ZXJ0ZXIoc3JjQWxwaGFiZXQsIGRzdEFscGhhYmV0KSB7XG4gICAgaWYgKCFzcmNBbHBoYWJldCB8fCAhZHN0QWxwaGFiZXQgfHwgIXNyY0FscGhhYmV0Lmxlbmd0aCB8fCAhZHN0QWxwaGFiZXQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIGFscGhhYmV0Jyk7XG4gICAgfVxuICAgIHRoaXMuc3JjQWxwaGFiZXQgPSBzcmNBbHBoYWJldDtcbiAgICB0aGlzLmRzdEFscGhhYmV0ID0gZHN0QWxwaGFiZXQ7XG59XG5cbi8qKlxuICogQ29udmVydCBudW1iZXIgZnJvbSBzb3VyY2UgYWxwaGFiZXQgdG8gZGVzdGluYXRpb24gYWxwaGFiZXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gbnVtYmVyIC0gbnVtYmVyIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHBvaW50c1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd8QXJyYXl9XG4gKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIHZhciBpLCBkaXZpZGUsIG5ld2xlbixcbiAgICBudW1iZXJNYXAgPSB7fSxcbiAgICBmcm9tQmFzZSA9IHRoaXMuc3JjQWxwaGFiZXQubGVuZ3RoLFxuICAgIHRvQmFzZSA9IHRoaXMuZHN0QWxwaGFiZXQubGVuZ3RoLFxuICAgIGxlbmd0aCA9IG51bWJlci5sZW5ndGgsXG4gICAgcmVzdWx0ID0gdHlwZW9mIG51bWJlciA9PT0gJ3N0cmluZycgPyAnJyA6IFtdO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBcIicgKyBudW1iZXIgKyAnXCIgY29udGFpbnMgb2Ygbm9uLWFscGhhYmV0aWMgZGlnaXRzICgnICsgdGhpcy5zcmNBbHBoYWJldCArICcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3JjQWxwaGFiZXQgPT09IHRoaXMuZHN0QWxwaGFiZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbnVtYmVyTWFwW2ldID0gdGhpcy5zcmNBbHBoYWJldC5pbmRleE9mKG51bWJlcltpXSk7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgICAgZGl2aWRlID0gMDtcbiAgICAgICAgbmV3bGVuID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXZpZGUgPSBkaXZpZGUgKiBmcm9tQmFzZSArIG51bWJlck1hcFtpXTtcbiAgICAgICAgICAgIGlmIChkaXZpZGUgPj0gdG9CYXNlKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyTWFwW25ld2xlbisrXSA9IHBhcnNlSW50KGRpdmlkZSAvIHRvQmFzZSwgMTApO1xuICAgICAgICAgICAgICAgIGRpdmlkZSA9IGRpdmlkZSAlIHRvQmFzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3bGVuID4gMCkge1xuICAgICAgICAgICAgICAgIG51bWJlck1hcFtuZXdsZW4rK10gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IG5ld2xlbjtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5kc3RBbHBoYWJldC5zbGljZShkaXZpZGUsIGRpdmlkZSArIDEpLmNvbmNhdChyZXN1bHQpO1xuICAgIH0gd2hpbGUgKG5ld2xlbiAhPT0gMCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZCBudW1iZXIgd2l0aCBzb3VyY2UgYWxwaGFiZXRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IG51bWJlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5zcmNBbHBoYWJldC5pbmRleE9mKG51bWJlcltpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnZlcnRlcjsiLCIvKiEgYmxvYi10by1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qIGdsb2JhbCBCbG9iLCBGaWxlUmVhZGVyICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvYlRvQnVmZmVyIChibG9iLCBjYikge1xuICBpZiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8ICEoYmxvYiBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgQmxvYicpXG4gIH1cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpXG4gIH1cblxuICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgZnVuY3Rpb24gb25Mb2FkRW5kIChlKSB7XG4gICAgcmVhZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBvbkxvYWRFbmQsIGZhbHNlKVxuICAgIGlmIChlLmVycm9yKSBjYihlLmVycm9yKVxuICAgIGVsc2UgY2IobnVsbCwgQnVmZmVyLmZyb20ocmVhZGVyLnJlc3VsdCkpXG4gIH1cblxuICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIG9uTG9hZEVuZCwgZmFsc2UpXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxufVxuIiwiLyohXG4gKiBDcm9zcy1Ccm93c2VyIFNwbGl0IDEuMS4xXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDEyIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogRUNNQVNjcmlwdCBjb21wbGlhbnQsIHVuaWZvcm0gY3Jvc3MtYnJvd3NlciBzcGxpdCBtZXRob2RcbiAqL1xuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYSByZWdleCBvciBzdHJpbmcgc2VwYXJhdG9yLiBNYXRjaGVzIG9mIHRoZVxuICogc2VwYXJhdG9yIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBhcnJheS4gSG93ZXZlciwgaWYgYHNlcGFyYXRvcmAgaXMgYSByZWdleCB0aGF0IGNvbnRhaW5zXG4gKiBjYXB0dXJpbmcgZ3JvdXBzLCBiYWNrcmVmZXJlbmNlcyBhcmUgc3BsaWNlZCBpbnRvIHRoZSByZXN1bHQgZWFjaCB0aW1lIGBzZXBhcmF0b3JgIGlzIG1hdGNoZWQuXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5XG4gKiBjcm9zcy1icm93c2VyLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXQuXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZVxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcpO1xuICogLy8gLT4gWydhJywgJ2InLCAnYycsICdkJ11cbiAqXG4gKiAvLyBXaXRoIGxpbWl0XG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJywgMik7XG4gKiAvLyAtPiBbJ2EnLCAnYiddXG4gKlxuICogLy8gQmFja3JlZmVyZW5jZXMgaW4gcmVzdWx0IGFycmF5XG4gKiBzcGxpdCgnLi53b3JkMSB3b3JkMi4uJywgLyhbYS16XSspKFxcZCspL2kpO1xuICogLy8gLT4gWycuLicsICd3b3JkJywgJzEnLCAnICcsICd3b3JkJywgJzInLCAnLi4nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBzcGxpdCh1bmRlZikge1xuXG4gIHZhciBuYXRpdmVTcGxpdCA9IFN0cmluZy5wcm90b3R5cGUuc3BsaXQsXG4gICAgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYyhcIlwiKVsxXSA9PT0gdW5kZWYsXG4gICAgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICBzZWxmO1xuXG4gIHNlbGYgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIGBuYXRpdmVTcGxpdGBcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09IFwiW29iamVjdCBSZWdFeHBdXCIpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChzZXBhcmF0b3IuZXh0ZW5kZWQgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyBcInlcIiA6IFwiXCIpLFxuICAgICAgLy8gRmlyZWZveCAzK1xuICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArIFwiZ1wiKSxcbiAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgc3RyICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBzZXBhcmF0b3Iuc291cmNlICsgXCIkKD8hXFxcXHMpXCIsIGZsYWdzKTtcbiAgICB9XG4gICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAqL1xuICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmID8gLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgbGltaXQgPj4+IDA7IC8vIFRvVWludDMyKGxpbWl0KVxuICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cikpIHtcbiAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB1bmRlZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdChcIlwiKSkge1xuICAgICAgICBvdXRwdXQucHVzaChcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59KSgpO1xuIiwiLy8gY29udGFpbnMsIGFkZCwgcmVtb3ZlLCB0b2dnbGVcbnZhciBpbmRleG9mID0gcmVxdWlyZSgnaW5kZXhvZicpXG5cbm1vZHVsZS5leHBvcnRzID0gQ2xhc3NMaXN0XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChlbGVtKSB7XG4gICAgdmFyIGNsID0gZWxlbS5jbGFzc0xpc3RcblxuICAgIGlmIChjbCkge1xuICAgICAgICByZXR1cm4gY2xcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NMaXN0ID0ge1xuICAgICAgICBhZGQ6IGFkZFxuICAgICAgICAsIHJlbW92ZTogcmVtb3ZlXG4gICAgICAgICwgY29udGFpbnM6IGNvbnRhaW5zXG4gICAgICAgICwgdG9nZ2xlOiB0b2dnbGVcbiAgICAgICAgLCB0b1N0cmluZzogJHRvU3RyaW5nXG4gICAgICAgICwgbGVuZ3RoOiAwXG4gICAgICAgICwgaXRlbTogaXRlbVxuICAgIH1cblxuICAgIHJldHVybiBjbGFzc0xpc3RcblxuICAgIGZ1bmN0aW9uIGFkZCh0b2tlbikge1xuICAgICAgICB2YXIgbGlzdCA9IGdldFRva2VucygpXG4gICAgICAgIGlmIChpbmRleG9mKGxpc3QsIHRva2VuKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsaXN0LnB1c2godG9rZW4pXG4gICAgICAgIHNldFRva2VucyhsaXN0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSh0b2tlbikge1xuICAgICAgICB2YXIgbGlzdCA9IGdldFRva2VucygpXG4gICAgICAgICAgICAsIGluZGV4ID0gaW5kZXhvZihsaXN0LCB0b2tlbilcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICBzZXRUb2tlbnMobGlzdClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWlucyh0b2tlbikge1xuICAgICAgICByZXR1cm4gaW5kZXhvZihnZXRUb2tlbnMoKSwgdG9rZW4pID4gLTFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGUodG9rZW4pIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRva2VuKSkge1xuICAgICAgICAgICAgcmVtb3ZlKHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGQodG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gZWxlbS5jbGFzc05hbWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVtKGluZGV4KSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBnZXRUb2tlbnMoKVxuICAgICAgICByZXR1cm4gdG9rZW5zW2luZGV4XSB8fCBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VG9rZW5zKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWVcblxuICAgICAgICByZXR1cm4gZmlsdGVyKGNsYXNzTmFtZS5zcGxpdChcIiBcIiksIGlzVHJ1dGh5KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRva2VucyhsaXN0KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aFxuXG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gbGlzdC5qb2luKFwiIFwiKVxuICAgICAgICBjbGFzc0xpc3QubGVuZ3RoID0gbGVuZ3RoXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3RbaV0gPSBsaXN0W2ldXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgbGlzdFtsZW5ndGhdXG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXIgKGFyciwgZm4pIHtcbiAgICB2YXIgcmV0ID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZm4oYXJyW2ldKSkgcmV0LnB1c2goYXJyW2ldKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGlzVHJ1dGh5KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IGVuYWJsZU92ZXJyaWRlID09PSBudWxsID8gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpIDogZW5hYmxlT3ZlcnJpZGUsXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnJvd3NlckluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckluZm8obmFtZSwgdmVyc2lvbiwgb3MpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5vcyA9IG9zO1xuICAgIH1cbiAgICByZXR1cm4gQnJvd3NlckluZm87XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VySW5mbyA9IEJyb3dzZXJJbmZvO1xudmFyIE5vZGVJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVJbmZvKHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ25vZGUnO1xuICAgICAgICB0aGlzLm9zID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbiAgICB9XG4gICAgcmV0dXJuIE5vZGVJbmZvO1xufSgpKTtcbmV4cG9ydHMuTm9kZUluZm8gPSBOb2RlSW5mbztcbnZhciBCb3RJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdEluZm8oKSB7XG4gICAgICAgIHRoaXMuYm90ID0gdHJ1ZTsgLy8gTk9URTogZGVwcmVjYXRlZCB0ZXN0IG5hbWUgaW5zdGVhZFxuICAgICAgICB0aGlzLm5hbWUgPSAnYm90JztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBCb3RJbmZvO1xufSgpKTtcbmV4cG9ydHMuQm90SW5mbyA9IEJvdEluZm87XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG52YXIgU0VBUkNIQk9YX1VBX1JFR0VYID0gL2FsZXhhfGJvdHxjcmF3bChlcnxpbmcpfGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmVlZGJ1cm5lcnxnb29nbGUgd2ViIHByZXZpZXd8bmFnaW9zfHBvc3RyYW5rfHBpbmdkb218c2x1cnB8c3BpZGVyfHlhaG9vIXx5YW5kZXgvO1xudmFyIFNFQVJDSEJPVF9PU19SRUdFWCA9IC8obnVoayl8KEdvb2dsZWJvdCl8KFlhbW15Ym90KXwoT3BlbmJvdCl8KFNsdXJwKXwoTVNOQm90KXwoQXNrIEplZXZlc1xcL1Rlb21hKXwoaWFfYXJjaGl2ZXIpLztcbnZhciBSRVFVSVJFRF9WRVJTSU9OX1BBUlRTID0gMztcbnZhciB1c2VyQWdlbnRSdWxlcyA9IFtcbiAgICBbJ2FvbCcsIC9BT0xTaGllbGRcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ2VkZ2UnLCAvRWRnZVxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsnZWRnZS1pb3MnLCAvRWRnaU9TXFwvKFswLTlcXC5fXSspL10sXG4gICAgWyd5YW5kZXhicm93c2VyJywgL1lhQnJvd3NlclxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsndml2YWxkaScsIC9WaXZhbGRpXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2tha2FvdGFsaycsIC9LQUtBT1RBTEtcXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnc2Ftc3VuZycsIC9TYW1zdW5nQnJvd3NlclxcLyhbMC05XFwuXSspL10sXG4gICAgWydzaWxrJywgL1xcYlNpbGtcXC8oWzAtOS5fLV0rKVxcYi9dLFxuICAgIFsnbWl1aScsIC9NaXVpQnJvd3NlclxcLyhbMC05XFwuXSspJC9dLFxuICAgIFsnYmVha2VyJywgL0JlYWtlckJyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnZWRnZS1jaHJvbWl1bScsIC9FZGdcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFtcbiAgICAgICAgJ2Nocm9taXVtLXdlYnZpZXcnLFxuICAgICAgICAvKD8hQ2hyb20uKk9QUil3dlxcKS4qQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS8sXG4gICAgXSxcbiAgICBbJ2Nocm9tZScsIC8oPyFDaHJvbS4qT1BSKUNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ3BoYW50b21qcycsIC9QaGFudG9tSlNcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnY3Jpb3MnLCAvQ3JpT1NcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnZmlyZWZveCcsIC9GaXJlZm94XFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSxcbiAgICBbJ2Z4aW9zJywgL0Z4aU9TXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ29wZXJhLW1pbmknLCAvT3BlcmEgTWluaS4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sXG4gICAgWydvcGVyYScsIC9PcGVyYVxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gICAgWydvcGVyYScsIC9PUFJcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnaWUnLCAvVHJpZGVudFxcLzdcXC4wLipydlxcOihbMC05XFwuXSspLipcXCkuKkdlY2tvJC9dLFxuICAgIFsnaWUnLCAvTVNJRVxccyhbMC05XFwuXSspOy4qVHJpZGVudFxcL1s0LTddLjAvXSxcbiAgICBbJ2llJywgL01TSUVcXHMoN1xcLjApL10sXG4gICAgWydiYjEwJywgL0JCMTA7XFxzVG91Y2guKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnYW5kcm9pZCcsIC9BbmRyb2lkXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ2lvcycsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipNb2JpbGUuKlNhZmFyaS4qL10sXG4gICAgWydzYWZhcmknLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qU2FmYXJpL10sXG4gICAgWydmYWNlYm9vaycsIC9GQkFWXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2luc3RhZ3JhbScsIC9JbnN0YWdyYW1cXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnaW9zLXdlYnZpZXcnLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qTW9iaWxlL10sXG4gICAgWydpb3Mtd2VidmlldycsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipHZWNrb1xcKSQvXSxcbiAgICBbJ3NlYXJjaGJvdCcsIFNFQVJDSEJPWF9VQV9SRUdFWF0sXG5dO1xudmFyIG9wZXJhdGluZ1N5c3RlbVJ1bGVzID0gW1xuICAgIFsnaU9TJywgL2lQKGhvbmV8b2R8YWQpL10sXG4gICAgWydBbmRyb2lkIE9TJywgL0FuZHJvaWQvXSxcbiAgICBbJ0JsYWNrQmVycnkgT1MnLCAvQmxhY2tCZXJyeXxCQjEwL10sXG4gICAgWydXaW5kb3dzIE1vYmlsZScsIC9JRU1vYmlsZS9dLFxuICAgIFsnQW1hem9uIE9TJywgL0tpbmRsZS9dLFxuICAgIFsnV2luZG93cyAzLjExJywgL1dpbjE2L10sXG4gICAgWydXaW5kb3dzIDk1JywgLyhXaW5kb3dzIDk1KXwoV2luOTUpfChXaW5kb3dzXzk1KS9dLFxuICAgIFsnV2luZG93cyA5OCcsIC8oV2luZG93cyA5OCl8KFdpbjk4KS9dLFxuICAgIFsnV2luZG93cyAyMDAwJywgLyhXaW5kb3dzIE5UIDUuMCl8KFdpbmRvd3MgMjAwMCkvXSxcbiAgICBbJ1dpbmRvd3MgWFAnLCAvKFdpbmRvd3MgTlQgNS4xKXwoV2luZG93cyBYUCkvXSxcbiAgICBbJ1dpbmRvd3MgU2VydmVyIDIwMDMnLCAvKFdpbmRvd3MgTlQgNS4yKS9dLFxuICAgIFsnV2luZG93cyBWaXN0YScsIC8oV2luZG93cyBOVCA2LjApL10sXG4gICAgWydXaW5kb3dzIDcnLCAvKFdpbmRvd3MgTlQgNi4xKS9dLFxuICAgIFsnV2luZG93cyA4JywgLyhXaW5kb3dzIE5UIDYuMikvXSxcbiAgICBbJ1dpbmRvd3MgOC4xJywgLyhXaW5kb3dzIE5UIDYuMykvXSxcbiAgICBbJ1dpbmRvd3MgMTAnLCAvKFdpbmRvd3MgTlQgMTAuMCkvXSxcbiAgICBbJ1dpbmRvd3MgTUUnLCAvV2luZG93cyBNRS9dLFxuICAgIFsnT3BlbiBCU0QnLCAvT3BlbkJTRC9dLFxuICAgIFsnU3VuIE9TJywgL1N1bk9TL10sXG4gICAgWydDaHJvbWUgT1MnLCAvQ3JPUy9dLFxuICAgIFsnTGludXgnLCAvKExpbnV4KXwoWDExKS9dLFxuICAgIFsnTWFjIE9TJywgLyhNYWNfUG93ZXJQQyl8KE1hY2ludG9zaCkvXSxcbiAgICBbJ1FOWCcsIC9RTlgvXSxcbiAgICBbJ0JlT1MnLCAvQmVPUy9dLFxuICAgIFsnT1MvMicsIC9PU1xcLzIvXSxcbiAgICBbJ1NlYXJjaCBCb3QnLCBTRUFSQ0hCT1RfT1NfUkVHRVhdLFxuXTtcbmZ1bmN0aW9uIGRldGVjdCh1c2VyQWdlbnQpIHtcbiAgICBpZiAoISF1c2VyQWdlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVXNlckFnZW50KHVzZXJBZ2VudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICAgIHJldHVybiBnZXROb2RlVmVyc2lvbigpO1xufVxuZXhwb3J0cy5kZXRlY3QgPSBkZXRlY3Q7XG5mdW5jdGlvbiBwYXJzZVVzZXJBZ2VudCh1YSkge1xuICAgIC8vIG9wdGVkIGZvciB1c2luZyByZWR1Y2UgaGVyZSByYXRoZXIgdGhhbiBBcnJheSNmaXJzdCB3aXRoIGEgcmVnZXgudGVzdCBjYWxsXG4gICAgLy8gdGhpcyBpcyBwcmltYXJpbHkgYmVjYXVzZSB1c2luZyB0aGUgcmVkdWNlIHdlIG9ubHkgcGVyZm9ybSB0aGUgcmVnZXhcbiAgICAvLyBleGVjdXRpb24gb25jZSByYXRoZXIgdGhhbiBvbmNlIGZvciB0aGUgdGVzdCBhbmQgZm9yIHRoZSBleGVjIGFnYWluIGJlbG93XG4gICAgLy8gcHJvYmFibHkgc29tZXRoaW5nIHRoYXQgbmVlZHMgdG8gYmUgYmVuY2htYXJrZWQgdGhvdWdoXG4gICAgdmFyIG1hdGNoZWRSdWxlID0gdWEgIT09ICcnICYmXG4gICAgICAgIHVzZXJBZ2VudFJ1bGVzLnJlZHVjZShmdW5jdGlvbiAobWF0Y2hlZCwgX2EpIHtcbiAgICAgICAgICAgIHZhciBicm93c2VyID0gX2FbMF0sIHJlZ2V4ID0gX2FbMV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVhTWF0Y2ggPSByZWdleC5leGVjKHVhKTtcbiAgICAgICAgICAgIHJldHVybiAhIXVhTWF0Y2ggJiYgW2Jyb3dzZXIsIHVhTWF0Y2hdO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgaWYgKCFtYXRjaGVkUnVsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBtYXRjaGVkUnVsZVswXSwgbWF0Y2ggPSBtYXRjaGVkUnVsZVsxXTtcbiAgICBpZiAobmFtZSA9PT0gJ3NlYXJjaGJvdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3RJbmZvKCk7XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uUGFydHMgPSBtYXRjaFsxXSAmJiBtYXRjaFsxXS5zcGxpdCgvWy5fXS8pLnNsaWNlKDAsIDMpO1xuICAgIGlmICh2ZXJzaW9uUGFydHMpIHtcbiAgICAgICAgaWYgKHZlcnNpb25QYXJ0cy5sZW5ndGggPCBSRVFVSVJFRF9WRVJTSU9OX1BBUlRTKSB7XG4gICAgICAgICAgICB2ZXJzaW9uUGFydHMgPSBfX3NwcmVhZEFycmF5cyh2ZXJzaW9uUGFydHMsIGNyZWF0ZVZlcnNpb25QYXJ0cyhSRVFVSVJFRF9WRVJTSU9OX1BBUlRTIC0gdmVyc2lvblBhcnRzLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2ZXJzaW9uUGFydHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCcm93c2VySW5mbyhuYW1lLCB2ZXJzaW9uUGFydHMuam9pbignLicpLCBkZXRlY3RPUyh1YSkpO1xufVxuZXhwb3J0cy5wYXJzZVVzZXJBZ2VudCA9IHBhcnNlVXNlckFnZW50O1xuZnVuY3Rpb24gZGV0ZWN0T1ModWEpIHtcbiAgICBmb3IgKHZhciBpaSA9IDAsIGNvdW50ID0gb3BlcmF0aW5nU3lzdGVtUnVsZXMubGVuZ3RoOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIHZhciBfYSA9IG9wZXJhdGluZ1N5c3RlbVJ1bGVzW2lpXSwgb3MgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnZXgudGVzdCh1YSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5kZXRlY3RPUyA9IGRldGVjdE9TO1xuZnVuY3Rpb24gZ2V0Tm9kZVZlcnNpb24oKSB7XG4gICAgdmFyIGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb247XG4gICAgcmV0dXJuIGlzTm9kZSA/IG5ldyBOb2RlSW5mbyhwcm9jZXNzLnZlcnNpb24uc2xpY2UoMSkpIDogbnVsbDtcbn1cbmV4cG9ydHMuZ2V0Tm9kZVZlcnNpb24gPSBnZXROb2RlVmVyc2lvbjtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25QYXJ0cyhjb3VudCkge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgY291bnQ7IGlpKyspIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbiIsIi8qIVxuICAqIGRvbXJlYWR5IChjKSBEdXN0aW4gRGlheiAyMDE0IC0gTGljZW5zZSBNSVRcbiAgKi9cbiFmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIHRoaXNbbmFtZV0gPSBkZWZpbml0aW9uKClcblxufSgnZG9tcmVhZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGZucyA9IFtdLCBsaXN0ZW5lclxuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIGhhY2sgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsXG4gICAgLCBkb21Db250ZW50TG9hZGVkID0gJ0RPTUNvbnRlbnRMb2FkZWQnXG4gICAgLCBsb2FkZWQgPSAoaGFjayA/IC9ebG9hZGVkfF5jLyA6IC9ebG9hZGVkfF5pfF5jLykudGVzdChkb2MucmVhZHlTdGF0ZSlcblxuXG4gIGlmICghbG9hZGVkKVxuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lcilcbiAgICBsb2FkZWQgPSAxXG4gICAgd2hpbGUgKGxpc3RlbmVyID0gZm5zLnNoaWZ0KCkpIGxpc3RlbmVyKClcbiAgfSlcblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgbG9hZGVkID8gc2V0VGltZW91dChmbiwgMCkgOiBmbnMucHVzaChmbilcbiAgfVxuXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBba2V5OiBzdHJpbmddOiBhbnkgfX0gRXh0ZW5zaW9uc1xuICogQHR5cGVkZWYge0Vycm9yfSBFcnJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gb2JqXG4gKiBAcGFyYW0ge0V4dGVuc2lvbnN9IHByb3BzXG4gKiBAcmV0dXJucyB7RXJyb3IgJiBFeHRlbnNpb25zfVxuICovXG5mdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2FueX0gZXJyIC0gQW4gRXJyb3JcbiAqIEBwYXJhbSB7c3RyaW5nfEV4dGVuc2lvbnN9IGNvZGUgLSBBIHN0cmluZyBjb2RlIG9yIHByb3BzIHRvIHNldCBvbiB0aGUgZXJyb3JcbiAqIEBwYXJhbSB7RXh0ZW5zaW9uc30gW3Byb3BzXSAtIFByb3BzIHRvIHNldCBvbiB0aGUgZXJyb3JcbiAqIEByZXR1cm5zIHtFcnJvciAmIEV4dGVuc2lvbnN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKGVyciwgY29kZSwgcHJvcHMpIHtcbiAgICBpZiAoIWVyciB8fCB0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgcGFzcyBhbiBFcnJvciB0byBlcnItY29kZScpO1xuICAgIH1cblxuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3BzID0gY29kZTtcbiAgICAgICAgY29kZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChjb2RlKSB7XG4gICAgICAgIHByb3BzLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhc3NpZ24oZXJyLCBwcm9wcyk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICBwcm9wcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIHByb3BzLnN0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgICAgIGNvbnN0IEVyckNsYXNzID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgRXJyQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXJyKSk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBhc3NpZ24obmV3IEVyckNsYXNzKCksIHByb3BzKTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVFcnJvcjtcbiIsIi8qKlxuICogQGF1dGhvciBUb3J1IE5hZ2FzaGltYSA8aHR0cHM6Ly9naXRodWIuY29tL215c3RpY2F0ZWE+XG4gKiBAY29weXJpZ2h0IDIwMTUgVG9ydSBOYWdhc2hpbWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTZWUgTElDRU5TRSBmaWxlIGluIHJvb3QgZGlyZWN0b3J5IGZvciBmdWxsIGxpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcml2YXRlRGF0YVxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudFBoYXNlIFRoZSBjdXJyZW50IGV2ZW50IHBoYXNlLlxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IFRoZSBjdXJyZW50IGV2ZW50IHRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FuY2VsZWQgVGhlIGZsYWcgdG8gcHJldmVudCBkZWZhdWx0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBzdG9wcGVkIFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBUaGUgbGlzdGVuZXIgaWYgdGhlIGN1cnJlbnQgbGlzdGVuZXIgaXMgcGFzc2l2ZS4gT3RoZXJ3aXNlIHRoaXMgaXMgbnVsbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lU3RhbXAgVGhlIHVuaXggdGltZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBQcml2YXRlIGRhdGEgZm9yIGV2ZW50IHdyYXBwZXJzLlxuICogQHR5cGUge1dlYWtNYXA8RXZlbnQsIFByaXZhdGVEYXRhPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDYWNoZSBmb3Igd3JhcHBlciBjbGFzc2VzLlxuICogQHR5cGUge1dlYWtNYXA8T2JqZWN0LCBGdW5jdGlvbj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3cmFwcGVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgdG8gZ2V0IHByaXZhdGUgZGF0YS5cbiAqIEByZXR1cm5zIHtQcml2YXRlRGF0YX0gVGhlIHByaXZhdGUgZGF0YSBvZiB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwZChldmVudCkge1xuICAgIGNvbnN0IHJldHYgPSBwcml2YXRlRGF0YS5nZXQoZXZlbnQpO1xuICAgIGNvbnNvbGUuYXNzZXJ0KHJldHYgIT0gbnVsbCwgXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnQgb2JqZWN0LCBidXQgZ290XCIsIGV2ZW50KTtcbiAgICByZXR1cm4gcmV0dlxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogVGhlIGV2ZW50IHdyYXBwZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IHRvIHdyYXAuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIHByaXZhdGVEYXRhLnNldCh0aGlzLCB7XG4gICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnRQaGFzZTogMixcbiAgICAgICAgY3VycmVudFRhcmdldDogZXZlbnRUYXJnZXQsXG4gICAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogbnVsbCxcbiAgICAgICAgdGltZVN0YW1wOiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI1VuZm9yZ2VhYmxlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUcnVzdGVkXCIsIHsgdmFsdWU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4gICAgLy8gRGVmaW5lIGFjY2Vzc29yc1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhldmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50LnR5cGVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmN1cnJlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0V2ZW50VGFyZ2V0W119IFRoZSBjb21wb3NlZCBwYXRoIG9mIHRoaXMgZXZlbnQuXG4gICAgICovXG4gICAgY29tcG9zZWRQYXRoKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gcGQodGhpcykuY3VycmVudFRhcmdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjdXJyZW50VGFyZ2V0XVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBOT05FLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IE5PTkUoKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIENBUFRVUklOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBDQVBUVVJJTkdfUEhBU0UoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEFUX1RBUkdFVC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBBVF9UQVJHRVQoKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEJVQkJMSU5HX1BIQVNFLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IEJVQkJMSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gM1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50UGhhc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG5cbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGJ1YmJsaW5nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBidWJibGVzKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5idWJibGVzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjYW5jZWxhYmxlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5jZWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5jYW5jZWxhYmxlKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhpcyBldmVudC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBkKHRoaXMpO1xuICAgICAgICBpZiAoZGF0YS5wYXNzaXZlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXZlbnQjcHJldmVudERlZmF1bHQoKSB3YXMgY2FsbGVkIGZyb20gYSBwYXNzaXZlIGxpc3RlbmVyOlwiLCBkYXRhLnBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEuZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBpbmRpY2F0ZSBjYW5jZWxsYXRpb24gc3RhdGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjb21wb3NlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY29tcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNvbXBvc2VkKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5peCB0aW1lIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdGltZVN0YW1wKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykudGltZVN0YW1wXG4gICAgfSxcbn07XG5cbi8vIGBjb25zdHJ1Y3RvcmAgaXMgbm90IGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEV2ZW50LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuXG4vLyBFbnN1cmUgYGV2ZW50IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50YCBpcyBgdHJ1ZWAuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LkV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50LnByb3RvdHlwZSwgd2luZG93LkV2ZW50LnByb3RvdHlwZSk7XG5cbiAgICAvLyBNYWtlIGFzc29jaWF0aW9uIGZvciB3cmFwcGVycy5cbiAgICB3cmFwcGVycy5zZXQod2luZG93LkV2ZW50LnByb3RvdHlwZSwgRXZlbnQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCBhIGdpdmVuIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgdGhlIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFtrZXldXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgcGQodGhpcykuZXZlbnRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIGEgZ2l2ZW4gbWV0aG9kIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gY2FsbCB0aGUgbWV0aG9kIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBkKHRoaXMpLmV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50W2tleV0uYXBwbHkoZXZlbnQsIGFyZ3VtZW50cylcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgbmV3IHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBCYXNlRXZlbnQgVGhlIGJhc2Ugd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgcHJvdG90eXBlIG9mIHRoZSBvcmlnaW5hbCBldmVudC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIGRlZmluZWQgd3JhcHBlciBjbGFzcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVdyYXBwZXIoQmFzZUV2ZW50LCBwcm90bykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm90byk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCYXNlRXZlbnRcbiAgICB9XG5cbiAgICAvKiogQ3VzdG9tRXZlbnQgKi9cbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgQmFzZUV2ZW50LmNhbGwodGhpcywgZXZlbnRUYXJnZXQsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEN1c3RvbUV2ZW50LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgfSk7XG5cbiAgICAvLyBEZWZpbmUgYWNjZXNzb3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIShrZXkgaW4gQmFzZUV2ZW50LnByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpO1xuICAgICAgICAgICAgY29uc3QgaXNGdW5jID0gKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgaXNGdW5jID8gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KSA6IGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50XG59XG5cbi8qKlxuICogR2V0IHRoZSB3cmFwcGVyIGNsYXNzIG9mIGEgZ2l2ZW4gcHJvdG90eXBlLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGdldCBpdHMgd3JhcHBlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRXcmFwcGVyKHByb3RvKSB7XG4gICAgaWYgKHByb3RvID09IG51bGwgfHwgcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50XG4gICAgfVxuXG4gICAgbGV0IHdyYXBwZXIgPSB3cmFwcGVycy5nZXQocHJvdG8pO1xuICAgIGlmICh3cmFwcGVyID09IG51bGwpIHtcbiAgICAgICAgd3JhcHBlciA9IGRlZmluZVdyYXBwZXIoZ2V0V3JhcHBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKSwgcHJvdG8pO1xuICAgICAgICB3cmFwcGVycy5zZXQocHJvdG8sIHdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlclxufVxuXG4vKipcbiAqIFdyYXAgYSBnaXZlbiBldmVudCB0byBtYW5hZ2VtZW50IGEgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoaXMgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RXZlbnR9IFRoZSB3cmFwcGVyIGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIGNvbnN0IFdyYXBwZXIgPSBnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkpO1xuICAgIHJldHVybiBuZXcgV3JhcHBlcihldmVudFRhcmdldCwgZXZlbnQpXG59XG5cbi8qKlxuICogR2V0IHRoZSBzdG9wcGVkIGZsYWcgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbiBpbW1lZGlhdGVseS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBwZChldmVudCkuc3RvcHBlZFxufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBldmVudCBwaGFzZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFBoYXNlIE5ldyBldmVudCBwaGFzZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0RXZlbnRQaGFzZShldmVudCwgZXZlbnRQaGFzZSkge1xuICAgIHBkKGV2ZW50KS5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IE5ldyBjdXJyZW50IHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudFRhcmdldChldmVudCwgY3VycmVudFRhcmdldCkge1xuICAgIHBkKGV2ZW50KS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbn1cblxuLyoqXG4gKiBTZXQgYSBwYXNzaXZlIGxpc3RlbmVyIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgTmV3IHBhc3NpdmUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFBhc3NpdmVMaXN0ZW5lcihldmVudCwgcGFzc2l2ZUxpc3RlbmVyKSB7XG4gICAgcGQoZXZlbnQpLnBhc3NpdmVMaXN0ZW5lciA9IHBhc3NpdmVMaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMaXN0ZW5lck5vZGVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcHJvcGVydHkgezF8MnwzfSBsaXN0ZW5lclR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGFzc2l2ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBvbmNlXG4gKiBAcHJvcGVydHkge0xpc3RlbmVyTm9kZXxudWxsfSBuZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHR5cGUge1dlYWtNYXA8b2JqZWN0LCBNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGxpc3RlbmVyc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIExpc3RlbmVyIHR5cGVzXG5jb25zdCBDQVBUVVJFID0gMTtcbmNvbnN0IEJVQkJMRSA9IDI7XG5jb25zdCBBVFRSSUJVVEUgPSAzO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogQHBhcmFtIHthbnl9IHggVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG59XG5cbi8qKlxuICogR2V0IGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgdG8gZ2V0LlxuICogQHJldHVybnMge01hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT59IFRoZSBsaXN0ZW5lcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZlbnRUYXJnZXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXAuZ2V0KGV2ZW50VGFyZ2V0KTtcbiAgICBpZiAobGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudFRhcmdldCBvYmplY3QsIGJ1dCBnb3QgYW5vdGhlciB2YWx1ZS5cIilcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyc1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIGV2ZW50IGF0dHJpYnV0ZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBnZXQgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmxpc3RlbmVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldChsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcblxuICAgICAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgcmVtb3Zpbmcgb2xkIHZhbHVlLlxuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgbmV3IHZhbHVlLlxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyVHlwZTogQVRUUklCVVRFLFxuICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgYW4gZXZlbnQgYXR0cmlidXRlIChlLmcuIGBldmVudFRhcmdldC5vbmNsaWNrYCkuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRUYXJnZXRQcm90b3R5cGUgVGhlIGV2ZW50IHRhcmdldCBwcm90b3R5cGUgdG8gZGVmaW5lIGFuIGV2ZW50IGF0dHJiaXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBkZWZpbmUuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGUoZXZlbnRUYXJnZXRQcm90b3R5cGUsIGV2ZW50TmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudFRhcmdldFByb3RvdHlwZSwgYG9uJHtldmVudE5hbWV9YCwgZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkpO1xufVxuXG4vKipcbiAqIERlZmluZSBhIGN1c3RvbSBFdmVudFRhcmdldCB3aXRoIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudE5hbWVzIEV2ZW50IG5hbWVzIGZvciBldmVudCBhdHRyaWJ1dGVzLlxuICogQHJldHVybnMge0V2ZW50VGFyZ2V0fSBUaGUgY3VzdG9tIEV2ZW50VGFyZ2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoZXZlbnROYW1lcykge1xuICAgIC8qKiBDdXN0b21FdmVudFRhcmdldCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50VGFyZ2V0KCkge1xuICAgICAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBDdXN0b21FdmVudFRhcmdldCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlKEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgZXZlbnROYW1lc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50VGFyZ2V0XG59XG5cbi8qKlxuICogRXZlbnRUYXJnZXQuXG4gKlxuICogLSBUaGlzIGlzIGNvbnN0cnVjdG9yIGlmIG5vIGFyZ3VtZW50cy5cbiAqIC0gVGhpcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBDdXN0b21FdmVudFRhcmdldCBjb25zdHJ1Y3RvciBpZiB0aGVyZSBhcmUgYXJndW1lbnRzLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBjbGFzcyBBIGV4dGVuZHMgRXZlbnRUYXJnZXQge31cbiAqICAgICBjbGFzcyBCIGV4dGVuZHMgRXZlbnRUYXJnZXQoXCJtZXNzYWdlXCIpIHt9XG4gKiAgICAgY2xhc3MgQyBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiLCBcImVycm9yXCIpIHt9XG4gKiAgICAgY2xhc3MgRCBleHRlbmRzIEV2ZW50VGFyZ2V0KFtcIm1lc3NhZ2VcIiwgXCJlcnJvclwiXSkge31cbiAqL1xuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgbGlzdGVuZXJzTWFwLnNldCh0aGlzLCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChhcmd1bWVudHNbMF0pXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0eXBlcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHR5cGVzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldCh0eXBlcylcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKVxuICAgIC8qZXNsaW50LWVuYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnRUYXJnZXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGdpdmVuIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBsaXN0ZW5lciB3YXMgYWRkZWQgYWN0dWFsbHkuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidsaXN0ZW5lcicgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBvcHRpb25zSXNPYmogPSBpc09iamVjdChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IG9wdGlvbnNJc09iaiA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKSA6IEJvb2xlYW4ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyVHlwZSA9IChjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRSk7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgIGxpc3RlbmVyVHlwZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMucGFzc2l2ZSksXG4gICAgICAgICAgICBvbmNlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLm9uY2UpLFxuICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgaXQgYXMgdGhlIGZpcnN0IG5vZGUgaWYgdGhlIGZpcnN0IG5vZGUgaXMgbnVsbC5cbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmF2ZXJzZSB0byB0aGUgdGFpbCB3aGlsZSBjaGVja2luZyBkdXBsaWNhdGlvbi4uXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgaWdub3JlIGR1cGxpY2F0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGl0LlxuICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBnaXZlbiBsaXN0ZW5lciBmcm9tIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZCBhY3R1YWxseS5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gaXNPYmplY3Qob3B0aW9ucykgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSkgOiBCb29sZWFuKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSAoY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEUpO1xuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJiBub2RlLmxpc3RlbmVyVHlwZSA9PT0gbGlzdGVuZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIGdpdmVuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIGV2ZW50IHRvIGRpc3BhdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgZmFsc2VgIGlmIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBsZXhpdHlcbiAgICAgICAgaWYgKGV2ZW50ID09IG51bGwgfHwgdHlwZW9mIGV2ZW50LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJcXFwiZXZlbnQudHlwZVxcXCIgc2hvdWxkIGJlIGEgc3RyaW5nLlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbGlzdGVuZXJzIGFyZW4ndCByZWdpc3RlcmVkLCB0ZXJtaW5hdGUuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gZXZlbnQudHlwZTtcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW5ub3QgcmV3cml0ZSBzZXZlcmFsIHByb3BlcnRpZXMsIHNvIHdyYXAgb2JqZWN0LlxuICAgICAgICBjb25zdCB3cmFwcGVkRXZlbnQgPSB3cmFwRXZlbnQodGhpcywgZXZlbnQpO1xuXG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBwcm9jZXNzIGNhcHR1cmluZyBwaGFzZSBhbmQgYnViYmxpbmcgcGhhc2UuXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgcGFydGljaXBhdGluZyBpbiBhIHRyZWUuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgbGlzdGVuZXIgaWYgaXQncyBvbmNlXG4gICAgICAgICAgICBpZiAobm9kZS5vbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhpcyBsaXN0ZW5lclxuICAgICAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKHdyYXBwZWRFdmVudCwgKG5vZGUucGFzc2l2ZSA/IG5vZGUubGlzdGVuZXIgOiBudWxsKSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuY2FsbCh0aGlzLCB3cmFwcGVkRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5saXN0ZW5lclR5cGUgIT09IEFUVFJJQlVURSAmJiB0eXBlb2Ygbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCh3cmFwcGVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCcmVhayBpZiBgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCB3YXMgY2FsbGVkLlxuICAgICAgICAgICAgaWYgKGlzU3RvcHBlZCh3cmFwcGVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzZXRQYXNzaXZlTGlzdGVuZXIod3JhcHBlZEV2ZW50LCBudWxsKTtcbiAgICAgICAgc2V0RXZlbnRQaGFzZSh3cmFwcGVkRXZlbnQsIDApO1xuICAgICAgICBzZXRDdXJyZW50VGFyZ2V0KHdyYXBwZWRFdmVudCwgbnVsbCk7XG5cbiAgICAgICAgcmV0dXJuICF3cmFwcGVkRXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICAgIH0sXG59O1xuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBFdmVudFRhcmdldCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcblxuLy8gRW5zdXJlIGBldmVudFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudFRhcmdldGAgaXMgYHRydWVgLlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5FdmVudFRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudFRhcmdldC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUpO1xufVxuXG5leHBvcnRzLmRlZmluZUV2ZW50QXR0cmlidXRlID0gZGVmaW5lRXZlbnRBdHRyaWJ1dGU7XG5leHBvcnRzLkV2ZW50VGFyZ2V0ID0gRXZlbnRUYXJnZXQ7XG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFRhcmdldDtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldFxubW9kdWxlLmV4cG9ydHMuRXZlbnRUYXJnZXQgPSBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBFdmVudFRhcmdldFxubW9kdWxlLmV4cG9ydHMuZGVmaW5lRXZlbnRBdHRyaWJ1dGUgPSBkZWZpbmVFdmVudEF0dHJpYnV0ZVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnQtdGFyZ2V0LXNoaW0uanMubWFwXG4iLCIvLyBvcmlnaW5hbGx5IHB1bGxlZCBvdXQgb2Ygc2ltcGxlLXBlZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCcm93c2VyUlRDICgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGxcbiAgdmFyIHdydGMgPSB7XG4gICAgUlRDUGVlckNvbm5lY3Rpb246IGdsb2JhbFRoaXMuUlRDUGVlckNvbm5lY3Rpb24gfHwgZ2xvYmFsVGhpcy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgZ2xvYmFsVGhpcy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbixcbiAgICBSVENTZXNzaW9uRGVzY3JpcHRpb246IGdsb2JhbFRoaXMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHx8XG4gICAgICBnbG9iYWxUaGlzLm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCBnbG9iYWxUaGlzLndlYmtpdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbixcbiAgICBSVENJY2VDYW5kaWRhdGU6IGdsb2JhbFRoaXMuUlRDSWNlQ2FuZGlkYXRlIHx8IGdsb2JhbFRoaXMubW96UlRDSWNlQ2FuZGlkYXRlIHx8XG4gICAgICBnbG9iYWxUaGlzLndlYmtpdFJUQ0ljZUNhbmRpZGF0ZVxuICB9XG4gIGlmICghd3J0Yy5SVENQZWVyQ29ubmVjdGlvbikgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHdydGNcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwpe1xuXG4gICAgdmFyIGlkcyA9IHt9O1xuXG4gICAgaWYoJ3N0cmluZycgPT0gdHlwZW9mIGVsKSBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsKTtcblxuICAgIGlmKCFlbCkgZWwgPSBkb2N1bWVudDtcblxuICAgIHZhciBjaGlsZHJlbiA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyk7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGNoaWxkcmVuLCBmdW5jdGlvbihlKXtcblxuXHRpZihlLmlkLmxlbmd0aCA+IDApe1xuXG5cdCAgICBpZHNbZS5pZF0gPSBlXG5cblx0fVxuXG4gICAgfSlcblxuICAgIHJldHVybiBpZHNcblxufVxuIiwiLy8gZ2V0VXNlck1lZGlhIGhlbHBlciBieSBASGVucmlrSm9yZXRlZyB1c2VkIGZvciBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHNoaW1cbnZhciBhZGFwdGVyID0gcmVxdWlyZSgnd2VicnRjLWFkYXB0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIGNiKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIHZhciBoYXZlT3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDI7XG4gICAgdmFyIGRlZmF1bHRPcHRzID0ge3ZpZGVvOiB0cnVlLCBhdWRpbzogdHJ1ZX07XG5cbiAgICB2YXIgZGVuaWVkID0gJ1Blcm1pc3Npb25EZW5pZWRFcnJvcic7XG4gICAgdmFyIGFsdERlbmllZCA9ICdQRVJNSVNTSU9OX0RFTklFRCc7XG4gICAgdmFyIG5vdFNhdGlzZmllZCA9ICdDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3InO1xuXG4gICAgLy8gbWFrZSBjb25zdHJhaW50cyBvcHRpb25hbFxuICAgIGlmICghaGF2ZU9wdHMpIHtcbiAgICAgICAgY2IgPSBjb25zdHJhaW50cztcbiAgICAgICAgY29uc3RyYWludHMgPSBkZWZhdWx0T3B0cztcbiAgICB9XG5cbiAgICAvLyB0cmVhdCBsYWNrIG9mIGJyb3dzZXIgc3VwcG9ydCBsaWtlIGFuIGVycm9yXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKXsgLy9nZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgLy8gdGhyb3cgcHJvcGVyIGVycm9yIHBlciBzcGVjXG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNZWRpYVN0cmVhbUVycm9yJyk7XG4gICAgICAgIGVycm9yLm5hbWUgPSAnTm90U3VwcG9ydGVkRXJyb3InO1xuXG4gICAgICAgIC8vIGtlZXAgYWxsIGNhbGxiYWNrcyBhc3luY1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBlcnJvciBoYW5kbGluZyB3aGVuIG5vIG1lZGlhIHR5cGVzIGFyZSByZXF1ZXN0ZWRcbiAgICBpZiAoIWNvbnN0cmFpbnRzLmF1ZGlvICYmICFjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTWVkaWFTdHJlYW1FcnJvcicpO1xuICAgICAgICBlcnJvci5uYW1lID0gJ05vTWVkaWFSZXF1ZXN0ZWRFcnJvcic7XG5cbiAgICAgICAgLy8ga2VlcCBhbGwgY2FsbGJhY2tzIGFzeW5jXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgLnRoZW4oZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICBjYihudWxsLCBzdHJlYW0pO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBjb2VyY2UgaW50byBhbiBlcnJvciBvYmplY3Qgc2luY2UgRkYgZ2l2ZXMgdXMgYSBzdHJpbmdcbiAgICAgICAgLy8gdGhlcmUgYXJlIG9ubHkgdHdvIHZhbGlkIG5hbWVzIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAgICAgICAvLyB3ZSBjb2VyY2UgYWxsIG5vbi1kZW5pZWQgdG8gXCJjb25zdHJhaW50IG5vdCBzYXRpc2ZpZWRcIi5cbiAgICAgICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTWVkaWFTdHJlYW1FcnJvcicpO1xuICAgICAgICAgICAgaWYgKGVyciA9PT0gZGVuaWVkIHx8IGVyciA9PT0gYWx0RGVuaWVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IGRlbmllZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IG5vdFNhdGlzZmllZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGdldCBhbiBlcnJvciBvYmplY3QgbWFrZSBzdXJlICcubmFtZScgcHJvcGVydHkgaXMgc2V0XG4gICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gc3BlYzogaHR0cDovL2Rldi53My5vcmcvMjAxMS93ZWJydGMvZWRpdG9yL2dldHVzZXJtZWRpYS5odG1sI25hdmlnYXRvcnVzZXJtZWRpYWVycm9yLWFuZC1uYXZpZ2F0b3J1c2VybWVkaWFlcnJvcmNhbGxiYWNrXG4gICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIGlmICghZXJyb3IubmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbGlrZWx5IGNocm9tZSB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHNldHMgYSBwcm9wZXJ0eSBjYWxsZWQgXCJFUlJPUl9ERU5JRURcIiBvbiB0aGUgZXJyb3Igb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gaWYgc28gd2UgbWFrZSBzdXJlIHRvIHNldCBhIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JbZGVuaWVkXSkge1xuICAgICAgICAgICAgICAgICAgICBlcnIubmFtZSA9IGRlbmllZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnIubmFtZSA9IG5vdFNhdGlzZmllZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYihlcnJvcik7XG4gICAgfSk7XG59O1xuIiwidmFyIHNwbGl0ID0gcmVxdWlyZSgnYnJvd3Nlci1zcGxpdCcpXG52YXIgQ2xhc3NMaXN0ID0gcmVxdWlyZSgnY2xhc3MtbGlzdCcpXG5cbnZhciB3ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdodG1sLWVsZW1lbnQnKSA6IHdpbmRvd1xudmFyIGRvY3VtZW50ID0gdy5kb2N1bWVudFxudmFyIFRleHQgPSB3LlRleHRcblxuZnVuY3Rpb24gY29udGV4dCAoKSB7XG5cbiAgdmFyIGNsZWFudXBGdW5jcyA9IFtdXG5cbiAgZnVuY3Rpb24gaCgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZSA9IG51bGxcbiAgICBmdW5jdGlvbiBpdGVtIChsKSB7XG4gICAgICB2YXIgclxuICAgICAgZnVuY3Rpb24gcGFyc2VDbGFzcyAoc3RyaW5nKSB7XG4gICAgICAgIC8vIE91ciBtaW5pbWFsIHBhcnNlciBkb2VzbuKAmXQgdW5kZXJzdGFuZCBlc2NhcGluZyBDU1Mgc3BlY2lhbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIGxpa2UgYCNgLiBEb27igJl0IHVzZSB0aGVtLiBNb3JlIHJlYWRpbmc6XG4gICAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9jc3MtZXNjYXBlcyAuXG5cbiAgICAgICAgdmFyIG0gPSBzcGxpdChzdHJpbmcsIC8oW1xcLiNdP1teXFxzIy5dKykvKVxuICAgICAgICBpZigvXlxcLnwjLy50ZXN0KG1bMV0pKVxuICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBmb3JFYWNoKG0sIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgdmFyIHMgPSB2LnN1YnN0cmluZygxLHYubGVuZ3RoKVxuICAgICAgICAgIGlmKCF2KSByZXR1cm5cbiAgICAgICAgICBpZighZSlcbiAgICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHYpXG4gICAgICAgICAgZWxzZSBpZiAodlswXSA9PT0gJy4nKVxuICAgICAgICAgICAgQ2xhc3NMaXN0KGUpLmFkZChzKVxuICAgICAgICAgIGVsc2UgaWYgKHZbMF0gPT09ICcjJylcbiAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKCdpZCcsIHMpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmKGwgPT0gbnVsbClcbiAgICAgICAgO1xuICAgICAgZWxzZSBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgaWYoIWUpXG4gICAgICAgICAgcGFyc2VDbGFzcyhsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobCkpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKCdudW1iZXInID09PSB0eXBlb2YgbFxuICAgICAgICB8fCAnYm9vbGVhbicgPT09IHR5cGVvZiBsXG4gICAgICAgIHx8IGwgaW5zdGFuY2VvZiBEYXRlXG4gICAgICAgIHx8IGwgaW5zdGFuY2VvZiBSZWdFeHAgKSB7XG4gICAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobC50b1N0cmluZygpKSlcbiAgICAgIH1cbiAgICAgIC8vdGhlcmUgbWlnaHQgYmUgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG4gICAgICBlbHNlIGlmIChpc0FycmF5KGwpKVxuICAgICAgICBmb3JFYWNoKGwsIGl0ZW0pXG4gICAgICBlbHNlIGlmKGlzTm9kZShsKSlcbiAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gbClcbiAgICAgIGVsc2UgaWYobCBpbnN0YW5jZW9mIFRleHQpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGwpXG4gICAgICBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBsKSB7XG4gICAgICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGxba10pIHtcbiAgICAgICAgICAgIGlmKC9eb25cXHcrLy50ZXN0KGspKSB7XG4gICAgICAgICAgICAgIChmdW5jdGlvbiAoaywgbCkgeyAvLyBjYXB0dXJlIGssIGwgaW4gdGhlIGNsb3N1cmVcbiAgICAgICAgICAgICAgICBpZiAoZS5hZGRFdmVudExpc3RlbmVyKXtcbiAgICAgICAgICAgICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihrLnN1YnN0cmluZygyKSwgbFtrXSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoay5zdWJzdHJpbmcoMiksIGxba10sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIGUuYXR0YWNoRXZlbnQoaywgbFtrXSlcbiAgICAgICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGUuZGV0YWNoRXZlbnQoaywgbFtrXSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KShrLCBsKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICBlW2tdID0gbFtrXSgpXG4gICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGxba10oZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBlW2tdID0gdlxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZihrID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGxba10pIHtcbiAgICAgICAgICAgICAgZS5zdHlsZS5jc3NUZXh0ID0gbFtrXVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGZvciAodmFyIHMgaW4gbFtrXSkgKGZ1bmN0aW9uKHMsIHYpIHtcbiAgICAgICAgICAgICAgICBpZignZnVuY3Rpb24nID09PSB0eXBlb2Ygdikge1xuICAgICAgICAgICAgICAgICAgLy8gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCB2KCkpXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaCh2KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCB2YWwpXG4gICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxba11bc10ubWF0Y2goLyguKilcXFcrIWltcG9ydGFudFxcVyokLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCBtYXRjaFsxXSwgJ2ltcG9ydGFudCcpXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIGxba11bc10pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKHMsIGxba11bc10pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGsgPT09ICdhdHRycycpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgaW4gbFtrXSkge1xuICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZSh2LCBsW2tdW3ZdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChrLnN1YnN0cigwLCA1KSA9PT0gXCJkYXRhLVwiKSB7XG4gICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrLCBsW2tdKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlW2tdID0gbFtrXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbCkge1xuICAgICAgICAvL2Fzc3VtZSBpdCdzIGFuIG9ic2VydmFibGUhXG4gICAgICAgIHZhciB2ID0gbCgpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGlzTm9kZSh2KSA/IHYgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2KSlcblxuICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChsKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgaWYoaXNOb2RlKHYpICYmIHIucGFyZW50RWxlbWVudClcbiAgICAgICAgICAgIHIucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQodiwgciksIHIgPSB2XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgci50ZXh0Q29udGVudCA9IHZcbiAgICAgICAgfSkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByXG4gICAgfVxuICAgIHdoaWxlKGFyZ3MubGVuZ3RoKVxuICAgICAgaXRlbShhcmdzLnNoaWZ0KCkpXG5cbiAgICByZXR1cm4gZVxuICB9XG5cbiAgaC5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xlYW51cEZ1bmNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNsZWFudXBGdW5jc1tpXSgpXG4gICAgfVxuICAgIGNsZWFudXBGdW5jcy5sZW5ndGggPSAwXG4gIH1cblxuICByZXR1cm4gaFxufVxuXG52YXIgaCA9IG1vZHVsZS5leHBvcnRzID0gY29udGV4dCgpXG5oLmNvbnRleHQgPSBjb250ZXh0XG5cbmZ1bmN0aW9uIGlzTm9kZSAoZWwpIHtcbiAgcmV0dXJuIGVsICYmIGVsLm5vZGVOYW1lICYmIGVsLm5vZGVUeXBlXG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKGFyciwgZm4pIHtcbiAgaWYgKGFyci5mb3JFYWNoKSByZXR1cm4gYXJyLmZvckVhY2goZm4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmbihhcnJbaV0sIGkpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJ1xufVxuXG5cbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmdzLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgXG4gICAgdmFyIGZsYWdzID0geyBib29scyA6IHt9LCBzdHJpbmdzIDoge30sIHVua25vd25GbjogbnVsbCB9O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzWyd1bmtub3duJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmxhZ3MudW5rbm93bkZuID0gb3B0c1sndW5rbm93biddO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0c1snYm9vbGVhbiddID09PSAnYm9vbGVhbicgJiYgb3B0c1snYm9vbGVhbiddKSB7XG4gICAgICBmbGFncy5hbGxCb29scyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtdLmNvbmNhdChvcHRzWydib29sZWFuJ10pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBmbGFncy5ib29sc1trZXldID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9wdHMuYWxpYXMgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBhbGlhc2VzW2tleV0gPSBbXS5jb25jYXQob3B0cy5hbGlhc1trZXldKTtcbiAgICAgICAgYWxpYXNlc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGFsaWFzZXNbeF0gPSBba2V5XS5jb25jYXQoYWxpYXNlc1trZXldLmZpbHRlcihmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ICE9PSB5O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIFtdLmNvbmNhdChvcHRzLnN0cmluZykuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBmbGFncy5zdHJpbmdzW2tleV0gPSB0cnVlO1xuICAgICAgICBpZiAoYWxpYXNlc1trZXldKSB7XG4gICAgICAgICAgICBmbGFncy5zdHJpbmdzW2FsaWFzZXNba2V5XV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgIH0pO1xuXG4gICAgdmFyIGRlZmF1bHRzID0gb3B0c1snZGVmYXVsdCddIHx8IHt9O1xuICAgIFxuICAgIHZhciBhcmd2ID0geyBfIDogW10gfTtcbiAgICBPYmplY3Qua2V5cyhmbGFncy5ib29scykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRzW2tleV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogZGVmYXVsdHNba2V5XSk7XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIG5vdEZsYWdzID0gW107XG5cbiAgICBpZiAoYXJncy5pbmRleE9mKCctLScpICE9PSAtMSkge1xuICAgICAgICBub3RGbGFncyA9IGFyZ3Muc2xpY2UoYXJncy5pbmRleE9mKCctLScpKzEpO1xuICAgICAgICBhcmdzID0gYXJncy5zbGljZSgwLCBhcmdzLmluZGV4T2YoJy0tJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFyZ0RlZmluZWQoa2V5LCBhcmcpIHtcbiAgICAgICAgcmV0dXJuIChmbGFncy5hbGxCb29scyAmJiAvXi0tW149XSskLy50ZXN0KGFyZykpIHx8XG4gICAgICAgICAgICBmbGFncy5zdHJpbmdzW2tleV0gfHwgZmxhZ3MuYm9vbHNba2V5XSB8fCBhbGlhc2VzW2tleV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QXJnIChrZXksIHZhbCwgYXJnKSB7XG4gICAgICAgIGlmIChhcmcgJiYgZmxhZ3MudW5rbm93bkZuICYmICFhcmdEZWZpbmVkKGtleSwgYXJnKSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzLnVua25vd25GbihhcmcpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gIWZsYWdzLnN0cmluZ3Nba2V5XSAmJiBpc051bWJlcih2YWwpXG4gICAgICAgICAgICA/IE51bWJlcih2YWwpIDogdmFsXG4gICAgICAgIDtcbiAgICAgICAgc2V0S2V5KGFyZ3YsIGtleS5zcGxpdCgnLicpLCB2YWx1ZSk7XG4gICAgICAgIFxuICAgICAgICAoYWxpYXNlc1trZXldIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBzZXRLZXkoYXJndiwgeC5zcGxpdCgnLicpLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEtleSAob2JqLCBrZXlzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbyA9IG9iajtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aC0xOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChvW2tleV0gPT09IHVuZGVmaW5lZCkgb1trZXldID0ge307XG4gICAgICAgICAgICBpZiAob1trZXldID09PSBPYmplY3QucHJvdG90eXBlIHx8IG9ba2V5XSA9PT0gTnVtYmVyLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgIHx8IG9ba2V5XSA9PT0gU3RyaW5nLnByb3RvdHlwZSkgb1trZXldID0ge307XG4gICAgICAgICAgICBpZiAob1trZXldID09PSBBcnJheS5wcm90b3R5cGUpIG9ba2V5XSA9IFtdO1xuICAgICAgICAgICAgbyA9IG9ba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSByZXR1cm47XG4gICAgICAgIGlmIChvID09PSBPYmplY3QucHJvdG90eXBlIHx8IG8gPT09IE51bWJlci5wcm90b3R5cGVcbiAgICAgICAgICAgIHx8IG8gPT09IFN0cmluZy5wcm90b3R5cGUpIG8gPSB7fTtcbiAgICAgICAgaWYgKG8gPT09IEFycmF5LnByb3RvdHlwZSkgbyA9IFtdO1xuICAgICAgICBpZiAob1trZXldID09PSB1bmRlZmluZWQgfHwgZmxhZ3MuYm9vbHNba2V5XSB8fCB0eXBlb2Ygb1trZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob1trZXldKSkge1xuICAgICAgICAgICAgb1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb1trZXldID0gWyBvW2tleV0sIHZhbHVlIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gYWxpYXNJc0Jvb2xlYW4oa2V5KSB7XG4gICAgICByZXR1cm4gYWxpYXNlc1trZXldLnNvbWUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gZmxhZ3MuYm9vbHNbeF07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgIFxuICAgICAgICBpZiAoL14tLS4rPS8udGVzdChhcmcpKSB7XG4gICAgICAgICAgICAvLyBVc2luZyBbXFxzXFxTXSBpbnN0ZWFkIG9mIC4gYmVjYXVzZSBqcyBkb2Vzbid0IHN1cHBvcnQgdGhlXG4gICAgICAgICAgICAvLyAnZG90YWxsJyByZWdleCBtb2RpZmllci4gU2VlOlxuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA2ODMwOC8xMzIxNlxuICAgICAgICAgICAgdmFyIG0gPSBhcmcubWF0Y2goL14tLShbXj1dKyk9KFtcXHNcXFNdKikkLyk7XG4gICAgICAgICAgICB2YXIga2V5ID0gbVsxXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1bMl07XG4gICAgICAgICAgICBpZiAoZmxhZ3MuYm9vbHNba2V5XSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgIT09ICdmYWxzZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRBcmcoa2V5LCB2YWx1ZSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXi0tbm8tLisvLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGFyZy5tYXRjaCgvXi0tbm8tKC4rKS8pWzFdO1xuICAgICAgICAgICAgc2V0QXJnKGtleSwgZmFsc2UsIGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14tLS4rLy50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBhcmcubWF0Y2goL14tLSguKykvKVsxXTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gYXJnc1tpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmICEvXi0vLnRlc3QobmV4dClcbiAgICAgICAgICAgICYmICFmbGFncy5ib29sc1trZXldXG4gICAgICAgICAgICAmJiAhZmxhZ3MuYWxsQm9vbHNcbiAgICAgICAgICAgICYmIChhbGlhc2VzW2tleV0gPyAhYWxpYXNJc0Jvb2xlYW4oa2V5KSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgbmV4dCwgYXJnKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXih0cnVlfGZhbHNlKSQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0ID09PSAndHJ1ZScsIGFyZyk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZmxhZ3Muc3RyaW5nc1trZXldID8gJycgOiB0cnVlLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eLVteLV0rLy50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIHZhciBsZXR0ZXJzID0gYXJnLnNsaWNlKDEsLTEpLnNwbGl0KCcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJyb2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXR0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBhcmcuc2xpY2UoaisyKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0LCBhcmcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoL1tBLVphLXpdLy50ZXN0KGxldHRlcnNbal0pICYmIC89Ly50ZXN0KG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0LnNwbGl0KCc9JylbMV0sIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoL1tBLVphLXpdLy50ZXN0KGxldHRlcnNbal0pXG4gICAgICAgICAgICAgICAgJiYgLy0/XFxkKyhcXC5cXGQqKT8oZS0/XFxkKyk/JC8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dCwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChsZXR0ZXJzW2orMV0gJiYgbGV0dGVyc1tqKzFdLm1hdGNoKC9cXFcvKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgYXJnLnNsaWNlKGorMiksIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIGZsYWdzLnN0cmluZ3NbbGV0dGVyc1tqXV0gPyAnJyA6IHRydWUsIGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIga2V5ID0gYXJnLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICAgIGlmICghYnJva2VuICYmIGtleSAhPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbaSsxXSAmJiAhL14oLXwtLSlbXi1dLy50ZXN0KGFyZ3NbaSsxXSlcbiAgICAgICAgICAgICAgICAmJiAhZmxhZ3MuYm9vbHNba2V5XVxuICAgICAgICAgICAgICAgICYmIChhbGlhc2VzW2tleV0gPyAhYWxpYXNJc0Jvb2xlYW4oa2V5KSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGFyZ3NbaSsxXSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmdzW2krMV0gJiYgL14odHJ1ZXxmYWxzZSkkLy50ZXN0KGFyZ3NbaSsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgYXJnc1tpKzFdID09PSAndHJ1ZScsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGZsYWdzLnN0cmluZ3Nba2V5XSA/ICcnIDogdHJ1ZSwgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWZsYWdzLnVua25vd25GbiB8fCBmbGFncy51bmtub3duRm4oYXJnKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhcmd2Ll8ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3Muc3RyaW5nc1snXyddIHx8ICFpc051bWJlcihhcmcpID8gYXJnIDogTnVtYmVyKGFyZylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuc3RvcEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgYXJndi5fLnB1c2guYXBwbHkoYXJndi5fLCBhcmdzLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWhhc0tleShhcmd2LCBrZXkuc3BsaXQoJy4nKSkpIHtcbiAgICAgICAgICAgIHNldEtleShhcmd2LCBrZXkuc3BsaXQoJy4nKSwgZGVmYXVsdHNba2V5XSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIChhbGlhc2VzW2tleV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBzZXRLZXkoYXJndiwgeC5zcGxpdCgnLicpLCBkZWZhdWx0c1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKG9wdHNbJy0tJ10pIHtcbiAgICAgICAgYXJndlsnLS0nXSA9IG5ldyBBcnJheSgpO1xuICAgICAgICBub3RGbGFncy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgYXJndlsnLS0nXS5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm90RmxhZ3MuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGFyZ3YuXy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcmd2O1xufTtcblxuZnVuY3Rpb24gaGFzS2V5IChvYmosIGtleXMpIHtcbiAgICB2YXIgbyA9IG9iajtcbiAgICBrZXlzLnNsaWNlKDAsLTEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvID0gKG9ba2V5XSB8fCB7fSk7XG4gICAgfSk7XG5cbiAgICB2YXIga2V5ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBrZXkgaW4gbztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIgKHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoL14weFswLTlhLWZdKyQvaS50ZXN0KHgpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gL15bLStdPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoZVstK10/XFxkKyk/JC8udGVzdCh4KTtcbn1cblxuIiwiXG4ndXNlIHN0cmljdCdcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vYnguY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2J4LmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBuaWNlRXJyb3JzID0ge1xuICAwOiBcIkludmFsaWQgdmFsdWUgZm9yIGNvbmZpZ3VyYXRpb24gJ2VuZm9yY2VBY3Rpb25zJywgZXhwZWN0ZWQgJ25ldmVyJywgJ2Fsd2F5cycgb3IgJ29ic2VydmVkJ1wiLFxuICAxOiBmdW5jdGlvbiBfKGFubm90YXRpb25UeXBlLCBrZXkpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6IEZpZWxkIG5vdCBmb3VuZC5cIjtcbiAgfSxcblxuICAvKlxyXG4gIDIocHJvcCkge1xyXG4gICAgICByZXR1cm4gYGludmFsaWQgZGVjb3JhdG9yIGZvciAnJHtwcm9wLnRvU3RyaW5nKCl9J2BcclxuICB9LFxyXG4gIDMocHJvcCkge1xyXG4gICAgICByZXR1cm4gYENhbm5vdCBkZWNvcmF0ZSAnJHtwcm9wLnRvU3RyaW5nKCl9JzogYWN0aW9uIGNhbiBvbmx5IGJlIHVzZWQgb24gcHJvcGVydGllcyB3aXRoIGEgZnVuY3Rpb24gdmFsdWUuYFxyXG4gIH0sXHJcbiAgNChwcm9wKSB7XHJcbiAgICAgIHJldHVybiBgQ2Fubm90IGRlY29yYXRlICcke3Byb3AudG9TdHJpbmcoKX0nOiBjb21wdXRlZCBjYW4gb25seSBiZSB1c2VkIG9uIGdldHRlciBwcm9wZXJ0aWVzLmBcclxuICB9LFxyXG4gICovXG4gIDU6IFwiJ2tleXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cywgc2V0cyBhbmQgbWFwc1wiLFxuICA2OiBcIid2YWx1ZXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cywgc2V0cyBhbmQgbWFwc1wiLFxuICA3OiBcIidlbnRyaWVzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgODogXCInc2V0KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgOTogXCIncmVtb3ZlKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgMTA6IFwiJ2hhcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDExOiBcIidnZXQoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICAxMjogXCJJbnZhbGlkIGFubm90YXRpb25cIixcbiAgMTM6IFwiRHluYW1pYyBvYnNlcnZhYmxlIG9iamVjdHMgY2Fubm90IGJlIGZyb3plblwiLFxuICAxNDogXCJJbnRlcmNlcHQgaGFuZGxlcnMgc2hvdWxkIHJldHVybiBub3RoaW5nIG9yIGEgY2hhbmdlIG9iamVjdFwiLFxuICAxNTogXCJPYnNlcnZhYmxlIGFycmF5cyBjYW5ub3QgYmUgZnJvemVuXCIsXG4gIDE2OiBcIk1vZGlmaWNhdGlvbiBleGNlcHRpb246IHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgYW4gb2JzZXJ2YWJsZSBhcnJheSB3YXMgY2hhbmdlZC5cIixcbiAgMTc6IGZ1bmN0aW9uIF8oaW5kZXgsIGxlbmd0aCkge1xuICAgIHJldHVybiBcIlttb2J4LmFycmF5XSBJbmRleCBvdXQgb2YgYm91bmRzLCBcIiArIGluZGV4ICsgXCIgaXMgbGFyZ2VyIHRoYW4gXCIgKyBsZW5ndGg7XG4gIH0sXG4gIDE4OiBcIm1vYngubWFwIHJlcXVpcmVzIE1hcCBwb2x5ZmlsbCBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci4gQ2hlY2sgYmFiZWwtcG9seWZpbGwgb3IgY29yZS1qcy9lczYvbWFwLmpzXCIsXG4gIDE5OiBmdW5jdGlvbiBfKG90aGVyKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGluaXRpYWxpemUgZnJvbSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIE1hcDogXCIgKyBvdGhlci5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9LFxuICAyMDogZnVuY3Rpb24gXyhvdGhlcikge1xuICAgIHJldHVybiBcIkNhbm5vdCBpbml0aWFsaXplIG1hcCBmcm9tIFwiICsgb3RoZXI7XG4gIH0sXG4gIDIxOiBmdW5jdGlvbiBfKGRhdGFTdHJ1Y3R1cmUpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgY29udmVydCB0byBtYXAgZnJvbSAnXCIgKyBkYXRhU3RydWN0dXJlICsgXCInXCI7XG4gIH0sXG4gIDIyOiBcIm1vYnguc2V0IHJlcXVpcmVzIFNldCBwb2x5ZmlsbCBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci4gQ2hlY2sgYmFiZWwtcG9seWZpbGwgb3IgY29yZS1qcy9lczYvc2V0LmpzXCIsXG4gIDIzOiBcIkl0IGlzIG5vdCBwb3NzaWJsZSB0byBnZXQgaW5kZXggYXRvbXMgZnJvbSBhcnJheXNcIixcbiAgMjQ6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCJDYW5ub3Qgb2J0YWluIGFkbWluaXN0cmF0aW9uIGZyb20gXCIgKyB0aGluZztcbiAgfSxcbiAgMjU6IGZ1bmN0aW9uIF8ocHJvcGVydHksIG5hbWUpIHtcbiAgICByZXR1cm4gXCJ0aGUgZW50cnkgJ1wiICsgcHJvcGVydHkgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG9ic2VydmFibGUgbWFwICdcIiArIG5hbWUgKyBcIidcIjtcbiAgfSxcbiAgMjY6IFwicGxlYXNlIHNwZWNpZnkgYSBwcm9wZXJ0eVwiLFxuICAyNzogZnVuY3Rpb24gXyhwcm9wZXJ0eSwgbmFtZSkge1xuICAgIHJldHVybiBcIm5vIG9ic2VydmFibGUgcHJvcGVydHkgJ1wiICsgcHJvcGVydHkudG9TdHJpbmcoKSArIFwiJyBmb3VuZCBvbiB0aGUgb2JzZXJ2YWJsZSBvYmplY3QgJ1wiICsgbmFtZSArIFwiJ1wiO1xuICB9LFxuICAyODogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIkNhbm5vdCBvYnRhaW4gYXRvbSBmcm9tIFwiICsgdGhpbmc7XG4gIH0sXG4gIDI5OiBcIkV4cGVjdGluZyBzb21lIG9iamVjdFwiLFxuICAzMDogXCJpbnZhbGlkIGFjdGlvbiBzdGFjay4gZGlkIHlvdSBmb3JnZXQgdG8gZmluaXNoIGFuIGFjdGlvbj9cIixcbiAgMzE6IFwibWlzc2luZyBvcHRpb24gZm9yIGNvbXB1dGVkOiBnZXRcIixcbiAgMzI6IGZ1bmN0aW9uIF8obmFtZSwgZGVyaXZhdGlvbikge1xuICAgIHJldHVybiBcIkN5Y2xlIGRldGVjdGVkIGluIGNvbXB1dGF0aW9uIFwiICsgbmFtZSArIFwiOiBcIiArIGRlcml2YXRpb247XG4gIH0sXG4gIDMzOiBmdW5jdGlvbiBfKG5hbWUpIHtcbiAgICByZXR1cm4gXCJUaGUgc2V0dGVyIG9mIGNvbXB1dGVkIHZhbHVlICdcIiArIG5hbWUgKyBcIicgaXMgdHJ5aW5nIHRvIHVwZGF0ZSBpdHNlbGYuIERpZCB5b3UgaW50ZW5kIHRvIHVwZGF0ZSBhbiBfb2JzZXJ2YWJsZV8gdmFsdWUsIGluc3RlYWQgb2YgdGhlIGNvbXB1dGVkIHByb3BlcnR5P1wiO1xuICB9LFxuICAzNDogZnVuY3Rpb24gXyhuYW1lKSB7XG4gICAgcmV0dXJuIFwiW0NvbXB1dGVkVmFsdWUgJ1wiICsgbmFtZSArIFwiJ10gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGFzc2lnbiBhIG5ldyB2YWx1ZSB0byBhIGNvbXB1dGVkIHZhbHVlLlwiO1xuICB9LFxuICAzNTogXCJUaGVyZSBhcmUgbXVsdGlwbGUsIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBNb2JYIGFjdGl2ZS4gTWFrZSBzdXJlIE1vYlggaXMgbG9hZGVkIG9ubHkgb25jZSBvciB1c2UgYGNvbmZpZ3VyZSh7IGlzb2xhdGVHbG9iYWxTdGF0ZTogdHJ1ZSB9KWBcIixcbiAgMzY6IFwiaXNvbGF0ZUdsb2JhbFN0YXRlIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIE1vYlggaXMgcnVubmluZyBhbnkgcmVhY3Rpb25zXCIsXG4gIDM3OiBmdW5jdGlvbiBfKG1ldGhvZCkge1xuICAgIHJldHVybiBcIlttb2J4XSBgb2JzZXJ2YWJsZUFycmF5LlwiICsgbWV0aG9kICsgXCIoKWAgbXV0YXRlcyB0aGUgYXJyYXkgaW4tcGxhY2UsIHdoaWNoIGlzIG5vdCBhbGxvd2VkIGluc2lkZSBhIGRlcml2YXRpb24uIFVzZSBgYXJyYXkuc2xpY2UoKS5cIiArIG1ldGhvZCArIFwiKClgIGluc3RlYWRcIjtcbiAgfSxcbiAgMzg6IFwiJ293bktleXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHNcIixcbiAgMzk6IFwiJ2RlZmluZVByb3BlcnR5KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzXCJcbn07XG52YXIgZXJyb3JzID0gIG5pY2VFcnJvcnMgO1xuZnVuY3Rpb24gZGllKGVycm9yKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgZSA9IHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVycm9yIDogZXJyb3JzW2Vycm9yXTtcbiAgICBpZiAodHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIikgZSA9IGUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW01vYlhdIFwiICsgZSk7XG4gIH1cbn1cblxudmFyIG1vY2tHbG9iYWwgPSB7fTtcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIHJldHVybiBtb2NrR2xvYmFsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbnZhciBnZXREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEVNUFRZX0FSUkFZID0gW107XG5PYmplY3QuZnJlZXplKEVNUFRZX0FSUkFZKTtcbnZhciBFTVBUWV9PQkpFQ1QgPSB7fTtcbk9iamVjdC5mcmVlemUoRU1QVFlfT0JKRUNUKTtcbnZhciBoYXNQcm94eSA9IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBwbGFpbk9iamVjdFN0cmluZyA9IC8qI19fUFVSRV9fKi9PYmplY3QudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGFzc2VydFByb3hpZXMoKSB7XG4gIGlmICghaGFzUHJveHkpIHtcbiAgICBkaWUoIFwiYFByb3h5YCBvYmplY3RzIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBQbGVhc2UgY29uZmlndXJlIE1vYlggdG8gZW5hYmxlIGEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24uYFwiICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQobXNnKSB7XG4gIGlmICggZ2xvYmFsU3RhdGUudmVyaWZ5UHJveGllcykge1xuICAgIGRpZShcIk1vYlggaXMgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG8gYmUgYWJsZSB0byBydW4gaW4gRVM1IG1vZGUsIGJ1dCBpbiBFUzUgTW9iWCB3b24ndCBiZSBhYmxlIHRvIFwiICsgbXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICByZXR1cm4gKytnbG9iYWxTdGF0ZS5tb2J4R3VpZDtcbn1cbi8qKlxyXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGlzIGludm9rZWQgYXQgbW9zdCBvbmNlLlxyXG4gKi9cblxuZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gIHZhciBpbnZva2VkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGludm9rZWQpIHJldHVybjtcbiAgICBpbnZva2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5naXNoKHZhbHVlKSB7XG4gIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuXG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICB2YXIgX3Byb3RvJGNvbnN0cnVjdG9yO1xuXG4gIGlmICghaXNPYmplY3QodmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuICgoX3Byb3RvJGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvdG8kY29uc3RydWN0b3IudG9TdHJpbmcoKSkgPT09IHBsYWluT2JqZWN0U3RyaW5nO1xufSAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc4NjUxNzBcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3Iob2JqKSB7XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqLmNvbnN0cnVjdG9yO1xuICBpZiAoIWNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG4gIGlmIChcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IGNvbnN0cnVjdG9yLm5hbWUgfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZEhpZGRlblByb3Aob2JqZWN0LCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wTmFtZSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRIaWRkZW5GaW5hbFByb3Aob2JqZWN0LCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wTmFtZSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShuYW1lLCB0aGVDbGFzcykge1xuICB2YXIgcHJvcE5hbWUgPSBcImlzTW9iWFwiICsgbmFtZTtcbiAgdGhlQ2xhc3MucHJvdG90eXBlW3Byb3BOYW1lXSA9IHRydWU7XG4gIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBpc09iamVjdCh4KSAmJiB4W3Byb3BOYW1lXSA9PT0gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRVM2TWFwKHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIE1hcDtcbn1cbmZ1bmN0aW9uIGlzRVM2U2V0KHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIFNldDtcbn1cbnZhciBoYXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmb2xsb3dpbmc6IG93biBlbnVtZXJhYmxlIGtleXMgYW5kIHN5bWJvbHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRQbGFpbk9iamVjdEtleXMob2JqZWN0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgLy8gTm90IHN1cHBvcnRlZCBpbiBJRSwgc28gdGhlcmUgYXJlIG5vdCBnb2luZyB0byBiZSBzeW1ib2wgcHJvcHMgYW55d2F5Li4uXG5cbiAgaWYgKCFoYXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHJldHVybiBrZXlzO1xuICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgaWYgKCFzeW1ib2xzLmxlbmd0aCkgcmV0dXJuIGtleXM7XG4gIHJldHVybiBbXS5jb25jYXQoa2V5cywgc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gb2JqZWN0UHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzKTtcbiAgfSkpO1xufSAvLyBGcm9tIEltbWVyIHV0aWxzXG4vLyBSZXR1cm5zIGFsbCBvd24ga2V5cywgaW5jbHVkaW5nIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xpY1xuXG52YXIgb3duS2V5cyA9IHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Qub3duS2V5cyA/IFJlZmxlY3Qub3duS2V5cyA6IGhhc0dldE93blByb3BlcnR5U3ltYm9scyA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG59IDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbmZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHJldHVybiBrZXk7XG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiKSByZXR1cm4ga2V5LnRvU3RyaW5nKCk7XG4gIHJldHVybiBuZXcgU3RyaW5nKGtleSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyBcIlwiICsgdmFsdWUgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3AodGFyZ2V0LCBwcm9wKSB7XG4gIHJldHVybiBvYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApO1xufSAvLyBGcm9tIEltbWVyIHV0aWxzXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQpIHtcbiAgLy8gUG9seWZpbGwgbmVlZGVkIGZvciBIZXJtZXMgYW5kIElFLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2hlcm1lcy9pc3N1ZXMvMjc0XG4gIHZhciByZXMgPSB7fTsgLy8gTm90ZTogd2l0aG91dCBwb2x5ZmlsbCBmb3Igb3duS2V5cywgc3ltYm9scyB3b24ndCBiZSBwaWNrZWQgdXBcblxuICBvd25LZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmVzW2tleV0gPSBnZXREZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTtcbn1cblxudmFyIHN0b3JlZEFubm90YXRpb25zU3ltYm9sID0gLyojX19QVVJFX18qL1N5bWJvbChcIm1vYngtc3RvcmVkLWFubm90YXRpb25zXCIpO1xuLyoqXHJcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjdHMgYXNcclxuICogLSBkZWNvcmF0b3JcclxuICogLSBhbm5vdGF0aW9uIG9iamVjdFxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgc3RvcmVBbm5vdGF0aW9uKHRhcmdldCwgcHJvcGVydHksIGFubm90YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVjb3JhdG9yLCBhbm5vdGF0aW9uKTtcbn1cbi8qKlxyXG4gKiBTdG9yZXMgYW5ub3RhdGlvbiB0byBwcm90b3R5cGUsXHJcbiAqIHNvIGl0IGNhbiBiZSBpbnNwZWN0ZWQgbGF0ZXIgYnkgYG1ha2VPYnNlcnZhYmxlYCBjYWxsZWQgZnJvbSBjb25zdHJ1Y3RvclxyXG4gKi9cblxuZnVuY3Rpb24gc3RvcmVBbm5vdGF0aW9uKHByb3RvdHlwZSwga2V5LCBhbm5vdGF0aW9uKSB7XG4gIGlmICghaGFzUHJvcChwcm90b3R5cGUsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sKSkge1xuICAgIGFkZEhpZGRlblByb3AocHJvdG90eXBlLCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCwgX2V4dGVuZHMoe30sIHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pKTtcbiAgfSAvLyBAb3ZlcnJpZGUgbXVzdCBvdmVycmlkZSBzb21ldGhpbmdcblxuXG4gIGlmICggaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiAhaGFzUHJvcChwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCIucHJvdG90eXBlLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgZGllKFwiJ1wiICsgZmllbGROYW1lICsgXCInIGlzIGRlY29yYXRlZCB3aXRoICdvdmVycmlkZScsIFwiICsgXCJidXQgbm8gc3VjaCBkZWNvcmF0ZWQgbWVtYmVyIHdhcyBmb3VuZCBvbiBwcm90b3R5cGUuXCIpO1xuICB9IC8vIENhbm5vdCByZS1kZWNvcmF0ZVxuXG5cbiAgYXNzZXJ0Tm90RGVjb3JhdGVkKHByb3RvdHlwZSwgYW5ub3RhdGlvbiwga2V5KTsgLy8gSWdub3JlIG92ZXJyaWRlXG5cbiAgaWYgKCFpc092ZXJyaWRlKGFubm90YXRpb24pKSB7XG4gICAgcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXVtrZXldID0gYW5ub3RhdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnROb3REZWNvcmF0ZWQocHJvdG90eXBlLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgaWYgKCAhaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiBoYXNQcm9wKHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0sIGtleSkpIHtcbiAgICB2YXIgZmllbGROYW1lID0gcHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBrZXkudG9TdHJpbmcoKTtcbiAgICB2YXIgY3VycmVudEFubm90YXRpb25UeXBlID0gcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXVtrZXldLmFubm90YXRpb25UeXBlXztcbiAgICB2YXIgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlXztcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ0BcIiArIHJlcXVlc3RlZEFubm90YXRpb25UeXBlICsgXCInIHRvICdcIiArIGZpZWxkTmFtZSArIFwiJzpcIiArIChcIlxcblRoZSBmaWVsZCBpcyBhbHJlYWR5IGRlY29yYXRlZCB3aXRoICdAXCIgKyBjdXJyZW50QW5ub3RhdGlvblR5cGUgKyBcIicuXCIpICsgXCJcXG5SZS1kZWNvcmF0aW5nIGZpZWxkcyBpcyBub3QgYWxsb3dlZC5cIiArIFwiXFxuVXNlICdAb3ZlcnJpZGUnIGRlY29yYXRvciBmb3IgbWV0aG9kcyBvdmVycmlkZW4gYnkgc3ViY2xhc3MuXCIpO1xuICB9XG59XG4vKipcclxuICogQ29sbGVjdHMgYW5ub3RhdGlvbnMgZnJvbSBwcm90b3R5cGVzIGFuZCBzdG9yZXMgdGhlbSBvbiB0YXJnZXQgKGluc3RhbmNlKVxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb2xsZWN0U3RvcmVkQW5ub3RhdGlvbnModGFyZ2V0KSB7XG4gIGlmICghaGFzUHJvcCh0YXJnZXQsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sKSkge1xuICAgIGlmICggIXRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pIHtcbiAgICAgIGRpZShcIk5vIGFubm90YXRpb25zIHdlcmUgcGFzc2VkIHRvIG1ha2VPYnNlcnZhYmxlLCBidXQgbm8gZGVjb3JhdGVkIG1lbWJlcnMgaGF2ZSBiZWVuIGZvdW5kIGVpdGhlclwiKTtcbiAgICB9IC8vIFdlIG5lZWQgYSBjb3B5IGFzIHdlIHdpbGwgcmVtb3ZlIGFubm90YXRpb24gZnJvbSB0aGUgbGlzdCBvbmNlIGl0J3MgYXBwbGllZC5cblxuXG4gICAgYWRkSGlkZGVuUHJvcCh0YXJnZXQsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sLCBfZXh0ZW5kcyh7fSwgdGFyZ2V0W3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF07XG59XG5cbnZhciAkbW9ieCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4IGFkbWluaXN0cmF0aW9uXCIpO1xudmFyIEF0b20gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBmb3IgZWZmZWN0aXZlIHVub2JzZXJ2aW5nLiBCYXNlQXRvbSBoYXMgdHJ1ZSwgZm9yIGV4dHJhIG9wdGltaXphdGlvbiwgc28gaXRzIG9uQmVjb21lVW5vYnNlcnZlZCBuZXZlciBnZXRzIGNhbGxlZCwgYmVjYXVzZSBpdCdzIG5vdCBuZWVkZWRcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgYXRvbS4gRm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBpdCBpcyByZWNvbW1lbmRlZCB0byBnaXZlIGl0IGEgbmFtZS5cclxuICAgKiBUaGUgb25CZWNvbWVPYnNlcnZlZCBhbmQgb25CZWNvbWVVbm9ic2VydmVkIGNhbGxiYWNrcyBjYW4gYmUgdXNlZCBmb3IgcmVzb3VyY2UgbWFuYWdlbWVudC5cclxuICAgKi9cbiAgZnVuY3Rpb24gQXRvbShuYW1lXykge1xuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9ICBcIkF0b21AXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gZmFsc2U7XG4gICAgdGhpcy5pc0JlaW5nT2JzZXJ2ZWRfID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlcnNfID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZGlmZlZhbHVlXyA9IDA7XG4gICAgdGhpcy5sYXN0QWNjZXNzZWRCeV8gPSAwO1xuICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHRoaXMub25CT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkJVT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICB9IC8vIG9uQmVjb21lT2JzZXJ2ZWRMaXN0ZW5lcnNcblxuXG4gIHZhciBfcHJvdG8gPSBBdG9tLnByb3RvdHlwZTtcblxuICBfcHJvdG8ub25CTyA9IGZ1bmN0aW9uIG9uQk8oKSB7XG4gICAgaWYgKHRoaXMub25CT0wpIHtcbiAgICAgIHRoaXMub25CT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uQlVPID0gZnVuY3Rpb24gb25CVU8oKSB7XG4gICAgaWYgKHRoaXMub25CVU9MKSB7XG4gICAgICB0aGlzLm9uQlVPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBJbnZva2UgdGhpcyBtZXRob2QgdG8gbm90aWZ5IG1vYnggdGhhdCB5b3VyIGF0b20gaGFzIGJlZW4gdXNlZCBzb21laG93LlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBjdXJyZW50bHkgYSByZWFjdGl2ZSBjb250ZXh0LlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcG9ydE9ic2VydmVkID0gZnVuY3Rpb24gcmVwb3J0T2JzZXJ2ZWQkMSgpIHtcbiAgICByZXR1cm4gcmVwb3J0T2JzZXJ2ZWQodGhpcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW52b2tlIHRoaXMgbWV0aG9kIF9hZnRlcl8gdGhpcyBtZXRob2QgaGFzIGNoYW5nZWQgdG8gc2lnbmFsIG1vYnggdGhhdCBhbGwgaXRzIG9ic2VydmVycyBzaG91bGQgaW52YWxpZGF0ZS5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBvcnRDaGFuZ2VkID0gZnVuY3Rpb24gcmVwb3J0Q2hhbmdlZCgpIHtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgcHJvcGFnYXRlQ2hhbmdlZCh0aGlzKTtcbiAgICBlbmRCYXRjaCgpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICB9O1xuXG4gIHJldHVybiBBdG9tO1xufSgpO1xudmFyIGlzQXRvbSA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiQXRvbVwiLCBBdG9tKTtcbmZ1bmN0aW9uIGNyZWF0ZUF0b20obmFtZSwgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIsIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIpIHtcbiAgaWYgKG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyID09PSB2b2lkIDApIHtcbiAgICBvbkJlY29tZU9ic2VydmVkSGFuZGxlciA9IG5vb3A7XG4gIH1cblxuICBpZiAob25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciA9PT0gdm9pZCAwKSB7XG4gICAgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciA9IG5vb3A7XG4gIH1cblxuICB2YXIgYXRvbSA9IG5ldyBBdG9tKG5hbWUpOyAvLyBkZWZhdWx0IGBub29wYCBsaXN0ZW5lciB3aWxsIG5vdCBpbml0aWFsaXplIHRoZSBob29rIFNldFxuXG4gIGlmIChvbkJlY29tZU9ic2VydmVkSGFuZGxlciAhPT0gbm9vcCkge1xuICAgIG9uQmVjb21lT2JzZXJ2ZWQoYXRvbSwgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIpO1xuICB9XG5cbiAgaWYgKG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgIT09IG5vb3ApIHtcbiAgICBvbkJlY29tZVVub2JzZXJ2ZWQoYXRvbSwgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlcik7XG4gIH1cblxuICByZXR1cm4gYXRvbTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHlDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5mdW5jdGlvbiBzdHJ1Y3R1cmFsQ29tcGFyZXIoYSwgYikge1xuICByZXR1cm4gZGVlcEVxdWFsKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBzaGFsbG93Q29tcGFyZXIoYSwgYikge1xuICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIDEpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZXIoYSwgYikge1xuICBpZiAoT2JqZWN0LmlzKSByZXR1cm4gT2JqZWN0LmlzKGEsIGIpO1xuICByZXR1cm4gYSA9PT0gYiA/IGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiIDogYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG52YXIgY29tcGFyZXIgPSB7XG4gIGlkZW50aXR5OiBpZGVudGl0eUNvbXBhcmVyLFxuICBzdHJ1Y3R1cmFsOiBzdHJ1Y3R1cmFsQ29tcGFyZXIsXG4gIFwiZGVmYXVsdFwiOiBkZWZhdWx0Q29tcGFyZXIsXG4gIHNoYWxsb3c6IHNoYWxsb3dDb21wYXJlclxufTtcblxuZnVuY3Rpb24gZGVlcEVuaGFuY2VyKHYsIF8sIG5hbWUpIHtcbiAgLy8gaXQgaXMgYW4gb2JzZXJ2YWJsZSBhbHJlYWR5LCBkb25lXG4gIGlmIChpc09ic2VydmFibGUodikpIHJldHVybiB2OyAvLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgY29udmVydGVkIGFuZCBtdXRhdGVkP1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCB7XG4gICAgbmFtZTogbmFtZVxuICB9KTtcbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCB1bmRlZmluZWQsIHtcbiAgICBuYW1lOiBuYW1lXG4gIH0pO1xuICBpZiAoaXNFUzZNYXAodikpIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7XG4gICAgbmFtZTogbmFtZVxuICB9KTtcbiAgaWYgKGlzRVM2U2V0KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwge1xuICAgIG5hbWU6IG5hbWVcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgJiYgIWlzQWN0aW9uKHYpICYmICFpc0Zsb3codikpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IodikpIHtcbiAgICAgIHJldHVybiBmbG93KHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXV0b0FjdGlvbihuYW1lLCB2KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFbmhhbmNlcih2LCBfLCBuYW1lKSB7XG4gIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkgcmV0dXJuIHY7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3QodikgfHwgaXNPYnNlcnZhYmxlQXJyYXkodikgfHwgaXNPYnNlcnZhYmxlTWFwKHYpIHx8IGlzT2JzZXJ2YWJsZVNldCh2KSkgcmV0dXJuIHY7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBkZWVwOiBmYWxzZVxuICB9KTtcbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCB1bmRlZmluZWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGRlZXA6IGZhbHNlXG4gIH0pO1xuICBpZiAoaXNFUzZNYXAodikpIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBkZWVwOiBmYWxzZVxuICB9KTtcbiAgaWYgKGlzRVM2U2V0KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZGVlcDogZmFsc2VcbiAgfSk7XG4gIGRpZShcIlRoZSBzaGFsbG93IG1vZGlmaWVyIC8gZGVjb3JhdG9yIGNhbiBvbmx5IHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBhcnJheXMsIG9iamVjdHMsIG1hcHMgYW5kIHNldHNcIik7XG59XG5mdW5jdGlvbiByZWZlcmVuY2VFbmhhbmNlcihuZXdWYWx1ZSkge1xuICAvLyBuZXZlciB0dXJuIGludG8gYW4gb2JzZXJ2YWJsZVxuICByZXR1cm4gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiByZWZTdHJ1Y3RFbmhhbmNlcih2LCBvbGRWYWx1ZSkge1xuICBpZiAoIGlzT2JzZXJ2YWJsZSh2KSkgZGllKFwib2JzZXJ2YWJsZS5zdHJ1Y3Qgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggb2JzZXJ2YWJsZSB2YWx1ZXNcIik7XG4gIGlmIChkZWVwRXF1YWwodiwgb2xkVmFsdWUpKSByZXR1cm4gb2xkVmFsdWU7XG4gIHJldHVybiB2O1xufVxuXG52YXIgT1ZFUlJJREUgPSBcIm92ZXJyaWRlXCI7XG52YXIgb3ZlcnJpZGUgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbih7XG4gIGFubm90YXRpb25UeXBlXzogT1ZFUlJJREUsXG4gIG1ha2VfOiBtYWtlXyxcbiAgZXh0ZW5kXzogZXh0ZW5kX1xufSk7XG5mdW5jdGlvbiBpc092ZXJyaWRlKGFubm90YXRpb24pIHtcbiAgcmV0dXJuIGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfID09PSBPVkVSUklERTtcbn1cblxuZnVuY3Rpb24gbWFrZV8oYWRtLCBrZXkpIHtcbiAgLy8gTXVzdCBub3QgYmUgcGxhaW4gb2JqZWN0XG4gIGlmICggYWRtLmlzUGxhaW5PYmplY3RfKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyBjYW5ub3QgYmUgdXNlZCBvbiBwbGFpbiBvYmplY3RzLlwiKSk7XG4gIH0gLy8gTXVzdCBvdmVycmlkZSBzb21ldGhpbmdcblxuXG4gIGlmICggIWhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9uc18sIGtleSkpIHtcbiAgICBkaWUoXCInXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInIGlzIGFubm90YXRlZCB3aXRoICdcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInLCBcIiArIFwiYnV0IG5vIHN1Y2ggYW5ub3RhdGVkIG1lbWJlciB3YXMgZm91bmQgb24gcHJvdG90eXBlLlwiKTtcbiAgfVxuXG4gIHJldHVybiAwXG4gIC8qIENhbmNlbCAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICBkaWUoXCInXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIHdpdGggJ21ha2VPYnNlcnZhYmxlJ1wiKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBuYW1lLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQxLFxuICAgIGV4dGVuZF86IGV4dGVuZF8kMVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQxKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfO1xuXG4gIC8vIGJvdW5kXG4gIGlmICgoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18uYm91bmQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwXG4gICAgLyogQ2FuY2VsICovXG4gICAgOiAxXG4gICAgLyogQnJlYWsgKi9cbiAgICA7XG4gIH0gLy8gb3duXG5cblxuICBpZiAoc291cmNlID09PSBhZG0udGFyZ2V0Xykge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDBcbiAgICAvKiBDYW5jZWwgKi9cbiAgICA6IDJcbiAgICAvKiBDb250aW51ZSAqL1xuICAgIDtcbiAgfSAvLyBwcm90b3R5cGVcblxuXG4gIGlmIChpc0FjdGlvbihkZXNjcmlwdG9yLnZhbHVlKSkge1xuICAgIC8vIEEgcHJvdG90eXBlIGNvdWxkIGhhdmUgYmVlbiBhbm5vdGF0ZWQgYWxyZWFkeSBieSBvdGhlciBjb25zdHJ1Y3RvcixcbiAgICAvLyByZXN0IG9mIHRoZSBwcm90byBjaGFpbiBtdXN0IGJlIGFubm90YXRlZCBhbHJlYWR5XG4gICAgcmV0dXJuIDFcbiAgICAvKiBCcmVhayAqL1xuICAgIDtcbiAgfVxuXG4gIHZhciBhY3Rpb25EZXNjcmlwdG9yID0gY3JlYXRlQWN0aW9uRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpO1xuICBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgYWN0aW9uRGVzY3JpcHRvcik7XG4gIHJldHVybiAyXG4gIC8qIENvbnRpbnVlICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQxKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIGFjdGlvbkRlc2NyaXB0b3IgPSBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBhY3Rpb25EZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBY3Rpb25EZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuXG4gIGlmICggIWlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgb24gcHJvcGVydGllcyB3aXRoIGEgZnVuY3Rpb24gdmFsdWUuXCIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yLCAvLyBwcm92aWRlcyBhYmlsaXR5IHRvIGRpc2FibGUgc2FmZURlc2NyaXB0b3JzIGZvciBwcm90b3R5cGVzXG5zYWZlRGVzY3JpcHRvcnMpIHtcbiAgdmFyIF9hbm5vdGF0aW9uJG9wdGlvbnNfLCBfYW5ub3RhdGlvbiRvcHRpb25zXyQsIF9hbm5vdGF0aW9uJG9wdGlvbnNfMiwgX2Fubm90YXRpb24kb3B0aW9uc18kMiwgX2Fubm90YXRpb24kb3B0aW9uc18zO1xuXG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuXG4gIGFzc2VydEFjdGlvbkRlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IpO1xuICB2YXIgdmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlO1xuXG4gIGlmICgoX2Fubm90YXRpb24kb3B0aW9uc18gPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18uYm91bmQpIHtcbiAgICB2YXIgX2FkbSRwcm94eV87XG5cbiAgICB2YWx1ZSA9IHZhbHVlLmJpbmQoKF9hZG0kcHJveHlfID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfIDogYWRtLnRhcmdldF8pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogY3JlYXRlQWN0aW9uKChfYW5ub3RhdGlvbiRvcHRpb25zXyQgPSAoX2Fubm90YXRpb24kb3B0aW9uc18yID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfMi5uYW1lKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kIDoga2V5LnRvU3RyaW5nKCksIHZhbHVlLCAoX2Fubm90YXRpb24kb3B0aW9uc18kMiA9IChfYW5ub3RhdGlvbiRvcHRpb25zXzMgPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18zLmF1dG9BY3Rpb24pICE9IG51bGwgPyBfYW5ub3RhdGlvbiRvcHRpb25zXyQyIDogZmFsc2UpLFxuICAgIC8vIE5vbi1jb25maWd1cmFibGUgZm9yIGNsYXNzZXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsIGZpZWxkIHJlZGVmaW5pdGlvbiBpbiBzdWJjbGFzc1xuICAgIGNvbmZpZ3VyYWJsZTogc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvcHVsbC8yNjQxI2lzc3VlY29tbWVudC03MzcyOTIwNThcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAvLyBOb24tb2JzZXZhYmxlLCB0aGVyZWZvcmUgbm9uLXdyaXRhYmxlXG4gICAgLy8gQWxzbyBwcmV2ZW50cyByZXdyaXRpbmcgaW4gc3ViY2xhc3MgY29uc3RydWN0b3JcbiAgICB3cml0YWJsZTogc2FmZURlc2NyaXB0b3JzID8gZmFsc2UgOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZsb3dBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDIsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQyXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDIoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSkge1xuICB2YXIgX3RoaXMkb3B0aW9uc187XG5cbiAgLy8gb3duXG4gIGlmIChzb3VyY2UgPT09IGFkbS50YXJnZXRfKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAgIC8qIENhbmNlbCAqL1xuICAgIDogMlxuICAgIC8qIENvbnRpbnVlICovXG4gICAgO1xuICB9IC8vIHByb3RvdHlwZVxuICAvLyBib3VuZCAtIG11c3QgYW5ub3RhdGUgcHJvdG9zIHRvIHN1cHBvcnQgc3VwZXIuZmxvdygpXG5cblxuICBpZiAoKChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXy5ib3VuZCkgJiYgIWlzRmxvdyhhZG0udGFyZ2V0X1trZXldKSkge1xuICAgIGlmICh0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCkgcmV0dXJuIDBcbiAgICAvKiBDYW5jZWwgKi9cbiAgICA7XG4gIH1cblxuICBpZiAoaXNGbG93KGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgLy8gQSBwcm90b3R5cGUgY291bGQgaGF2ZSBiZWVuIGFubm90YXRlZCBhbHJlYWR5IGJ5IG90aGVyIGNvbnN0cnVjdG9yLFxuICAgIC8vIHJlc3Qgb2YgdGhlIHByb3RvIGNoYWluIG11c3QgYmUgYW5ub3RhdGVkIGFscmVhZHlcbiAgICByZXR1cm4gMVxuICAgIC8qIEJyZWFrICovXG4gICAgO1xuICB9XG5cbiAgdmFyIGZsb3dEZXNjcmlwdG9yID0gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlLCBmYWxzZSk7XG4gIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBmbG93RGVzY3JpcHRvcik7XG4gIHJldHVybiAyXG4gIC8qIENvbnRpbnVlICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQyKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfMjtcblxuICB2YXIgZmxvd0Rlc2NyaXB0b3IgPSBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvciwgKF90aGlzJG9wdGlvbnNfMiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzIuYm91bmQpO1xuICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIGZsb3dEZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGbG93RGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgX3JlZjIpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcblxuICBpZiAoICFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIHByb3BlcnRpZXMgd2l0aCBhIGdlbmVyYXRvciBmdW5jdGlvbiB2YWx1ZS5cIikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZsb3dEZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yLCBib3VuZCwgLy8gcHJvdmlkZXMgYWJpbGl0eSB0byBkaXNhYmxlIHNhZmVEZXNjcmlwdG9ycyBmb3IgcHJvdG90eXBlc1xuc2FmZURlc2NyaXB0b3JzKSB7XG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuXG4gIGFzc2VydEZsb3dEZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgdmFyIHZhbHVlID0gZGVzY3JpcHRvci52YWx1ZTtcblxuICBpZiAoYm91bmQpIHtcbiAgICB2YXIgX2FkbSRwcm94eV87XG5cbiAgICB2YWx1ZSA9IHZhbHVlLmJpbmQoKF9hZG0kcHJveHlfID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfIDogYWRtLnRhcmdldF8pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogZmxvdyh2YWx1ZSksXG4gICAgLy8gTm9uLWNvbmZpZ3VyYWJsZSBmb3IgY2xhc3Nlc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWwgZmllbGQgcmVkZWZpbml0aW9uIGluIHN1YmNsYXNzXG4gICAgY29uZmlndXJhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9wdWxsLzI2NDEjaXNzdWVjb21tZW50LTczNzI5MjA1OFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIC8vIE5vbi1vYnNldmFibGUsIHRoZXJlZm9yZSBub24td3JpdGFibGVcbiAgICAvLyBBbHNvIHByZXZlbnRzIHJld3JpdGluZyBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgIHdyaXRhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBmYWxzZSA6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDMsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQzXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDMoYWRtLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAvKiBDYW5jZWwgKi9cbiAgOiAxXG4gIC8qIEJyZWFrICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQzKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVDb21wdXRlZFByb3BlcnR5XyhrZXksIF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnNfLCB7XG4gICAgZ2V0OiBkZXNjcmlwdG9yLmdldCxcbiAgICBzZXQ6IGRlc2NyaXB0b3Iuc2V0XG4gIH0pLCBwcm94eVRyYXApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDb21wdXRlZERlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIF9yZWYyKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcbiAgdmFyIGdldCA9IF9yZWYyLmdldDtcblxuICBpZiAoICFnZXQpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBnZXR0ZXIoK3NldHRlcikgcHJvcGVydGllcy5cIikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDQsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDQoYWRtLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAvKiBDYW5jZWwgKi9cbiAgOiAxXG4gIC8qIEJyZWFrICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQ0KGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfJGVuaGFuYywgX3RoaXMkb3B0aW9uc187XG5cbiAgYXNzZXJ0T2JzZXJ2YWJsZURlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IpO1xuICByZXR1cm4gYWRtLmRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8oa2V5LCBkZXNjcmlwdG9yLnZhbHVlLCAoX3RoaXMkb3B0aW9uc18kZW5oYW5jID0gKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfLmVuaGFuY2VyKSAhPSBudWxsID8gX3RoaXMkb3B0aW9uc18kZW5oYW5jIDogZGVlcEVuaGFuY2VyLCBwcm94eVRyYXApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYnNlcnZhYmxlRGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgZGVzY3JpcHRvcikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG5cbiAgaWYgKCAhKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW5ub3QgYmUgdXNlZCBvbiBnZXR0ZXIvc2V0dGVyIHByb3BlcnRpZXNcIikpO1xuICB9XG59XG5cbnZhciBBVVRPID0gXCJ0cnVlXCI7XG52YXIgYXV0b0Fubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQXV0b0Fubm90YXRpb24oKTtcbmZ1bmN0aW9uIGNyZWF0ZUF1dG9Bbm5vdGF0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IEFVVE8sXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDUsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQ1XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDUoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18zLCBfdGhpcyRvcHRpb25zXzQ7XG5cbiAgLy8gZ2V0dGVyIC0+IGNvbXB1dGVkXG4gIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgIHJldHVybiBjb21wdXRlZC5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgfSAvLyBsb25lIHNldHRlciAtPiBhY3Rpb24gc2V0dGVyXG5cblxuICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAvLyBUT0RPIG1ha2UgYWN0aW9uIGFwcGxpY2FibGUgdG8gc2V0dGVyIGFuZCBkZWxlZ2F0ZSB0byBhY3Rpb24ubWFrZV9cbiAgICB2YXIgc2V0ID0gY3JlYXRlQWN0aW9uKGtleS50b1N0cmluZygpLCBkZXNjcmlwdG9yLnNldCk7IC8vIG93blxuXG4gICAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8pIHtcbiAgICAgIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICAgIHNldDogc2V0XG4gICAgICB9KSA9PT0gbnVsbCA/IDBcbiAgICAgIC8qIENhbmNlbCAqL1xuICAgICAgOiAyXG4gICAgICAvKiBDb250aW51ZSAqL1xuICAgICAgO1xuICAgIH0gLy8gcHJvdG9cblxuXG4gICAgZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogc2V0XG4gICAgfSk7XG4gICAgcmV0dXJuIDJcbiAgICAvKiBDb250aW51ZSAqL1xuICAgIDtcbiAgfSAvLyBmdW5jdGlvbiBvbiBwcm90byAtPiBhdXRvQWN0aW9uL2Zsb3dcblxuXG4gIGlmIChzb3VyY2UgIT09IGFkbS50YXJnZXRfICYmIHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgX3RoaXMkb3B0aW9uc18yO1xuXG4gICAgaWYgKGlzR2VuZXJhdG9yKGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9uc187XG5cbiAgICAgIHZhciBmbG93QW5ub3RhdGlvbiA9ICgoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18uYXV0b0JpbmQpID8gZmxvdy5ib3VuZCA6IGZsb3c7XG4gICAgICByZXR1cm4gZmxvd0Fubm90YXRpb24ubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIGFjdGlvbkFubm90YXRpb24gPSAoKF90aGlzJG9wdGlvbnNfMiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzIuYXV0b0JpbmQpID8gYXV0b0FjdGlvbi5ib3VuZCA6IGF1dG9BY3Rpb247XG4gICAgcmV0dXJuIGFjdGlvbkFubm90YXRpb24ubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gIH0gLy8gb3RoZXIgLT4gb2JzZXJ2YWJsZVxuICAvLyBDb3B5IHByb3BzIGZyb20gcHJvdG8gYXMgd2VsbCwgc2VlIHRlc3Q6XG4gIC8vIFwiZGVjb3JhdGUgc2hvdWxkIHdvcmsgd2l0aCBPYmplY3QuY3JlYXRlXCJcblxuXG4gIHZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9ICgoX3RoaXMkb3B0aW9uc18zID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfMy5kZWVwKSA9PT0gZmFsc2UgPyBvYnNlcnZhYmxlLnJlZiA6IG9ic2VydmFibGU7IC8vIGlmIGZ1bmN0aW9uIHJlc3BlY3QgYXV0b0JpbmQgb3B0aW9uXG5cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgKChfdGhpcyRvcHRpb25zXzQgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc180LmF1dG9CaW5kKSkge1xuICAgIHZhciBfYWRtJHByb3h5XztcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlLmJpbmQoKF9hZG0kcHJveHlfID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfIDogYWRtLnRhcmdldF8pO1xuICB9XG5cbiAgcmV0dXJuIG9ic2VydmFibGVBbm5vdGF0aW9uLm1ha2VfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfJDUoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgX3RoaXMkb3B0aW9uc181LCBfdGhpcyRvcHRpb25zXzY7XG5cbiAgLy8gZ2V0dGVyIC0+IGNvbXB1dGVkXG4gIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgIHJldHVybiBjb21wdXRlZC5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xuICB9IC8vIGxvbmUgc2V0dGVyIC0+IGFjdGlvbiBzZXR0ZXJcblxuXG4gIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgIC8vIFRPRE8gbWFrZSBhY3Rpb24gYXBwbGljYWJsZSB0byBzZXR0ZXIgYW5kIGRlbGVnYXRlIHRvIGFjdGlvbi5leHRlbmRfXG4gICAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICBzZXQ6IGNyZWF0ZUFjdGlvbihrZXkudG9TdHJpbmcoKSwgZGVzY3JpcHRvci5zZXQpXG4gICAgfSwgcHJveHlUcmFwKTtcbiAgfSAvLyBvdGhlciAtPiBvYnNlcnZhYmxlXG4gIC8vIGlmIGZ1bmN0aW9uIHJlc3BlY3QgYXV0b0JpbmQgb3B0aW9uXG5cblxuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiAoKF90aGlzJG9wdGlvbnNfNSA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzUuYXV0b0JpbmQpKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfMjtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlLmJpbmQoKF9hZG0kcHJveHlfMiA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XzIgOiBhZG0udGFyZ2V0Xyk7XG4gIH1cblxuICB2YXIgb2JzZXJ2YWJsZUFubm90YXRpb24gPSAoKF90aGlzJG9wdGlvbnNfNiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzYuZGVlcCkgPT09IGZhbHNlID8gb2JzZXJ2YWJsZS5yZWYgOiBvYnNlcnZhYmxlO1xuICByZXR1cm4gb2JzZXJ2YWJsZUFubm90YXRpb24uZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbn1cblxudmFyIE9CU0VSVkFCTEUgPSBcIm9ic2VydmFibGVcIjtcbnZhciBPQlNFUlZBQkxFX1JFRiA9IFwib2JzZXJ2YWJsZS5yZWZcIjtcbnZhciBPQlNFUlZBQkxFX1NIQUxMT1cgPSBcIm9ic2VydmFibGUuc2hhbGxvd1wiO1xudmFyIE9CU0VSVkFCTEVfU1RSVUNUID0gXCJvYnNlcnZhYmxlLnN0cnVjdFwiOyAvLyBQcmVkZWZpbmVkIGJhZ3Mgb2YgY3JlYXRlIG9ic2VydmFibGUgb3B0aW9ucywgdG8gYXZvaWQgYWxsb2NhdGluZyB0ZW1wb3JhcmlseSBvcHRpb24gb2JqZWN0c1xuLy8gaW4gdGhlIG1ham9yaXR5IG9mIGNhc2VzXG5cbnZhciBkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMgPSB7XG4gIGRlZXA6IHRydWUsXG4gIG5hbWU6IHVuZGVmaW5lZCxcbiAgZGVmYXVsdERlY29yYXRvcjogdW5kZWZpbmVkLFxuICBwcm94eTogdHJ1ZVxufTtcbk9iamVjdC5mcmVlemUoZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zKTtcbmZ1bmN0aW9uIGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnModGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nIHx8IGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucztcbn1cbnZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFKTtcbnZhciBvYnNlcnZhYmxlUmVmQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFX1JFRiwge1xuICBlbmhhbmNlcjogcmVmZXJlbmNlRW5oYW5jZXJcbn0pO1xudmFyIG9ic2VydmFibGVTaGFsbG93QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFX1NIQUxMT1csIHtcbiAgZW5oYW5jZXI6IHNoYWxsb3dFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZVN0cnVjdEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9TVFJVQ1QsIHtcbiAgZW5oYW5jZXI6IHJlZlN0cnVjdEVuaGFuY2VyXG59KTtcbnZhciBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVBbm5vdGF0aW9uKTtcbmZ1bmN0aW9uIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kZWVwID09PSB0cnVlID8gZGVlcEVuaGFuY2VyIDogb3B0aW9ucy5kZWVwID09PSBmYWxzZSA/IHJlZmVyZW5jZUVuaGFuY2VyIDogZ2V0RW5oYW5jZXJGcm9tQW5ub3RhdGlvbihvcHRpb25zLmRlZmF1bHREZWNvcmF0b3IpO1xufVxuZnVuY3Rpb24gZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGRlZmF1bHREZWNvcjtcblxuICByZXR1cm4gb3B0aW9ucyA/IChfb3B0aW9ucyRkZWZhdWx0RGVjb3IgPSBvcHRpb25zLmRlZmF1bHREZWNvcmF0b3IpICE9IG51bGwgPyBfb3B0aW9ucyRkZWZhdWx0RGVjb3IgOiBjcmVhdGVBdXRvQW5ub3RhdGlvbihvcHRpb25zKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEVuaGFuY2VyRnJvbUFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICB2YXIgX2Fubm90YXRpb24kb3B0aW9uc18kLCBfYW5ub3RhdGlvbiRvcHRpb25zXztcblxuICByZXR1cm4gIWFubm90YXRpb24gPyBkZWVwRW5oYW5jZXIgOiAoX2Fubm90YXRpb24kb3B0aW9uc18kID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfLmVuaGFuY2VyKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kIDogZGVlcEVuaGFuY2VyO1xufVxuLyoqXHJcbiAqIFR1cm5zIGFuIG9iamVjdCwgYXJyYXkgb3IgZnVuY3Rpb24gaW50byBhIHJlYWN0aXZlIHN0cnVjdHVyZS5cclxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHdoaWNoIHNob3VsZCBiZWNvbWUgb2JzZXJ2YWJsZS5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGUodiwgYXJnMiwgYXJnMykge1xuICAvLyBAb2JzZXJ2YWJsZSBzb21lUHJvcDtcbiAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgc3RvcmVBbm5vdGF0aW9uKHYsIGFyZzIsIG9ic2VydmFibGVBbm5vdGF0aW9uKTtcbiAgICByZXR1cm47XG4gIH0gLy8gYWxyZWFkeSBvYnNlcnZhYmxlIC0gaWdub3JlXG5cblxuICBpZiAoaXNPYnNlcnZhYmxlKHYpKSByZXR1cm4gdjsgLy8gcGxhaW4gb2JqZWN0XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCBhcmcyLCBhcmczKTsgLy8gQXJyYXlcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwgYXJnMik7IC8vIE1hcFxuXG4gIGlmIChpc0VTNk1hcCh2KSkgcmV0dXJuIG9ic2VydmFibGUubWFwKHYsIGFyZzIpOyAvLyBTZXRcblxuICBpZiAoaXNFUzZTZXQodikpIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCBhcmcyKTsgLy8gb3RoZXIgb2JqZWN0IC0gaWdub3JlXG5cbiAgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwpIHJldHVybiB2OyAvLyBhbnl0aGluZyBlbHNlXG5cbiAgcmV0dXJuIG9ic2VydmFibGUuYm94KHYsIGFyZzIpO1xufVxuXG5PYmplY3QuYXNzaWduKGNyZWF0ZU9ic2VydmFibGUsIG9ic2VydmFibGVEZWNvcmF0b3JBbm5vdGF0aW9uKTtcbnZhciBvYnNlcnZhYmxlRmFjdG9yaWVzID0ge1xuICBib3g6IGZ1bmN0aW9uIGJveCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lLCB0cnVlLCBvLmVxdWFscyk7XG4gIH0sXG4gIGFycmF5OiBmdW5jdGlvbiBhcnJheShpbml0aWFsVmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiAoZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9PT0gZmFsc2UgfHwgby5wcm94eSA9PT0gZmFsc2UgPyBjcmVhdGVMZWdhY3lBcnJheSA6IGNyZWF0ZU9ic2VydmFibGVBcnJheSkoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVNYXAoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTZXQoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QocHJvcHMsIGRlY29yYXRvcnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JzZXJ2YWJsZShnbG9iYWxTdGF0ZS51c2VQcm94aWVzID09PSBmYWxzZSB8fCAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcm94eSkgPT09IGZhbHNlID8gYXNPYnNlcnZhYmxlT2JqZWN0KHt9LCBvcHRpb25zKSA6IGFzRHluYW1pY09ic2VydmFibGVPYmplY3Qoe30sIG9wdGlvbnMpLCBwcm9wcywgZGVjb3JhdG9ycyk7XG4gIH0sXG4gIHJlZjogLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZVJlZkFubm90YXRpb24pLFxuICBzaGFsbG93OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU2hhbGxvd0Fubm90YXRpb24pLFxuICBkZWVwOiBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbixcbiAgc3RydWN0OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU3RydWN0QW5ub3RhdGlvbilcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG52YXIgb2JzZXJ2YWJsZSA9IC8qI19fUFVSRV9fKi9hc3NpZ24oY3JlYXRlT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZUZhY3Rvcmllcyk7XG5cbnZhciBDT01QVVRFRCA9IFwiY29tcHV0ZWRcIjtcbnZhciBDT01QVVRFRF9TVFJVQ1QgPSBcImNvbXB1dGVkLnN0cnVjdFwiO1xudmFyIGNvbXB1dGVkQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURUQpO1xudmFyIGNvbXB1dGVkU3RydWN0QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURURfU1RSVUNULCB7XG4gIGVxdWFsczogY29tcGFyZXIuc3RydWN0dXJhbFxufSk7XG4vKipcclxuICogRGVjb3JhdG9yIGZvciBjbGFzcyBwcm9wZXJ0aWVzOiBAY29tcHV0ZWQgZ2V0IHZhbHVlKCkgeyByZXR1cm4gZXhwcjsgfS5cclxuICogRm9yIGxlZ2FjeSBwdXJwb3NlcyBhbHNvIGludm9rYWJsZSBhcyBFUzUgb2JzZXJ2YWJsZSBjcmVhdGVkOiBgY29tcHV0ZWQoKCkgPT4gZXhwcilgO1xyXG4gKi9cblxudmFyIGNvbXB1dGVkID0gZnVuY3Rpb24gY29tcHV0ZWQoYXJnMSwgYXJnMikge1xuICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICAvLyBAY29tcHV0ZWRcbiAgICByZXR1cm4gc3RvcmVBbm5vdGF0aW9uKGFyZzEsIGFyZzIsIGNvbXB1dGVkQW5ub3RhdGlvbik7XG4gIH1cblxuICBpZiAoaXNQbGFpbk9iamVjdChhcmcxKSkge1xuICAgIC8vIEBjb21wdXRlZCh7IG9wdGlvbnMgfSlcbiAgICByZXR1cm4gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihjcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURUQsIGFyZzEpKTtcbiAgfSAvLyBjb21wdXRlZChleHByLCBvcHRpb25zPylcblxuXG4gIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oYXJnMSkpIGRpZShcIkZpcnN0IGFyZ3VtZW50IHRvIGBjb21wdXRlZGAgc2hvdWxkIGJlIGFuIGV4cHJlc3Npb24uXCIpO1xuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSBkaWUoXCJBIHNldHRlciBhcyBzZWNvbmQgYXJndW1lbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgdXNlIGB7IHNldDogZm4gfWAgb3B0aW9uIGluc3RlYWRcIik7XG4gIH1cblxuICB2YXIgb3B0cyA9IGlzUGxhaW5PYmplY3QoYXJnMikgPyBhcmcyIDoge307XG4gIG9wdHMuZ2V0ID0gYXJnMTtcbiAgb3B0cy5uYW1lIHx8IChvcHRzLm5hbWUgPSBhcmcxLm5hbWUgfHwgXCJcIik7XG4gIC8qIGZvciBnZW5lcmF0ZWQgbmFtZSAqL1xuXG4gIHJldHVybiBuZXcgQ29tcHV0ZWRWYWx1ZShvcHRzKTtcbn07XG5PYmplY3QuYXNzaWduKGNvbXB1dGVkLCBjb21wdXRlZEFubm90YXRpb24pO1xuY29tcHV0ZWQuc3RydWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oY29tcHV0ZWRTdHJ1Y3RBbm5vdGF0aW9uKTtcblxudmFyIF9nZXREZXNjcmlwdG9yJGNvbmZpZywgX2dldERlc2NyaXB0b3I7XG4vLyBtb2J4IHZlcnNpb25zXG5cbnZhciBjdXJyZW50QWN0aW9uSWQgPSAwO1xudmFyIG5leHRBY3Rpb25JZCA9IDE7XG52YXIgaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUgPSAoX2dldERlc2NyaXB0b3IkY29uZmlnID0gKF9nZXREZXNjcmlwdG9yID0gLyojX19QVVJFX18qL2dldERlc2NyaXB0b3IoZnVuY3Rpb24gKCkge30sIFwibmFtZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXREZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkgIT0gbnVsbCA/IF9nZXREZXNjcmlwdG9yJGNvbmZpZyA6IGZhbHNlOyAvLyB3ZSBjYW4gc2FmZWx5IHJlY3ljbGUgdGhpcyBvYmplY3RcblxudmFyIHRtcE5hbWVEZXNjcmlwdG9yID0ge1xuICB2YWx1ZTogXCJhY3Rpb25cIixcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlXG59O1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKGFjdGlvbk5hbWUsIGZuLCBhdXRvQWN0aW9uLCByZWYpIHtcbiAgaWYgKGF1dG9BY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIGF1dG9BY3Rpb24gPSBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSBkaWUoXCJgYWN0aW9uYCBjYW4gb25seSBiZSBpbnZva2VkIG9uIGZ1bmN0aW9uc1wiKTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbk5hbWUgIT09IFwic3RyaW5nXCIgfHwgIWFjdGlvbk5hbWUpIGRpZShcImFjdGlvbnMgc2hvdWxkIGhhdmUgdmFsaWQgbmFtZXMsIGdvdDogJ1wiICsgYWN0aW9uTmFtZSArIFwiJ1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcygpIHtcbiAgICByZXR1cm4gZXhlY3V0ZUFjdGlvbihhY3Rpb25OYW1lLCBhdXRvQWN0aW9uLCBmbiwgcmVmIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXMuaXNNb2J4QWN0aW9uID0gdHJ1ZTtcblxuICBpZiAoaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUpIHtcbiAgICB0bXBOYW1lRGVzY3JpcHRvci52YWx1ZSA9IGFjdGlvbk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcywgXCJuYW1lXCIsIHRtcE5hbWVEZXNjcmlwdG9yKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGNhblJ1bkFzRGVyaXZhdGlvbiwgZm4sIHNjb3BlLCBhcmdzKSB7XG4gIHZhciBydW5JbmZvID0gX3N0YXJ0QWN0aW9uKGFjdGlvbk5hbWUsIGNhblJ1bkFzRGVyaXZhdGlvbiwgc2NvcGUsIGFyZ3MpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlLCBhcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcnVuSW5mby5lcnJvcl8gPSBlcnI7XG4gICAgdGhyb3cgZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIF9lbmRBY3Rpb24ocnVuSW5mbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9zdGFydEFjdGlvbihhY3Rpb25OYW1lLCBjYW5SdW5Bc0Rlcml2YXRpb24sIC8vIHRydWUgZm9yIGF1dG9BY3Rpb25cbnNjb3BlLCBhcmdzKSB7XG4gIHZhciBub3RpZnlTcHlfID0gIGlzU3B5RW5hYmxlZCgpICYmICEhYWN0aW9uTmFtZTtcbiAgdmFyIHN0YXJ0VGltZV8gPSAwO1xuXG4gIGlmICggbm90aWZ5U3B5Xykge1xuICAgIHN0YXJ0VGltZV8gPSBEYXRlLm5vdygpO1xuICAgIHZhciBmbGF0dGVuZWRBcmdzID0gYXJncyA/IEFycmF5LmZyb20oYXJncykgOiBFTVBUWV9BUlJBWTtcbiAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICB0eXBlOiBBQ1RJT04sXG4gICAgICBuYW1lOiBhY3Rpb25OYW1lLFxuICAgICAgb2JqZWN0OiBzY29wZSxcbiAgICAgIGFyZ3VtZW50czogZmxhdHRlbmVkQXJnc1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHByZXZEZXJpdmF0aW9uXyA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgdmFyIHJ1bkFzQWN0aW9uID0gIWNhblJ1bkFzRGVyaXZhdGlvbiB8fCAhcHJldkRlcml2YXRpb25fO1xuICBzdGFydEJhdGNoKCk7XG4gIHZhciBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfID0gZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXM7IC8vIGJ5IGRlZmF1bHQgcHJlc2VydmUgcHJldmlvdXMgYWxsb3dcblxuICBpZiAocnVuQXNBY3Rpb24pIHtcbiAgICB1bnRyYWNrZWRTdGFydCgpO1xuICAgIHByZXZBbGxvd1N0YXRlQ2hhbmdlc18gPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpO1xuICB9XG5cbiAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHNfID0gYWxsb3dTdGF0ZVJlYWRzU3RhcnQodHJ1ZSk7XG4gIHZhciBydW5JbmZvID0ge1xuICAgIHJ1bkFzQWN0aW9uXzogcnVuQXNBY3Rpb24sXG4gICAgcHJldkRlcml2YXRpb25fOiBwcmV2RGVyaXZhdGlvbl8sXG4gICAgcHJldkFsbG93U3RhdGVDaGFuZ2VzXzogcHJldkFsbG93U3RhdGVDaGFuZ2VzXyxcbiAgICBwcmV2QWxsb3dTdGF0ZVJlYWRzXzogcHJldkFsbG93U3RhdGVSZWFkc18sXG4gICAgbm90aWZ5U3B5Xzogbm90aWZ5U3B5XyxcbiAgICBzdGFydFRpbWVfOiBzdGFydFRpbWVfLFxuICAgIGFjdGlvbklkXzogbmV4dEFjdGlvbklkKyssXG4gICAgcGFyZW50QWN0aW9uSWRfOiBjdXJyZW50QWN0aW9uSWRcbiAgfTtcbiAgY3VycmVudEFjdGlvbklkID0gcnVuSW5mby5hY3Rpb25JZF87XG4gIHJldHVybiBydW5JbmZvO1xufVxuZnVuY3Rpb24gX2VuZEFjdGlvbihydW5JbmZvKSB7XG4gIGlmIChjdXJyZW50QWN0aW9uSWQgIT09IHJ1bkluZm8uYWN0aW9uSWRfKSB7XG4gICAgZGllKDMwKTtcbiAgfVxuXG4gIGN1cnJlbnRBY3Rpb25JZCA9IHJ1bkluZm8ucGFyZW50QWN0aW9uSWRfO1xuXG4gIGlmIChydW5JbmZvLmVycm9yXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IHRydWU7XG4gIH1cblxuICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChydW5JbmZvLnByZXZBbGxvd1N0YXRlQ2hhbmdlc18pO1xuICBhbGxvd1N0YXRlUmVhZHNFbmQocnVuSW5mby5wcmV2QWxsb3dTdGF0ZVJlYWRzXyk7XG4gIGVuZEJhdGNoKCk7XG4gIGlmIChydW5JbmZvLnJ1bkFzQWN0aW9uXykgdW50cmFja2VkRW5kKHJ1bkluZm8ucHJldkRlcml2YXRpb25fKTtcblxuICBpZiAoIHJ1bkluZm8ubm90aWZ5U3B5Xykge1xuICAgIHNweVJlcG9ydEVuZCh7XG4gICAgICB0aW1lOiBEYXRlLm5vdygpIC0gcnVuSW5mby5zdGFydFRpbWVfXG4gICAgfSk7XG4gIH1cblxuICBnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gZmFsc2U7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlcyhhbGxvd1N0YXRlQ2hhbmdlcywgZnVuYykge1xuICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoYWxsb3dTdGF0ZUNoYW5nZXMpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChhbGxvd1N0YXRlQ2hhbmdlcykge1xuICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzO1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IGFsbG93U3RhdGVDaGFuZ2VzO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBwcmV2O1xufVxuXG52YXIgX1N5bWJvbCR0b1ByaW1pdGl2ZTtcbnZhciBDUkVBVEUgPSBcImNyZWF0ZVwiO1xuX1N5bWJvbCR0b1ByaW1pdGl2ZSA9IFN5bWJvbC50b1ByaW1pdGl2ZTtcbnZhciBPYnNlcnZhYmxlVmFsdWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdG9tKSB7XG4gIF9pbmhlcml0c0xvb3NlKE9ic2VydmFibGVWYWx1ZSwgX0F0b20pO1xuXG4gIGZ1bmN0aW9uIE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZW5oYW5jZXIsIG5hbWVfLCBub3RpZnlTcHksIGVxdWFscykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9ICBcIk9ic2VydmFibGVWYWx1ZUBcIiArIGdldE5leHRJZCgpIDtcbiAgICB9XG5cbiAgICBpZiAobm90aWZ5U3B5ID09PSB2b2lkIDApIHtcbiAgICAgIG5vdGlmeVNweSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVxdWFscyA9PT0gdm9pZCAwKSB7XG4gICAgICBlcXVhbHMgPSBjb21wYXJlcltcImRlZmF1bHRcIl07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQXRvbS5jYWxsKHRoaXMsIG5hbWVfKSB8fCB0aGlzO1xuICAgIF90aGlzLmVuaGFuY2VyID0gdm9pZCAwO1xuICAgIF90aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIF90aGlzLmVxdWFscyA9IHZvaWQgMDtcbiAgICBfdGhpcy5oYXNVbnJlcG9ydGVkQ2hhbmdlXyA9IGZhbHNlO1xuICAgIF90aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgX3RoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICBfdGhpcy52YWx1ZV8gPSB2b2lkIDA7XG4gICAgX3RoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuZW5oYW5jZXIgPSBlbmhhbmNlcjtcbiAgICBfdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIF90aGlzLmVxdWFscyA9IGVxdWFscztcbiAgICBfdGhpcy52YWx1ZV8gPSBlbmhhbmNlcih2YWx1ZSwgdW5kZWZpbmVkLCBuYW1lXyk7XG5cbiAgICBpZiAoIG5vdGlmeVNweSAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgLy8gb25seSBub3RpZnkgc3B5IGlmIHRoaXMgaXMgYSBzdGFuZC1hbG9uZSBvYnNlcnZhYmxlXG4gICAgICBzcHlSZXBvcnQoe1xuICAgICAgICB0eXBlOiBDUkVBVEUsXG4gICAgICAgIG9iamVjdDogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgIG5ld1ZhbHVlOiBcIlwiICsgX3RoaXMudmFsdWVfXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVoYW5jZVZhbHVlID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgbmV3VmFsdWUgPSB0aGlzLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpO1xuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcblxuICAgICAgaWYgKCBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwidmFsdWVcIixcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucHJlcGFyZU5ld1ZhbHVlXyA9IGZ1bmN0aW9uIHByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpIHtcbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzKTtcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEO1xuICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfSAvLyBhcHBseSBtb2RpZmllclxuXG5cbiAgICBuZXdWYWx1ZSA9IHRoaXMuZW5oYW5jZXIobmV3VmFsdWUsIHRoaXMudmFsdWVfLCB0aGlzLm5hbWVfKTtcbiAgICByZXR1cm4gdGhpcy5lcXVhbHModGhpcy52YWx1ZV8sIG5ld1ZhbHVlKSA/IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCA6IG5ld1ZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5zZXROZXdWYWx1ZV8gPSBmdW5jdGlvbiBzZXROZXdWYWx1ZV8obmV3VmFsdWUpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICB0aGlzLnZhbHVlXyA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucmVwb3J0Q2hhbmdlZCgpO1xuXG4gICAgaWYgKGhhc0xpc3RlbmVycyh0aGlzKSkge1xuICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIHtcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB0aGlzLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlKHRoaXMudmFsdWVfKTtcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5KSBsaXN0ZW5lcih7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJ2YWx1ZVwiLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgbmV3VmFsdWU6IHRoaXMudmFsdWVfLFxuICAgICAgb2xkVmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KCkge1xuICAgIC8vIHVzZWQgYnkgTVNUIG90IGdldCB1bmRlaGFuY2VkIHZhbHVlXG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV8gKyBcIltcIiArIHRoaXMudmFsdWVfICsgXCJdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0b1ByaW1pdGl2ZSh0aGlzLmdldCgpKTtcbiAgfTtcblxuICBfcHJvdG9bX1N5bWJvbCR0b1ByaW1pdGl2ZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlVmFsdWU7XG59KEF0b20pO1xudmFyIGlzT2JzZXJ2YWJsZVZhbHVlID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlVmFsdWVcIiwgT2JzZXJ2YWJsZVZhbHVlKTtcblxudmFyIF9TeW1ib2wkdG9QcmltaXRpdmUkMTtcbi8qKlxyXG4gKiBBIG5vZGUgaW4gdGhlIHN0YXRlIGRlcGVuZGVuY3kgcm9vdCB0aGF0IG9ic2VydmVzIG90aGVyIG5vZGVzLCBhbmQgY2FuIGJlIG9ic2VydmVkIGl0c2VsZi5cclxuICpcclxuICogQ29tcHV0ZWRWYWx1ZSB3aWxsIHJlbWVtYmVyIHRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGJhdGNoLCBvclxyXG4gKiB3aGlsZSBiZWluZyBvYnNlcnZlZC5cclxuICpcclxuICogRHVyaW5nIHRoaXMgdGltZSBpdCB3aWxsIHJlY29tcHV0ZSBvbmx5IHdoZW4gb25lIG9mIGl0cyBkaXJlY3QgZGVwZW5kZW5jaWVzIGNoYW5nZWQsXHJcbiAqIGJ1dCBvbmx5IHdoZW4gaXQgaXMgYmVpbmcgYWNjZXNzZWQgd2l0aCBgQ29tcHV0ZWRWYWx1ZS5nZXQoKWAuXHJcbiAqXHJcbiAqIEltcGxlbWVudGF0aW9uIGRlc2NyaXB0aW9uOlxyXG4gKiAxLiBGaXJzdCB0aW1lIGl0J3MgYmVpbmcgYWNjZXNzZWQgaXQgd2lsbCBjb21wdXRlIGFuZCByZW1lbWJlciByZXN1bHRcclxuICogICAgZ2l2ZSBiYWNrIHJlbWVtYmVyZWQgcmVzdWx0IHVudGlsIDIuIGhhcHBlbnNcclxuICogMi4gRmlyc3QgdGltZSBhbnkgZGVlcCBkZXBlbmRlbmN5IGNoYW5nZSwgcHJvcGFnYXRlIFBPU1NJQkxZX1NUQUxFIHRvIGFsbCBvYnNlcnZlcnMsIHdhaXQgZm9yIDMuXHJcbiAqIDMuIFdoZW4gaXQncyBiZWluZyBhY2Nlc3NlZCwgcmVjb21wdXRlIGlmIGFueSBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZC5cclxuICogICAgaWYgcmVzdWx0IGNoYW5nZWQ6IHByb3BhZ2F0ZSBTVEFMRSB0byBhbGwgb2JzZXJ2ZXJzLCB0aGF0IHdlcmUgUE9TU0lCTFlfU1RBTEUgZnJvbSB0aGUgbGFzdCBzdGVwLlxyXG4gKiAgICBnbyB0byBzdGVwIDIuIGVpdGhlciB3YXlcclxuICpcclxuICogSWYgYXQgYW55IHBvaW50IGl0J3Mgb3V0c2lkZSBiYXRjaCBhbmQgaXQgaXNuJ3Qgb2JzZXJ2ZWQ6IHJlc2V0IGV2ZXJ5dGhpbmcgYW5kIGdvIHRvIDEuXHJcbiAqL1xuXG5fU3ltYm9sJHRvUHJpbWl0aXZlJDEgPSBTeW1ib2wudG9QcmltaXRpdmU7XG52YXIgQ29tcHV0ZWRWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIG5vZGVzIHdlIGFyZSBsb29raW5nIGF0LiBPdXIgdmFsdWUgZGVwZW5kcyBvbiB0aGVzZSBub2Rlc1xuICAvLyBkdXJpbmcgdHJhY2tpbmcgaXQncyBhbiBhcnJheSB3aXRoIG5ldyBvYnNlcnZlZCBvYnNlcnZlcnNcbiAgLy8gdG8gY2hlY2sgZm9yIGN5Y2xlc1xuICAvLyBOLkI6IHVubWluaWZpZWQgYXMgaXQgaXMgdXNlZCBieSBNU1RcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgY29tcHV0ZWQgdmFsdWUgYmFzZWQgb24gYSBmdW5jdGlvbiBleHByZXNzaW9uLlxyXG4gICAqXHJcbiAgICogVGhlIGBuYW1lYCBwcm9wZXJ0eSBpcyBmb3IgZGVidWcgcHVycG9zZXMgb25seS5cclxuICAgKlxyXG4gICAqIFRoZSBgZXF1YWxzYCBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIHVzZSB0byBkZXRlcm1pbmUgaWYgYSBuZXdseSBwcm9kdWNlZFxyXG4gICAqIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgcHJldmlvdXMgdmFsdWUuIFR3byBjb21wYXJlcnMgYXJlIHByb3ZpZGVkIGluIHRoZSBsaWJyYXJ5OyBgZGVmYXVsdENvbXBhcmVyYFxyXG4gICAqIGNvbXBhcmVzIGJhc2VkIG9uIGlkZW50aXR5IGNvbXBhcmlzb24gKD09PSksIGFuZCBgc3RydWN0dXJhbENvbXBhcmVyYCBkZWVwbHkgY29tcGFyZXMgdGhlIHN0cnVjdHVyZS5cclxuICAgKiBTdHJ1Y3R1cmFsIGNvbXBhcmlzb24gY2FuIGJlIGNvbnZlbmllbnQgaWYgeW91IGFsd2F5cyBwcm9kdWNlIGEgbmV3IGFnZ3JlZ2F0ZWQgb2JqZWN0IGFuZFxyXG4gICAqIGRvbid0IHdhbnQgdG8gbm90aWZ5IG9ic2VydmVycyBpZiBpdCBpcyBzdHJ1Y3R1cmFsbHkgdGhlIHNhbWUuXHJcbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIHdvcmtpbmcgd2l0aCB2ZWN0b3JzLCBtb3VzZSBjb29yZGluYXRlcyBldGMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIENvbXB1dGVkVmFsdWUob3B0aW9ucykge1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLm9ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLm5ld09ic2VydmluZ18gPSBudWxsO1xuICAgIHRoaXMuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbl8gPSBmYWxzZTtcbiAgICB0aGlzLm9ic2VydmVyc18gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5kaWZmVmFsdWVfID0gMDtcbiAgICB0aGlzLnJ1bklkXyA9IDA7XG4gICAgdGhpcy5sYXN0QWNjZXNzZWRCeV8gPSAwO1xuICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgICB0aGlzLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgICB0aGlzLnZhbHVlXyA9IG5ldyBDYXVnaHRFeGNlcHRpb24obnVsbCk7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyaWdnZXJlZEJ5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyXyA9IGZhbHNlO1xuICAgIHRoaXMuZGVyaXZhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1RyYWNpbmdfID0gVHJhY2VNb2RlLk5PTkU7XG4gICAgdGhpcy5zY29wZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lcXVhbHNfID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWlyZXNSZWFjdGlvbl8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZWVwQWxpdmVfID0gdm9pZCAwO1xuICAgIHRoaXMub25CT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkJVT0wgPSB2b2lkIDA7XG4gICAgaWYgKCFvcHRpb25zLmdldCkgZGllKDMxKTtcbiAgICB0aGlzLmRlcml2YXRpb24gPSBvcHRpb25zLmdldDtcbiAgICB0aGlzLm5hbWVfID0gb3B0aW9ucy5uYW1lIHx8ICggXCJDb21wdXRlZFZhbHVlQFwiICsgZ2V0TmV4dElkKCkgKTtcblxuICAgIGlmIChvcHRpb25zLnNldCkge1xuICAgICAgdGhpcy5zZXR0ZXJfID0gY3JlYXRlQWN0aW9uKCB0aGlzLm5hbWVfICsgXCItc2V0dGVyXCIgLCBvcHRpb25zLnNldCk7XG4gICAgfVxuXG4gICAgdGhpcy5lcXVhbHNfID0gb3B0aW9ucy5lcXVhbHMgfHwgKG9wdGlvbnMuY29tcGFyZVN0cnVjdHVyYWwgfHwgb3B0aW9ucy5zdHJ1Y3QgPyBjb21wYXJlci5zdHJ1Y3R1cmFsIDogY29tcGFyZXJbXCJkZWZhdWx0XCJdKTtcbiAgICB0aGlzLnNjb3BlXyA9IG9wdGlvbnMuY29udGV4dDtcbiAgICB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fID0gISFvcHRpb25zLnJlcXVpcmVzUmVhY3Rpb247XG4gICAgdGhpcy5rZWVwQWxpdmVfID0gISFvcHRpb25zLmtlZXBBbGl2ZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb21wdXRlZFZhbHVlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ub25CZWNvbWVTdGFsZV8gPSBmdW5jdGlvbiBvbkJlY29tZVN0YWxlXygpIHtcbiAgICBwcm9wYWdhdGVNYXliZUNoYW5nZWQodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQk8gPSBmdW5jdGlvbiBvbkJPKCkge1xuICAgIGlmICh0aGlzLm9uQk9MKSB7XG4gICAgICB0aGlzLm9uQk9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJVTyA9IGZ1bmN0aW9uIG9uQlVPKCkge1xuICAgIGlmICh0aGlzLm9uQlVPTCkge1xuICAgICAgdGhpcy5vbkJVT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGlzIGNvbXB1dGVkIHZhbHVlLlxyXG4gICAqIFdpbGwgZXZhbHVhdGUgaXRzIGNvbXB1dGF0aW9uIGZpcnN0IGlmIG5lZWRlZC5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuaXNDb21wdXRpbmdfKSBkaWUoMzIsIHRoaXMubmFtZV8sIHRoaXMuZGVyaXZhdGlvbik7XG5cbiAgICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA9PT0gMCAmJiAvLyAhZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0cGlvbiAmJlxuICAgIHRoaXMub2JzZXJ2ZXJzXy5zaXplID09PSAwICYmICF0aGlzLmtlZXBBbGl2ZV8pIHtcbiAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgIHRoaXMud2FybkFib3V0VW50cmFja2VkUmVhZF8oKTtcbiAgICAgICAgc3RhcnRCYXRjaCgpOyAvLyBTZWUgcGVyZiB0ZXN0ICdjb21wdXRlZCBtZW1vaXphdGlvbidcblxuICAgICAgICB0aGlzLnZhbHVlXyA9IHRoaXMuY29tcHV0ZVZhbHVlXyhmYWxzZSk7XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcG9ydE9ic2VydmVkKHRoaXMpO1xuXG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZSh0aGlzKSkge1xuICAgICAgICB2YXIgcHJldlRyYWNraW5nQ29udGV4dCA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDtcbiAgICAgICAgaWYgKHRoaXMua2VlcEFsaXZlXyAmJiAhcHJldlRyYWNraW5nQ29udGV4dCkgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudHJhY2tBbmRDb21wdXRlKCkpIHByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZCh0aGlzKTtcbiAgICAgICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gcHJldlRyYWNraW5nQ29udGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy52YWx1ZV87XG4gICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpIHRocm93IHJlc3VsdC5jYXVzZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zZXR0ZXJfKSB7XG4gICAgICBpZiAodGhpcy5pc1J1bm5pbmdTZXR0ZXJfKSBkaWUoMzMsIHRoaXMubmFtZV8pO1xuICAgICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXJfID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR0ZXJfLmNhbGwodGhpcy5zY29wZV8sIHZhbHVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBkaWUoMzQsIHRoaXMubmFtZV8pO1xuICB9O1xuXG4gIF9wcm90by50cmFja0FuZENvbXB1dGUgPSBmdW5jdGlvbiB0cmFja0FuZENvbXB1dGUoKSB7XG4gICAgLy8gTi5COiB1bm1pbmlmaWVkIGFzIGl0IGlzIHVzZWQgYnkgTVNUXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgdmFyIHdhc1N1c3BlbmRlZCA9XG4gICAgLyogc2VlICMxMjA4ICovXG4gICAgdGhpcy5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5jb21wdXRlVmFsdWVfKHRydWUpO1xuXG4gICAgaWYgKCBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiY29tcHV0ZWRcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBvYmplY3Q6IHRoaXMuc2NvcGVfLFxuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICBvbGRWYWx1ZTogdGhpcy52YWx1ZV8sXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWQgPSB3YXNTdXNwZW5kZWQgfHwgaXNDYXVnaHRFeGNlcHRpb24ob2xkVmFsdWUpIHx8IGlzQ2F1Z2h0RXhjZXB0aW9uKG5ld1ZhbHVlKSB8fCAhdGhpcy5lcXVhbHNfKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy52YWx1ZV8gPSBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcblxuICBfcHJvdG8uY29tcHV0ZVZhbHVlXyA9IGZ1bmN0aW9uIGNvbXB1dGVWYWx1ZV8odHJhY2spIHtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IHRydWU7IC8vIGRvbid0IGFsbG93IHN0YXRlIGNoYW5nZXMgZHVyaW5nIGNvbXB1dGF0aW9uXG5cbiAgICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoZmFsc2UpO1xuICAgIHZhciByZXM7XG5cbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJlcyA9IHRyYWNrRGVyaXZlZEZ1bmN0aW9uKHRoaXMsIHRoaXMuZGVyaXZhdGlvbiwgdGhpcy5zY29wZV8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXMgPSB0aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLnNjb3BlXyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuc2NvcGVfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlcyA9IG5ldyBDYXVnaHRFeGNlcHRpb24oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IGZhbHNlO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgX3Byb3RvLnN1c3BlbmRfID0gZnVuY3Rpb24gc3VzcGVuZF8oKSB7XG4gICAgaWYgKCF0aGlzLmtlZXBBbGl2ZV8pIHtcbiAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgICAgdGhpcy52YWx1ZV8gPSB1bmRlZmluZWQ7IC8vIGRvbid0IGhvbGQgb24gdG8gY29tcHV0ZWQgdmFsdWUhXG5cbiAgICAgIGlmICggdGhpcy5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIHdhcyBzdXNwZW5kZWQgYW5kIGl0IHdpbGwgcmVjb21wdXRlIG9uIHRoZSBuZXh0IGFjY2Vzcy5cIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG4gICAgdmFyIHByZXZWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gYXV0b3J1bihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPOiB3aHkgaXMgdGhpcyBpbiBhIGRpZmZlcmVudCBwbGFjZSB0aGFuIHRoZSBzcHlSZXBvcnQoKSBmdW5jdGlvbj8gaW4gYWxsIG90aGVyIG9ic2VydmFibGVzIGl0J3MgY2FsbGVkIGluIHRoZSBzYW1lIHBsYWNlXG4gICAgICB2YXIgbmV3VmFsdWUgPSBfdGhpcy5nZXQoKTtcblxuICAgICAgaWYgKCFmaXJzdFRpbWUgfHwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJjb21wdXRlZFwiLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICAgIG9iamVjdDogX3RoaXMsXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlOiBwcmV2VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHVudHJhY2tlZEVuZChwcmV2VSk7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgcHJldlZhbHVlID0gbmV3VmFsdWU7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLndhcm5BYm91dFVudHJhY2tlZFJlYWRfID0gZnVuY3Rpb24gd2FybkFib3V0VW50cmFja2VkUmVhZF8oKSB7XG5cbiAgICBpZiAodGhpcy5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gQ29tcHV0ZWQgdmFsdWUgJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LiBEb2luZyBhIGZ1bGwgcmVjb21wdXRlLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsU3RhdGUuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uIHx8IHRoaXMucmVxdWlyZXNSZWFjdGlvbl8pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIGlzIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuIERvaW5nIGEgZnVsbCByZWNvbXB1dGUuXCIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXyArIFwiW1wiICsgdGhpcy5kZXJpdmF0aW9uLnRvU3RyaW5nKCkgKyBcIl1cIjtcbiAgfTtcblxuICBfcHJvdG8udmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRvUHJpbWl0aXZlKHRoaXMuZ2V0KCkpO1xuICB9O1xuXG4gIF9wcm90b1tfU3ltYm9sJHRvUHJpbWl0aXZlJDFdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgfTtcblxuICByZXR1cm4gQ29tcHV0ZWRWYWx1ZTtcbn0oKTtcbnZhciBpc0NvbXB1dGVkVmFsdWUgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIkNvbXB1dGVkVmFsdWVcIiwgQ29tcHV0ZWRWYWx1ZSk7XG5cbnZhciBJRGVyaXZhdGlvblN0YXRlXztcblxuKGZ1bmN0aW9uIChJRGVyaXZhdGlvblN0YXRlXykge1xuICAvLyBiZWZvcmUgYmVpbmcgcnVuIG9yIChvdXRzaWRlIGJhdGNoIGFuZCBub3QgYmVpbmcgb2JzZXJ2ZWQpXG4gIC8vIGF0IHRoaXMgcG9pbnQgZGVyaXZhdGlvbiBpcyBub3QgaG9sZGluZyBhbnkgZGF0YSBhYm91dCBkZXBlbmRlbmN5IHRyZWVcbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJOT1RfVFJBQ0tJTkdfXCJdID0gLTFdID0gXCJOT1RfVFJBQ0tJTkdfXCI7IC8vIG5vIHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkIHNpbmNlIGxhc3QgY29tcHV0YXRpb25cbiAgLy8gd29uJ3QgcmVjYWxjdWxhdGUgZGVyaXZhdGlvblxuICAvLyB0aGlzIGlzIHdoYXQgbWFrZXMgbW9ieCBmYXN0XG5cbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJVUF9UT19EQVRFX1wiXSA9IDBdID0gXCJVUF9UT19EQVRFX1wiOyAvLyBzb21lIGRlZXAgZGVwZW5kZW5jeSBjaGFuZ2VkLCBidXQgZG9uJ3Qga25vdyBpZiBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZFxuICAvLyB3aWxsIHJlcXVpcmUgdG8gY2hlY2sgZmlyc3QgaWYgVVBfVE9fREFURSBvciBQT1NTSUJMWV9TVEFMRVxuICAvLyBjdXJyZW50bHkgb25seSBDb21wdXRlZFZhbHVlIHdpbGwgcHJvcGFnYXRlIFBPU1NJQkxZX1NUQUxFXG4gIC8vXG4gIC8vIGhhdmluZyB0aGlzIHN0YXRlIGlzIHNlY29uZCBiaWcgb3B0aW1pemF0aW9uOlxuICAvLyBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSBvbiBldmVyeSBkZXBlbmRlbmN5IGNoYW5nZSwgYnV0IG9ubHkgd2hlbiBpdCdzIG5lZWRlZFxuXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiUE9TU0lCTFlfU1RBTEVfXCJdID0gMV0gPSBcIlBPU1NJQkxZX1NUQUxFX1wiOyAvLyBBIHNoYWxsb3cgZGVwZW5kZW5jeSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uIGFuZCB0aGUgZGVyaXZhdGlvblxuICAvLyB3aWxsIG5lZWQgdG8gcmVjb21wdXRlIHdoZW4gaXQncyBuZWVkZWQgbmV4dC5cblxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIlNUQUxFX1wiXSA9IDJdID0gXCJTVEFMRV9cIjtcbn0pKElEZXJpdmF0aW9uU3RhdGVfIHx8IChJRGVyaXZhdGlvblN0YXRlXyA9IHt9KSk7XG5cbnZhciBUcmFjZU1vZGU7XG5cbihmdW5jdGlvbiAoVHJhY2VNb2RlKSB7XG4gIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkxPR1wiXSA9IDFdID0gXCJMT0dcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkJSRUFLXCJdID0gMl0gPSBcIkJSRUFLXCI7XG59KShUcmFjZU1vZGUgfHwgKFRyYWNlTW9kZSA9IHt9KSk7XG5cbnZhciBDYXVnaHRFeGNlcHRpb24gPSBmdW5jdGlvbiBDYXVnaHRFeGNlcHRpb24oY2F1c2UpIHtcbiAgdGhpcy5jYXVzZSA9IHZvaWQgMDtcbiAgdGhpcy5jYXVzZSA9IGNhdXNlOyAvLyBFbXB0eVxufTtcbmZ1bmN0aW9uIGlzQ2F1Z2h0RXhjZXB0aW9uKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDYXVnaHRFeGNlcHRpb247XG59XG4vKipcclxuICogRmluZHMgb3V0IHdoZXRoZXIgYW55IGRlcGVuZGVuY3kgb2YgdGhlIGRlcml2YXRpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXHJcbiAqIElmIGRlcGVuZGVuY2llc1N0YXRlIGlzIDEgdGhlbiBpdCB3aWxsIHJlY2FsY3VsYXRlIGRlcGVuZGVuY2llcyxcclxuICogaWYgYW55IGRlcGVuZGVuY3kgY2hhbmdlZCBpdCB3aWxsIHByb3BhZ2F0ZSBpdCBieSBjaGFuZ2luZyBkZXBlbmRlbmNpZXNTdGF0ZSB0byAyLlxyXG4gKlxyXG4gKiBCeSBpdGVyYXRpbmcgb3ZlciB0aGUgZGVwZW5kZW5jaWVzIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSB3ZXJlIHJlcG9ydGVkIGFuZFxyXG4gKiBzdG9wcGluZyBvbiB0aGUgZmlyc3QgY2hhbmdlLCBhbGwgdGhlIHJlY2FsY3VsYXRpb25zIGFyZSBvbmx5IGNhbGxlZCBmb3IgQ29tcHV0ZWRWYWx1ZXNcclxuICogdGhhdCB3aWxsIGJlIHRyYWNrZWQgYnkgZGVyaXZhdGlvbi4gVGhhdCBpcyBiZWNhdXNlIHdlIGFzc3VtZSB0aGF0IGlmIHRoZSBmaXJzdCB4XHJcbiAqIGRlcGVuZGVuY2llcyBvZiB0aGUgZGVyaXZhdGlvbiBkb2Vzbid0IGNoYW5nZSB0aGVuIHRoZSBkZXJpdmF0aW9uIHNob3VsZCBydW4gdGhlIHNhbWUgd2F5XHJcbiAqIHVwIHVudGlsIGFjY2Vzc2luZyB4LXRoIGRlcGVuZGVuY3kuXHJcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRDb21wdXRlKGRlcml2YXRpb24pIHtcbiAgc3dpdGNoIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXykge1xuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV86XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR186XG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV86XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfOlxuICAgICAge1xuICAgICAgICAvLyBzdGF0ZSBwcm9wYWdhdGlvbiBjYW4gb2NjdXIgb3V0c2lkZSBvZiBhY3Rpb24vcmVhY3RpdmUgY29udGV4dCAjMjE5NVxuICAgICAgICB2YXIgcHJldkFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpO1xuICAgICAgICB2YXIgcHJldlVudHJhY2tlZCA9IHVudHJhY2tlZFN0YXJ0KCk7IC8vIG5vIG5lZWQgZm9yIHRob3NlIGNvbXB1dGVkcyB0byBiZSByZXBvcnRlZCwgdGhleSB3aWxsIGJlIHBpY2tlZCB1cCBpbiB0cmFja0Rlcml2ZWRGdW5jdGlvbi5cblxuICAgICAgICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfLFxuICAgICAgICAgICAgbCA9IG9icy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgb2JqID0gb2JzW2ldO1xuXG4gICAgICAgICAgaWYgKGlzQ29tcHV0ZWRWYWx1ZShvYmopKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcykge1xuICAgICAgICAgICAgICBvYmouZ2V0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iai5nZXQoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiB0aGUgdmFsdWUgKm9yKiBleGNlcHRpb24gYXQgdGhpcyBtb21lbnQsIGJ1dCBpZiB0aGVyZSBpcyBvbmUsIG5vdGlmeSBhbGxcbiAgICAgICAgICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgICAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGlmIENvbXB1dGVkVmFsdWUgYG9iamAgYWN0dWFsbHkgY2hhbmdlZCBpdCB3aWxsIGJlIGNvbXB1dGVkIGFuZCBwcm9wYWdhdGVkIHRvIGl0cyBvYnNlcnZlcnMuXG4gICAgICAgICAgICAvLyBhbmQgYGRlcml2YXRpb25gIGlzIGFuIG9ic2VydmVyIG9mIGBvYmpgXG4gICAgICAgICAgICAvLyBpbnZhcmlhbnRTaG91bGRDb21wdXRlKGRlcml2YXRpb24pXG5cblxuICAgICAgICAgICAgaWYgKGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV8pIHtcbiAgICAgICAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICAgICAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pO1xuICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0NvbXB1dGluZ0Rlcml2YXRpb24oKSB7XG4gIHJldHVybiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gIT09IG51bGw7IC8vIGZpbHRlciBvdXQgYWN0aW9ucyBpbnNpZGUgY29tcHV0YXRpb25zXG59XG5mdW5jdGlvbiBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZChhdG9tKSB7XG5cbiAgdmFyIGhhc09ic2VydmVycyA9IGF0b20ub2JzZXJ2ZXJzXy5zaXplID4gMDsgLy8gU2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBjaGFuZ2Ugb2JzZXJ2ZWQgc3RhdGUgb3V0c2lkZSBzdHJpY3QgbW9kZSwgZXhjZXB0IGR1cmluZyBpbml0aWFsaXphdGlvbiwgc2VlICM1NjNcblxuICBpZiAoIWdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzICYmIChoYXNPYnNlcnZlcnMgfHwgZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPT09IFwiYWx3YXlzXCIpKSBjb25zb2xlLndhcm4oXCJbTW9iWF0gXCIgKyAoZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPyBcIlNpbmNlIHN0cmljdC1tb2RlIGlzIGVuYWJsZWQsIGNoYW5naW5nIChvYnNlcnZlZCkgb2JzZXJ2YWJsZSB2YWx1ZXMgd2l0aG91dCB1c2luZyBhbiBhY3Rpb24gaXMgbm90IGFsbG93ZWQuIFRyaWVkIHRvIG1vZGlmeTogXCIgOiBcIlNpZGUgZWZmZWN0cyBsaWtlIGNoYW5naW5nIHN0YXRlIGFyZSBub3QgYWxsb3dlZCBhdCB0aGlzIHBvaW50LiBBcmUgeW91IHRyeWluZyB0byBtb2RpZnkgc3RhdGUgZnJvbSwgZm9yIGV4YW1wbGUsIGEgY29tcHV0ZWQgdmFsdWUgb3IgdGhlIHJlbmRlciBmdW5jdGlvbiBvZiBhIFJlYWN0IGNvbXBvbmVudD8gWW91IGNhbiB3cmFwIHNpZGUgZWZmZWN0cyBpbiAncnVuSW5BY3Rpb24nIChvciBkZWNvcmF0ZSBmdW5jdGlvbnMgd2l0aCAnYWN0aW9uJykgaWYgbmVlZGVkLiBUcmllZCB0byBtb2RpZnk6IFwiKSArIGF0b20ubmFtZV8pO1xufVxuZnVuY3Rpb24gY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpIHtcbiAgaWYgKCAhZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzICYmIGdsb2JhbFN0YXRlLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKFwiW21vYnhdIE9ic2VydmFibGUgJ1wiICsgb2JzZXJ2YWJsZS5uYW1lXyArIFwiJyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LlwiKTtcbiAgfVxufVxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBgZmAgYW5kIHRyYWNrcyB3aGljaCBvYnNlcnZhYmxlcyBhcmUgYmVpbmcgYWNjZXNzZWQuXHJcbiAqIFRoZSB0cmFja2luZyBpbmZvcm1hdGlvbiBpcyBzdG9yZWQgb24gdGhlIGBkZXJpdmF0aW9uYCBvYmplY3QgYW5kIHRoZSBkZXJpdmF0aW9uIGlzIHJlZ2lzdGVyZWRcclxuICogYXMgb2JzZXJ2ZXIgb2YgYW55IG9mIHRoZSBhY2Nlc3NlZCBvYnNlcnZhYmxlcy5cclxuICovXG5cbmZ1bmN0aW9uIHRyYWNrRGVyaXZlZEZ1bmN0aW9uKGRlcml2YXRpb24sIGYsIGNvbnRleHQpIHtcbiAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTsgLy8gcHJlIGFsbG9jYXRlIGFycmF5IGFsbG9jYXRpb24gKyByb29tIGZvciB2YXJpYXRpb24gaW4gZGVwc1xuICAvLyBhcnJheSB3aWxsIGJlIHRyaW1tZWQgYnkgYmluZERlcGVuZGVuY2llc1xuXG4gIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pO1xuICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ18gPSBuZXcgQXJyYXkoZGVyaXZhdGlvbi5vYnNlcnZpbmdfLmxlbmd0aCArIDEwMCk7XG4gIGRlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF8gPSAwO1xuICBkZXJpdmF0aW9uLnJ1bklkXyA9ICsrZ2xvYmFsU3RhdGUucnVuSWQ7XG4gIHZhciBwcmV2VHJhY2tpbmcgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IGRlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLmluQmF0Y2grKztcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgIHJlc3VsdCA9IGYuY2FsbChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZi5jYWxsKGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDYXVnaHRFeGNlcHRpb24oZSk7XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaC0tO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBwcmV2VHJhY2tpbmc7XG4gIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XG4gIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pO1xuICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcbiAgaWYgKGRlcml2YXRpb24ub2JzZXJ2aW5nXy5sZW5ndGggIT09IDApIHJldHVybjtcblxuICBpZiAoZ2xvYmFsU3RhdGUucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUgfHwgZGVyaXZhdGlvbi5yZXF1aXJlc09ic2VydmFibGVfKSB7XG4gICAgY29uc29sZS53YXJuKFwiW21vYnhdIERlcml2YXRpb24gJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJyBpcyBjcmVhdGVkL3VwZGF0ZWQgd2l0aG91dCByZWFkaW5nIGFueSBvYnNlcnZhYmxlIHZhbHVlLlwiKTtcbiAgfVxufVxuLyoqXHJcbiAqIGRpZmZzIG5ld09ic2VydmluZyB3aXRoIG9ic2VydmluZy5cclxuICogdXBkYXRlIG9ic2VydmluZyB0byBiZSBuZXdPYnNlcnZpbmcgd2l0aCB1bmlxdWUgb2JzZXJ2YWJsZXNcclxuICogbm90aWZ5IG9ic2VydmVycyB0aGF0IGJlY29tZSBvYnNlcnZlZC91bm9ic2VydmVkXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbikge1xuICAvLyBpbnZhcmlhbnQoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSAhPT0gSURlcml2YXRpb25TdGF0ZS5OT1RfVFJBQ0tJTkcsIFwiSU5URVJOQUwgRVJST1IgYmluZERlcGVuZGVuY2llcyBleHBlY3RzIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGUgIT09IC0xXCIpO1xuICB2YXIgcHJldk9ic2VydmluZyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXztcbiAgdmFyIG9ic2VydmluZyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXyA9IGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nXztcbiAgdmFyIGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfOyAvLyBHbyB0aHJvdWdoIGFsbCBuZXcgb2JzZXJ2YWJsZXMgYW5kIGNoZWNrIGRpZmZWYWx1ZTogKHRoaXMgbGlzdCBjYW4gY29udGFpbiBkdXBsaWNhdGVzKTpcbiAgLy8gICAwOiBmaXJzdCBvY2N1cnJlbmNlLCBjaGFuZ2UgdG8gMSBhbmQga2VlcCBpdFxuICAvLyAgIDE6IGV4dHJhIG9jY3VycmVuY2UsIGRyb3AgaXRcblxuICB2YXIgaTAgPSAwLFxuICAgICAgbCA9IGRlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF87XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgZGVwID0gb2JzZXJ2aW5nW2ldO1xuXG4gICAgaWYgKGRlcC5kaWZmVmFsdWVfID09PSAwKSB7XG4gICAgICBkZXAuZGlmZlZhbHVlXyA9IDE7XG4gICAgICBpZiAoaTAgIT09IGkpIG9ic2VydmluZ1tpMF0gPSBkZXA7XG4gICAgICBpMCsrO1xuICAgIH0gLy8gVXBjYXN0IGlzICdzYWZlJyBoZXJlLCBiZWNhdXNlIGlmIGRlcCBpcyBJT2JzZXJ2YWJsZSwgYGRlcGVuZGVuY2llc1N0YXRlYCB3aWxsIGJlIHVuZGVmaW5lZCxcbiAgICAvLyBub3QgaGl0dGluZyB0aGUgY29uZGl0aW9uXG5cblxuICAgIGlmIChkZXAuZGVwZW5kZW5jaWVzU3RhdGVfID4gbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlKSB7XG4gICAgICBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgPSBkZXAuZGVwZW5kZW5jaWVzU3RhdGVfO1xuICAgIH1cbiAgfVxuXG4gIG9ic2VydmluZy5sZW5ndGggPSBpMDtcbiAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfID0gbnVsbDsgLy8gbmV3T2JzZXJ2aW5nIHNob3VsZG4ndCBiZSBuZWVkZWQgb3V0c2lkZSB0cmFja2luZyAoc3RhdGVtZW50IG1vdmVkIGRvd24gdG8gd29yayBhcm91bmQgRkYgYnVnLCBzZWUgIzYxNClcbiAgLy8gR28gdGhyb3VnaCBhbGwgb2xkIG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6IChpdCBpcyB1bmlxdWUgYWZ0ZXIgbGFzdCBiaW5kRGVwZW5kZW5jaWVzKVxuICAvLyAgIDA6IGl0J3Mgbm90IGluIG5ldyBvYnNlcnZhYmxlcywgdW5vYnNlcnZlIGl0XG4gIC8vICAgMTogaXQga2VlcHMgYmVpbmcgb2JzZXJ2ZWQsIGRvbid0IHdhbnQgdG8gbm90aWZ5IGl0LiBjaGFuZ2UgdG8gMFxuXG4gIGwgPSBwcmV2T2JzZXJ2aW5nLmxlbmd0aDtcblxuICB3aGlsZSAobC0tKSB7XG4gICAgdmFyIF9kZXAgPSBwcmV2T2JzZXJ2aW5nW2xdO1xuXG4gICAgaWYgKF9kZXAuZGlmZlZhbHVlXyA9PT0gMCkge1xuICAgICAgcmVtb3ZlT2JzZXJ2ZXIoX2RlcCwgZGVyaXZhdGlvbik7XG4gICAgfVxuXG4gICAgX2RlcC5kaWZmVmFsdWVfID0gMDtcbiAgfSAvLyBHbyB0aHJvdWdoIGFsbCBuZXcgb2JzZXJ2YWJsZXMgYW5kIGNoZWNrIGRpZmZWYWx1ZTogKG5vdyBpdCBzaG91bGQgYmUgdW5pcXVlKVxuICAvLyAgIDA6IGl0IHdhcyBzZXQgdG8gMCBpbiBsYXN0IGxvb3AuIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gIC8vICAgMTogaXQgd2Fzbid0IG9ic2VydmVkLCBsZXQncyBvYnNlcnZlIGl0LiBzZXQgYmFjayB0byAwXG5cblxuICB3aGlsZSAoaTAtLSkge1xuICAgIHZhciBfZGVwMiA9IG9ic2VydmluZ1tpMF07XG5cbiAgICBpZiAoX2RlcDIuZGlmZlZhbHVlXyA9PT0gMSkge1xuICAgICAgX2RlcDIuZGlmZlZhbHVlXyA9IDA7XG4gICAgICBhZGRPYnNlcnZlcihfZGVwMiwgZGVyaXZhdGlvbik7XG4gICAgfVxuICB9IC8vIFNvbWUgbmV3IG9ic2VydmVkIGRlcml2YXRpb25zIG1heSBiZWNvbWUgc3RhbGUgZHVyaW5nIHRoaXMgZGVyaXZhdGlvbiBjb21wdXRhdGlvblxuICAvLyBzbyB0aGV5IGhhdmUgaGFkIG5vIGNoYW5jZSB0byBwcm9wYWdhdGUgc3RhbGVuZXNzICgjOTE2KVxuXG5cbiAgaWYgKGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSAhPT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZTtcbiAgICBkZXJpdmF0aW9uLm9uQmVjb21lU3RhbGVfKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYXJPYnNlcnZpbmcoZGVyaXZhdGlvbikge1xuICAvLyBpbnZhcmlhbnQoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAsIFwiSU5URVJOQUwgRVJST1IgY2xlYXJPYnNlcnZpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IGluc2lkZSBiYXRjaFwiKTtcbiAgdmFyIG9icyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXztcbiAgZGVyaXZhdGlvbi5vYnNlcnZpbmdfID0gW107XG4gIHZhciBpID0gb2JzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcmVtb3ZlT2JzZXJ2ZXIob2JzW2ldLCBkZXJpdmF0aW9uKTtcbiAgfVxuXG4gIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbn1cbmZ1bmN0aW9uIHVudHJhY2tlZChhY3Rpb24pIHtcbiAgdmFyIHByZXYgPSB1bnRyYWNrZWRTdGFydCgpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGFjdGlvbigpO1xuICB9IGZpbmFsbHkge1xuICAgIHVudHJhY2tlZEVuZChwcmV2KTtcbiAgfVxufVxuZnVuY3Rpb24gdW50cmFja2VkU3RhcnQoKSB7XG4gIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBudWxsO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHVudHJhY2tlZEVuZChwcmV2KSB7XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IHByZXY7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlUmVhZHNTdGFydChhbGxvd1N0YXRlUmVhZHMpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHM7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkcztcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlUmVhZHNFbmQocHJldikge1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgPSBwcmV2O1xufVxuLyoqXHJcbiAqIG5lZWRlZCB0byBrZWVwIGBsb3dlc3RPYnNlcnZlclN0YXRlYCBjb3JyZWN0LiB3aGVuIGNoYW5naW5nIGZyb20gKDIgb3IgMSkgdG8gMFxyXG4gKlxyXG4gKi9cblxuZnVuY3Rpb24gY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbikge1xuICBpZiAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSByZXR1cm47XG4gIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIHZhciBpID0gb2JzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgb2JzW2ldLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gIH1cbn1cblxuLyoqXHJcbiAqIFRoZXNlIHZhbHVlcyB3aWxsIHBlcnNpc3QgaWYgZ2xvYmFsIHN0YXRlIGlzIHJlc2V0XHJcbiAqL1xuXG52YXIgcGVyc2lzdGVudEtleXMgPSBbXCJtb2J4R3VpZFwiLCBcInNweUxpc3RlbmVyc1wiLCBcImVuZm9yY2VBY3Rpb25zXCIsIFwiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsIFwicmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGVcIiwgXCJvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvblwiLCBcImFsbG93U3RhdGVSZWFkc1wiLCBcImRpc2FibGVFcnJvckJvdW5kYXJpZXNcIiwgXCJydW5JZFwiLCBcIlVOQ0hBTkdFRFwiLCBcInVzZVByb3hpZXNcIl07XG52YXIgTW9iWEdsb2JhbHMgPSBmdW5jdGlvbiBNb2JYR2xvYmFscygpIHtcbiAgdGhpcy52ZXJzaW9uID0gNjtcbiAgdGhpcy5VTkNIQU5HRUQgPSB7fTtcbiAgdGhpcy50cmFja2luZ0Rlcml2YXRpb24gPSBudWxsO1xuICB0aGlzLnRyYWNraW5nQ29udGV4dCA9IG51bGw7XG4gIHRoaXMucnVuSWQgPSAwO1xuICB0aGlzLm1vYnhHdWlkID0gMDtcbiAgdGhpcy5pbkJhdGNoID0gMDtcbiAgdGhpcy5wZW5kaW5nVW5vYnNlcnZhdGlvbnMgPSBbXTtcbiAgdGhpcy5wZW5kaW5nUmVhY3Rpb25zID0gW107XG4gIHRoaXMuaXNSdW5uaW5nUmVhY3Rpb25zID0gZmFsc2U7XG4gIHRoaXMuYWxsb3dTdGF0ZUNoYW5nZXMgPSBmYWxzZTtcbiAgdGhpcy5hbGxvd1N0YXRlUmVhZHMgPSB0cnVlO1xuICB0aGlzLmVuZm9yY2VBY3Rpb25zID0gdHJ1ZTtcbiAgdGhpcy5zcHlMaXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMgPSBbXTtcbiAgdGhpcy5jb21wdXRlZFJlcXVpcmVzUmVhY3Rpb24gPSBmYWxzZTtcbiAgdGhpcy5yZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZSA9IGZhbHNlO1xuICB0aGlzLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uID0gZmFsc2U7XG4gIHRoaXMuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9IGZhbHNlO1xuICB0aGlzLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMgPSBmYWxzZTtcbiAgdGhpcy51c2VQcm94aWVzID0gdHJ1ZTtcbiAgdGhpcy52ZXJpZnlQcm94aWVzID0gZmFsc2U7XG4gIHRoaXMuc2FmZURlc2NyaXB0b3JzID0gdHJ1ZTtcbn07XG52YXIgY2FuTWVyZ2VHbG9iYWxTdGF0ZSA9IHRydWU7XG52YXIgaXNvbGF0ZUNhbGxlZCA9IGZhbHNlO1xudmFyIGdsb2JhbFN0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIGdsb2JhbCA9IC8qI19fUFVSRV9fKi9nZXRHbG9iYWwoKTtcbiAgaWYgKGdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ID4gMCAmJiAhZ2xvYmFsLl9fbW9ieEdsb2JhbHMpIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSBmYWxzZTtcbiAgaWYgKGdsb2JhbC5fX21vYnhHbG9iYWxzICYmIGdsb2JhbC5fX21vYnhHbG9iYWxzLnZlcnNpb24gIT09IG5ldyBNb2JYR2xvYmFscygpLnZlcnNpb24pIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSBmYWxzZTtcblxuICBpZiAoIWNhbk1lcmdlR2xvYmFsU3RhdGUpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghaXNvbGF0ZUNhbGxlZCkge1xuICAgICAgICBkaWUoMzUpO1xuICAgICAgfVxuICAgIH0sIDEpO1xuICAgIHJldHVybiBuZXcgTW9iWEdsb2JhbHMoKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuX19tb2J4R2xvYmFscykge1xuICAgIGdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ICs9IDE7XG4gICAgaWYgKCFnbG9iYWwuX19tb2J4R2xvYmFscy5VTkNIQU5HRUQpIGdsb2JhbC5fX21vYnhHbG9iYWxzLlVOQ0hBTkdFRCA9IHt9OyAvLyBtYWtlIG1lcmdlIGJhY2t3YXJkIGNvbXBhdGlibGVcblxuICAgIHJldHVybiBnbG9iYWwuX19tb2J4R2xvYmFscztcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA9IDE7XG4gICAgcmV0dXJuIGdsb2JhbC5fX21vYnhHbG9iYWxzID0gLyojX19QVVJFX18qL25ldyBNb2JYR2xvYmFscygpO1xuICB9XG59KCk7XG5mdW5jdGlvbiBpc29sYXRlR2xvYmFsU3RhdGUoKSB7XG4gIGlmIChnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLmxlbmd0aCB8fCBnbG9iYWxTdGF0ZS5pbkJhdGNoIHx8IGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucykgZGllKDM2KTtcbiAgaXNvbGF0ZUNhbGxlZCA9IHRydWU7XG5cbiAgaWYgKGNhbk1lcmdlR2xvYmFsU3RhdGUpIHtcbiAgICB2YXIgZ2xvYmFsID0gZ2V0R2xvYmFsKCk7XG4gICAgaWYgKC0tZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPT09IDApIGdsb2JhbC5fX21vYnhHbG9iYWxzID0gdW5kZWZpbmVkO1xuICAgIGdsb2JhbFN0YXRlID0gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEdsb2JhbFN0YXRlKCkge1xuICByZXR1cm4gZ2xvYmFsU3RhdGU7XG59XG4vKipcclxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seTsgdGhpcyB3aWxsIGJyZWFrIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBleGlzdGluZyBvYnNlcnZhYmxlcyxcclxuICogYnV0IGNhbiBiZSB1c2VkIHRvIGdldCBiYWNrIGF0IGEgc3RhYmxlIHN0YXRlIGFmdGVyIHRocm93aW5nIGVycm9yc1xyXG4gKi9cblxuZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcbiAgdmFyIGRlZmF1bHRHbG9iYWxzID0gbmV3IE1vYlhHbG9iYWxzKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRHbG9iYWxzKSB7XG4gICAgaWYgKHBlcnNpc3RlbnRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIGdsb2JhbFN0YXRlW2tleV0gPSBkZWZhdWx0R2xvYmFsc1trZXldO1xuICB9XG5cbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSAhZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGhhc09ic2VydmVycyhvYnNlcnZhYmxlKSB7XG4gIHJldHVybiBvYnNlcnZhYmxlLm9ic2VydmVyc18gJiYgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPiAwO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpIHtcbiAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2ZXJzXztcbn0gLy8gZnVuY3Rpb24gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGU6IElPYnNlcnZhYmxlKSB7XG4vLyAgICAgY29uc3QgbGlzdCA9IG9ic2VydmFibGUub2JzZXJ2ZXJzXG4vLyAgICAgY29uc3QgbWFwID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnNJbmRleGVzXG4vLyAgICAgY29uc3QgbCA9IGxpc3QubGVuZ3RoXG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbi8vICAgICAgICAgY29uc3QgaWQgPSBsaXN0W2ldLl9fbWFwaWRcbi8vICAgICAgICAgaWYgKGkpIHtcbi8vICAgICAgICAgICAgIGludmFyaWFudChtYXBbaWRdID09PSBpLCBcIklOVEVSTkFMIEVSUk9SIG1hcHMgZGVyaXZhdGlvbi5fX21hcGlkIHRvIGluZGV4IGluIGxpc3RcIikgLy8gZm9yIHBlcmZvcm1hbmNlXG4vLyAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICBpbnZhcmlhbnQoIShpZCBpbiBtYXApLCBcIklOVEVSTkFMIEVSUk9SIG9ic2VydmVyIG9uIGluZGV4IDAgc2hvdWxkbid0IGJlIGhlbGQgaW4gbWFwLlwiKSAvLyBmb3IgcGVyZm9ybWFuY2Vcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBpbnZhcmlhbnQoXG4vLyAgICAgICAgIGxpc3QubGVuZ3RoID09PSAwIHx8IE9iamVjdC5rZXlzKG1hcCkubGVuZ3RoID09PSBsaXN0Lmxlbmd0aCAtIDEsXG4vLyAgICAgICAgIFwiSU5URVJOQUwgRVJST1IgdGhlcmUgaXMgbm8ganVuayBpbiBtYXBcIlxuLy8gICAgIClcbi8vIH1cblxuZnVuY3Rpb24gYWRkT2JzZXJ2ZXIob2JzZXJ2YWJsZSwgbm9kZSkge1xuICAvLyBpbnZhcmlhbnQobm9kZS5kZXBlbmRlbmNpZXNTdGF0ZSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IsIGNhbiBhZGQgb25seSBkZXBlbmRlbmNpZXNTdGF0ZSAhPT0gLTFcIik7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSA9PT0gLTEsIFwiSU5URVJOQUwgRVJST1IgYWRkIGFscmVhZHkgYWRkZWQgbm9kZVwiKTtcbiAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uYWRkKG5vZGUpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA+IG5vZGUuZGVwZW5kZW5jaWVzU3RhdGVfKSBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gbm9kZS5kZXBlbmRlbmNpZXNTdGF0ZV87IC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiBkaWRuJ3QgYWRkIG5vZGVcIik7XG59XG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XG4gIC8vIGludmFyaWFudChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCwgXCJJTlRFUk5BTCBFUlJPUiwgcmVtb3ZlIHNob3VsZCBiZSBjYWxsZWQgb25seSBpbnNpZGUgYmF0Y2hcIik7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IgcmVtb3ZlIGFscmVhZHkgcmVtb3ZlZCBub2RlXCIpO1xuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzX1tcImRlbGV0ZVwiXShub2RlKTtcblxuICBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPT09IDApIHtcbiAgICAvLyBkZWxldGluZyBsYXN0IG9ic2VydmVyXG4gICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xuICB9IC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpID09PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiByZW1vdmUgYWxyZWFkeSByZW1vdmVkIG5vZGUyXCIpO1xuXG59XG5mdW5jdGlvbiBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSkge1xuICBpZiAob2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9PT0gZmFsc2UpIHtcbiAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCwgXCJJTlRFUk5BTCBFUlJPUiwgc2hvdWxkIG9ubHkgcXVldWUgZm9yIHVub2JzZXJ2YXRpb24gdW5vYnNlcnZlZCBvYnNlcnZhYmxlc1wiKTtcbiAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gdHJ1ZTtcbiAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMucHVzaChvYnNlcnZhYmxlKTtcbiAgfVxufVxuLyoqXHJcbiAqIEJhdGNoIHN0YXJ0cyBhIHRyYW5zYWN0aW9uLCBhdCBsZWFzdCBmb3IgcHVycG9zZXMgb2YgbWVtb2l6aW5nIENvbXB1dGVkVmFsdWVzIHdoZW4gbm90aGluZyBlbHNlIGRvZXMuXHJcbiAqIER1cmluZyBhIGJhdGNoIGBvbkJlY29tZVVub2JzZXJ2ZWRgIHdpbGwgYmUgY2FsbGVkIGF0IG1vc3Qgb25jZSBwZXIgb2JzZXJ2YWJsZS5cclxuICogQXZvaWRzIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxyXG4gKi9cblxuZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaCsrO1xufVxuZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gIGlmICgtLWdsb2JhbFN0YXRlLmluQmF0Y2ggPT09IDApIHtcbiAgICBydW5SZWFjdGlvbnMoKTsgLy8gdGhlIGJhdGNoIGlzIGFjdHVhbGx5IGFib3V0IHRvIGZpbmlzaCwgYWxsIHVub2JzZXJ2aW5nIHNob3VsZCBoYXBwZW4gaGVyZS5cblxuICAgIHZhciBsaXN0ID0gZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGxpc3RbaV07XG4gICAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gZmFsc2U7XG5cbiAgICAgIGlmIChvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAob2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBvYnNlcnZhYmxlIGhhZCByZWFjdGl2ZSBvYnNlcnZlcnMsIHRyaWdnZXIgdGhlIGhvb2tzXG4gICAgICAgICAgb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfID0gZmFsc2U7XG4gICAgICAgICAgb2JzZXJ2YWJsZS5vbkJVTygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlKSB7XG4gICAgICAgICAgLy8gY29tcHV0ZWQgdmFsdWVzIGFyZSBhdXRvbWF0aWNhbGx5IHRlYXJlZCBkb3duIHdoZW4gdGhlIGxhc3Qgb2JzZXJ2ZXIgbGVhdmVzXG4gICAgICAgICAgLy8gdGhpcyBwcm9jZXNzIGhhcHBlbnMgcmVjdXJzaXZlbHksIHRoaXMgY29tcHV0ZWQgbWlnaHQgYmUgdGhlIGxhc3Qgb2JzZXJ2YWJlIG9mIGFub3RoZXIsIGV0Yy4uXG4gICAgICAgICAgb2JzZXJ2YWJsZS5zdXNwZW5kXygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkKG9ic2VydmFibGUpIHtcbiAgY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpO1xuICB2YXIgZGVyaXZhdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcblxuICBpZiAoZGVyaXZhdGlvbiAhPT0gbnVsbCkge1xuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIG9wdGltaXphdGlvbiwgZ2l2ZSBlYWNoIGRlcml2YXRpb24gcnVuIGFuIHVuaXF1ZSBpZCAocnVuSWQpXHJcbiAgICAgKiBDaGVjayBpZiBsYXN0IHRpbWUgdGhpcyBvYnNlcnZhYmxlIHdhcyBhY2Nlc3NlZCB0aGUgc2FtZSBydW5JZCBpcyB1c2VkXHJcbiAgICAgKiBpZiB0aGlzIGlzIHRoZSBjYXNlLCB0aGUgcmVsYXRpb24gaXMgYWxyZWFkeSBrbm93blxyXG4gICAgICovXG4gICAgaWYgKGRlcml2YXRpb24ucnVuSWRfICE9PSBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5Xykge1xuICAgICAgb2JzZXJ2YWJsZS5sYXN0QWNjZXNzZWRCeV8gPSBkZXJpdmF0aW9uLnJ1bklkXzsgLy8gVHJpZWQgc3RvcmluZyBuZXdPYnNlcnZpbmcsIG9yIG9ic2VydmluZywgb3IgYm90aCBhcyBTZXQsIGJ1dCBwZXJmb3JtYW5jZSBkaWRuJ3QgY29tZSBjbG9zZS4uLlxuXG4gICAgICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ19bZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50XysrXSA9IG9ic2VydmFibGU7XG5cbiAgICAgIGlmICghb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfICYmIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCkge1xuICAgICAgICBvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8gPSB0cnVlO1xuICAgICAgICBvYnNlcnZhYmxlLm9uQk8oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA9PT0gMCAmJiBnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCkge1xuICAgIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gZnVuY3Rpb24gaW52YXJpYW50TE9TKG9ic2VydmFibGU6IElPYnNlcnZhYmxlLCBtc2c6IHN0cmluZykge1xuLy8gICAgIC8vIGl0J3MgZXhwZW5zaXZlIHNvIGJldHRlciBub3QgcnVuIGl0IGluIHByb2R1Y2l0b24uIGJ1dCB0ZW1wb3JhcmlseSBoZWxwZnVsIGZvciB0ZXN0aW5nXG4vLyAgICAgY29uc3QgbWluID0gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5taW4oYSwgYi5kZXBlbmRlbmNpZXNTdGF0ZSksIDIpXG4vLyAgICAgaWYgKG1pbiA+PSBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUpIHJldHVybiAvLyA8LSB0aGUgb25seSBhc3N1bXB0aW9uIGFib3V0IGBsb3dlc3RPYnNlcnZlclN0YXRlYFxuLy8gICAgIHRocm93IG5ldyBFcnJvcihcbi8vICAgICAgICAgXCJsb3dlc3RPYnNlcnZlclN0YXRlIGlzIHdyb25nIGZvciBcIiArXG4vLyAgICAgICAgICAgICBtc2cgK1xuLy8gICAgICAgICAgICAgXCIgYmVjYXVzZSBcIiArXG4vLyAgICAgICAgICAgICBtaW4gK1xuLy8gICAgICAgICAgICAgXCIgPCBcIiArXG4vLyAgICAgICAgICAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVcbi8vICAgICApXG4vLyB9XG5cbi8qKlxyXG4gKiBOT1RFOiBjdXJyZW50IHByb3BhZ2F0aW9uIG1lY2hhbmlzbSB3aWxsIGluIGNhc2Ugb2Ygc2VsZiByZXJ1bmluZyBhdXRvcnVucyBiZWhhdmUgdW5leHBlY3RlZGx5XHJcbiAqIEl0IHdpbGwgcHJvcGFnYXRlIGNoYW5nZXMgdG8gb2JzZXJ2ZXJzIGZyb20gcHJldmlvdXMgcnVuXHJcbiAqIEl0J3MgaGFyZCBvciBtYXliZSBpbXBvc3NpYmxlICh3aXRoIHJlYXNvbmFibGUgcGVyZikgdG8gZ2V0IGl0IHJpZ2h0IHdpdGggY3VycmVudCBhcHByb2FjaFxyXG4gKiBIb3BlZnVsbHkgc2VsZiByZXJ1bmluZyBhdXRvcnVucyBhcmVuJ3QgYSBmZWF0dXJlIHBlb3BsZSBzaG91bGQgZGVwZW5kIG9uXHJcbiAqIEFsc28gbW9zdCBiYXNpYyB1c2UgY2FzZXMgc2hvdWxkIGJlIG9rXHJcbiAqL1xuLy8gQ2FsbGVkIGJ5IEF0b20gd2hlbiBpdHMgdmFsdWUgY2hhbmdlc1xuXG5mdW5jdGlvbiBwcm9wYWdhdGVDaGFuZ2VkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY2hhbmdlZCBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXykgcmV0dXJuO1xuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfOyAvLyBJZGVhbGx5IHdlIHVzZSBmb3IuLm9mIGhlcmUsIGJ1dCB0aGUgZG93bmNvbXBpbGVkIHZlcnNpb24gaXMgcmVhbGx5IHNsb3cuLi5cblxuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICAgIGlmICggZC5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGQub25CZWNvbWVTdGFsZV8oKTtcbiAgICB9XG5cbiAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcbiAgfSk7IC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNoYW5nZWQgZW5kXCIpO1xufSAvLyBDYWxsZWQgYnkgQ29tcHV0ZWRWYWx1ZSB3aGVuIGl0IHJlY2FsY3VsYXRlIGFuZCBpdHMgdmFsdWUgY2hhbmdlZFxuXG5mdW5jdGlvbiBwcm9wYWdhdGVDaGFuZ2VDb25maXJtZWQob2JzZXJ2YWJsZSkge1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjb25maXJtZWQgc3RhcnRcIik7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV8pIHJldHVybjtcbiAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXykge1xuICAgICAgZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87XG5cbiAgICAgIGlmICggZC5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8gLy8gdGhpcyBoYXBwZW5zIGR1cmluZyBjb21wdXRpbmcgb2YgYGRgLCBqdXN0IGtlZXAgbG93ZXN0T2JzZXJ2ZXJTdGF0ZSB1cCB0byBkYXRlLlxuICAgICkge1xuICAgICAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gICAgICB9XG4gIH0pOyAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjb25maXJtZWQgZW5kXCIpO1xufSAvLyBVc2VkIGJ5IGNvbXB1dGVkIHdoZW4gaXRzIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IHdlIGRvbid0IHdhbid0IHRvIGltbWVkaWF0ZWx5IHJlY29tcHV0ZS5cblxuZnVuY3Rpb24gcHJvcGFnYXRlTWF5YmVDaGFuZ2VkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwibWF5YmUgc3RhcnRcIik7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfICE9PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykgcmV0dXJuO1xuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICAgIGQuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfO1xuICAgICAgZC5vbkJlY29tZVN0YWxlXygpO1xuICAgIH1cbiAgfSk7IC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcIm1heWJlIGVuZFwiKTtcbn1cblxuZnVuY3Rpb24gbG9nVHJhY2VJbmZvKGRlcml2YXRpb24sIG9ic2VydmFibGUpIHtcbiAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJyBpcyBpbnZhbGlkYXRlZCBkdWUgdG8gYSBjaGFuZ2UgaW46ICdcIiArIG9ic2VydmFibGUubmFtZV8gKyBcIidcIik7XG5cbiAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nXyA9PT0gVHJhY2VNb2RlLkJSRUFLKSB7XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgcHJpbnREZXBUcmVlKGdldERlcGVuZGVuY3lUcmVlKGRlcml2YXRpb24pLCBsaW5lcywgMSk7IC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gICAgbmV3IEZ1bmN0aW9uKFwiZGVidWdnZXI7XFxuLypcXG5UcmFjaW5nICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIidcXG5cXG5Zb3UgYXJlIGVudGVyaW5nIHRoaXMgYnJlYWsgcG9pbnQgYmVjYXVzZSBkZXJpdmF0aW9uICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgYmVpbmcgdHJhY2VkIGFuZCAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInIGlzIG5vdyBmb3JjaW5nIGl0IHRvIHVwZGF0ZS5cXG5KdXN0IGZvbGxvdyB0aGUgc3RhY2t0cmFjZSB5b3Ugc2hvdWxkIG5vdyBzZWUgaW4gdGhlIGRldnRvb2xzIHRvIHNlZSBwcmVjaXNlbHkgd2hhdCBwaWVjZSBvZiB5b3VyIGNvZGUgaXMgY2F1c2luZyB0aGlzIHVwZGF0ZVxcblRoZSBzdGFja2ZyYW1lIHlvdSBhcmUgbG9va2luZyBmb3IgaXMgYXQgbGVhc3QgfjYtOCBzdGFjay1mcmFtZXMgdXAuXFxuXFxuXCIgKyAoZGVyaXZhdGlvbiBpbnN0YW5jZW9mIENvbXB1dGVkVmFsdWUgPyBkZXJpdmF0aW9uLmRlcml2YXRpb24udG9TdHJpbmcoKS5yZXBsYWNlKC9bKl1cXC8vZywgXCIvXCIpIDogXCJcIikgKyBcIlxcblxcblRoZSBkZXBlbmRlbmNpZXMgZm9yIHRoaXMgZGVyaXZhdGlvbiBhcmU6XFxuXFxuXCIgKyBsaW5lcy5qb2luKFwiXFxuXCIpICsgXCJcXG4qL1xcbiAgICBcIikoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludERlcFRyZWUodHJlZSwgbGluZXMsIGRlcHRoKSB7XG4gIGlmIChsaW5lcy5sZW5ndGggPj0gMTAwMCkge1xuICAgIGxpbmVzLnB1c2goXCIoYW5kIG1hbnkgbW9yZSlcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGluZXMucHVzaChcIlwiICsgbmV3IEFycmF5KGRlcHRoKS5qb2luKFwiXFx0XCIpICsgdHJlZS5uYW1lKTsgLy8gTVdFOiBub3QgdGhlIGZhc3Rlc3QsIGJ1dCB0aGUgZWFzaWVzdCB3YXkgOilcblxuICBpZiAodHJlZS5kZXBlbmRlbmNpZXMpIHRyZWUuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIHByaW50RGVwVHJlZShjaGlsZCwgbGluZXMsIGRlcHRoICsgMSk7XG4gIH0pO1xufVxuXG52YXIgUmVhY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBub2RlcyB3ZSBhcmUgbG9va2luZyBhdC4gT3VyIHZhbHVlIGRlcGVuZHMgb24gdGhlc2Ugbm9kZXNcbiAgZnVuY3Rpb24gUmVhY3Rpb24obmFtZV8sIG9uSW52YWxpZGF0ZV8sIGVycm9ySGFuZGxlcl8sIHJlcXVpcmVzT2JzZXJ2YWJsZV8pIHtcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSAgXCJSZWFjdGlvbkBcIiArIGdldE5leHRJZCgpIDtcbiAgICB9XG5cbiAgICBpZiAocmVxdWlyZXNPYnNlcnZhYmxlXyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXF1aXJlc09ic2VydmFibGVfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLm9uSW52YWxpZGF0ZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvckhhbmRsZXJfID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWlyZXNPYnNlcnZhYmxlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLm5ld09ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdGhpcy5kaWZmVmFsdWVfID0gMDtcbiAgICB0aGlzLnJ1bklkXyA9IDA7XG4gICAgdGhpcy51bmJvdW5kRGVwc0NvdW50XyA9IDA7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTY2hlZHVsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5pc1RyYWNrUGVuZGluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzUnVubmluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzVHJhY2luZ18gPSBUcmFjZU1vZGUuTk9ORTtcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG4gICAgdGhpcy5vbkludmFsaWRhdGVfID0gb25JbnZhbGlkYXRlXztcbiAgICB0aGlzLmVycm9ySGFuZGxlcl8gPSBlcnJvckhhbmRsZXJfO1xuICAgIHRoaXMucmVxdWlyZXNPYnNlcnZhYmxlXyA9IHJlcXVpcmVzT2JzZXJ2YWJsZV87XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3Rpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbkJlY29tZVN0YWxlXyA9IGZ1bmN0aW9uIG9uQmVjb21lU3RhbGVfKCkge1xuICAgIHRoaXMuc2NoZWR1bGVfKCk7XG4gIH07XG5cbiAgX3Byb3RvLnNjaGVkdWxlXyA9IGZ1bmN0aW9uIHNjaGVkdWxlXygpIHtcbiAgICBpZiAoIXRoaXMuaXNTY2hlZHVsZWRfKSB7XG4gICAgICB0aGlzLmlzU2NoZWR1bGVkXyA9IHRydWU7XG4gICAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICBydW5SZWFjdGlvbnMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmlzU2NoZWR1bGVkID0gZnVuY3Rpb24gaXNTY2hlZHVsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTY2hlZHVsZWRfO1xuICB9XG4gIC8qKlxyXG4gICAqIGludGVybmFsLCB1c2Ugc2NoZWR1bGUoKSBpZiB5b3UgaW50ZW5kIHRvIGtpY2sgb2ZmIGEgcmVhY3Rpb25cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5ydW5SZWFjdGlvbl8gPSBmdW5jdGlvbiBydW5SZWFjdGlvbl8oKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICB0aGlzLmlzU2NoZWR1bGVkXyA9IGZhbHNlO1xuICAgICAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQ7XG4gICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuXG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZSh0aGlzKSkge1xuICAgICAgICB0aGlzLmlzVHJhY2tQZW5kaW5nXyA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLm9uSW52YWxpZGF0ZV8oKTtcblxuICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMuaXNUcmFja1BlbmRpbmdfICYmIGlzU3B5RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAvLyBvbkludmFsaWRhdGUgZGlkbid0IHRyaWdnZXIgdHJhY2sgcmlnaHQgYXdheS4uXG4gICAgICAgICAgICBzcHlSZXBvcnQoe1xuICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICAgICAgICB0eXBlOiBcInNjaGVkdWxlZC1yZWFjdGlvblwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLnJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gcHJldjtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50cmFjayA9IGZ1bmN0aW9uIHRyYWNrKGZuKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZF8pIHtcbiAgICAgIHJldHVybjsgLy8gY29uc29sZS53YXJuKFwiUmVhY3Rpb24gYWxyZWFkeSBkaXNwb3NlZFwiKSAvLyBOb3RlOiBOb3QgYSB3YXJuaW5nIC8gZXJyb3IgaW4gbW9ieCA0IGVpdGhlclxuICAgIH1cblxuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICB2YXIgbm90aWZ5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIHN0YXJ0VGltZTtcblxuICAgIGlmICggbm90aWZ5KSB7XG4gICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBcInJlYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuaXNSdW5uaW5nXyA9IHRydWU7XG4gICAgdmFyIHByZXZSZWFjdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDsgLy8gcmVhY3Rpb25zIGNvdWxkIGNyZWF0ZSByZWFjdGlvbnMuLi5cblxuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdCA9IHRyYWNrRGVyaXZlZEZ1bmN0aW9uKHRoaXMsIGZuLCB1bmRlZmluZWQpO1xuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHByZXZSZWFjdGlvbjtcbiAgICB0aGlzLmlzUnVubmluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzVHJhY2tQZW5kaW5nXyA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZF8pIHtcbiAgICAgIC8vIGRpc3Bvc2VkIGR1cmluZyBsYXN0IHJ1bi4gQ2xlYW4gdXAgZXZlcnl0aGluZyB0aGF0IHdhcyBib3VuZCBhZnRlciB0aGUgZGlzcG9zZSBjYWxsLlxuICAgICAgY2xlYXJPYnNlcnZpbmcodGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpIHRoaXMucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhyZXN1bHQuY2F1c2UpO1xuXG4gICAgaWYgKCBub3RpZnkpIHtcbiAgICAgIHNweVJlcG9ydEVuZCh7XG4gICAgICAgIHRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVuZEJhdGNoKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8gPSBmdW5jdGlvbiByZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKGVycm9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLmVycm9ySGFuZGxlcl8pIHtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyXyhlcnJvciwgdGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpIHRocm93IGVycm9yO1xuICAgIHZhciBtZXNzYWdlID0gIFwiW21vYnhdIEVuY291bnRlcmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiB0aGF0IHdhcyB0aHJvd24gYnkgYSByZWFjdGlvbiBvciBvYnNlcnZlciBjb21wb25lbnQsIGluOiAnXCIgKyB0aGlzICsgXCInXCIgO1xuXG4gICAgaWYgKCFnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGVycm9yKTtcbiAgICAgIC8qKiBJZiBkZWJ1Z2dpbmcgYnJvdWdodCB5b3UgaGVyZSwgcGxlYXNlLCByZWFkIHRoZSBhYm92ZSBtZXNzYWdlIDotKS4gVG54ISAqL1xuICAgIH0gZWxzZSBjb25zb2xlLndhcm4oXCJbbW9ieF0gKGVycm9yIGluIHJlYWN0aW9uICdcIiArIHRoaXMubmFtZV8gKyBcIicgc3VwcHJlc3NlZCwgZml4IGVycm9yIG9mIGNhdXNpbmcgYWN0aW9uIGJlbG93KVwiKTsgLy8gcHJldHRpZXItaWdub3JlXG5cblxuICAgIGlmICggaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgZXJyb3I6IFwiXCIgKyBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmKGVycm9yLCBfdGhpcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkXykge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkXyA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5pc1J1bm5pbmdfKSB7XG4gICAgICAgIC8vIGlmIGRpc3Bvc2VkIHdoaWxlIHJ1bm5pbmcsIGNsZWFuIHVwIGxhdGVyLiBNYXliZSBub3Qgb3B0aW1hbCwgYnV0IHJhcmUgY2FzZVxuICAgICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgICAgICBlbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0RGlzcG9zZXJfID0gZnVuY3Rpb24gZ2V0RGlzcG9zZXJfKCkge1xuICAgIHZhciByID0gdGhpcy5kaXNwb3NlLmJpbmQodGhpcyk7XG4gICAgclskbW9ieF0gPSB0aGlzO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlJlYWN0aW9uW1wiICsgdGhpcy5uYW1lXyArIFwiXVwiO1xuICB9O1xuXG4gIF9wcm90by50cmFjZSA9IGZ1bmN0aW9uIHRyYWNlJDEoZW50ZXJCcmVha1BvaW50KSB7XG4gICAgaWYgKGVudGVyQnJlYWtQb2ludCA9PT0gdm9pZCAwKSB7XG4gICAgICBlbnRlckJyZWFrUG9pbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0cmFjZSh0aGlzLCBlbnRlckJyZWFrUG9pbnQpO1xuICB9O1xuXG4gIHJldHVybiBSZWFjdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIG9uUmVhY3Rpb25FcnJvcihoYW5kbGVyKSB7XG4gIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ID49IDApIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBNYWdpYyBudW1iZXIgYWxlcnQhXHJcbiAqIERlZmluZXMgd2l0aGluIGhvdyBtYW55IHRpbWVzIGEgcmVhY3Rpb24gaXMgYWxsb3dlZCB0byByZS10cmlnZ2VyIGl0c2VsZlxyXG4gKiB1bnRpbCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhpcyBpcyBnb25uYSBiZSBhIG5ldmVyIGVuZGluZyBsb29wLi4uXHJcbiAqL1xuXG52YXIgTUFYX1JFQUNUSU9OX0lURVJBVElPTlMgPSAxMDA7XG5cbnZhciByZWFjdGlvblNjaGVkdWxlciA9IGZ1bmN0aW9uIHJlYWN0aW9uU2NoZWR1bGVyKGYpIHtcbiAgcmV0dXJuIGYoKTtcbn07XG5cbmZ1bmN0aW9uIHJ1blJlYWN0aW9ucygpIHtcbiAgLy8gVHJhbXBvbGluaW5nLCBpZiBydW5SZWFjdGlvbnMgYXJlIGFscmVhZHkgcnVubmluZywgbmV3IHJlYWN0aW9ucyB3aWxsIGJlIHBpY2tlZCB1cFxuICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAgfHwgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zKSByZXR1cm47XG4gIHJlYWN0aW9uU2NoZWR1bGVyKHJ1blJlYWN0aW9uc0hlbHBlcik7XG59XG5cbmZ1bmN0aW9uIHJ1blJlYWN0aW9uc0hlbHBlcigpIHtcbiAgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zID0gdHJ1ZTtcbiAgdmFyIGFsbFJlYWN0aW9ucyA9IGdsb2JhbFN0YXRlLnBlbmRpbmdSZWFjdGlvbnM7XG4gIHZhciBpdGVyYXRpb25zID0gMDsgLy8gV2hpbGUgcnVubmluZyByZWFjdGlvbnMsIG5ldyByZWFjdGlvbnMgbWlnaHQgYmUgdHJpZ2dlcmVkLlxuICAvLyBIZW5jZSB3ZSB3b3JrIHdpdGggdHdvIHZhcmlhYmxlcyBhbmQgY2hlY2sgd2hldGhlclxuICAvLyB3ZSBjb252ZXJnZSB0byBubyByZW1haW5pbmcgcmVhY3Rpb25zIGFmdGVyIGEgd2hpbGUuXG5cbiAgd2hpbGUgKGFsbFJlYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCsraXRlcmF0aW9ucyA9PT0gTUFYX1JFQUNUSU9OX0lURVJBVElPTlMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoIFwiUmVhY3Rpb24gZG9lc24ndCBjb252ZXJnZSB0byBhIHN0YWJsZSBzdGF0ZSBhZnRlciBcIiArIE1BWF9SRUFDVElPTl9JVEVSQVRJT05TICsgXCIgaXRlcmF0aW9ucy5cIiArIChcIiBQcm9iYWJseSB0aGVyZSBpcyBhIGN5Y2xlIGluIHRoZSByZWFjdGl2ZSBmdW5jdGlvbjogXCIgKyBhbGxSZWFjdGlvbnNbMF0pICk7XG4gICAgICBhbGxSZWFjdGlvbnMuc3BsaWNlKDApOyAvLyBjbGVhciByZWFjdGlvbnNcbiAgICB9XG5cbiAgICB2YXIgcmVtYWluaW5nUmVhY3Rpb25zID0gYWxsUmVhY3Rpb25zLnNwbGljZSgwKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVtYWluaW5nUmVhY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVtYWluaW5nUmVhY3Rpb25zW2ldLnJ1blJlYWN0aW9uXygpO1xuICAgIH1cbiAgfVxuXG4gIGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucyA9IGZhbHNlO1xufVxuXG52YXIgaXNSZWFjdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiUmVhY3Rpb25cIiwgUmVhY3Rpb24pO1xuZnVuY3Rpb24gc2V0UmVhY3Rpb25TY2hlZHVsZXIoZm4pIHtcbiAgdmFyIGJhc2VTY2hlZHVsZXIgPSByZWFjdGlvblNjaGVkdWxlcjtcblxuICByZWFjdGlvblNjaGVkdWxlciA9IGZ1bmN0aW9uIHJlYWN0aW9uU2NoZWR1bGVyKGYpIHtcbiAgICByZXR1cm4gZm4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJhc2VTY2hlZHVsZXIoZik7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3B5RW5hYmxlZCgpIHtcbiAgcmV0dXJuICAhIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGg7XG59XG5mdW5jdGlvbiBzcHlSZXBvcnQoZXZlbnQpIHtcblxuICBpZiAoIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGxpc3RlbmVycyA9IGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0oZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBzcHlSZXBvcnRTdGFydChldmVudCkge1xuXG4gIHZhciBjaGFuZ2UgPSBfZXh0ZW5kcyh7fSwgZXZlbnQsIHtcbiAgICBzcHlSZXBvcnRTdGFydDogdHJ1ZVxuICB9KTtcblxuICBzcHlSZXBvcnQoY2hhbmdlKTtcbn1cbnZhciBFTkRfRVZFTlQgPSB7XG4gIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICBzcHlSZXBvcnRFbmQ6IHRydWVcbn07XG5mdW5jdGlvbiBzcHlSZXBvcnRFbmQoY2hhbmdlKSB7XG4gIGlmIChjaGFuZ2UpIHNweVJlcG9ydChfZXh0ZW5kcyh7fSwgY2hhbmdlLCB7XG4gICAgdHlwZTogXCJyZXBvcnQtZW5kXCIsXG4gICAgc3B5UmVwb3J0RW5kOiB0cnVlXG4gIH0pKTtlbHNlIHNweVJlcG9ydChFTkRfRVZFTlQpO1xufVxuZnVuY3Rpb24gc3B5KGxpc3RlbmVyKSB7XG4gIHtcbiAgICBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzID0gZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgICAgICByZXR1cm4gbCAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgQUNUSU9OID0gXCJhY3Rpb25cIjtcbnZhciBBQ1RJT05fQk9VTkQgPSBcImFjdGlvbi5ib3VuZFwiO1xudmFyIEFVVE9BQ1RJT04gPSBcImF1dG9BY3Rpb25cIjtcbnZhciBBVVRPQUNUSU9OX0JPVU5EID0gXCJhdXRvQWN0aW9uLmJvdW5kXCI7XG52YXIgREVGQVVMVF9BQ1RJT05fTkFNRSA9IFwiPHVubmFtZWQgYWN0aW9uPlwiO1xudmFyIGFjdGlvbkFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBQ1RJT04pO1xudmFyIGFjdGlvbkJvdW5kQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFDVElPTl9CT1VORCwge1xuICBib3VuZDogdHJ1ZVxufSk7XG52YXIgYXV0b0FjdGlvbkFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBVVRPQUNUSU9OLCB7XG4gIGF1dG9BY3Rpb246IHRydWVcbn0pO1xudmFyIGF1dG9BY3Rpb25Cb3VuZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBVVRPQUNUSU9OX0JPVU5ELCB7XG4gIGF1dG9BY3Rpb246IHRydWUsXG4gIGJvdW5kOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uRmFjdG9yeShhdXRvQWN0aW9uKSB7XG4gIHZhciByZXMgPSBmdW5jdGlvbiBhY3Rpb24oYXJnMSwgYXJnMikge1xuICAgIC8vIGFjdGlvbihmbigpIHt9KVxuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzEpKSByZXR1cm4gY3JlYXRlQWN0aW9uKGFyZzEubmFtZSB8fCBERUZBVUxUX0FDVElPTl9OQU1FLCBhcmcxLCBhdXRvQWN0aW9uKTsgLy8gYWN0aW9uKFwibmFtZVwiLCBmbigpIHt9KVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oYXJnMikpIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMSwgYXJnMiwgYXV0b0FjdGlvbik7IC8vIEBhY3Rpb25cblxuICAgIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgICAgcmV0dXJuIHN0b3JlQW5ub3RhdGlvbihhcmcxLCBhcmcyLCBhdXRvQWN0aW9uID8gYXV0b0FjdGlvbkFubm90YXRpb24gOiBhY3Rpb25Bbm5vdGF0aW9uKTtcbiAgICB9IC8vIGFjdGlvbihcIm5hbWVcIikgJiBAYWN0aW9uKFwibmFtZVwiKVxuXG5cbiAgICBpZiAoaXNTdHJpbmdpc2goYXJnMSkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGNyZWF0ZUFjdGlvbkFubm90YXRpb24oYXV0b0FjdGlvbiA/IEFVVE9BQ1RJT04gOiBBQ1RJT04sIHtcbiAgICAgICAgbmFtZTogYXJnMSxcbiAgICAgICAgYXV0b0FjdGlvbjogYXV0b0FjdGlvblxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGRpZShcIkludmFsaWQgYXJndW1lbnRzIGZvciBgYWN0aW9uYFwiKTtcbiAgfTtcblxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgYWN0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkZhY3RvcnkoZmFsc2UpO1xuT2JqZWN0LmFzc2lnbihhY3Rpb24sIGFjdGlvbkFubm90YXRpb24pO1xudmFyIGF1dG9BY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uRmFjdG9yeSh0cnVlKTtcbk9iamVjdC5hc3NpZ24oYXV0b0FjdGlvbiwgYXV0b0FjdGlvbkFubm90YXRpb24pO1xuYWN0aW9uLmJvdW5kID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oYWN0aW9uQm91bmRBbm5vdGF0aW9uKTtcbmF1dG9BY3Rpb24uYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhdXRvQWN0aW9uQm91bmRBbm5vdGF0aW9uKTtcbmZ1bmN0aW9uIHJ1bkluQWN0aW9uKGZuKSB7XG4gIHJldHVybiBleGVjdXRlQWN0aW9uKGZuLm5hbWUgfHwgREVGQVVMVF9BQ1RJT05fTkFNRSwgZmFsc2UsIGZuLCB0aGlzLCB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaXNBY3Rpb24odGhpbmcpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odGhpbmcpICYmIHRoaW5nLmlzTW9ieEFjdGlvbiA9PT0gdHJ1ZTtcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuYW1lZCByZWFjdGl2ZSB2aWV3IGFuZCBrZWVwcyBpdCBhbGl2ZSwgc28gdGhhdCB0aGUgdmlldyBpcyBhbHdheXNcclxuICogdXBkYXRlZCBpZiBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzLCBldmVuIHdoZW4gdGhlIHZpZXcgaXMgbm90IGZ1cnRoZXIgdXNlZCBieSBzb21ldGhpbmcgZWxzZS5cclxuICogQHBhcmFtIHZpZXcgVGhlIHJlYWN0aXZlIHZpZXdcclxuICogQHJldHVybnMgZGlzcG9zZXIgZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHN0b3AgdGhlIHZpZXcgZnJvbSBiZWluZyB1cGRhdGVkIGluIHRoZSBmdXR1cmUuXHJcbiAqL1xuXG5mdW5jdGlvbiBhdXRvcnVuKHZpZXcsIG9wdHMpIHtcbiAgdmFyIF9vcHRzJG5hbWUsIF9vcHRzO1xuXG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gRU1QVFlfT0JKRUNUO1xuICB9XG5cbiAge1xuICAgIGlmICghaXNGdW5jdGlvbih2aWV3KSkgZGllKFwiQXV0b3J1biBleHBlY3RzIGEgZnVuY3Rpb24gYXMgZmlyc3QgYXJndW1lbnRcIik7XG4gICAgaWYgKGlzQWN0aW9uKHZpZXcpKSBkaWUoXCJBdXRvcnVuIGRvZXMgbm90IGFjY2VwdCBhY3Rpb25zIHNpbmNlIGFjdGlvbnMgYXJlIHVudHJhY2thYmxlXCIpO1xuICB9XG5cbiAgdmFyIG5hbWUgPSAoX29wdHMkbmFtZSA9IChfb3B0cyA9IG9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZSA6ICB2aWV3Lm5hbWUgfHwgXCJBdXRvcnVuQFwiICsgZ2V0TmV4dElkKCkgO1xuICB2YXIgcnVuU3luYyA9ICFvcHRzLnNjaGVkdWxlciAmJiAhb3B0cy5kZWxheTtcbiAgdmFyIHJlYWN0aW9uO1xuXG4gIGlmIChydW5TeW5jKSB7XG4gICAgLy8gbm9ybWFsIGF1dG9ydW5cbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcbiAgICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cyk7IC8vIGRlYm91bmNlZCBhdXRvcnVuXG5cbiAgICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgc2NoZWR1bGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghcmVhY3Rpb24uaXNEaXNwb3NlZF8pIHJlYWN0aW9uLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGlvblJ1bm5lcigpIHtcbiAgICB2aWV3KHJlYWN0aW9uKTtcbiAgfVxuXG4gIHJlYWN0aW9uLnNjaGVkdWxlXygpO1xuICByZXR1cm4gcmVhY3Rpb24uZ2V0RGlzcG9zZXJfKCk7XG59XG5cbnZhciBydW4gPSBmdW5jdGlvbiBydW4oZikge1xuICByZXR1cm4gZigpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cykge1xuICByZXR1cm4gb3B0cy5zY2hlZHVsZXIgPyBvcHRzLnNjaGVkdWxlciA6IG9wdHMuZGVsYXkgPyBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIG9wdHMuZGVsYXkpO1xuICB9IDogcnVuO1xufVxuXG5mdW5jdGlvbiByZWFjdGlvbihleHByZXNzaW9uLCBlZmZlY3QsIG9wdHMpIHtcbiAgdmFyIF9vcHRzJG5hbWUyO1xuXG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gRU1QVFlfT0JKRUNUO1xuICB9XG5cbiAge1xuICAgIGlmICghaXNGdW5jdGlvbihleHByZXNzaW9uKSB8fCAhaXNGdW5jdGlvbihlZmZlY3QpKSBkaWUoXCJGaXJzdCBhbmQgc2Vjb25kIGFyZ3VtZW50IHRvIHJlYWN0aW9uIHNob3VsZCBiZSBmdW5jdGlvbnNcIik7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KG9wdHMpKSBkaWUoXCJUaGlyZCBhcmd1bWVudCBvZiByZWFjdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgfVxuXG4gIHZhciBuYW1lID0gKF9vcHRzJG5hbWUyID0gb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZTIgOiAgXCJSZWFjdGlvbkBcIiArIGdldE5leHRJZCgpIDtcbiAgdmFyIGVmZmVjdEFjdGlvbiA9IGFjdGlvbihuYW1lLCBvcHRzLm9uRXJyb3IgPyB3cmFwRXJyb3JIYW5kbGVyKG9wdHMub25FcnJvciwgZWZmZWN0KSA6IGVmZmVjdCk7XG4gIHZhciBydW5TeW5jID0gIW9wdHMuc2NoZWR1bGVyICYmICFvcHRzLmRlbGF5O1xuICB2YXIgc2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cyk7XG4gIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgb2xkVmFsdWUgPSB1bmRlZmluZWQ7IC8vIG9ubHkgYW4gaXNzdWUgd2l0aCBmaXJlSW1tZWRpYXRlbHlcblxuICB2YXIgZXF1YWxzID0gb3B0cy5jb21wYXJlU3RydWN0dXJhbCA/IGNvbXBhcmVyLnN0cnVjdHVyYWwgOiBvcHRzLmVxdWFscyB8fCBjb21wYXJlcltcImRlZmF1bHRcIl07XG4gIHZhciByID0gbmV3IFJlYWN0aW9uKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmlyc3RUaW1lIHx8IHJ1blN5bmMpIHtcbiAgICAgIHJlYWN0aW9uUnVubmVyKCk7XG4gICAgfSBlbHNlIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlcihyZWFjdGlvblJ1bm5lcik7XG4gICAgfVxuICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcblxuICBmdW5jdGlvbiByZWFjdGlvblJ1bm5lcigpIHtcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmIChyLmlzRGlzcG9zZWRfKSByZXR1cm47XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICByLnRyYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBhbGxvd1N0YXRlQ2hhbmdlcyhmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbihyKTtcbiAgICAgIH0pO1xuICAgICAgY2hhbmdlZCA9IGZpcnN0VGltZSB8fCAhZXF1YWxzKHZhbHVlLCBuZXh0VmFsdWUpO1xuICAgICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH0pO1xuICAgIGlmIChmaXJzdFRpbWUgJiYgb3B0cy5maXJlSW1tZWRpYXRlbHkpIGVmZmVjdEFjdGlvbih2YWx1ZSwgb2xkVmFsdWUsIHIpO2Vsc2UgaWYgKCFmaXJzdFRpbWUgJiYgY2hhbmdlZCkgZWZmZWN0QWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSwgcik7XG4gICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gIH1cblxuICByLnNjaGVkdWxlXygpO1xuICByZXR1cm4gci5nZXREaXNwb3Nlcl8oKTtcbn1cblxuZnVuY3Rpb24gd3JhcEVycm9ySGFuZGxlcihlcnJvckhhbmRsZXIsIGJhc2VGbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYmFzZUZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JIYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgT05fQkVDT01FX09CU0VSVkVEID0gXCJvbkJPXCI7XG52YXIgT05fQkVDT01FX1VOT0JTRVJWRUQgPSBcIm9uQlVPXCI7XG5mdW5jdGlvbiBvbkJlY29tZU9ic2VydmVkKHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHJldHVybiBpbnRlcmNlcHRIb29rKE9OX0JFQ09NRV9PQlNFUlZFRCwgdGhpbmcsIGFyZzIsIGFyZzMpO1xufVxuZnVuY3Rpb24gb25CZWNvbWVVbm9ic2VydmVkKHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHJldHVybiBpbnRlcmNlcHRIb29rKE9OX0JFQ09NRV9VTk9CU0VSVkVELCB0aGluZywgYXJnMiwgYXJnMyk7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdEhvb2soaG9vaywgdGhpbmcsIGFyZzIsIGFyZzMpIHtcbiAgdmFyIGF0b20gPSB0eXBlb2YgYXJnMyA9PT0gXCJmdW5jdGlvblwiID8gZ2V0QXRvbSh0aGluZywgYXJnMikgOiBnZXRBdG9tKHRoaW5nKTtcbiAgdmFyIGNiID0gaXNGdW5jdGlvbihhcmczKSA/IGFyZzMgOiBhcmcyO1xuICB2YXIgbGlzdGVuZXJzS2V5ID0gaG9vayArIFwiTFwiO1xuXG4gIGlmIChhdG9tW2xpc3RlbmVyc0tleV0pIHtcbiAgICBhdG9tW2xpc3RlbmVyc0tleV0uYWRkKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBhdG9tW2xpc3RlbmVyc0tleV0gPSBuZXcgU2V0KFtjYl0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9va0xpc3RlbmVycyA9IGF0b21bbGlzdGVuZXJzS2V5XTtcblxuICAgIGlmIChob29rTGlzdGVuZXJzKSB7XG4gICAgICBob29rTGlzdGVuZXJzW1wiZGVsZXRlXCJdKGNiKTtcblxuICAgICAgaWYgKGhvb2tMaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgYXRvbVtsaXN0ZW5lcnNLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIE5FVkVSID0gXCJuZXZlclwiO1xudmFyIEFMV0FZUyA9IFwiYWx3YXlzXCI7XG52YXIgT0JTRVJWRUQgPSBcIm9ic2VydmVkXCI7IC8vIGNvbnN0IElGX0FWQUlMQUJMRSA9IFwiaWZhdmFpbGFibGVcIlxuXG5mdW5jdGlvbiBjb25maWd1cmUob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5pc29sYXRlR2xvYmFsU3RhdGUgPT09IHRydWUpIHtcbiAgICBpc29sYXRlR2xvYmFsU3RhdGUoKTtcbiAgfVxuXG4gIHZhciB1c2VQcm94aWVzID0gb3B0aW9ucy51c2VQcm94aWVzLFxuICAgICAgZW5mb3JjZUFjdGlvbnMgPSBvcHRpb25zLmVuZm9yY2VBY3Rpb25zO1xuXG4gIGlmICh1c2VQcm94aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbG9iYWxTdGF0ZS51c2VQcm94aWVzID0gdXNlUHJveGllcyA9PT0gQUxXQVlTID8gdHJ1ZSA6IHVzZVByb3hpZXMgPT09IE5FVkVSID8gZmFsc2UgOiB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCI7XG4gIH1cblxuICBpZiAodXNlUHJveGllcyA9PT0gXCJpZmF2YWlsYWJsZVwiKSBnbG9iYWxTdGF0ZS52ZXJpZnlQcm94aWVzID0gdHJ1ZTtcblxuICBpZiAoZW5mb3JjZUFjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlYSA9IGVuZm9yY2VBY3Rpb25zID09PSBBTFdBWVMgPyBBTFdBWVMgOiBlbmZvcmNlQWN0aW9ucyA9PT0gT0JTRVJWRUQ7XG4gICAgZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPSBlYTtcbiAgICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IGVhID09PSB0cnVlIHx8IGVhID09PSBBTFdBWVMgPyBmYWxzZSA6IHRydWU7XG4gIH1cbiAgW1wiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsIFwicmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGVcIiwgXCJvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvblwiLCBcImRpc2FibGVFcnJvckJvdW5kYXJpZXNcIiwgXCJzYWZlRGVzY3JpcHRvcnNcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvcHRpb25zKSBnbG9iYWxTdGF0ZVtrZXldID0gISFvcHRpb25zW2tleV07XG4gIH0pO1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgPSAhZ2xvYmFsU3RhdGUub2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb247XG5cbiAgaWYgKCBnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiV0FSTklORzogRGVidWcgZmVhdHVyZSBvbmx5LiBNb2JYIHdpbGwgTk9UIHJlY292ZXIgZnJvbSBlcnJvcnMgd2hlbiBgZGlzYWJsZUVycm9yQm91bmRhcmllc2AgaXMgZW5hYmxlZC5cIik7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWFjdGlvblNjaGVkdWxlcikge1xuICAgIHNldFJlYWN0aW9uU2NoZWR1bGVyKG9wdGlvbnMucmVhY3Rpb25TY2hlZHVsZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZE9ic2VydmFibGUodGFyZ2V0LCBwcm9wZXJ0aWVzLCBhbm5vdGF0aW9ucywgb3B0aW9ucykge1xuICB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiA0KSBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgZXhwZWN0ZWQgMi00IGFyZ3VtZW50c1wiKTtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIikgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIGV4cGVjdHMgYW4gb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50XCIpO1xuICAgIGlmIChpc09ic2VydmFibGVNYXAodGFyZ2V0KSkgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIHNob3VsZCBub3QgYmUgdXNlZCBvbiBtYXBzLCB1c2UgbWFwLm1lcmdlIGluc3RlYWRcIik7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHByb3BlcnRpZXMpKSBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJlJyBvbmx5IGFjY2VwdHMgcGxhaW4gb2JqZWN0cyBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZShwcm9wZXJ0aWVzKSB8fCBpc09ic2VydmFibGUoYW5ub3RhdGlvbnMpKSBkaWUoXCJFeHRlbmRpbmcgYW4gb2JqZWN0IHdpdGggYW5vdGhlciBvYnNlcnZhYmxlIChvYmplY3QpIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gIH0gLy8gUHVsbCBkZXNjcmlwdG9ycyBmaXJzdCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBkZWFsIHdpdGggcHJvcHMgYWRkZWQgYnkgYWRtaW5pc3RyYXRpb24gKCRtb2J4KVxuXG5cbiAgdmFyIGRlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhwcm9wZXJ0aWVzKTtcbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTtcbiAgc3RhcnRCYXRjaCgpO1xuXG4gIHRyeSB7XG4gICAgb3duS2V5cyhkZXNjcmlwdG9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBhZG0uZXh0ZW5kXyhrZXksIGRlc2NyaXB0b3JzW2tleV0sIC8vIG11c3QgcGFzcyBcInVuZGVmaW5lZFwiIGZvciB7IGtleTogdW5kZWZpbmVkIH1cbiAgICAgICFhbm5vdGF0aW9ucyA/IHRydWUgOiBrZXkgaW4gYW5ub3RhdGlvbnMgPyBhbm5vdGF0aW9uc1trZXldIDogdHJ1ZSk7XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgZW5kQmF0Y2goKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGdldERlcGVuZGVuY3lUcmVlKHRoaW5nLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gbm9kZVRvRGVwZW5kZW5jeVRyZWUoZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbn1cblxuZnVuY3Rpb24gbm9kZVRvRGVwZW5kZW5jeVRyZWUobm9kZSkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIG5hbWU6IG5vZGUubmFtZV9cbiAgfTtcbiAgaWYgKG5vZGUub2JzZXJ2aW5nXyAmJiBub2RlLm9ic2VydmluZ18ubGVuZ3RoID4gMCkgcmVzdWx0LmRlcGVuZGVuY2llcyA9IHVuaXF1ZShub2RlLm9ic2VydmluZ18pLm1hcChub2RlVG9EZXBlbmRlbmN5VHJlZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldE9ic2VydmVyVHJlZSh0aGluZywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG5vZGVUb09ic2VydmVyVHJlZShnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xufVxuXG5mdW5jdGlvbiBub2RlVG9PYnNlcnZlclRyZWUobm9kZSkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIG5hbWU6IG5vZGUubmFtZV9cbiAgfTtcbiAgaWYgKGhhc09ic2VydmVycyhub2RlKSkgcmVzdWx0Lm9ic2VydmVycyA9IEFycmF5LmZyb20oZ2V0T2JzZXJ2ZXJzKG5vZGUpKS5tYXAobm9kZVRvT2JzZXJ2ZXJUcmVlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsaXN0KSk7XG59XG5cbnZhciBnZW5lcmF0b3JJZCA9IDA7XG5mdW5jdGlvbiBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHRoaXMubWVzc2FnZSA9IFwiRkxPV19DQU5DRUxMRURcIjtcbn1cbkZsb3dDYW5jZWxsYXRpb25FcnJvci5wcm90b3R5cGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuZnVuY3Rpb24gaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRmxvd0NhbmNlbGxhdGlvbkVycm9yO1xufVxudmFyIGZsb3dBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUZsb3dBbm5vdGF0aW9uKFwiZmxvd1wiKTtcbnZhciBmbG93Qm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUZsb3dBbm5vdGF0aW9uKFwiZmxvdy5ib3VuZFwiLCB7XG4gIGJvdW5kOiB0cnVlXG59KTtcbnZhciBmbG93ID0gLyojX19QVVJFX18qL09iamVjdC5hc3NpZ24oZnVuY3Rpb24gZmxvdyhhcmcxLCBhcmcyKSB7XG4gIC8vIEBmbG93XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgZmxvd0Fubm90YXRpb24pO1xuICB9IC8vIGZsb3coZm4pXG5cblxuICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIGRpZShcIkZsb3cgZXhwZWN0cyBzaW5nbGUgYXJndW1lbnQgd2l0aCBnZW5lcmF0b3IgZnVuY3Rpb25cIik7XG4gIHZhciBnZW5lcmF0b3IgPSBhcmcxO1xuICB2YXIgbmFtZSA9IGdlbmVyYXRvci5uYW1lIHx8IFwiPHVubmFtZWQgZmxvdz5cIjsgLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RqL2NvL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5cbiAgdmFyIHJlcyA9IGZ1bmN0aW9uIHJlcygpIHtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcnVuSWQgPSArK2dlbmVyYXRvcklkO1xuICAgIHZhciBnZW4gPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIGluaXRcIiwgZ2VuZXJhdG9yKS5hcHBseShjdHgsIGFyZ3MpO1xuICAgIHZhciByZWplY3RvcjtcbiAgICB2YXIgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgc3RlcElkID0gMDtcbiAgICAgIHJlamVjdG9yID0gcmVqZWN0O1xuXG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXMpIHtcbiAgICAgICAgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIHlpZWxkIFwiICsgc3RlcElkKyssIGdlbi5uZXh0KS5jYWxsKGdlbiwgcmVzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KHJldCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyKSB7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0ID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSB5aWVsZCBcIiArIHN0ZXBJZCsrLCBnZW5bXCJ0aHJvd1wiXSkuY2FsbChnZW4sIGVycik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0KHJldCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHJldC50aGVuKSkge1xuICAgICAgICAgIC8vIGFuIGFzeW5jIGl0ZXJhdG9yXG4gICAgICAgICAgcmV0LnRoZW4obmV4dCwgcmVqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0LmRvbmUpIHJldHVybiByZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgb25GdWxmaWxsZWQodW5kZWZpbmVkKTsgLy8ga2ljayBvZmYgdGhlIHByb2Nlc3NcbiAgICB9KTtcbiAgICBwcm9taXNlLmNhbmNlbCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0gY2FuY2VsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkgY2FuY2VsUHJvbWlzZShwZW5kaW5nUHJvbWlzZSk7IC8vIEZpbmFsbHkgYmxvY2sgY2FuIHJldHVybiAob3IgeWllbGQpIHN0dWZmLi5cblxuICAgICAgICB2YXIgX3JlcyA9IGdlbltcInJldHVyblwiXSh1bmRlZmluZWQpOyAvLyBlYXQgYW55dGhpbmcgdGhhdCBwcm9taXNlIHdvdWxkIGRvLCBpdCdzIGNhbmNlbGxlZCFcblxuXG4gICAgICAgIHZhciB5aWVsZGVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShfcmVzLnZhbHVlKTtcbiAgICAgICAgeWllbGRlZFByb21pc2UudGhlbihub29wLCBub29wKTtcbiAgICAgICAgY2FuY2VsUHJvbWlzZSh5aWVsZGVkUHJvbWlzZSk7IC8vIG1heWJlIGl0IGNhbiBiZSBjYW5jZWxsZWQgOilcbiAgICAgICAgLy8gcmVqZWN0IG91ciBvcmlnaW5hbCBwcm9taXNlXG5cbiAgICAgICAgcmVqZWN0b3IobmV3IEZsb3dDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0b3IoZSk7IC8vIHRoZXJlIGNvdWxkIGJlIGEgdGhyb3dpbmcgZmluYWxseSBibG9ja1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJlcy5pc01vYlhGbG93ID0gdHJ1ZTtcbiAgcmV0dXJuIHJlcztcbn0sIGZsb3dBbm5vdGF0aW9uKTtcbmZsb3cuYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihmbG93Qm91bmRBbm5vdGF0aW9uKTtcblxuZnVuY3Rpb24gY2FuY2VsUHJvbWlzZShwcm9taXNlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHByb21pc2UuY2FuY2VsKSkgcHJvbWlzZS5jYW5jZWwoKTtcbn1cblxuZnVuY3Rpb24gZmxvd1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdDsgLy8ganVzdCB0cmlja2luZyBUeXBlU2NyaXB0IDopXG59XG5mdW5jdGlvbiBpc0Zsb3coZm4pIHtcbiAgcmV0dXJuIChmbiA9PSBudWxsID8gdm9pZCAwIDogZm4uaXNNb2JYRmxvdykgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdFJlYWRzKHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIHZhciB0YXJnZXQ7XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVZhbHVlKHRoaW5nKSkge1xuICAgIHRhcmdldCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpKSB7XG4gICAgaWYgKCAhaXNTdHJpbmdpc2gocHJvcE9ySGFuZGxlcikpIHJldHVybiBkaWUoXCJJbnRlcmNlcHRSZWFkcyBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBzcGVjaWZpYyBwcm9wZXJ0eSwgbm90IHdpdGggYW4gb2JqZWN0IGluIGdlbmVyYWxcIik7XG4gICAgdGFyZ2V0ID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BPckhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaWUoXCJFeHBlY3RlZCBvYnNlcnZhYmxlIG1hcCwgb2JqZWN0IG9yIGFycmF5IGFzIGZpcnN0IGFycmF5XCIpO1xuICB9XG5cbiAgaWYgKCB0YXJnZXQuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGRpZShcIkFuIGludGVyY2VwdCByZWFkZXIgd2FzIGFscmVhZHkgZXN0YWJsaXNoZWRcIik7XG4gIHRhcmdldC5kZWhhbmNlciA9IHR5cGVvZiBwcm9wT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wT3JIYW5kbGVyIDogaGFuZGxlcjtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0YXJnZXQuZGVoYW5jZXIgPSB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdCh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcikge1xuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkgcmV0dXJuIGludGVyY2VwdFByb3BlcnR5KHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKTtlbHNlIHJldHVybiBpbnRlcmNlcHRJbnRlcmNlcHRhYmxlKHRoaW5nLCBwcm9wT3JIYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSh0aGluZywgaGFuZGxlcikge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpLmludGVyY2VwdF8oaGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdFByb3BlcnR5KHRoaW5nLCBwcm9wZXJ0eSwgaGFuZGxlcikge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KS5pbnRlcmNlcHRfKGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBfaXNDb21wdXRlZCh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbHVlWyRtb2J4XS52YWx1ZXNfLmhhcyhwcm9wZXJ0eSkpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgYXRvbSA9IGdldEF0b20odmFsdWUsIHByb3BlcnR5KTtcbiAgICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKGF0b20pO1xuICB9XG5cbiAgcmV0dXJuIGlzQ29tcHV0ZWRWYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0NvbXB1dGVkKHZhbHVlKSB7XG4gIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBkaWUoXCJpc0NvbXB1dGVkIGV4cGVjdHMgb25seSAxIGFyZ3VtZW50LiBVc2UgaXNDb21wdXRlZFByb3AgdG8gaW5zcGVjdCB0aGUgb2JzZXJ2YWJpbGl0eSBvZiBhIHByb3BlcnR5XCIpO1xuICByZXR1cm4gX2lzQ29tcHV0ZWQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNDb21wdXRlZFByb3AodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmICggIWlzU3RyaW5naXNoKHByb3BOYW1lKSkgcmV0dXJuIGRpZShcImlzQ29tcHV0ZWQgZXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgcmV0dXJuIF9pc0NvbXB1dGVkKHZhbHVlLCBwcm9wTmFtZSk7XG59XG5cbmZ1bmN0aW9uIF9pc09ic2VydmFibGUodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcblxuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICggKGlzT2JzZXJ2YWJsZU1hcCh2YWx1ZSkgfHwgaXNPYnNlcnZhYmxlQXJyYXkodmFsdWUpKSkgcmV0dXJuIGRpZShcImlzT2JzZXJ2YWJsZShvYmplY3QsIHByb3BlcnR5TmFtZSkgaXMgbm90IHN1cHBvcnRlZCBmb3IgYXJyYXlzIGFuZCBtYXBzLiBVc2UgbWFwLmhhcyBvciBhcnJheS5sZW5ndGggaW5zdGVhZC5cIik7XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlWyRtb2J4XS52YWx1ZXNfLmhhcyhwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEZvciBmaXJzdCBjaGVjaywgc2VlICM3MDFcblxuXG4gIHJldHVybiBpc09ic2VydmFibGVPYmplY3QodmFsdWUpIHx8ICEhdmFsdWVbJG1vYnhdIHx8IGlzQXRvbSh2YWx1ZSkgfHwgaXNSZWFjdGlvbih2YWx1ZSkgfHwgaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHZhbHVlKSB7XG4gIGlmICggYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgZGllKFwiaXNPYnNlcnZhYmxlIGV4cGVjdHMgb25seSAxIGFyZ3VtZW50LiBVc2UgaXNPYnNlcnZhYmxlUHJvcCB0byBpbnNwZWN0IHRoZSBvYnNlcnZhYmlsaXR5IG9mIGEgcHJvcGVydHlcIik7XG4gIHJldHVybiBfaXNPYnNlcnZhYmxlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZVByb3AodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmICggIWlzU3RyaW5naXNoKHByb3BOYW1lKSkgcmV0dXJuIGRpZShcImV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gIHJldHVybiBfaXNPYnNlcnZhYmxlKHZhbHVlLCBwcm9wTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGtleXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmtleXNfKCk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikgfHwgaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmoua2V5cygpKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSk7XG4gIH1cblxuICBkaWUoNSk7XG59XG5mdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBvYmouZ2V0KGtleSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmoudmFsdWVzKCkpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH1cblxuICBkaWUoNik7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqW2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iai5nZXQoa2V5KV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmouZW50cmllcygpKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBbaW5kZXgsIGtleV07XG4gICAgfSk7XG4gIH1cblxuICBkaWUoNyk7XG59XG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICB2YXIgX3ZhbHVlcyA9IGtleTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIF92YWx1ZXMpIHtcbiAgICAgICAgc2V0KG9iaiwgX2tleSwgX3ZhbHVlc1tfa2V5XSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgb2JqWyRtb2J4XS5zZXRfKGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgb2JqLnNldChrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIG9iai5hZGQoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIGlmIChrZXkgPCAwKSBkaWUoXCJJbnZhbGlkIGluZGV4OiAnXCIgKyBrZXkgKyBcIidcIik7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIGlmIChrZXkgPj0gb2JqLmxlbmd0aCkgb2JqLmxlbmd0aCA9IGtleSArIDE7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICBlbmRCYXRjaCgpO1xuICB9IGVsc2UgZGllKDgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlKG9iaiwga2V5KSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIG9ialskbW9ieF0uZGVsZXRlXyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgb2JqW1wiZGVsZXRlXCJdKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBvYmpbXCJkZWxldGVcIl0oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIG9iai5zcGxpY2Uoa2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBkaWUoOSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5oYXNfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmhhcyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIG9iai5oYXMoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIGtleSA+PSAwICYmIGtleSA8IG9iai5sZW5ndGg7XG4gIH1cblxuICBkaWUoMTApO1xufVxuZnVuY3Rpb24gZ2V0KG9iaiwga2V5KSB7XG4gIGlmICghaGFzKG9iaiwga2V5KSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5nZXRfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmdldChrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cblxuICBkaWUoMTEpO1xufVxuZnVuY3Rpb24gYXBpRGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0uZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvcik7XG4gIH1cblxuICBkaWUoMzkpO1xufVxuZnVuY3Rpb24gYXBpT3duS2V5cyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0ub3duS2V5c18oKTtcbiAgfVxuXG4gIGRpZSgzOCk7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmUodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIGlmIChpc0Z1bmN0aW9uKGNiT3JGaXJlKSkgcmV0dXJuIG9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSwgZmlyZUltbWVkaWF0ZWx5KTtlbHNlIHJldHVybiBvYnNlcnZlT2JzZXJ2YWJsZSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlKTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZU9ic2VydmFibGUodGhpbmcsIGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKS5vYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZU9ic2VydmFibGVQcm9wZXJ0eSh0aGluZywgcHJvcGVydHksIGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkub2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSk7XG59XG5cbmZ1bmN0aW9uIGNhY2hlKG1hcCwga2V5LCB2YWx1ZSkge1xuICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRvSlNIZWxwZXIoc291cmNlLCBfX2FscmVhZHlTZWVuKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCB8fCB0eXBlb2Ygc291cmNlICE9PSBcIm9iamVjdFwiIHx8IHNvdXJjZSBpbnN0YW5jZW9mIERhdGUgfHwgIWlzT2JzZXJ2YWJsZShzb3VyY2UpKSByZXR1cm4gc291cmNlO1xuICBpZiAoaXNPYnNlcnZhYmxlVmFsdWUoc291cmNlKSB8fCBpc0NvbXB1dGVkVmFsdWUoc291cmNlKSkgcmV0dXJuIHRvSlNIZWxwZXIoc291cmNlLmdldCgpLCBfX2FscmVhZHlTZWVuKTtcblxuICBpZiAoX19hbHJlYWR5U2Vlbi5oYXMoc291cmNlKSkge1xuICAgIHJldHVybiBfX2FscmVhZHlTZWVuLmdldChzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHNvdXJjZSkpIHtcbiAgICB2YXIgcmVzID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICByZXNbaWR4XSA9IHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KHNvdXJjZSkpIHtcbiAgICB2YXIgX3JlcyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwgbmV3IFNldCgpKTtcblxuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgX3Jlcy5hZGQodG9KU0hlbHBlcih2YWx1ZSwgX19hbHJlYWR5U2VlbikpO1xuICAgIH0pO1xuICAgIHJldHVybiBfcmVzO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChzb3VyY2UpKSB7XG4gICAgdmFyIF9yZXMyID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgTWFwKCkpO1xuXG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIF9yZXMyLnNldChrZXksIHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3JlczI7XG4gIH0gZWxzZSB7XG4gICAgLy8gbXVzdCBiZSBvYnNlcnZhYmxlIG9iamVjdFxuICAgIHZhciBfcmVzMyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwge30pO1xuXG4gICAgYXBpT3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKG9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICBfcmVzM1trZXldID0gdG9KU0hlbHBlcihzb3VyY2Vba2V5XSwgX19hbHJlYWR5U2Vlbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZXMzO1xuICB9XG59XG4vKipcclxuICogQmFzaWNhbGx5LCBhIGRlZXAgY2xvbmUsIHNvIHRoYXQgbm8gcmVhY3RpdmUgcHJvcGVydHkgd2lsbCBleGlzdCBhbnltb3JlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiB0b0pTKHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMpIGRpZShcInRvSlMgbm8gbG9uZ2VyIHN1cHBvcnRzIG9wdGlvbnNcIik7XG4gIHJldHVybiB0b0pTSGVscGVyKHNvdXJjZSwgbmV3IE1hcCgpKTtcbn1cblxuZnVuY3Rpb24gdHJhY2UoKSB7XG4gIHZhciBlbnRlckJyZWFrUG9pbnQgPSBmYWxzZTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiYm9vbGVhblwiKSBlbnRlckJyZWFrUG9pbnQgPSBhcmdzLnBvcCgpO1xuICB2YXIgZGVyaXZhdGlvbiA9IGdldEF0b21Gcm9tQXJncyhhcmdzKTtcblxuICBpZiAoIWRlcml2YXRpb24pIHtcbiAgICByZXR1cm4gZGllKFwiJ3RyYWNlKGJyZWFrPyknIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgdHJhY2tlZCBjb21wdXRlZCB2YWx1ZSBvciBhIFJlYWN0aW9uLiBDb25zaWRlciBwYXNzaW5nIGluIHRoZSBjb21wdXRlZCB2YWx1ZSBvciByZWFjdGlvbiBleHBsaWNpdGx5XCIpO1xuICB9XG5cbiAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nXyA9PT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIHRyYWNpbmcgZW5hYmxlZFwiKTtcbiAgfVxuXG4gIGRlcml2YXRpb24uaXNUcmFjaW5nXyA9IGVudGVyQnJlYWtQb2ludCA/IFRyYWNlTW9kZS5CUkVBSyA6IFRyYWNlTW9kZS5MT0c7XG59XG5cbmZ1bmN0aW9uIGdldEF0b21Gcm9tQXJncyhhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGdldEF0b20oYXJnc1swXSk7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxufVxuXG4vKipcclxuICogRHVyaW5nIGEgdHJhbnNhY3Rpb24gbm8gdmlld3MgYXJlIHVwZGF0ZWQgdW50aWwgdGhlIGVuZCBvZiB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJ1biBzeW5jaHJvbm91c2x5IG5vbmV0aGVsZXNzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIGEgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHNvbWUgcmVhY3RpdmUgc3RhdGVcclxuICogQHJldHVybnMgYW55IHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSAnYWN0aW9uJyBwYXJhbWV0ZXIuXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2FjdGlvbihhY3Rpb24sIHRoaXNBcmcpIHtcbiAgaWYgKHRoaXNBcmcgPT09IHZvaWQgMCkge1xuICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBzdGFydEJhdGNoKCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYWN0aW9uLmFwcGx5KHRoaXNBcmcpO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJnMSAmJiB0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIHdoZW5Qcm9taXNlKHByZWRpY2F0ZSwgYXJnMSk7XG4gIHJldHVybiBfd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIgfHwge30pO1xufVxuXG5mdW5jdGlvbiBfd2hlbihwcmVkaWNhdGUsIGVmZmVjdCwgb3B0cykge1xuICB2YXIgdGltZW91dEhhbmRsZTtcblxuICBpZiAodHlwZW9mIG9wdHMudGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIldIRU5fVElNRU9VVFwiKTtcbiAgICB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWRpc3Bvc2VyWyRtb2J4XS5pc0Rpc3Bvc2VkXykge1xuICAgICAgICBkaXNwb3NlcigpO1xuICAgICAgICBpZiAob3B0cy5vbkVycm9yKSBvcHRzLm9uRXJyb3IoZXJyb3IpO2Vsc2UgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSwgb3B0cy50aW1lb3V0KTtcbiAgfVxuXG4gIG9wdHMubmFtZSA9ICBvcHRzLm5hbWUgfHwgXCJXaGVuQFwiICsgZ2V0TmV4dElkKCkgO1xuICB2YXIgZWZmZWN0QWN0aW9uID0gY3JlYXRlQWN0aW9uKCBvcHRzLm5hbWUgKyBcIi1lZmZlY3RcIiAsIGVmZmVjdCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gIHZhciBkaXNwb3NlciA9IGF1dG9ydW4oZnVuY3Rpb24gKHIpIHtcbiAgICAvLyBwcmVkaWNhdGUgc2hvdWxkIG5vdCBjaGFuZ2Ugc3RhdGVcbiAgICB2YXIgY29uZCA9IGFsbG93U3RhdGVDaGFuZ2VzKGZhbHNlLCBwcmVkaWNhdGUpO1xuXG4gICAgaWYgKGNvbmQpIHtcbiAgICAgIHIuZGlzcG9zZSgpO1xuICAgICAgaWYgKHRpbWVvdXRIYW5kbGUpIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgIGVmZmVjdEFjdGlvbigpO1xuICAgIH1cbiAgfSwgb3B0cyk7XG4gIHJldHVybiBkaXNwb3Nlcjtcbn1cblxuZnVuY3Rpb24gd2hlblByb21pc2UocHJlZGljYXRlLCBvcHRzKSB7XG4gIGlmICggb3B0cyAmJiBvcHRzLm9uRXJyb3IpIHJldHVybiBkaWUoXCJ0aGUgb3B0aW9ucyAnb25FcnJvcicgYW5kICdwcm9taXNlJyBjYW5ub3QgYmUgY29tYmluZWRcIik7XG4gIHZhciBjYW5jZWw7XG4gIHZhciByZXMgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGRpc3Bvc2VyID0gX3doZW4ocHJlZGljYXRlLCByZXNvbHZlLCBfZXh0ZW5kcyh7fSwgb3B0cywge1xuICAgICAgb25FcnJvcjogcmVqZWN0XG4gICAgfSkpO1xuXG4gICAgY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgZGlzcG9zZXIoKTtcbiAgICAgIHJlamVjdChcIldIRU5fQ0FOQ0VMTEVEXCIpO1xuICAgIH07XG4gIH0pO1xuICByZXMuY2FuY2VsID0gY2FuY2VsO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRBZG0odGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRbJG1vYnhdO1xufSAvLyBPcHRpbWl6YXRpb246IHdlIGRvbid0IG5lZWQgdGhlIGludGVybWVkaWF0ZSBvYmplY3RzIGFuZCBjb3VsZCBoYXZlIGEgY29tcGxldGVseSBjdXN0b20gYWRtaW5pc3RyYXRpb24gZm9yIER5bmFtaWNPYmplY3RzLFxuLy8gYW5kIHNraXAgZWl0aGVyIHRoZSBpbnRlcm5hbCB2YWx1ZXMgbWFwLCBvciB0aGUgYmFzZSBvYmplY3Qgd2l0aCBpdHMgcHJvcGVydHkgZGVzY3JpcHRvcnMhXG5cblxudmFyIG9iamVjdFByb3h5VHJhcHMgPSB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgbmFtZSkge1xuICAgIGlmICggZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGV0ZWN0IG5ldyBwcm9wZXJ0aWVzIHVzaW5nIHRoZSAnaW4nIG9wZXJhdG9yLiBVc2UgJ2hhcycgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLmhhc18obmFtZSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgIHJldHVybiBnZXRBZG0odGFyZ2V0KS5nZXRfKG5hbWUpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF9nZXRBZG0kc2V0XztcblxuICAgIGlmICghaXNTdHJpbmdpc2gobmFtZSkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggIWdldEFkbSh0YXJnZXQpLnZhbHVlc18uaGFzKG5hbWUpKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiYWRkIGEgbmV3IG9ic2VydmFibGUgcHJvcGVydHkgdGhyb3VnaCBkaXJlY3QgYXNzaWdubWVudC4gVXNlICdzZXQnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH0gLy8gbnVsbCAoaW50ZXJjZXB0ZWQpIC0+IHRydWUgKHN1Y2Nlc3MpXG5cblxuICAgIHJldHVybiAoX2dldEFkbSRzZXRfID0gZ2V0QWRtKHRhcmdldCkuc2V0XyhuYW1lLCB2YWx1ZSwgdHJ1ZSkpICE9IG51bGwgPyBfZ2V0QWRtJHNldF8gOiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBuYW1lKSB7XG4gICAgdmFyIF9nZXRBZG0kZGVsZXRlXztcblxuICAgIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJkZWxldGUgcHJvcGVydGllcyBmcm9tIGFuIG9ic2VydmFibGUgb2JqZWN0LiBVc2UgJ3JlbW92ZScgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfVxuXG4gICAgaWYgKCFpc1N0cmluZ2lzaChuYW1lKSkgcmV0dXJuIGZhbHNlOyAvLyBudWxsIChpbnRlcmNlcHRlZCkgLT4gdHJ1ZSAoc3VjY2VzcylcblxuICAgIHJldHVybiAoX2dldEFkbSRkZWxldGVfID0gZ2V0QWRtKHRhcmdldCkuZGVsZXRlXyhuYW1lLCB0cnVlKSkgIT0gbnVsbCA/IF9nZXRBZG0kZGVsZXRlXyA6IHRydWU7XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgX2dldEFkbSRkZWZpbmVQcm9wZXJ0O1xuXG4gICAge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImRlZmluZSBwcm9wZXJ0eSBvbiBhbiBvYnNlcnZhYmxlIG9iamVjdC4gVXNlICdkZWZpbmVQcm9wZXJ0eScgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfSAvLyBudWxsIChpbnRlcmNlcHRlZCkgLT4gdHJ1ZSAoc3VjY2VzcylcblxuXG4gICAgcmV0dXJuIChfZ2V0QWRtJGRlZmluZVByb3BlcnQgPSBnZXRBZG0odGFyZ2V0KS5kZWZpbmVQcm9wZXJ0eV8obmFtZSwgZGVzY3JpcHRvcikpICE9IG51bGwgPyBfZ2V0QWRtJGRlZmluZVByb3BlcnQgOiB0cnVlO1xuICB9LFxuICBvd25LZXlzOiBmdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICAgIGlmICggZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiaXRlcmF0ZSBrZXlzIHRvIGRldGVjdCBhZGRlZCAvIHJlbW92ZWQgcHJvcGVydGllcy4gVXNlICdrZXlzJyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gZ2V0QWRtKHRhcmdldCkub3duS2V5c18oKTtcbiAgfSxcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGRpZSgxMyk7XG4gIH1cbn07XG5mdW5jdGlvbiBhc0R5bmFtaWNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgX3RhcmdldCQkbW9ieCwgX3RhcmdldCQkbW9ieCRwcm94eV87XG5cbiAgYXNzZXJ0UHJveGllcygpO1xuICB0YXJnZXQgPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgcmV0dXJuIChfdGFyZ2V0JCRtb2J4JHByb3h5XyA9IChfdGFyZ2V0JCRtb2J4ID0gdGFyZ2V0WyRtb2J4XSkucHJveHlfKSAhPSBudWxsID8gX3RhcmdldCQkbW9ieCRwcm94eV8gOiBfdGFyZ2V0JCRtb2J4LnByb3h5XyA9IG5ldyBQcm94eSh0YXJnZXQsIG9iamVjdFByb3h5VHJhcHMpO1xufVxuXG5mdW5jdGlvbiBoYXNJbnRlcmNlcHRvcnMoaW50ZXJjZXB0YWJsZSkge1xuICByZXR1cm4gaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfICE9PSB1bmRlZmluZWQgJiYgaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiByZWdpc3RlckludGVyY2VwdG9yKGludGVyY2VwdGFibGUsIGhhbmRsZXIpIHtcbiAgdmFyIGludGVyY2VwdG9ycyA9IGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyB8fCAoaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfID0gW10pO1xuICBpbnRlcmNlcHRvcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBpbnRlcmNlcHRvcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkgaW50ZXJjZXB0b3JzLnNwbGljZShpZHgsIDEpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGludGVyY2VwdENoYW5nZShpbnRlcmNlcHRhYmxlLCBjaGFuZ2UpIHtcbiAgdmFyIHByZXZVID0gdW50cmFja2VkU3RhcnQoKTtcblxuICB0cnkge1xuICAgIC8vIEludGVyY2VwdG9yIGNhbiBtb2RpZnkgdGhlIGFycmF5LCBjb3B5IGl0IHRvIGF2b2lkIGNvbmN1cnJlbnQgbW9kaWZpY2F0aW9uLCBzZWUgIzE5NTBcbiAgICB2YXIgaW50ZXJjZXB0b3JzID0gW10uY29uY2F0KGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyB8fCBbXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGludGVyY2VwdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoYW5nZSA9IGludGVyY2VwdG9yc1tpXShjaGFuZ2UpO1xuICAgICAgaWYgKGNoYW5nZSAmJiAhY2hhbmdlLnR5cGUpIGRpZSgxNCk7XG4gICAgICBpZiAoIWNoYW5nZSkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1bnRyYWNrZWRFbmQocHJldlUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0xpc3RlbmVycyhsaXN0ZW5hYmxlKSB7XG4gIHJldHVybiBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18ubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXIobGlzdGVuYWJsZSwgaGFuZGxlcikge1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfIHx8IChsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gPSBbXSk7XG4gIGxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xuICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgIGlmIChpZHggIT09IC0xKSBsaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGxpc3RlbmFibGUsIGNoYW5nZSkge1xuICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfO1xuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuO1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0oY2hhbmdlKTtcbiAgfVxuXG4gIHVudHJhY2tlZEVuZChwcmV2VSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VPYnNlcnZhYmxlKHRhcmdldCwgYW5ub3RhdGlvbnMsIG9wdGlvbnMpIHtcbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTtcbiAgc3RhcnRCYXRjaCgpO1xuXG4gIHRyeSB7XG4gICAgdmFyIF9hbm5vdGF0aW9ucztcblxuICAgIC8vIERlZmF1bHQgdG8gZGVjb3JhdG9yc1xuICAgIChfYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucykgIT0gbnVsbCA/IF9hbm5vdGF0aW9ucyA6IGFubm90YXRpb25zID0gY29sbGVjdFN0b3JlZEFubm90YXRpb25zKHRhcmdldCk7IC8vIEFubm90YXRlXG5cbiAgICBvd25LZXlzKGFubm90YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBhZG0ubWFrZV8oa2V5LCBhbm5vdGF0aW9uc1trZXldKTtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0gLy8gcHJvdG9ba2V5c1N5bWJvbF0gPSBuZXcgU2V0PFByb3BlcnR5S2V5PigpXG5cbnZhciBrZXlzU3ltYm9sID0gLyojX19QVVJFX18qL1N5bWJvbChcIm1vYngta2V5c1wiKTtcbmZ1bmN0aW9uIG1ha2VBdXRvT2JzZXJ2YWJsZSh0YXJnZXQsIG92ZXJyaWRlcywgb3B0aW9ucykge1xuICB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgIWlzUGxhaW5PYmplY3QoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpKSBkaWUoXCInbWFrZUF1dG9PYnNlcnZhYmxlJyBjYW4gb25seSBiZSB1c2VkIGZvciBjbGFzc2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIHN1cGVyY2xhc3NcIik7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpKSBkaWUoXCJtYWtlQXV0b09ic2VydmFibGUgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYmplY3RzIG5vdCBhbHJlYWR5IG1hZGUgb2JzZXJ2YWJsZVwiKTtcbiAgfSAvLyBPcHRpbWl6YXRpb246IGF2b2lkIHZpc2l0aW5nIHByb3Rvc1xuICAvLyBBc3N1bWVzIHRoYXQgYW5ub3RhdGlvbi5tYWtlXy8uZXh0ZW5kXyB3b3JrcyB0aGUgc2FtZSBmb3IgcGxhaW4gb2JqZWN0c1xuXG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBleHRlbmRPYnNlcnZhYmxlKHRhcmdldCwgdGFyZ2V0LCBvdmVycmlkZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTsgLy8gT3B0aW1pemF0aW9uOiBjYWNoZSBrZXlzIG9uIHByb3RvXG4gIC8vIEFzc3VtZXMgbWFrZUF1dG9PYnNlcnZhYmxlIGNhbiBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBvYmplY3QgYW5kIGNhbid0IGJlIHVzZWQgaW4gc3ViY2xhc3NcblxuICBpZiAoIXRhcmdldFtrZXlzU3ltYm9sXSkge1xuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgIHZhciBrZXlzID0gbmV3IFNldChbXS5jb25jYXQob3duS2V5cyh0YXJnZXQpLCBvd25LZXlzKHByb3RvKSkpO1xuICAgIGtleXNbXCJkZWxldGVcIl0oXCJjb25zdHJ1Y3RvclwiKTtcbiAgICBrZXlzW1wiZGVsZXRlXCJdKCRtb2J4KTtcbiAgICBhZGRIaWRkZW5Qcm9wKHByb3RvLCBrZXlzU3ltYm9sLCBrZXlzKTtcbiAgfVxuXG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIHRhcmdldFtrZXlzU3ltYm9sXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBhZG0ubWFrZV8oa2V5LCAvLyBtdXN0IHBhc3MgXCJ1bmRlZmluZWRcIiBmb3IgeyBrZXk6IHVuZGVmaW5lZCB9XG4gICAgICAhb3ZlcnJpZGVzID8gdHJ1ZSA6IGtleSBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXNba2V5XSA6IHRydWUpO1xuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgU1BMSUNFID0gXCJzcGxpY2VcIjtcbnZhciBVUERBVEUgPSBcInVwZGF0ZVwiO1xudmFyIE1BWF9TUExJQ0VfU0laRSA9IDEwMDAwOyAvLyBTZWUgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvaXNzdWVzLzg1OVxuXG52YXIgYXJyYXlUcmFwcyA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgdmFyIGFkbSA9IHRhcmdldFskbW9ieF07XG4gICAgaWYgKG5hbWUgPT09ICRtb2J4KSByZXR1cm4gYWRtO1xuICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSByZXR1cm4gYWRtLmdldEFycmF5TGVuZ3RoXygpO1xuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmICFpc05hTihuYW1lKSkge1xuICAgICAgcmV0dXJuIGFkbS5nZXRfKHBhcnNlSW50KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUHJvcChhcnJheUV4dGVuc2lvbnMsIG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXJyYXlFeHRlbnNpb25zW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRbbmFtZV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYWRtID0gdGFyZ2V0WyRtb2J4XTtcblxuICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICBhZG0uc2V0QXJyYXlMZW5ndGhfKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIgfHwgaXNOYU4obmFtZSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBudW1lcmljIHN0cmluZ1xuICAgICAgYWRtLnNldF8ocGFyc2VJbnQobmFtZSksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKCkge1xuICAgIGRpZSgxNSk7XG4gIH1cbn07XG52YXIgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyB0aGlzIGlzIHRoZSBwcm9wIHRoYXQgZ2V0cyBwcm94aWVkLCBzbyBjYW4ndCByZXBsYWNlIGl0IVxuICBmdW5jdGlvbiBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgb3duZWRfLCBsZWdhY3lNb2RlXykge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWUgPSAgXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgdGhpcy5vd25lZF8gPSB2b2lkIDA7XG4gICAgdGhpcy5sZWdhY3lNb2RlXyA9IHZvaWQgMDtcbiAgICB0aGlzLmF0b21fID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWVzXyA9IFtdO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gPSAwO1xuICAgIHRoaXMub3duZWRfID0gb3duZWRfO1xuICAgIHRoaXMubGVnYWN5TW9kZV8gPSBsZWdhY3lNb2RlXztcbiAgICB0aGlzLmF0b21fID0gbmV3IEF0b20obmFtZSk7XG5cbiAgICB0aGlzLmVuaGFuY2VyXyA9IGZ1bmN0aW9uIChuZXdWLCBvbGRWKSB7XG4gICAgICByZXR1cm4gZW5oYW5jZXIobmV3Viwgb2xkViwgIG5hbWUgKyBcIlsuLl1cIiApO1xuICAgIH07XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZXNfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlc18odmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMubGVuZ3RoID4gMCkgcmV0dXJuIHZhbHVlcy5tYXAodGhpcy5kZWhhbmNlcik7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5ID09PSB2b2lkIDApIHtcbiAgICAgIGZpcmVJbW1lZGlhdGVseSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiYXJyYXlcIixcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgICB0eXBlOiBcInNwbGljZVwiLFxuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgYWRkZWQ6IHRoaXMudmFsdWVzXy5zbGljZSgpLFxuICAgICAgICBhZGRlZENvdW50OiB0aGlzLnZhbHVlc18ubGVuZ3RoLFxuICAgICAgICByZW1vdmVkOiBbXSxcbiAgICAgICAgcmVtb3ZlZENvdW50OiAwXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgX3Byb3RvLmdldEFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIGdldEFycmF5TGVuZ3RoXygpIHtcbiAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLnNldEFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIHNldEFycmF5TGVuZ3RoXyhuZXdMZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIG5ld0xlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBuZXdMZW5ndGggPCAwKSBkaWUoXCJPdXQgb2YgcmFuZ2U6IFwiICsgbmV3TGVuZ3RoKTtcbiAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gICAgaWYgKG5ld0xlbmd0aCA9PT0gY3VycmVudExlbmd0aCkgcmV0dXJuO2Vsc2UgaWYgKG5ld0xlbmd0aCA+IGN1cnJlbnRMZW5ndGgpIHtcbiAgICAgIHZhciBuZXdJdGVtcyA9IG5ldyBBcnJheShuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3SXRlbXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICB9IC8vIE5vIEFycmF5LmZpbGwgZXZlcnl3aGVyZS4uLlxuXG5cbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhjdXJyZW50TGVuZ3RoLCAwLCBuZXdJdGVtcyk7XG4gICAgfSBlbHNlIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhuZXdMZW5ndGgsIGN1cnJlbnRMZW5ndGggLSBuZXdMZW5ndGgpO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVBcnJheUxlbmd0aF8gPSBmdW5jdGlvbiB1cGRhdGVBcnJheUxlbmd0aF8ob2xkTGVuZ3RoLCBkZWx0YSkge1xuICAgIGlmIChvbGRMZW5ndGggIT09IHRoaXMubGFzdEtub3duTGVuZ3RoXykgZGllKDE2KTtcbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gKz0gZGVsdGE7XG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gJiYgZGVsdGEgPiAwKSByZXNlcnZlQXJyYXlCdWZmZXIob2xkTGVuZ3RoICsgZGVsdGEgKyAxKTtcbiAgfTtcblxuICBfcHJvdG8uc3BsaWNlV2l0aEFycmF5XyA9IGZ1bmN0aW9uIHNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy52YWx1ZXNfLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgaW5kZXggPSAwO2Vsc2UgaWYgKGluZGV4ID4gbGVuZ3RoKSBpbmRleCA9IGxlbmd0aDtlbHNlIGlmIChpbmRleCA8IDApIGluZGV4ID0gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaW5kZXgpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSBkZWxldGVDb3VudCA9IGxlbmd0aCAtIGluZGV4O2Vsc2UgaWYgKGRlbGV0ZUNvdW50ID09PSB1bmRlZmluZWQgfHwgZGVsZXRlQ291bnQgPT09IG51bGwpIGRlbGV0ZUNvdW50ID0gMDtlbHNlIGRlbGV0ZUNvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGVsZXRlQ291bnQsIGxlbmd0aCAtIGluZGV4KSk7XG4gICAgaWYgKG5ld0l0ZW1zID09PSB1bmRlZmluZWQpIG5ld0l0ZW1zID0gRU1QVFlfQVJSQVk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgdHlwZTogU1BMSUNFLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHJlbW92ZWRDb3VudDogZGVsZXRlQ291bnQsXG4gICAgICAgIGFkZGVkOiBuZXdJdGVtc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgICAgZGVsZXRlQ291bnQgPSBjaGFuZ2UucmVtb3ZlZENvdW50O1xuICAgICAgbmV3SXRlbXMgPSBjaGFuZ2UuYWRkZWQ7XG4gICAgfVxuXG4gICAgbmV3SXRlbXMgPSBuZXdJdGVtcy5sZW5ndGggPT09IDAgPyBuZXdJdGVtcyA6IG5ld0l0ZW1zLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIF90aGlzLmVuaGFuY2VyXyh2LCB1bmRlZmluZWQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gfHwgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdmFyIGxlbmd0aERlbHRhID0gbmV3SXRlbXMubGVuZ3RoIC0gZGVsZXRlQ291bnQ7XG4gICAgICB0aGlzLnVwZGF0ZUFycmF5TGVuZ3RoXyhsZW5ndGgsIGxlbmd0aERlbHRhKTsgLy8gY2hlY2tzIGlmIGludGVybmFsIGFycmF5IHdhc24ndCBtb2RpZmllZFxuICAgIH1cblxuICAgIHZhciByZXMgPSB0aGlzLnNwbGljZUl0ZW1zSW50b1ZhbHVlc18oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gICAgaWYgKGRlbGV0ZUNvdW50ICE9PSAwIHx8IG5ld0l0ZW1zLmxlbmd0aCAhPT0gMCkgdGhpcy5ub3RpZnlBcnJheVNwbGljZV8oaW5kZXgsIG5ld0l0ZW1zLCByZXMpO1xuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZXNfKHJlcyk7XG4gIH07XG5cbiAgX3Byb3RvLnNwbGljZUl0ZW1zSW50b1ZhbHVlc18gPSBmdW5jdGlvbiBzcGxpY2VJdGVtc0ludG9WYWx1ZXNfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICBpZiAobmV3SXRlbXMubGVuZ3RoIDwgTUFYX1NQTElDRV9TSVpFKSB7XG4gICAgICB2YXIgX3RoaXMkdmFsdWVzXztcblxuICAgICAgcmV0dXJuIChfdGhpcyR2YWx1ZXNfID0gdGhpcy52YWx1ZXNfKS5zcGxpY2UuYXBwbHkoX3RoaXMkdmFsdWVzXywgW2luZGV4LCBkZWxldGVDb3VudF0uY29uY2F0KG5ld0l0ZW1zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLnZhbHVlc18uc2xpY2UoaW5kZXgsIGluZGV4ICsgZGVsZXRlQ291bnQpO1xuICAgICAgdmFyIG9sZEl0ZW1zID0gdGhpcy52YWx1ZXNfLnNsaWNlKGluZGV4ICsgZGVsZXRlQ291bnQpO1xuICAgICAgdGhpcy52YWx1ZXNfLmxlbmd0aCA9IGluZGV4ICsgbmV3SXRlbXMubGVuZ3RoIC0gZGVsZXRlQ291bnQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW2luZGV4ICsgaV0gPSBuZXdJdGVtc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9sZEl0ZW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0aGlzLnZhbHVlc19baW5kZXggKyBuZXdJdGVtcy5sZW5ndGggKyBfaV0gPSBvbGRJdGVtc1tfaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5ub3RpZnlBcnJheUNoaWxkVXBkYXRlXyA9IGZ1bmN0aW9uIG5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfKGluZGV4LCBuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWRfICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgIH0gOiBudWxsOyAvLyBUaGUgcmVhc29uIHdoeSB0aGlzIGlzIG9uIHJpZ2h0IGhhbmQgc2lkZSBoZXJlIChhbmQgbm90IGFib3ZlKSwgaXMgdGhpcyB3YXkgdGhlIHVnbGlmaWVyIHdpbGwgZHJvcCBpdCwgYnV0IGl0IHdvbid0XG4gICAgLy8gY2F1c2UgYW55IHJ1bnRpbWUgb3ZlcmhlYWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSB3aXRob3V0IE5PREVfRU5WIHNldCwgdW5sZXNzIHNweWluZyBpcyBlbmFibGVkXG5cbiAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICB0aGlzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gIH07XG5cbiAgX3Byb3RvLm5vdGlmeUFycmF5U3BsaWNlXyA9IGZ1bmN0aW9uIG5vdGlmeUFycmF5U3BsaWNlXyhpbmRleCwgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWRfICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgIHR5cGU6IFNQTElDRSxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICBhZGRlZDogYWRkZWQsXG4gICAgICByZW1vdmVkQ291bnQ6IHJlbW92ZWQubGVuZ3RoLFxuICAgICAgYWRkZWRDb3VudDogYWRkZWQubGVuZ3RoXG4gICAgfSA6IG51bGw7XG4gICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRDaGFuZ2VkKCk7IC8vIGNvbmZvcm06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29ic2VydmVcblxuICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0XyA9IGZ1bmN0aW9uIGdldF8oaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCB0aGlzLnZhbHVlc18ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHRoaXMudmFsdWVzX1tpbmRleF0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUud2FybiggXCJbbW9ieF0gT3V0IG9mIGJvdW5kcyByZWFkOiBcIiArIGluZGV4ICk7XG4gIH07XG5cbiAgX3Byb3RvLnNldF8gPSBmdW5jdGlvbiBzZXRfKGluZGV4LCBuZXdWYWx1ZSkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlc187XG5cbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAvLyB1cGRhdGUgYXQgaW5kZXggaW4gcmFuZ2VcbiAgICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbV8pO1xuICAgICAgdmFyIG9sZFZhbHVlID0gdmFsdWVzW2luZGV4XTtcblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuO1xuICAgICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgbmV3VmFsdWUgPSB0aGlzLmVuaGFuY2VyXyhuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgdmFyIGNoYW5nZWQgPSBuZXdWYWx1ZSAhPT0gb2xkVmFsdWU7XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlBcnJheUNoaWxkVXBkYXRlXyhpbmRleCwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBhZGQgYSBuZXcgaXRlbVxuICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCAwLCBbbmV3VmFsdWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3V0IG9mIGJvdW5kc1xuICAgICAgZGllKDE3LCBpbmRleCwgdmFsdWVzLmxlbmd0aCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSAgXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA7XG4gIH1cblxuICBpZiAob3duZWQgPT09IHZvaWQgMCkge1xuICAgIG93bmVkID0gZmFsc2U7XG4gIH1cblxuICBhc3NlcnRQcm94aWVzKCk7XG4gIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkLCBmYWxzZSk7XG4gIGFkZEhpZGRlbkZpbmFsUHJvcChhZG0udmFsdWVzXywgJG1vYngsIGFkbSk7XG4gIHZhciBwcm94eSA9IG5ldyBQcm94eShhZG0udmFsdWVzXywgYXJyYXlUcmFwcyk7XG4gIGFkbS5wcm94eV8gPSBwcm94eTtcblxuICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLmxlbmd0aCkge1xuICAgIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydCh0cnVlKTtcbiAgICBhZG0uc3BsaWNlV2l0aEFycmF5XygwLCAwLCBpbml0aWFsVmFsdWVzKTtcbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgfVxuXG4gIHJldHVybiBwcm94eTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbnZhciBhcnJheUV4dGVuc2lvbnMgPSB7XG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoMCk7XG4gIH0sXG4gIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UobmV3SXRlbXMpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIGFkbS52YWx1ZXNfLmxlbmd0aCwgbmV3SXRlbXMpO1xuICB9LFxuICAvLyBVc2VkIGJ5IEpTT04uc3RyaW5naWZ5XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKCk7XG4gIH0sXG5cbiAgLypcclxuICAgKiBmdW5jdGlvbnMgdGhhdCBkbyBhbHRlciB0aGUgaW50ZXJuYWwgc3RydWN0dXJlIG9mIHRoZSBhcnJheSwgKGJhc2VkIG9uIGxpYi5lczYuZC50cylcclxuICAgKiBzaW5jZSB0aGVzZSBmdW5jdGlvbnMgYWx0ZXIgdGhlIGlubmVyIHN0cnVjdHVyZSBvZiB0aGUgYXJyYXksIHRoZSBoYXZlIHNpZGUgZWZmZWN0cy5cclxuICAgKiBCZWNhdXNlIHRoZSBoYXZlIHNpZGUgZWZmZWN0cywgdGhleSBzaG91bGQgbm90IGJlIHVzZWQgaW4gY29tcHV0ZWQgZnVuY3Rpb24sXHJcbiAgICogYW5kIGZvciB0aGF0IHJlYXNvbiB0aGUgZG8gbm90IGNhbGwgZGVwZW5kZW5jeVN0YXRlLm5vdGlmeU9ic2VydmVkXHJcbiAgICovXG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKGluZGV4LCBkZWxldGVDb3VudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBuZXdJdGVtcyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBuZXdJdGVtc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbXTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oaW5kZXgpO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQpO1xuICAgIH1cblxuICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgc3BsaWNlV2l0aEFycmF5OiBmdW5jdGlvbiBzcGxpY2VXaXRoQXJyYXkoaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIHJldHVybiB0aGlzWyRtb2J4XS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuICB9LFxuICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGl0ZW1zW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgYWRtLnNwbGljZVdpdGhBcnJheV8oYWRtLnZhbHVlc18ubGVuZ3RoLCAwLCBpdGVtcyk7XG4gICAgcmV0dXJuIGFkbS52YWx1ZXNfLmxlbmd0aDtcbiAgfSxcbiAgcG9wOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKE1hdGgubWF4KHRoaXNbJG1vYnhdLnZhbHVlc18ubGVuZ3RoIC0gMSwgMCksIDEpWzBdO1xuICB9LFxuICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKDAsIDEpWzBdO1xuICB9LFxuICB1bnNoaWZ0OiBmdW5jdGlvbiB1bnNoaWZ0KCkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcblxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGl0ZW1zW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuXG4gICAgYWRtLnNwbGljZVdpdGhBcnJheV8oMCwgMCwgaXRlbXMpO1xuICAgIHJldHVybiBhZG0udmFsdWVzXy5sZW5ndGg7XG4gIH0sXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgLy8gcmV2ZXJzZSBieSBkZWZhdWx0IG11dGF0ZXMgaW4gcGxhY2UgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0XG4gICAgLy8gd2hpY2ggbWFrZXMgaXQgYm90aCBhICdkZXJpdmF0aW9uJyBhbmQgYSAnbXV0YXRpb24nLlxuICAgIGlmIChnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIGRpZSgzNywgXCJyZXZlcnNlXCIpO1xuICAgIH1cblxuICAgIHRoaXMucmVwbGFjZSh0aGlzLnNsaWNlKCkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgICAvLyBzb3J0IGJ5IGRlZmF1bHQgbXV0YXRlcyBpbiBwbGFjZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcbiAgICAvLyB3aGljaCBnb2VzIGFnYWluc3QgYWxsIGdvb2QgcHJhY3RpY2VzLiBMZXQncyBub3QgY2hhbmdlIHRoZSBhcnJheSBpbiBwbGFjZSFcbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICBkaWUoMzcsIFwic29ydFwiKTtcbiAgICB9XG5cbiAgICB2YXIgY29weSA9IHRoaXMuc2xpY2UoKTtcbiAgICBjb3B5LnNvcnQuYXBwbHkoY29weSwgYXJndW1lbnRzKTtcbiAgICB0aGlzLnJlcGxhY2UoY29weSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKHZhbHVlKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIHZhciBpZHggPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pLmluZGV4T2YodmFsdWUpO1xuXG4gICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICB0aGlzLnNwbGljZShpZHgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuLyoqXHJcbiAqIFdyYXAgZnVuY3Rpb24gZnJvbSBwcm90b3R5cGVcclxuICogV2l0aG91dCB0aGlzLCBldmVyeXRoaW5nIHdvcmtzIGFzIHdlbGwsIGJ1dCB0aGlzIHdvcmtzXHJcbiAqIGZhc3RlciBhcyBldmVyeXRoaW5nIHdvcmtzIG9uIHVucHJveGllZCB2YWx1ZXNcclxuICovXG5cbmFkZEFycmF5RXh0ZW5zaW9uKFwiY29uY2F0XCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmbGF0XCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJpbmNsdWRlc1wiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiaW5kZXhPZlwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiam9pblwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwibGFzdEluZGV4T2ZcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInNsaWNlXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJ0b1N0cmluZ1wiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwidG9Mb2NhbGVTdHJpbmdcIiwgc2ltcGxlRnVuYyk7IC8vIG1hcFxuXG5hZGRBcnJheUV4dGVuc2lvbihcImV2ZXJ5XCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmlsdGVyXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmluZFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbmRJbmRleFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZsYXRNYXBcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmb3JFYWNoXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwibWFwXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwic29tZVwiLCBtYXBMaWtlRnVuYyk7IC8vIHJlZHVjZVxuXG5hZGRBcnJheUV4dGVuc2lvbihcInJlZHVjZVwiLCByZWR1Y2VMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInJlZHVjZVJpZ2h0XCIsIHJlZHVjZUxpa2VGdW5jKTtcblxuZnVuY3Rpb24gYWRkQXJyYXlFeHRlbnNpb24oZnVuY05hbWUsIGZ1bmNGYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlW2Z1bmNOYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgYXJyYXlFeHRlbnNpb25zW2Z1bmNOYW1lXSA9IGZ1bmNGYWN0b3J5KGZ1bmNOYW1lKTtcbiAgfVxufSAvLyBSZXBvcnQgYW5kIGRlbGVnYXRlIHRvIGRlaGFuY2VkIGFycmF5XG5cblxuZnVuY3Rpb24gc2ltcGxlRnVuYyhmdW5jTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBhZG0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgZGVoYW5jZWRWYWx1ZXMgPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pO1xuICAgIHJldHVybiBkZWhhbmNlZFZhbHVlc1tmdW5jTmFtZV0uYXBwbHkoZGVoYW5jZWRWYWx1ZXMsIGFyZ3VtZW50cyk7XG4gIH07XG59IC8vIE1ha2Ugc3VyZSBjYWxsYmFja3MgcmVjaWV2ZSBjb3JyZWN0IGFycmF5IGFyZyAjMjMyNlxuXG5cbmZ1bmN0aW9uIG1hcExpa2VGdW5jKGZ1bmNOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBhZG0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgZGVoYW5jZWRWYWx1ZXMgPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pO1xuICAgIHJldHVybiBkZWhhbmNlZFZhbHVlc1tmdW5jTmFtZV0oZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBlbGVtZW50LCBpbmRleCwgX3RoaXMyKTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gTWFrZSBzdXJlIGNhbGxiYWNrcyByZWNpZXZlIGNvcnJlY3QgYXJyYXkgYXJnICMyMzI2XG5cblxuZnVuY3Rpb24gcmVkdWNlTGlrZUZ1bmMoZnVuY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBhZG0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgZGVoYW5jZWRWYWx1ZXMgPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pOyAvLyAjMjQzMiAtIHJlZHVjZSBiZWhhdmlvciBkZXBlbmRzIG9uIGFyZ3VtZW50cy5sZW5ndGhcblxuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcblxuICAgIGFyZ3VtZW50c1swXSA9IGZ1bmN0aW9uIChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUsIGluZGV4LCBfdGhpczMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVoYW5jZWRWYWx1ZXNbZnVuY05hbWVdLmFwcGx5KGRlaGFuY2VkVmFsdWVzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgaXNPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb25cIiwgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24pO1xuZnVuY3Rpb24gaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHRoaW5nKSAmJiBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKHRoaW5nWyRtb2J4XSk7XG59XG5cbnZhciBfU3ltYm9sJGl0ZXJhdG9yLCBfU3ltYm9sJHRvU3RyaW5nVGFnO1xudmFyIE9ic2VydmFibGVNYXBNYXJrZXIgPSB7fTtcbnZhciBBREQgPSBcImFkZFwiO1xudmFyIERFTEVURSA9IFwiZGVsZXRlXCI7IC8vIGp1c3QgZXh0ZW5kIE1hcD8gU2VlIGFsc28gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbmVzdGhhcnVzLzEzYjRkNzRmMmVmNGEyZjQzNTdkYmQzZmMyM2MxZTU0XG4vLyBCdXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvMTU1NlxuXG5fU3ltYm9sJGl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xuX1N5bWJvbCR0b1N0cmluZ1RhZyA9IFN5bWJvbC50b1N0cmluZ1RhZztcbnZhciBPYnNlcnZhYmxlTWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gaGFzTWFwLCBub3QgaGFzaE1hcCA+LSkuXG4gIGZ1bmN0aW9uIE9ic2VydmFibGVNYXAoaW5pdGlhbERhdGEsIGVuaGFuY2VyXywgbmFtZV8pIHtcbiAgICBpZiAoZW5oYW5jZXJfID09PSB2b2lkIDApIHtcbiAgICAgIGVuaGFuY2VyXyA9IGRlZXBFbmhhbmNlcjtcbiAgICB9XG5cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSAgXCJPYnNlcnZhYmxlTWFwQFwiICsgZ2V0TmV4dElkKCkgO1xuICAgIH1cblxuICAgIHRoaXMuZW5oYW5jZXJfID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpc1skbW9ieF0gPSBPYnNlcnZhYmxlTWFwTWFya2VyO1xuICAgIHRoaXMuZGF0YV8gPSB2b2lkIDA7XG4gICAgdGhpcy5oYXNNYXBfID0gdm9pZCAwO1xuICAgIHRoaXMua2V5c0F0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVuaGFuY2VyXyA9IGVuaGFuY2VyXztcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oTWFwKSkge1xuICAgICAgZGllKDE4KTtcbiAgICB9XG5cbiAgICB0aGlzLmtleXNBdG9tXyA9IGNyZWF0ZUF0b20oIHRoaXMubmFtZV8gKyBcIi5rZXlzKClcIiApO1xuICAgIHRoaXMuZGF0YV8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oYXNNYXBfID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubWVyZ2UoaW5pdGlhbERhdGEpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVNYXAucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYXNfID0gZnVuY3Rpb24gaGFzXyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhXy5oYXMoa2V5KTtcbiAgfTtcblxuICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKGtleSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikgcmV0dXJuIHRoaXMuaGFzXyhrZXkpO1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGFzTWFwXy5nZXQoa2V5KTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHZhciBuZXdFbnRyeSA9IGVudHJ5ID0gbmV3IE9ic2VydmFibGVWYWx1ZSh0aGlzLmhhc18oa2V5KSwgcmVmZXJlbmNlRW5oYW5jZXIsICB0aGlzLm5hbWVfICsgXCIuXCIgKyBzdHJpbmdpZnlLZXkoa2V5KSArIFwiP1wiICwgZmFsc2UpO1xuICAgICAgdGhpcy5oYXNNYXBfLnNldChrZXksIG5ld0VudHJ5KTtcbiAgICAgIG9uQmVjb21lVW5vYnNlcnZlZChuZXdFbnRyeSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaGFzTWFwX1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5LmdldCgpO1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBoYXNLZXkgPSB0aGlzLmhhc18oa2V5KTtcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBoYXNLZXkgPyBVUERBVEUgOiBBREQsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiB0aGlzO1xuICAgICAgdmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc0tleSkge1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90b1tcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmtleXNBdG9tXyk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5hbWU6IGtleVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc18oa2V5KSkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcblxuICAgICAgdmFyIF9jaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJtYXBcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBERUxFVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgb2xkVmFsdWU6IHRoaXMuZGF0YV8uZ2V0KGtleSkudmFsdWVfLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZSk7XG4gICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuXG4gICAgICAgIF90aGlzMi51cGRhdGVIYXNNYXBFbnRyeV8oa2V5LCBmYWxzZSk7XG5cbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBfdGhpczIuZGF0YV8uZ2V0KGtleSk7XG5cbiAgICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8odW5kZWZpbmVkKTtcblxuICAgICAgICBfdGhpczIuZGF0YV9bXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UpO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVIYXNNYXBFbnRyeV8gPSBmdW5jdGlvbiB1cGRhdGVIYXNNYXBFbnRyeV8oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGFzTWFwXy5nZXQoa2V5KTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkuc2V0TmV3VmFsdWVfKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVZhbHVlXyA9IGZ1bmN0aW9uIHVwZGF0ZVZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLmRhdGFfLmdldChrZXkpO1xuICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS5wcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKTtcblxuICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm1hcFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hZGRWYWx1ZV8gPSBmdW5jdGlvbiBhZGRWYWx1ZV8oa2V5LCBuZXdWYWx1ZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVWYWx1ZShuZXdWYWx1ZSwgX3RoaXMzLmVuaGFuY2VyXywgIF90aGlzMy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgLCBmYWxzZSk7XG5cbiAgICAgIF90aGlzMy5kYXRhXy5zZXQoa2V5LCBvYnNlcnZhYmxlKTtcblxuICAgICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnZhbHVlXzsgLy8gdmFsdWUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWRcblxuICAgICAgX3RoaXMzLnVwZGF0ZUhhc01hcEVudHJ5XyhrZXksIHRydWUpO1xuXG4gICAgICBfdGhpczMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICB9KTtcbiAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcIm1hcFwiLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgdHlwZTogQURELFxuICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgbmFtZToga2V5LFxuICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgfSA6IG51bGw7XG4gICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKHRoaXMuaGFzKGtleSkpIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZV8odGhpcy5kYXRhXy5nZXQoa2V5KS5nZXQoKSk7XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlXyh1bmRlZmluZWQpO1xuICB9O1xuXG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV8ua2V5cygpO1xuICB9O1xuXG4gIF9wcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgX2tleXMkbmV4dCA9IGtleXMubmV4dCgpLFxuICAgICAgICAgICAgZG9uZSA9IF9rZXlzJG5leHQuZG9uZSxcbiAgICAgICAgICAgIHZhbHVlID0gX2tleXMkbmV4dC52YWx1ZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGRvbmUsXG4gICAgICAgICAgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBzZWxmLmdldCh2YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgX2tleXMkbmV4dDIgPSBrZXlzLm5leHQoKSxcbiAgICAgICAgICAgIGRvbmUgPSBfa2V5cyRuZXh0Mi5kb25lLFxuICAgICAgICAgICAgdmFsdWUgPSBfa2V5cyRuZXh0Mi52YWx1ZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGRvbmUsXG4gICAgICAgICAgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBbdmFsdWUsIHNlbGYuZ2V0KHZhbHVlKV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG9bX1N5bWJvbCRpdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9O1xuXG4gIF9wcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc3RlcC52YWx1ZSxcbiAgICAgICAgICBrZXkgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIE1lcmdlIGFub3RoZXIgb2JqZWN0IGludG8gdGhpcyBvYmplY3QsIHJldHVybnMgdGhpcy4gKi9cbiAgO1xuXG4gIF9wcm90by5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKG90aGVyKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgTWFwKG90aGVyKTtcbiAgICB9XG5cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChvdGhlcikpIGdldFBsYWluT2JqZWN0S2V5cyhvdGhlcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuc2V0KGtleSwgb3RoZXJba2V5XSk7XG4gICAgICB9KTtlbHNlIGlmIChBcnJheS5pc0FycmF5KG90aGVyKSkgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIga2V5ID0gX3JlZlswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtlbHNlIGlmIChpc0VTNk1hcChvdGhlcikpIHtcbiAgICAgICAgaWYgKG90aGVyLmNvbnN0cnVjdG9yICE9PSBNYXApIGRpZSgxOSwgb3RoZXIpO1xuICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlciAhPT0gbnVsbCAmJiBvdGhlciAhPT0gdW5kZWZpbmVkKSBkaWUoMjAsIG90aGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzNS5rZXlzKCkpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBfdGhpczVbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHZhbHVlcykge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgLy8gSW1wbGVtZW50YXRpb24gcmVxdWlyZW1lbnRzOlxuICAgIC8vIC0gcmVzcGVjdCBvcmRlcmluZyBvZiByZXBsYWNlbWVudCBtYXBcbiAgICAvLyAtIGFsbG93IGludGVyY2VwdG9ycyB0byBydW4gYW5kIHBvdGVudGlhbGx5IHByZXZlbnQgaW5kaXZpZHVhbCBvcGVyYXRpb25zXG4gICAgLy8gLSBkb24ndCByZWNyZWF0ZSBvYnNlcnZhYmxlcyB0aGF0IGFscmVhZHkgZXhpc3QgaW4gb3JpZ2luYWwgbWFwIChzbyB3ZSBkb24ndCBkZXN0cm95IGV4aXN0aW5nIHN1YnNjcmlwdGlvbnMpXG4gICAgLy8gLSBkb24ndCBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCBpZiB0aGUga2V5cyBvZiByZXN1bHRpbmcgbWFwIGFyZSBpbmRlbnRpY2FsIChvcmRlciBtYXR0ZXJzISlcbiAgICAvLyAtIG5vdGUgdGhhdCByZXN1bHQgbWFwIG1heSBkaWZmZXIgZnJvbSByZXBsYWNlbWVudCBtYXAgZHVlIHRvIHRoZSBpbnRlcmNlcHRvcnNcbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIG1hcCBzbyB3ZSBjYW4gZG8gcXVpY2sga2V5IGxvb2t1cHNcbiAgICAgIHZhciByZXBsYWNlbWVudE1hcCA9IGNvbnZlcnRUb01hcCh2YWx1ZXMpO1xuICAgICAgdmFyIG9yZGVyZWREYXRhID0gbmV3IE1hcCgpOyAvLyBVc2VkIGZvciBvcHRpbWl6YXRpb25cblxuICAgICAgdmFyIGtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkID0gZmFsc2U7IC8vIERlbGV0ZSBrZXlzIHRoYXQgZG9uJ3QgZXhpc3QgaW4gcmVwbGFjZW1lbnQgbWFwXG4gICAgICAvLyBpZiB0aGUga2V5IGRlbGV0aW9uIGlzIHByZXZlbnRlZCBieSBpbnRlcmNlcHRvclxuICAgICAgLy8gYWRkIGVudHJ5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlc3VsdCBtYXBcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXM2LmRhdGFfLmtleXMoKSksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBrZXkgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgLy8gQ29uY3VycmVudGx5IGl0ZXJhdGluZy9kZWxldGluZyBrZXlzXG4gICAgICAgIC8vIGl0ZXJhdG9yIHNob3VsZCBoYW5kbGUgdGhpcyBjb3JyZWN0bHlcbiAgICAgICAgaWYgKCFyZXBsYWNlbWVudE1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgIHZhciBkZWxldGVkID0gX3RoaXM2W1wiZGVsZXRlXCJdKGtleSk7IC8vIFdhcyB0aGUga2V5IHJlbW92ZWQ/XG5cblxuICAgICAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgICAgICAvLyBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCgpIHdhcyBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpczYuZGF0YV8uZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIG9yZGVyZWREYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTWVyZ2UgZW50cmllc1xuXG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJlcGxhY2VtZW50TWFwLmVudHJpZXMoKSksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc3RlcDQudmFsdWUsXG4gICAgICAgICAgICBfa2V5ID0gX3N0ZXA0JHZhbHVlWzBdLFxuICAgICAgICAgICAgX3ZhbHVlID0gX3N0ZXA0JHZhbHVlWzFdO1xuXG4gICAgICAgIC8vIFdlIHdpbGwgd2FudCB0byBrbm93IHdoZXRoZXIgYSBuZXcga2V5IGlzIGFkZGVkXG4gICAgICAgIHZhciBrZXlFeGlzdGVkID0gX3RoaXM2LmRhdGFfLmhhcyhfa2V5KTsgLy8gQWRkIG9yIHVwZGF0ZSB2YWx1ZVxuXG5cbiAgICAgICAgX3RoaXM2LnNldChfa2V5LCBfdmFsdWUpOyAvLyBUaGUgYWRkaXRpb24gY291bGQgaGF2ZSBiZWVuIHByZXZlbnQgYnkgaW50ZXJjZXB0b3JcblxuXG4gICAgICAgIGlmIChfdGhpczYuZGF0YV8uaGFzKF9rZXkpKSB7XG4gICAgICAgICAgLy8gVGhlIHVwZGF0ZSBjb3VsZCBoYXZlIGJlZW4gcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAgICAgLy8gYW5kIGFsc28gd2Ugd2FudCB0byBwcmVzZXJ2ZSBleGlzdGluZyB2YWx1ZXNcbiAgICAgICAgICAvLyBzbyB1c2UgdmFsdWUgZnJvbSBfZGF0YSBtYXAgKGluc3RlYWQgb2YgcmVwbGFjZW1lbnQgbWFwKVxuICAgICAgICAgIHZhciBfdmFsdWUyID0gX3RoaXM2LmRhdGFfLmdldChfa2V5KTtcblxuICAgICAgICAgIG9yZGVyZWREYXRhLnNldChfa2V5LCBfdmFsdWUyKTsgLy8gV2FzIGEgbmV3IGtleSBhZGRlZD9cblxuICAgICAgICAgIGlmICgha2V5RXhpc3RlZCkge1xuICAgICAgICAgICAgLy8gX2tleXNBdG9tLnJlcG9ydENoYW5nZWQoKSB3YXMgYWxyZWFkeSBjYWxsZWRcbiAgICAgICAgICAgIGtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2hlY2sgZm9yIHBvc3NpYmxlIGtleSBvcmRlciBjaGFuZ2VcblxuXG4gICAgICBpZiAoIWtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkKSB7XG4gICAgICAgIGlmIChfdGhpczYuZGF0YV8uc2l6ZSAhPT0gb3JkZXJlZERhdGEuc2l6ZSkge1xuICAgICAgICAgIC8vIElmIHNpemUgZGlmZmVycywga2V5cyBhcmUgZGVmaW5pdGVseSBtb2RpZmllZFxuICAgICAgICAgIF90aGlzNi5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpdGVyMSA9IF90aGlzNi5kYXRhXy5rZXlzKCk7XG5cbiAgICAgICAgICB2YXIgaXRlcjIgPSBvcmRlcmVkRGF0YS5rZXlzKCk7XG4gICAgICAgICAgdmFyIG5leHQxID0gaXRlcjEubmV4dCgpO1xuICAgICAgICAgIHZhciBuZXh0MiA9IGl0ZXIyLm5leHQoKTtcblxuICAgICAgICAgIHdoaWxlICghbmV4dDEuZG9uZSkge1xuICAgICAgICAgICAgaWYgKG5leHQxLnZhbHVlICE9PSBuZXh0Mi52YWx1ZSkge1xuICAgICAgICAgICAgICBfdGhpczYua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV4dDEgPSBpdGVyMS5uZXh0KCk7XG4gICAgICAgICAgICBuZXh0MiA9IGl0ZXIyLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVXNlIGNvcnJlY3RseSBvcmRlcmVkIG1hcFxuXG5cbiAgICAgIF90aGlzNi5kYXRhXyA9IG9yZGVyZWREYXRhO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgT2JzZXJ2YWJsZU1hcF1cIjtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxyXG4gICAqIE9ic2VydmVzIHRoaXMgb2JqZWN0LiBUcmlnZ2VycyBmb3IgdGhlIGV2ZW50cyAnYWRkJywgJ3VwZGF0ZScgYW5kICdkZWxldGUnLlxyXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcclxuICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xyXG4gICAqL1xuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKCBmaXJlSW1tZWRpYXRlbHkgPT09IHRydWUpIGRpZShcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgZmlyZUltbWVkaWF0ZWx5PXRydWUgaW4gY29tYmluYXRpb24gd2l0aCBtYXBzLlwiKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoT2JzZXJ2YWJsZU1hcCwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwiTWFwXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmFibGVNYXA7XG59KCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG52YXIgaXNPYnNlcnZhYmxlTWFwID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlTWFwXCIsIE9ic2VydmFibGVNYXApO1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9NYXAoZGF0YVN0cnVjdHVyZSkge1xuICBpZiAoaXNFUzZNYXAoZGF0YVN0cnVjdHVyZSkgfHwgaXNPYnNlcnZhYmxlTWFwKGRhdGFTdHJ1Y3R1cmUpKSB7XG4gICAgcmV0dXJuIGRhdGFTdHJ1Y3R1cmU7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhU3RydWN0dXJlKSkge1xuICAgIHJldHVybiBuZXcgTWFwKGRhdGFTdHJ1Y3R1cmUpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoZGF0YVN0cnVjdHVyZSkpIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGRhdGFTdHJ1Y3R1cmUpIHtcbiAgICAgIG1hcC5zZXQoa2V5LCBkYXRhU3RydWN0dXJlW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpZSgyMSwgZGF0YVN0cnVjdHVyZSk7XG4gIH1cbn1cblxudmFyIF9TeW1ib2wkaXRlcmF0b3IkMSwgX1N5bWJvbCR0b1N0cmluZ1RhZyQxO1xudmFyIE9ic2VydmFibGVTZXRNYXJrZXIgPSB7fTtcbl9TeW1ib2wkaXRlcmF0b3IkMSA9IFN5bWJvbC5pdGVyYXRvcjtcbl9TeW1ib2wkdG9TdHJpbmdUYWckMSA9IFN5bWJvbC50b1N0cmluZ1RhZztcbnZhciBPYnNlcnZhYmxlU2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZVNldChpbml0aWFsRGF0YSwgZW5oYW5jZXIsIG5hbWVfKSB7XG4gICAgaWYgKGVuaGFuY2VyID09PSB2b2lkIDApIHtcbiAgICAgIGVuaGFuY2VyID0gZGVlcEVuaGFuY2VyO1xuICAgIH1cblxuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9ICBcIk9ic2VydmFibGVTZXRAXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzWyRtb2J4XSA9IE9ic2VydmFibGVTZXRNYXJrZXI7XG4gICAgdGhpcy5kYXRhXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmF0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oU2V0KSkge1xuICAgICAgZGllKDIyKTtcbiAgICB9XG5cbiAgICB0aGlzLmF0b21fID0gY3JlYXRlQXRvbSh0aGlzLm5hbWVfKTtcblxuICAgIHRoaXMuZW5oYW5jZXJfID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHtcbiAgICAgIHJldHVybiBlbmhhbmNlcihuZXdWLCBvbGRWLCBuYW1lXyk7XG4gICAgfTtcblxuICAgIGlmIChpbml0aWFsRGF0YSkge1xuICAgICAgdGhpcy5yZXBsYWNlKGluaXRpYWxEYXRhKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZVNldC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdW50cmFja2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShfdGhpcy5kYXRhXy52YWx1ZXMoKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBfdGhpc1tcImRlbGV0ZVwiXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja0ZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdmFsdWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICBjYWxsYmFja0ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5hdG9tXyk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIHRoaXM7IC8vIGlkZWFsbHksIHZhbHVlID0gY2hhbmdlLnZhbHVlIHdvdWxkIGJlIGRvbmUgaGVyZSwgc28gdGhhdCB2YWx1ZXMgY2FuIGJlXG4gICAgICAvLyBjaGFuZ2VkIGJ5IGludGVyY2VwdG9yLiBTYW1lIGFwcGxpZXMgZm9yIG90aGVyIFNldCBhbmQgTWFwIGFwaSdzLlxuICAgIH1cblxuICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5kYXRhXy5hZGQoX3RoaXMyLmVuaGFuY2VyXyh2YWx1ZSwgdW5kZWZpbmVkKSk7XG5cbiAgICAgICAgX3RoaXMyLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG5vdGlmeVNweSA9ICBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwic2V0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGlmIChub3RpZnlTcHkgJiYgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZSk7XG4gICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICBpZiAobm90aWZ5U3B5ICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90b1tcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIF9kZWxldGUodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBERUxFVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgb2xkVmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9ICBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgIHZhciBfY2hhbmdlMiA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInNldFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAobm90aWZ5U3B5ICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UyKTtcbiAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcblxuICAgICAgICBfdGhpczMuZGF0YV9bXCJkZWxldGVcIl0odmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZTIpO1xuICAgICAgaWYgKG5vdGlmeVNweSAmJiBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiKSBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKHZhbHVlKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmhhcyh0aGlzLmRlaGFuY2VWYWx1ZV8odmFsdWUpKTtcbiAgfTtcblxuICBfcHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgdmFyIGtleXMgPSBBcnJheS5mcm9tKHRoaXMua2V5cygpKTtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgbmV4dEluZGV4ICs9IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA8IHZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IFtrZXlzW2luZGV4XSwgdmFsdWVzW2luZGV4XV0sXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuXG4gIF9wcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICB2YXIgb2JzZXJ2YWJsZVZhbHVlcyA9IEFycmF5LmZyb20odGhpcy5kYXRhXy52YWx1ZXMoKSk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgb2JzZXJ2YWJsZVZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IHNlbGYuZGVoYW5jZVZhbHVlXyhvYnNlcnZhYmxlVmFsdWVzW25leHRJbmRleCsrXSksXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG90aGVyKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlU2V0KG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2V0KG90aGVyKTtcbiAgICB9XG5cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvdGhlcikpIHtcbiAgICAgICAgX3RoaXM0LmNsZWFyKCk7XG5cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0VTNlNldChvdGhlcikpIHtcbiAgICAgICAgX3RoaXM0LmNsZWFyKCk7XG5cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlciAhPT0gbnVsbCAmJiBvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpZShcIkNhbm5vdCBpbml0aWFsaXplIHNldCBmcm9tIFwiICsgb3RoZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAvLyAuLi4gJ2ZpcmVJbW1lZGlhdGVseScgY291bGQgYWxzbyBiZSB0cnVlP1xuICAgIGlmICggZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggc2V0cy5cIik7XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IE9ic2VydmFibGVTZXRdXCI7XG4gIH07XG5cbiAgX3Byb3RvW19TeW1ib2wkaXRlcmF0b3IkMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVTZXQsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnJDEsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJTZXRcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZVNldDtcbn0oKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbnZhciBpc09ic2VydmFibGVTZXQgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVTZXRcIiwgT2JzZXJ2YWJsZVNldCk7XG5cbnZhciBkZXNjcmlwdG9yQ2FjaGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBSRU1PVkUgPSBcInJlbW92ZVwiO1xudmFyIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbih0YXJnZXRfLCB2YWx1ZXNfLCBuYW1lXywgLy8gVXNlZCBhbnl0aW1lIGFubm90YXRpb24gaXMgbm90IGV4cGxpY2l0ZWx5IHByb3ZpZGVkXG4gIGRlZmF1bHRBbm5vdGF0aW9uXykge1xuICAgIGlmICh2YWx1ZXNfID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlc18gPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRBbm5vdGF0aW9uXyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0QW5ub3RhdGlvbl8gPSBhdXRvQW5ub3RhdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldF8gPSB2b2lkIDA7XG4gICAgdGhpcy52YWx1ZXNfID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlzQXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUGxhaW5PYmplY3RfID0gdm9pZCAwO1xuICAgIHRoaXMuYXBwbGllZEFubm90YXRpb25zXyA9IHZvaWQgMDtcbiAgICB0aGlzLnBlbmRpbmdLZXlzXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRhcmdldF8gPSB0YXJnZXRfO1xuICAgIHRoaXMudmFsdWVzXyA9IHZhbHVlc187XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIHRoaXMuZGVmYXVsdEFubm90YXRpb25fID0gZGVmYXVsdEFubm90YXRpb25fO1xuICAgIHRoaXMua2V5c0F0b21fID0gbmV3IEF0b20oIHRoaXMubmFtZV8gKyBcIi5rZXlzXCIgKTsgLy8gT3B0aW1pemF0aW9uOiB3ZSB1c2UgdGhpcyBmcmVxdWVudGx5XG5cbiAgICB0aGlzLmlzUGxhaW5PYmplY3RfID0gaXNQbGFpbk9iamVjdCh0aGlzLnRhcmdldF8pO1xuXG4gICAgaWYgKCAhaXNBbm5vdGF0aW9uKHRoaXMuZGVmYXVsdEFubm90YXRpb25fKSkge1xuICAgICAgZGllKFwiZGVmYXVsdEFubm90YXRpb24gbXVzdCBiZSB2YWxpZCBhbm5vdGF0aW9uXCIpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIFByZXBhcmUgc3RydWN0dXJlIGZvciB0cmFja2luZyB3aGljaCBmaWVsZHMgd2VyZSBhbHJlYWR5IGFubm90YXRlZFxuICAgICAgdGhpcy5hcHBsaWVkQW5ub3RhdGlvbnNfID0ge307XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldE9ic2VydmFibGVQcm9wVmFsdWVfID0gZnVuY3Rpb24gZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXy5nZXQoa2V5KS5nZXQoKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8gPSBmdW5jdGlvbiBzZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLnZhbHVlc18uZ2V0KGtleSk7XG5cbiAgICBpZiAob2JzZXJ2YWJsZSBpbnN0YW5jZW9mIENvbXB1dGVkVmFsdWUpIHtcbiAgICAgIG9ic2VydmFibGUuc2V0KG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gaW50ZXJjZXB0XG5cblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUucHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSk7IC8vIG5vdGlmeSBzcHkgJiBvYnNlcnZlcnNcblxuICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgdmFyIG5vdGlmeVNweSA9ICBpc1NweUVuYWJsZWQoKTtcblxuICAgICAgdmFyIF9jaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9IDogbnVsbDtcblxuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UpO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5nZXRfID0gZnVuY3Rpb24gZ2V0XyhrZXkpIHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICYmICFoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgLy8gS2V5IGRvZXNuJ3QgZXhpc3QgeWV0LCBzdWJzY3JpYmUgZm9yIGl0IGluIGNhc2UgaXQncyBhZGRlZCBsYXRlclxuICAgICAgdGhpcy5oYXNfKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0X1trZXldO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGNvcHkgYXMgaXNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRfID0gZnVuY3Rpb24gc2V0XyhrZXksIHZhbHVlLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERvbid0IHVzZSAuaGFzKGtleSkgLSB3ZSBjYXJlIGFib3V0IG93blxuICAgIGlmIChoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgLy8gRXhpc3RpbmcgcHJvcFxuICAgICAgaWYgKHRoaXMudmFsdWVzXy5oYXMoa2V5KSkge1xuICAgICAgICAvLyBPYnNlcnZhYmxlIChjYW4gYmUgaW50ZXJjZXB0ZWQpXG4gICAgICAgIHJldHVybiB0aGlzLnNldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgLy8gTm9uLW9ic2VydmFibGUgLSBwcm94eVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGhpcy50YXJnZXRfLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vbi1vYnNlcnZhYmxlXG4gICAgICAgIHRoaXMudGFyZ2V0X1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZXcgcHJvcFxuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9LCB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXywgcHJveHlUcmFwKTtcbiAgICB9XG4gIH0gLy8gVHJhcCBmb3IgXCJpblwiXG4gIDtcblxuICBfcHJvdG8uaGFzXyA9IGZ1bmN0aW9uIGhhc18oa2V5KSB7XG4gICAgaWYgKCFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIC8vIFNraXAga2V5IHN1YnNjcmlwdGlvbiBvdXRzaWRlIGRlcml2YXRpb25cbiAgICAgIHJldHVybiBrZXkgaW4gdGhpcy50YXJnZXRfO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ0tleXNfIHx8ICh0aGlzLnBlbmRpbmdLZXlzXyA9IG5ldyBNYXAoKSk7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5wZW5kaW5nS2V5c18uZ2V0KGtleSk7XG5cbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICBlbnRyeSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUoa2V5IGluIHRoaXMudGFyZ2V0XywgcmVmZXJlbmNlRW5oYW5jZXIsICB0aGlzLm5hbWVfICsgXCIuXCIgKyBzdHJpbmdpZnlLZXkoa2V5KSArIFwiP1wiICwgZmFsc2UpO1xuICAgICAgdGhpcy5wZW5kaW5nS2V5c18uc2V0KGtleSwgZW50cnkpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS5nZXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge0Fubm90YXRpb258Ym9vbGVhbn0gYW5ub3RhdGlvbiB0cnVlIC0gdXNlIGRlZmF1bHQgYW5ub3RhdGlvbiwgZmFsc2UgLSBpZ25vcmUgcHJvcFxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm1ha2VfID0gZnVuY3Rpb24gbWFrZV8oa2V5LCBhbm5vdGF0aW9uKSB7XG4gICAgaWYgKGFubm90YXRpb24gPT09IHRydWUpIHtcbiAgICAgIGFubm90YXRpb24gPSB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXztcbiAgICB9XG5cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhc3NlcnRBbm5vdGFibGUodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcblxuICAgIGlmICghKGtleSBpbiB0aGlzLnRhcmdldF8pKSB7XG4gICAgICB2YXIgX3RoaXMkdGFyZ2V0XyRzdG9yZWRBO1xuXG4gICAgICAvLyBUaHJvdyBvbiBtaXNzaW5nIGtleSwgZXhjZXB0IGZvciBkZWNvcmF0b3JzOlxuICAgICAgLy8gRGVjb3JhdG9yIGFubm90YXRpb25zIGFyZSBjb2xsZWN0ZWQgZnJvbSB3aG9sZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIHN1cGVyKCkgc29tZSBwcm9wcyBtYXkgbm90IGV4aXN0IHlldC5cbiAgICAgIC8vIEhvd2V2ZXIgd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBtaXNzaW5nIHByb3AsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBkZWNvcmF0b3IgbXVzdCBoYXZlIGJlZW4gYXBwbGllZCB0byBzb21ldGhpbmcuXG4gICAgICBpZiAoKF90aGlzJHRhcmdldF8kc3RvcmVkQSA9IHRoaXMudGFyZ2V0X1tzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0YXJnZXRfJHN0b3JlZEFba2V5XSkge1xuICAgICAgICByZXR1cm47IC8vIHdpbGwgYmUgYW5ub3RhdGVkIGJ5IHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWUoMSwgYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV8sIHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gdGhpcy50YXJnZXRfO1xuXG4gICAgd2hpbGUgKHNvdXJjZSAmJiBzb3VyY2UgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcblxuICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgdmFyIG91dGNvbWUgPSBhbm5vdGF0aW9uLm1ha2VfKHRoaXMsIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgICAgICAgaWYgKG91dGNvbWUgPT09IDBcbiAgICAgICAgLyogQ2FuY2VsICovXG4gICAgICAgICkgcmV0dXJuO1xuICAgICAgICBpZiAob3V0Y29tZSA9PT0gMVxuICAgICAgICAvKiBCcmVhayAqL1xuICAgICAgICApIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgICB9XG5cbiAgICByZWNvcmRBbm5vdGF0aW9uQXBwbGllZCh0aGlzLCBhbm5vdGF0aW9uLCBrZXkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlEZXNjcmlwdG9yfSBkZXNjcmlwdG9yXHJcbiAgICogQHBhcmFtIHtBbm5vdGF0aW9ufGJvb2xlYW59IGFubm90YXRpb24gdHJ1ZSAtIHVzZSBkZWZhdWx0IGFubm90YXRpb24sIGZhbHNlIC0gY29weSBhcyBpc1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmV4dGVuZF8gPSBmdW5jdGlvbiBleHRlbmRfKGtleSwgZGVzY3JpcHRvciwgYW5ub3RhdGlvbiwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgYW5ub3RhdGlvbiA9IHRoaXMuZGVmYXVsdEFubm90YXRpb25fO1xuICAgIH1cblxuICAgIGlmIChhbm5vdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbiAgICB9XG5cbiAgICBhc3NlcnRBbm5vdGFibGUodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgICB2YXIgb3V0Y29tZSA9IGFubm90YXRpb24uZXh0ZW5kXyh0aGlzLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG5cbiAgICBpZiAob3V0Y29tZSkge1xuICAgICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Y29tZTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlZmluZVByb3BlcnR5XyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0QmF0Y2goKTsgLy8gRGVsZXRlXG5cbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG5cbiAgICAgIGlmICghZGVsZXRlT3V0Y29tZSkge1xuICAgICAgICAvLyBGYWlsdXJlIG9yIGludGVyY2VwdGVkXG4gICAgICAgIHJldHVybiBkZWxldGVPdXRjb21lO1xuICAgICAgfSAvLyBBREQgaW50ZXJjZXB0b3JcblxuXG4gICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgICAgbmV3VmFsdWU6IGRlc2NyaXB0b3IudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgIGRlc2NyaXB0b3IgPSBfZXh0ZW5kcyh7fSwgZGVzY3JpcHRvciwge1xuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRGVmaW5lXG5cblxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9IC8vIE5vdGlmeVxuXG5cbiAgICAgIHRoaXMubm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCBkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBvcmlnaW5hbCBkZXNjcmlwdG9yIGJlY29tZXMgcmVsZXZhbnQsIG1vdmUgdGhpcyB0byBhbm5vdGF0aW9uIGRpcmVjdGx5XG4gIDtcblxuICBfcHJvdG8uZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5XyA9IGZ1bmN0aW9uIGRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8oa2V5LCB2YWx1ZSwgZW5oYW5jZXIsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0QmF0Y2goKTsgLy8gRGVsZXRlXG5cbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG5cbiAgICAgIGlmICghZGVsZXRlT3V0Y29tZSkge1xuICAgICAgICAvLyBGYWlsdXJlIG9yIGludGVyY2VwdGVkXG4gICAgICAgIHJldHVybiBkZWxldGVPdXRjb21lO1xuICAgICAgfSAvLyBBREQgaW50ZXJjZXB0b3JcblxuXG4gICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgICAgbmV3VmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FjaGVkRGVzY3JpcHRvciA9IGdldENhY2hlZE9ic2VydmFibGVQcm9wRGVzY3JpcHRvcihrZXkpO1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzID8gdGhpcy5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogY2FjaGVkRGVzY3JpcHRvci5nZXQsXG4gICAgICAgIHNldDogY2FjaGVkRGVzY3JpcHRvci5zZXRcbiAgICAgIH07IC8vIERlZmluZVxuXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCBlbmhhbmNlciwgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiLCBmYWxzZSk7XG4gICAgICB0aGlzLnZhbHVlc18uc2V0KGtleSwgb2JzZXJ2YWJsZSk7IC8vIE5vdGlmeSAodmFsdWUgcG9zc2libHkgY2hhbmdlZCBieSBPYnNlcnZhYmxlVmFsdWUpXG5cbiAgICAgIHRoaXMubm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCBvYnNlcnZhYmxlLnZhbHVlXyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgb3JpZ2luYWwgZGVzY3JpcHRvciBiZWNvbWVzIHJlbGV2YW50LCBtb3ZlIHRoaXMgdG8gYW5ub3RhdGlvbiBkaXJlY3RseVxuICA7XG5cbiAgX3Byb3RvLmRlZmluZUNvbXB1dGVkUHJvcGVydHlfID0gZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8oa2V5LCBvcHRpb25zLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7IC8vIERlbGV0ZVxuXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuXG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH0gLy8gQUREIGludGVyY2VwdG9yXG5cblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5uYW1lIHx8IChvcHRpb25zLm5hbWUgPSBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5XCIpO1xuICAgICAgb3B0aW9ucy5jb250ZXh0ID0gdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfO1xuICAgICAgdmFyIGNhY2hlZERlc2NyaXB0b3IgPSBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KTtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IHRoaXMuaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBjYWNoZWREZXNjcmlwdG9yLmdldCxcbiAgICAgICAgc2V0OiBjYWNoZWREZXNjcmlwdG9yLnNldFxuICAgICAgfTsgLy8gRGVmaW5lXG5cbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZhbHVlc18uc2V0KGtleSwgbmV3IENvbXB1dGVkVmFsdWUob3B0aW9ucykpOyAvLyBOb3RpZnlcblxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIHVuZGVmaW5lZCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eURlc2NyaXB0b3J9IGRlc2NyaXB0b3JcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVfID0gZnVuY3Rpb24gZGVsZXRlXyhrZXksIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTm8gc3VjaCBwcm9wXG4gICAgaWYgKCFoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBJbnRlcmNlcHRcblxuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIHR5cGU6IFJFTU9WRVxuICAgICAgfSk7IC8vIENhbmNlbGxlZFxuXG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBEZWxldGVcblxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpcyRwZW5kaW5nS2V5c18sIF90aGlzJHBlbmRpbmdLZXlzXyRnZTtcblxuICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLnZhbHVlc18uZ2V0KGtleSk7IC8vIFZhbHVlIG5lZWRlZCBmb3Igc3BpZXMvbGlzdGVuZXJzXG5cbiAgICAgIHZhciB2YWx1ZSA9IHVuZGVmaW5lZDsgLy8gT3B0aW1pemF0aW9uOiBkb24ndCBwdWxsIHRoZSB2YWx1ZSB1bmxlc3Mgd2Ugd2lsbCBuZWVkIGl0XG5cbiAgICAgIGlmICghb2JzZXJ2YWJsZSAmJiAobm90aWZ5IHx8IG5vdGlmeVNweSkpIHtcbiAgICAgICAgdmFyIF9nZXREZXNjcmlwdG9yO1xuXG4gICAgICAgIHZhbHVlID0gKF9nZXREZXNjcmlwdG9yID0gZ2V0RGVzY3JpcHRvcih0aGlzLnRhcmdldF8sIGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0RGVzY3JpcHRvci52YWx1ZTtcbiAgICAgIH0gLy8gZGVsZXRlIHByb3AgKGRvIGZpcnN0LCBtYXkgZmFpbClcblxuXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhcmdldF9ba2V5XTtcbiAgICAgIH0gLy8gQWxsb3cgcmUtYW5ub3RhdGluZyB0aGlzIGZpZWxkXG5cblxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXBwbGllZEFubm90YXRpb25zX1trZXldO1xuICAgICAgfSAvLyBDbGVhciBvYnNlcnZhYmxlXG5cblxuICAgICAgaWYgKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW1wiZGVsZXRlXCJdKGtleSk7IC8vIGZvciBjb21wdXRlZCwgdmFsdWUgaXMgdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBPYnNlcnZhYmxlVmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ic2VydmFibGUudmFsdWVfO1xuICAgICAgICB9IC8vIE5vdGlmeTogYXV0b3J1bigoKSA9PiBvYmpba2V5XSksIHNlZSAjMTc5NlxuXG5cbiAgICAgICAgcHJvcGFnYXRlQ2hhbmdlZChvYnNlcnZhYmxlKTtcbiAgICAgIH0gLy8gTm90aWZ5IFwia2V5cy9lbnRyaWVzL3ZhbHVlc1wiIG9ic2VydmVyc1xuXG5cbiAgICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTsgLy8gTm90aWZ5IFwiaGFzXCIgb2JzZXJ2ZXJzXG4gICAgICAvLyBcImluXCIgYXMgaXQgbWF5IHN0aWxsIGV4aXN0IGluIHByb3RvXG5cbiAgICAgIChfdGhpcyRwZW5kaW5nS2V5c18gPSB0aGlzLnBlbmRpbmdLZXlzXykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRwZW5kaW5nS2V5c18kZ2UgPSBfdGhpcyRwZW5kaW5nS2V5c18uZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwZW5kaW5nS2V5c18kZ2Uuc2V0KGtleSBpbiB0aGlzLnRhcmdldF8pOyAvLyBOb3RpZnkgc3BpZXMvbGlzdGVuZXJzXG5cbiAgICAgIGlmIChub3RpZnkgfHwgbm90aWZ5U3B5KSB7XG4gICAgICAgIHZhciBfY2hhbmdlMiA9IHtcbiAgICAgICAgICB0eXBlOiBSRU1PVkUsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICAgIG9sZFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChfY2hhbmdlMik7XG4gICAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlMik7XG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogT2JzZXJ2ZXMgdGhpcyBvYmplY3QuIFRyaWdnZXJzIGZvciB0aGUgZXZlbnRzICdhZGQnLCAndXBkYXRlJyBhbmQgJ2RlbGV0ZScuXHJcbiAgICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qvb2JzZXJ2ZVxyXG4gICAqIGZvciBjYWxsYmFjayBkZXRhaWxzXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhjYWxsYmFjaywgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKCBmaXJlSW1tZWRpYXRlbHkgPT09IHRydWUpIGRpZShcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZpcmUgaW1tZWRpYXRlbHkgcHJvcGVydHkgZm9yIG9ic2VydmFibGUgb2JqZWN0cy5cIik7XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgY2FsbGJhY2spO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fID0gZnVuY3Rpb24gbm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBfdGhpcyRwZW5kaW5nS2V5c18yLCBfdGhpcyRwZW5kaW5nS2V5c18yJGc7XG5cbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgIHZhciBub3RpZnlTcHkgPSAgaXNTcHlFbmFibGVkKCk7XG5cbiAgICBpZiAobm90aWZ5IHx8IG5vdGlmeVNweSkge1xuICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxuXG4gICAgKF90aGlzJHBlbmRpbmdLZXlzXzIgPSB0aGlzLnBlbmRpbmdLZXlzXykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRwZW5kaW5nS2V5c18yJGcgPSBfdGhpcyRwZW5kaW5nS2V5c18yLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcGVuZGluZ0tleXNfMiRnLnNldCh0cnVlKTsgLy8gTm90aWZ5IFwia2V5cy9lbnRyaWVzL3ZhbHVlc1wiIG9ic2VydmVyc1xuXG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICB9O1xuXG4gIF9wcm90by5vd25LZXlzXyA9IGZ1bmN0aW9uIG93bktleXNfKCkge1xuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIG93bktleXModGhpcy50YXJnZXRfKTtcbiAgfTtcblxuICBfcHJvdG8ua2V5c18gPSBmdW5jdGlvbiBrZXlzXygpIHtcbiAgICAvLyBSZXR1cm5zIGVudW1lcmFibGUgJiYgb3duLCBidXQgdW5mb3J0dW5hdGVseSBrZXlzQXRvbSB3aWxsIHJlcG9ydCBvbiBBTlkga2V5IGNoYW5nZS5cbiAgICAvLyBUaGVyZSBpcyBubyB3YXkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBPYmplY3Qua2V5cyhvYmplY3QpIGFuZCBSZWZsZWN0Lm93bktleXMob2JqZWN0KSAtIGJvdGggYXJlIGhhbmRsZWQgYnkgb3duS2V5cyB0cmFwLlxuICAgIC8vIFdlIGNhbiBlaXRoZXIgb3Zlci1yZXBvcnQgaW4gT2JqZWN0LmtleXMob2JqZWN0KSBvciB1bmRlci1yZXBvcnQgaW4gUmVmbGVjdC5vd25LZXlzKG9iamVjdClcbiAgICAvLyBXZSBjaG9vc2UgdG8gb3Zlci1yZXBvcnQgaW4gT2JqZWN0LmtleXMob2JqZWN0KSwgYmVjYXVzZTpcbiAgICAvLyAtIHR5cGljYWxseSBpdCdzIHVzZWQgd2l0aCBzaW1wbGUgZGF0YSBvYmplY3RzXG4gICAgLy8gLSB3aGVuIHN5bWJvbGljL25vbi1lbnVtZXJhYmxlIGtleXMgYXJlIHJlbGV2YW50IFJlZmxlY3Qub3duS2V5cyB3b3JrcyBhcyBleHBlY3RlZFxuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudGFyZ2V0Xyk7XG4gIH07XG5cbiAgcmV0dXJuIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJG5hbWU7XG5cbiAgaWYgKCBvcHRpb25zICYmIGlzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpKSB7XG4gICAgZGllKFwiT3B0aW9ucyBjYW4ndCBiZSBwcm92aWRlZCBmb3IgYWxyZWFkeSBvYnNlcnZhYmxlIG9iamVjdHMuXCIpO1xuICB9XG5cbiAgaWYgKGhhc1Byb3AodGFyZ2V0LCAkbW9ieCkpIHtcbiAgICBpZiAoICEoZ2V0QWRtaW5pc3RyYXRpb24odGFyZ2V0KSBpbnN0YW5jZW9mIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbikpIHtcbiAgICAgIGRpZShcIkNhbm5vdCBjb252ZXJ0ICdcIiArIGdldERlYnVnTmFtZSh0YXJnZXQpICsgXCInIGludG8gb2JzZXJ2YWJsZSBvYmplY3Q6XCIgKyBcIlxcblRoZSB0YXJnZXQgaXMgYWxyZWFkeSBvYnNlcnZhYmxlIG9mIGRpZmZlcmVudCB0eXBlLlwiICsgXCJcXG5FeHRlbmRpbmcgYnVpbHRpbnMgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmICggIU9iamVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSkgZGllKFwiQ2Fubm90IG1ha2UgdGhlIGRlc2lnbmF0ZWQgb2JqZWN0IG9ic2VydmFibGU7IGl0IGlzIG5vdCBleHRlbnNpYmxlXCIpO1xuICB2YXIgbmFtZSA9IChfb3B0aW9ucyRuYW1lID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lKSAhPSBudWxsID8gX29wdGlvbnMkbmFtZSA6ICAoaXNQbGFpbk9iamVjdCh0YXJnZXQpID8gXCJPYnNlcnZhYmxlT2JqZWN0XCIgOiB0YXJnZXQuY29uc3RydWN0b3IubmFtZSkgKyBcIkBcIiArIGdldE5leHRJZCgpIDtcbiAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGFyZ2V0LCBuZXcgTWFwKCksIFN0cmluZyhuYW1lKSwgZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgYWRkSGlkZGVuUHJvcCh0YXJnZXQsICRtb2J4LCBhZG0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxudmFyIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb25cIiwgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKTtcblxuZnVuY3Rpb24gZ2V0Q2FjaGVkT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSkge1xuICByZXR1cm4gZGVzY3JpcHRvckNhY2hlW2tleV0gfHwgKGRlc2NyaXB0b3JDYWNoZVtrZXldID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLnNldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykge1xuICBpZiAoaXNPYmplY3QodGhpbmcpKSB7XG4gICAgcmV0dXJuIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRoaW5nWyRtb2J4XSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWNvcmRBbm5vdGF0aW9uQXBwbGllZChhZG0sIGFubm90YXRpb24sIGtleSkge1xuICB2YXIgX2FkbSR0YXJnZXRfJHN0b3JlZEFuO1xuXG4gIHtcbiAgICBhZG0uYXBwbGllZEFubm90YXRpb25zX1trZXldID0gYW5ub3RhdGlvbjtcbiAgfSAvLyBSZW1vdmUgYXBwbGllZCBkZWNvcmF0b3IgYW5ub3RhdGlvbiBzbyB3ZSBkb24ndCB0cnkgdG8gYXBwbHkgaXQgYWdhaW4gaW4gc3ViY2xhc3MgY29uc3RydWN0b3JcblxuXG4gIChfYWRtJHRhcmdldF8kc3RvcmVkQW4gPSBhZG0udGFyZ2V0X1tzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9hZG0kdGFyZ2V0XyRzdG9yZWRBbltrZXldO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBbm5vdGFibGUoYWRtLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgLy8gVmFsaWQgYW5ub3RhdGlvblxuICBpZiAoICFpc0Fubm90YXRpb24oYW5ub3RhdGlvbikpIHtcbiAgICBkaWUoXCJDYW5ub3QgYW5ub3RhdGUgJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzogSW52YWxpZCBhbm5vdGF0aW9uLlwiKTtcbiAgfVxuICAvKlxyXG4gIC8vIENvbmZpZ3VyYWJsZSwgbm90IHNlYWxlZCwgbm90IGZyb3plblxyXG4gIC8vIFBvc3NpYmx5IG5vdCBuZWVkZWQsIGp1c3QgYSBsaXR0bGUgYmV0dGVyIGVycm9yIHRoZW4gdGhlIG9uZSB0aHJvd24gYnkgZW5naW5lLlxyXG4gIC8vIENhc2VzIHdoZXJlIHRoaXMgd291bGQgYmUgdXNlZnVsIHRoZSBtb3N0IChzdWJjbGFzcyBmaWVsZCBpbml0aWFsaXplcikgYXJlIG5vdCBpbnRlcmNlcHRhYmxlIGJ5IHRoaXMuXHJcbiAgaWYgKF9fREVWX18pIHtcclxuICAgICAgY29uc3QgY29uZmlndXJhYmxlID0gZ2V0RGVzY3JpcHRvcihhZG0udGFyZ2V0Xywga2V5KT8uY29uZmlndXJhYmxlXHJcbiAgICAgIGNvbnN0IGZyb3plbiA9IE9iamVjdC5pc0Zyb3plbihhZG0udGFyZ2V0XylcclxuICAgICAgY29uc3Qgc2VhbGVkID0gT2JqZWN0LmlzU2VhbGVkKGFkbS50YXJnZXRfKVxyXG4gICAgICBpZiAoIWNvbmZpZ3VyYWJsZSB8fCBmcm96ZW4gfHwgc2VhbGVkKSB7XHJcbiAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBgJHthZG0ubmFtZV99LiR7a2V5LnRvU3RyaW5nKCl9YFxyXG4gICAgICAgICAgY29uc3QgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlX1xyXG4gICAgICAgICAgbGV0IGVycm9yID0gYENhbm5vdCBhcHBseSAnJHtyZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZX0nIHRvICcke2ZpZWxkTmFtZX0nOmBcclxuICAgICAgICAgIGlmIChmcm96ZW4pIHtcclxuICAgICAgICAgICAgICBlcnJvciArPSBgXFxuT2JqZWN0IGlzIGZyb3plbi5gXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcbk9iamVjdCBpcyBzZWFsZWQuYFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFjb25maWd1cmFibGUpIHtcclxuICAgICAgICAgICAgICBlcnJvciArPSBgXFxucHJvcGVydHkgaXMgbm90IGNvbmZpZ3VyYWJsZS5gXHJcbiAgICAgICAgICAgICAgLy8gTWVudGlvbiBvbmx5IGlmIGNhdXNlZCBieSB1cyB0byBhdm9pZCBjb25mdXNpb25cclxuICAgICAgICAgICAgICBpZiAoaGFzUHJvcChhZG0uYXBwbGllZEFubm90YXRpb25zISwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICBlcnJvciArPSBgXFxuVG8gcHJldmVudCBhY2NpZGVudGFsIHJlLWRlZmluaXRpb24gb2YgYSBmaWVsZCBieSBhIHN1YmNsYXNzLCBgXHJcbiAgICAgICAgICAgICAgICAgIGVycm9yICs9IGBhbGwgYW5ub3RhdGVkIGZpZWxkcyBvZiBub24tcGxhaW4gb2JqZWN0cyAoY2xhc3NlcykgYXJlIG5vdCBjb25maWd1cmFibGUuYFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRpZShlcnJvcilcclxuICAgICAgfVxyXG4gIH1cclxuICAqL1xuICAvLyBOb3QgYW5ub3RhdGVkXG5cblxuICBpZiAoICFpc092ZXJyaWRlKGFubm90YXRpb24pICYmIGhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9uc18sIGtleSkpIHtcbiAgICB2YXIgZmllbGROYW1lID0gYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKTtcbiAgICB2YXIgY3VycmVudEFubm90YXRpb25UeXBlID0gYWRtLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XS5hbm5vdGF0aW9uVHlwZV87XG4gICAgdmFyIHJlcXVlc3RlZEFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV87XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIHJlcXVlc3RlZEFubm90YXRpb25UeXBlICsgXCInIHRvICdcIiArIGZpZWxkTmFtZSArIFwiJzpcIiArIChcIlxcblRoZSBmaWVsZCBpcyBhbHJlYWR5IGFubm90YXRlZCB3aXRoICdcIiArIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSArIFwiJy5cIikgKyBcIlxcblJlLWFubm90YXRpbmcgZmllbGRzIGlzIG5vdCBhbGxvd2VkLlwiICsgXCJcXG5Vc2UgJ292ZXJyaWRlJyBhbm5vdGF0aW9uIGZvciBtZXRob2RzIG92ZXJyaWRlbiBieSBzdWJjbGFzcy5cIik7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFRoaXMgYXJyYXkgYnVmZmVyIGNvbnRhaW5zIHR3byBsaXN0cyBvZiBwcm9wZXJ0aWVzLCBzbyB0aGF0IGFsbCBhcnJheXNcclxuICogY2FuIHJlY3ljbGUgdGhlaXIgcHJvcGVydHkgZGVmaW5pdGlvbnMsIHdoaWNoIHNpZ25pZmljYW50bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb2YgY3JlYXRpbmdcclxuICogcHJvcGVydGllcyBvbiB0aGUgZmx5LlxyXG4gKi9cblxudmFyIE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUgPSAwOyAvLyBUeXBlc2NyaXB0IHdvcmthcm91bmQgdG8gbWFrZSBzdXJlIE9ic2VydmFibGVBcnJheSBleHRlbmRzIEFycmF5XG5cbnZhciBTdHViQXJyYXkgPSBmdW5jdGlvbiBTdHViQXJyYXkoKSB7fTtcblxuZnVuY3Rpb24gaW5oZXJpdChjdG9yLCBwcm90bykge1xuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGN0b3IucHJvdG90eXBlLCBwcm90byk7XG4gIH0gZWxzZSBpZiAoY3Rvci5wcm90b3R5cGUuX19wcm90b19fICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdG9yLnByb3RvdHlwZS5fX3Byb3RvX18gPSBwcm90bztcbiAgfSBlbHNlIHtcbiAgICBjdG9yLnByb3RvdHlwZSA9IHByb3RvO1xuICB9XG59XG5cbmluaGVyaXQoU3R1YkFycmF5LCBBcnJheS5wcm90b3R5cGUpOyAvLyBXZWV4IHByb3RvIGZyZWV6ZSBwcm90ZWN0aW9uIHdhcyBoZXJlLFxuLy8gYnV0IGl0IGlzIHVuY2xlYXIgd2h5IHRoZSBoYWNrIGlzIG5lZWQgYXMgTW9iWCBuZXZlciBjaGFuZ2VkIHRoZSBwcm90b3R5cGVcbi8vIGFueXdheSwgc28gcmVtb3ZlZCBpdCBpbiBWNlxuXG52YXIgTGVnYWN5T2JzZXJ2YWJsZUFycmF5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R1YkFycmF5KSB7XG4gIF9pbmhlcml0c0xvb3NlKExlZ2FjeU9ic2VydmFibGVBcnJheSwgX1N0dWJBcnJheSk7XG5cbiAgZnVuY3Rpb24gTGVnYWN5T2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lLCBvd25lZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWUgPSAgXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgaWYgKG93bmVkID09PSB2b2lkIDApIHtcbiAgICAgIG93bmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfU3R1YkFycmF5LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICB2YXIgYWRtID0gbmV3IE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBvd25lZCwgdHJ1ZSk7XG4gICAgYWRtLnByb3h5XyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpO1xuICAgIGFkZEhpZGRlbkZpbmFsUHJvcChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJG1vYngsIGFkbSk7XG5cbiAgICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLmxlbmd0aCkge1xuICAgICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgIF90aGlzLnNwbGljZVdpdGhBcnJheSgwLCAwLCBpbml0aWFsVmFsdWVzKTtcblxuICAgICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB0aGlzWyRtb2J4XS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFycmF5cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFycmF5c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLnNsaWNlKCksIC8vQHRzLWlnbm9yZVxuICAgIGFycmF5cy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBpc09ic2VydmFibGVBcnJheShhKSA/IGEuc2xpY2UoKSA6IGE7XG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90b1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG5leHRJbmRleCA8IHNlbGYubGVuZ3RoID8ge1xuICAgICAgICAgIHZhbHVlOiBzZWxmW25leHRJbmRleCsrXSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhMZWdhY3lPYnNlcnZhYmxlQXJyYXksIFt7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldEFycmF5TGVuZ3RoXygpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGVuZ3RoKSB7XG4gICAgICB0aGlzWyRtb2J4XS5zZXRBcnJheUxlbmd0aF8obmV3TGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIkFycmF5XCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExlZ2FjeU9ic2VydmFibGVBcnJheTtcbn0oU3R1YkFycmF5KTtcblxuT2JqZWN0LmVudHJpZXMoYXJyYXlFeHRlbnNpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwcm9wID0gX3JlZlswXSxcbiAgICAgIGZuID0gX3JlZlsxXTtcbiAgaWYgKHByb3AgIT09IFwiY29uY2F0XCIpIGFkZEhpZGRlblByb3AoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZSwgcHJvcCwgZm4pO1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldF8oaW5kZXgpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXNbJG1vYnhdLnNldF8oaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5QnVmZmVySXRlbShpbmRleCkge1xuICBkZWZpbmVQcm9wZXJ0eShMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBcIlwiICsgaW5kZXgsIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVBcnJheUJ1ZmZlcihtYXgpIHtcbiAgaWYgKG1heCA+IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkU7IGluZGV4IDwgbWF4ICsgMTAwOyBpbmRleCsrKSB7XG4gICAgICBjcmVhdGVBcnJheUJ1ZmZlckl0ZW0oaW5kZXgpO1xuICAgIH1cblxuICAgIE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUgPSBtYXg7XG4gIH1cbn1cbnJlc2VydmVBcnJheUJ1ZmZlcigxMDAwKTtcbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgTGVnYWN5T2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJiB0aGluZyAhPT0gbnVsbCkge1xuICAgIGlmIChpc09ic2VydmFibGVBcnJheSh0aGluZykpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSBkaWUoMjMpO1xuICAgICAgcmV0dXJuIHRoaW5nWyRtb2J4XS5hdG9tXztcbiAgICB9XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlU2V0KHRoaW5nKSkge1xuICAgICAgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSkge1xuICAgICAgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGluZy5rZXlzQXRvbV87XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaW5nLmRhdGFfLmdldChwcm9wZXJ0eSkgfHwgdGhpbmcuaGFzTWFwXy5nZXQocHJvcGVydHkpO1xuICAgICAgaWYgKCFvYnNlcnZhYmxlKSBkaWUoMjUsIHByb3BlcnR5LCBnZXREZWJ1Z05hbWUodGhpbmcpKTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpKSB7XG4gICAgICBpZiAoIXByb3BlcnR5KSByZXR1cm4gZGllKDI2KTtcblxuICAgICAgdmFyIF9vYnNlcnZhYmxlID0gdGhpbmdbJG1vYnhdLnZhbHVlc18uZ2V0KHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFfb2JzZXJ2YWJsZSkgZGllKDI3LCBwcm9wZXJ0eSwgZ2V0RGVidWdOYW1lKHRoaW5nKSk7XG4gICAgICByZXR1cm4gX29ic2VydmFibGU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXRvbSh0aGluZykgfHwgaXNDb21wdXRlZFZhbHVlKHRoaW5nKSB8fCBpc1JlYWN0aW9uKHRoaW5nKSkge1xuICAgICAgcmV0dXJuIHRoaW5nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaW5nKSkge1xuICAgIGlmIChpc1JlYWN0aW9uKHRoaW5nWyRtb2J4XSkpIHtcbiAgICAgIC8vIGRpc3Bvc2VyIGZ1bmN0aW9uXG4gICAgICByZXR1cm4gdGhpbmdbJG1vYnhdO1xuICAgIH1cbiAgfVxuXG4gIGRpZSgyOCk7XG59XG5mdW5jdGlvbiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpIHtcbiAgaWYgKCF0aGluZykgZGllKDI5KTtcbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbihnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xuICBpZiAoaXNBdG9tKHRoaW5nKSB8fCBpc0NvbXB1dGVkVmFsdWUodGhpbmcpIHx8IGlzUmVhY3Rpb24odGhpbmcpKSByZXR1cm4gdGhpbmc7XG4gIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHJldHVybiB0aGluZztcbiAgaWYgKHRoaW5nWyRtb2J4XSkgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgZGllKDI0LCB0aGluZyk7XG59XG5mdW5jdGlvbiBnZXREZWJ1Z05hbWUodGhpbmcsIHByb3BlcnR5KSB7XG4gIHZhciBuYW1lZDtcblxuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIG5hbWVkID0gZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpO1xuICB9IGVsc2UgaWYgKGlzQWN0aW9uKHRoaW5nKSkge1xuICAgIHJldHVybiB0aGluZy5uYW1lO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykgfHwgaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVTZXQodGhpbmcpKSB7XG4gICAgbmFtZWQgPSBnZXRBZG1pbmlzdHJhdGlvbih0aGluZyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdmFsaWQgZm9yIGFycmF5cyBhcyB3ZWxsXG4gICAgbmFtZWQgPSBnZXRBdG9tKHRoaW5nKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lZC5uYW1lXztcbn1cblxudmFyIHRvU3RyaW5nID0gb2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIsIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgZGVwdGggPSAtMTtcbiAgfVxuXG4gIHJldHVybiBlcShhLCBiLCBkZXB0aCk7XG59IC8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzVjMjM3YTdjNjgyZmI2OGZkNTM3ODIwM2YwYmYyMmRjZTE2MjQ4NTQvdW5kZXJzY29yZS5qcyNMMTE4Ni1MMTI4OVxuLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cblxuZnVuY3Rpb24gZXEoYSwgYiwgZGVwdGgsIGFTdGFjaywgYlN0YWNrKSB7XG4gIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7IC8vIGBudWxsYCBvciBgdW5kZWZpbmVkYCBvbmx5IGVxdWFsIHRvIGl0c2VsZiAoc3RyaWN0IGNvbXBhcmlzb24pLlxuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7IC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG5cbiAgaWYgKGEgIT09IGEpIHJldHVybiBiICE9PSBiOyAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICBpZiAoIWlzRnVuY3Rpb24odHlwZSkgJiYgdHlwZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7IC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG5cbiAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgIGNhc2UgXCJbb2JqZWN0IFJlZ0V4cF1cIjogLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcblxuICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICByZXR1cm4gXCJcIiArIGEgPT09IFwiXCIgKyBiO1xuXG4gICAgY2FzZSBcIltvYmplY3QgTnVtYmVyXVwiOlxuICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOLlxuICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjsgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cblxuICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcblxuICAgIGNhc2UgXCJbb2JqZWN0IERhdGVdXCI6XG4gICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgIHJldHVybiArYSA9PT0gK2I7XG5cbiAgICBjYXNlIFwiW29iamVjdCBTeW1ib2xdXCI6XG4gICAgICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wudmFsdWVPZi5jYWxsKGEpID09PSBTeW1ib2wudmFsdWVPZi5jYWxsKGIpO1xuXG4gICAgY2FzZSBcIltvYmplY3QgTWFwXVwiOlxuICAgIGNhc2UgXCJbb2JqZWN0IFNldF1cIjpcbiAgICAgIC8vIE1hcHMgYW5kIFNldHMgYXJlIHVud3JhcHBlZCB0byBhcnJheXMgb2YgZW50cnktcGFpcnMsIGFkZGluZyBhbiBpbmNpZGVudGFsIGxldmVsLlxuICAgICAgLy8gSGlkZSB0aGlzIGV4dHJhIGxldmVsIGJ5IGluY3JlYXNpbmcgdGhlIGRlcHRoLlxuICAgICAgaWYgKGRlcHRoID49IDApIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH0gLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG5cblxuICBhID0gdW53cmFwKGEpO1xuICBiID0gdW53cmFwKGIpO1xuICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cbiAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICBpZiAodHlwZW9mIGEgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7IC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJiBpc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXB0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChkZXB0aCA8IDApIHtcbiAgICBkZXB0aCA9IC0xO1xuICB9IC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuXG5cbiAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgfSAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG5cblxuICBhU3RhY2sucHVzaChhKTtcbiAgYlN0YWNrLnB1c2goYik7IC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuXG4gIGlmIChhcmVBcnJheXMpIHtcbiAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlOyAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBkZXB0aCAtIDEsIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBrZXk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cblxuICAgIGlmIChPYmplY3Qua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgIGlmICghKGhhc1Byb3AoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgZGVwdGggLSAxLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuXG5cbiAgYVN0YWNrLnBvcCgpO1xuICBiU3RhY2sucG9wKCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB1bndyYXAoYSkge1xuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkoYSkpIHJldHVybiBhLnNsaWNlKCk7XG4gIGlmIChpc0VTNk1hcChhKSB8fCBpc09ic2VydmFibGVNYXAoYSkpIHJldHVybiBBcnJheS5mcm9tKGEuZW50cmllcygpKTtcbiAgaWYgKGlzRVM2U2V0KGEpIHx8IGlzT2JzZXJ2YWJsZVNldChhKSkgcmV0dXJuIEFycmF5LmZyb20oYS5lbnRyaWVzKCkpO1xuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gbWFrZUl0ZXJhYmxlKGl0ZXJhdG9yKSB7XG4gIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBnZXRTZWxmO1xuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGYoKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBpc0Fubm90YXRpb24odGhpbmcpIHtcbiAgcmV0dXJuICgvLyBDYW4gYmUgZnVuY3Rpb25cbiAgICB0aGluZyBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlb2YgdGhpbmcuYW5ub3RhdGlvblR5cGVfID09PSBcInN0cmluZ1wiICYmIGlzRnVuY3Rpb24odGhpbmcubWFrZV8pICYmIGlzRnVuY3Rpb24odGhpbmcuZXh0ZW5kXylcbiAgKTtcbn1cblxuLyoqXHJcbiAqIChjKSBNaWNoZWwgV2VzdHN0cmF0ZSAyMDE1IC0gMjAyMFxyXG4gKiBNSVQgTGljZW5zZWRcclxuICpcclxuICogV2VsY29tZSB0byB0aGUgbW9ieCBzb3VyY2VzISBUbyBnZXQgYW4gZ2xvYmFsIG92ZXJ2aWV3IG9mIGhvdyBNb2JYIGludGVybmFsbHkgd29ya3MsXHJcbiAqIHRoaXMgaXMgYSBnb29kIHBsYWNlIHRvIHN0YXJ0OlxyXG4gKiBodHRwczovL21lZGl1bS5jb20vQG13ZXN0c3RyYXRlL2JlY29taW5nLWZ1bGx5LXJlYWN0aXZlLWFuLWluLWRlcHRoLWV4cGxhbmF0aW9uLW9mLW1vYnNlcnZhYmxlLTU1OTk1MjYyYTI1NCMueHZiaDZxZDc0XHJcbiAqXHJcbiAqIFNvdXJjZSBmb2xkZXJzOlxyXG4gKiA9PT09PT09PT09PT09PT1cclxuICpcclxuICogLSBhcGkvICAgICBNb3N0IG9mIHRoZSBwdWJsaWMgc3RhdGljIG1ldGhvZHMgZXhwb3NlZCBieSB0aGUgbW9kdWxlIGNhbiBiZSBmb3VuZCBoZXJlLlxyXG4gKiAtIGNvcmUvICAgIEltcGxlbWVudGF0aW9uIG9mIHRoZSBNb2JYIGFsZ29yaXRobTsgYXRvbXMsIGRlcml2YXRpb25zLCByZWFjdGlvbnMsIGRlcGVuZGVuY3kgdHJlZXMsIG9wdGltaXphdGlvbnMuIENvb2wgc3R1ZmYgY2FuIGJlIGZvdW5kIGhlcmUuXHJcbiAqIC0gdHlwZXMvICAgQWxsIHRoZSBtYWdpYyB0aGF0IGlzIG5lZWQgdG8gaGF2ZSBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgdmFsdWVzIGlzIGluIHRoaXMgZm9sZGVyLiBJbmNsdWRpbmcgdGhlIG1vZGlmaWVycyBsaWtlIGBhc0ZsYXRgLlxyXG4gKiAtIHV0aWxzLyAgIFV0aWxpdHkgc3R1ZmYuXHJcbiAqXHJcbiAqL1xuW1wiU3ltYm9sXCIsIFwiTWFwXCIsIFwiU2V0XCJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgdmFyIGcgPSBnZXRHbG9iYWwoKTtcblxuICBpZiAodHlwZW9mIGdbbV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkaWUoXCJNb2JYIHJlcXVpcmVzIGdsb2JhbCAnXCIgKyBtICsgXCInIHRvIGJlIGF2YWlsYWJsZSBvciBwb2x5ZmlsbGVkXCIpO1xuICB9XG59KTtcblxuaWYgKHR5cGVvZiBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gXCJvYmplY3RcIikge1xuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmR5a29nL21vYngtZGV2dG9vbHMvXG4gIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdE1vYngoe1xuICAgIHNweTogc3B5LFxuICAgIGV4dHJhczoge1xuICAgICAgZ2V0RGVidWdOYW1lOiBnZXREZWJ1Z05hbWVcbiAgICB9LFxuICAgICRtb2J4OiAkbW9ieFxuICB9KTtcbn1cblxuZXhwb3J0cy4kbW9ieCA9ICRtb2J4O1xuZXhwb3J0cy5GbG93Q2FuY2VsbGF0aW9uRXJyb3IgPSBGbG93Q2FuY2VsbGF0aW9uRXJyb3I7XG5leHBvcnRzLk9ic2VydmFibGVNYXAgPSBPYnNlcnZhYmxlTWFwO1xuZXhwb3J0cy5PYnNlcnZhYmxlU2V0ID0gT2JzZXJ2YWJsZVNldDtcbmV4cG9ydHMuUmVhY3Rpb24gPSBSZWFjdGlvbjtcbmV4cG9ydHMuX2FsbG93U3RhdGVDaGFuZ2VzID0gYWxsb3dTdGF0ZUNoYW5nZXM7XG5leHBvcnRzLl9hbGxvd1N0YXRlQ2hhbmdlc0luc2lkZUNvbXB1dGVkID0gcnVuSW5BY3Rpb247XG5leHBvcnRzLl9hbGxvd1N0YXRlUmVhZHNFbmQgPSBhbGxvd1N0YXRlUmVhZHNFbmQ7XG5leHBvcnRzLl9hbGxvd1N0YXRlUmVhZHNTdGFydCA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0O1xuZXhwb3J0cy5fYXV0b0FjdGlvbiA9IGF1dG9BY3Rpb247XG5leHBvcnRzLl9lbmRBY3Rpb24gPSBfZW5kQWN0aW9uO1xuZXhwb3J0cy5fZ2V0QWRtaW5pc3RyYXRpb24gPSBnZXRBZG1pbmlzdHJhdGlvbjtcbmV4cG9ydHMuX2dldEdsb2JhbFN0YXRlID0gZ2V0R2xvYmFsU3RhdGU7XG5leHBvcnRzLl9pbnRlcmNlcHRSZWFkcyA9IGludGVyY2VwdFJlYWRzO1xuZXhwb3J0cy5faXNDb21wdXRpbmdEZXJpdmF0aW9uID0gaXNDb21wdXRpbmdEZXJpdmF0aW9uO1xuZXhwb3J0cy5fcmVzZXRHbG9iYWxTdGF0ZSA9IHJlc2V0R2xvYmFsU3RhdGU7XG5leHBvcnRzLl9zdGFydEFjdGlvbiA9IF9zdGFydEFjdGlvbjtcbmV4cG9ydHMuYWN0aW9uID0gYWN0aW9uO1xuZXhwb3J0cy5hdXRvcnVuID0gYXV0b3J1bjtcbmV4cG9ydHMuY29tcGFyZXIgPSBjb21wYXJlcjtcbmV4cG9ydHMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbmV4cG9ydHMuY29uZmlndXJlID0gY29uZmlndXJlO1xuZXhwb3J0cy5jcmVhdGVBdG9tID0gY3JlYXRlQXRvbTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydHkgPSBhcGlEZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydHMuZW50cmllcyA9IGVudHJpZXM7XG5leHBvcnRzLmV4dGVuZE9ic2VydmFibGUgPSBleHRlbmRPYnNlcnZhYmxlO1xuZXhwb3J0cy5mbG93ID0gZmxvdztcbmV4cG9ydHMuZmxvd1Jlc3VsdCA9IGZsb3dSZXN1bHQ7XG5leHBvcnRzLmdldCA9IGdldDtcbmV4cG9ydHMuZ2V0QXRvbSA9IGdldEF0b207XG5leHBvcnRzLmdldERlYnVnTmFtZSA9IGdldERlYnVnTmFtZTtcbmV4cG9ydHMuZ2V0RGVwZW5kZW5jeVRyZWUgPSBnZXREZXBlbmRlbmN5VHJlZTtcbmV4cG9ydHMuZ2V0T2JzZXJ2ZXJUcmVlID0gZ2V0T2JzZXJ2ZXJUcmVlO1xuZXhwb3J0cy5oYXMgPSBoYXM7XG5leHBvcnRzLmludGVyY2VwdCA9IGludGVyY2VwdDtcbmV4cG9ydHMuaXNBY3Rpb24gPSBpc0FjdGlvbjtcbmV4cG9ydHMuaXNCb3hlZE9ic2VydmFibGUgPSBpc09ic2VydmFibGVWYWx1ZTtcbmV4cG9ydHMuaXNDb21wdXRlZCA9IGlzQ29tcHV0ZWQ7XG5leHBvcnRzLmlzQ29tcHV0ZWRQcm9wID0gaXNDb21wdXRlZFByb3A7XG5leHBvcnRzLmlzRmxvdyA9IGlzRmxvdztcbmV4cG9ydHMuaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3IgPSBpc0Zsb3dDYW5jZWxsYXRpb25FcnJvcjtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlID0gaXNPYnNlcnZhYmxlO1xuZXhwb3J0cy5pc09ic2VydmFibGVBcnJheSA9IGlzT2JzZXJ2YWJsZUFycmF5O1xuZXhwb3J0cy5pc09ic2VydmFibGVNYXAgPSBpc09ic2VydmFibGVNYXA7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZU9iamVjdCA9IGlzT2JzZXJ2YWJsZU9iamVjdDtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlUHJvcCA9IGlzT2JzZXJ2YWJsZVByb3A7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZVNldCA9IGlzT2JzZXJ2YWJsZVNldDtcbmV4cG9ydHMua2V5cyA9IGtleXM7XG5leHBvcnRzLm1ha2VBdXRvT2JzZXJ2YWJsZSA9IG1ha2VBdXRvT2JzZXJ2YWJsZTtcbmV4cG9ydHMubWFrZU9ic2VydmFibGUgPSBtYWtlT2JzZXJ2YWJsZTtcbmV4cG9ydHMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG5leHBvcnRzLm9ic2VydmUgPSBvYnNlcnZlO1xuZXhwb3J0cy5vbkJlY29tZU9ic2VydmVkID0gb25CZWNvbWVPYnNlcnZlZDtcbmV4cG9ydHMub25CZWNvbWVVbm9ic2VydmVkID0gb25CZWNvbWVVbm9ic2VydmVkO1xuZXhwb3J0cy5vblJlYWN0aW9uRXJyb3IgPSBvblJlYWN0aW9uRXJyb3I7XG5leHBvcnRzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG5leHBvcnRzLm93bktleXMgPSBhcGlPd25LZXlzO1xuZXhwb3J0cy5yZWFjdGlvbiA9IHJlYWN0aW9uO1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG5leHBvcnRzLnJ1bkluQWN0aW9uID0gcnVuSW5BY3Rpb247XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuc3B5ID0gc3B5O1xuZXhwb3J0cy50b0pTID0gdG9KUztcbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcbmV4cG9ydHMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbmV4cG9ydHMudW50cmFja2VkID0gdW50cmFja2VkO1xuZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5leHBvcnRzLndoZW4gPSB3aGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ieC5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJmdW5jdGlvbiB0KHQpe2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoLGk9bmV3IEFycmF5KG4+MT9uLTE6MCkscj0xO3I8bjtyKyspaVtyLTFdPWFyZ3VtZW50c1tyXTt0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXJcIj09dHlwZW9mIHQ/XCJbTW9iWF0gbWluaWZpZWQgZXJyb3IgbnI6IFwiK3QrKGkubGVuZ3RoP1wiIFwiK2kubWFwKFN0cmluZykuam9pbihcIixcIik6XCJcIikrXCIuIEZpbmQgdGhlIGZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9ibG9iL21haW4vcGFja2FnZXMvbW9ieC9zcmMvZXJyb3JzLnRzXCI6XCJbTW9iWF0gXCIrdCl9ZnVuY3Rpb24gbigpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp4bn1mdW5jdGlvbiBpKCl7Vm58fHQoXCJQcm94eSBub3QgYXZhaWxhYmxlXCIpfWZ1bmN0aW9uIHIodCl7dmFyIG49ITE7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIW4pcmV0dXJuIG49ITAsdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIGUodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH1mdW5jdGlvbiBvKHQpe3N3aXRjaCh0eXBlb2YgdCl7Y2FzZVwic3RyaW5nXCI6Y2FzZVwic3ltYm9sXCI6Y2FzZVwibnVtYmVyXCI6cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gbnVsbCE9PXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fWZ1bmN0aW9uIHModCl7dmFyIG47aWYoIXUodCkpcmV0dXJuITE7dmFyIGk9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO3JldHVybiBudWxsPT1pfHwobnVsbD09KG49aS5jb25zdHJ1Y3Rvcik/dm9pZCAwOm4udG9TdHJpbmcoKSk9PT1Obn1mdW5jdGlvbiBmKHQpe3ZhciBuPW51bGw9PXQ/dm9pZCAwOnQuY29uc3RydWN0b3I7cmV0dXJuISFuJiYoXCJHZW5lcmF0b3JGdW5jdGlvblwiPT09bi5uYW1lfHxcIkdlbmVyYXRvckZ1bmN0aW9uXCI9PT1uLmRpc3BsYXlOYW1lKX1mdW5jdGlvbiBhKHQsbixpKXtnbih0LG4se2VudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwLHZhbHVlOml9KX1mdW5jdGlvbiBjKHQsbixpKXtnbih0LG4se2VudW1lcmFibGU6ITEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwLHZhbHVlOml9KX1mdW5jdGlvbiBoKHQsbil7dmFyIGk9XCJpc01vYlhcIit0O3JldHVybiBuLnByb3RvdHlwZVtpXT0hMCxmdW5jdGlvbih0KXtyZXR1cm4gdSh0KSYmITA9PT10W2ldfX1mdW5jdGlvbiB2KHQpe3JldHVybiB0IGluc3RhbmNlb2YgTWFwfWZ1bmN0aW9uIGwodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBTZXR9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gbnVsbD09PXQ/bnVsbDpcIm9iamVjdFwiPT10eXBlb2YgdD9cIlwiK3Q6dH1mdW5jdGlvbiBiKHQsbil7cmV0dXJuIF9uLmhhc093blByb3BlcnR5LmNhbGwodCxuKX1mdW5jdGlvbiBwKHQsbil7Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciByPW5baV07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiB5KHQsbixpKXtyZXR1cm4gbiYmcCh0LnByb3RvdHlwZSxuKSxpJiZwKHQsaSksdH1mdW5jdGlvbiBtKCl7cmV0dXJuKG09T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl7dmFyIGk9YXJndW1lbnRzW25dO2Zvcih2YXIgciBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLHIpJiYodFtyXT1pW3JdKX1yZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiB3KHQsbil7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShuLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dCx0Ll9fcHJvdG9fXz1ufWZ1bmN0aW9uIGoodCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9ZnVuY3Rpb24geCh0LG4peyhudWxsPT1ufHxuPnQubGVuZ3RoKSYmKG49dC5sZW5ndGgpO2Zvcih2YXIgaT0wLHI9bmV3IEFycmF5KG4pO2k8bjtpKyspcltpXT10W2ldO3JldHVybiByfWZ1bmN0aW9uIE8odCxuKXt2YXIgaTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU3ltYm9sfHxudWxsPT10W1N5bWJvbC5pdGVyYXRvcl0pe2lmKEFycmF5LmlzQXJyYXkodCl8fChpPWZ1bmN0aW9uKHQpe2lmKHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiB4KHQsdm9pZCAwKTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PW4mJnQuY29uc3RydWN0b3ImJihuPXQuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uP0FycmF5LmZyb20odCk6XCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pP3godCx2b2lkIDApOnZvaWQgMH19KHQpKXx8biYmdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXtpJiYodD1pKTt2YXIgcj0wO3JldHVybiBmdW5jdGlvbigpe3JldHVybiByPj10Lmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtyKytdfX19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXJldHVybihpPXRbU3ltYm9sLml0ZXJhdG9yXSgpKS5uZXh0LmJpbmQoaSl9ZnVuY3Rpb24gQSh0KXtyZXR1cm4gT2JqZWN0LmFzc2lnbigoZnVuY3Rpb24obixpKXtnKG4saSx0KX0pLHQpfWZ1bmN0aW9uIGcodCxuLGkpe2IodCxDbil8fGEodCxDbixtKHt9LHRbQ25dKSksZnVuY3Rpb24odCl7cmV0dXJuXCJvdmVycmlkZVwiPT09dC50fShpKXx8KHRbQ25dW25dPWkpfWZ1bmN0aW9uIF8odCxuLGkpe3ZvaWQgMD09PW4mJihuPVJuKSx2b2lkIDA9PT1pJiYoaT1Sbik7dmFyIHI9bmV3IExuKHQpO3JldHVybiBuIT09Um4mJlN0KHIsbiksaSE9PVJuJiZNdChyLGkpLHJ9ZnVuY3Rpb24gUyh0LG4saSl7cmV0dXJuIEl0KHQpP3Q6QXJyYXkuaXNBcnJheSh0KT8kbi5hcnJheSh0LHtuYW1lOml9KTpzKHQpPyRuLm9iamVjdCh0LHZvaWQgMCx7bmFtZTppfSk6dih0KT8kbi5tYXAodCx7bmFtZTppfSk6bCh0KT8kbi5zZXQodCx7bmFtZTppfSk6XCJmdW5jdGlvblwiIT10eXBlb2YgdHx8QXQodCl8fEN0KHQpP3Q6Zih0KT9SaSh0KTpfaShpLHQpfWZ1bmN0aW9uIE0odCl7cmV0dXJuIHR9ZnVuY3Rpb24gVih0LG4pe3JldHVybnt0OnQsaTpuLG86Tix1OlJ9fWZ1bmN0aW9uIE4odCxuLGkscil7dmFyIGU7aWYobnVsbD09KGU9dGhpcy5pKT92b2lkIDA6ZS5ib3VuZClyZXR1cm4gbnVsbD09PXRoaXMudSh0LG4saSwhMSk/MDoxO2lmKHI9PT10LnMpcmV0dXJuIG51bGw9PT10aGlzLnUodCxuLGksITEpPzA6MjtpZihBdChpLnZhbHVlKSlyZXR1cm4gMTt2YXIgbz1rKHQsdGhpcyxuLGksITEpO3JldHVybiBnbihyLG4sbyksMn1mdW5jdGlvbiBSKHQsbixpLHIpe3ZhciBlPWsodCx0aGlzLG4saSk7cmV0dXJuIHQuaChuLGUscil9ZnVuY3Rpb24gayh0LG4saSxyLGUpe3ZhciBvLHUscyxmLGE7dm9pZCAwPT09ZSYmKGU9cGkuc2FmZURlc2NyaXB0b3JzKTt2YXIgYyxoPXIudmFsdWU7cmV0dXJuKG51bGw9PShvPW4uaSk/dm9pZCAwOm8uYm91bmQpJiYoaD1oLmJpbmQobnVsbCE9KGM9dC52KT9jOnQucykpLHt2YWx1ZTp6KG51bGwhPSh1PW51bGw9PShzPW4uaSk/dm9pZCAwOnMubmFtZSk/dTppLnRvU3RyaW5nKCksaCxudWxsIT0oZj1udWxsPT0oYT1uLmkpP3ZvaWQgMDphLmF1dG9BY3Rpb24pJiZmKSxjb25maWd1cmFibGU6IWV8fHQubCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiFlfX1mdW5jdGlvbiBFKHQsbil7cmV0dXJue3Q6dCxpOm4sbzpULHU6Q319ZnVuY3Rpb24gVCh0LG4saSxyKXt2YXIgZTtpZihyPT09dC5zKXJldHVybiBudWxsPT09dGhpcy51KHQsbixpLCExKT8wOjI7aWYoKG51bGw9PShlPXRoaXMuaSk/dm9pZCAwOmUuYm91bmQpJiYhQ3QodC5zW25dKSYmbnVsbD09PXRoaXMudSh0LG4saSwhMSkpcmV0dXJuIDA7aWYoQ3QoaS52YWx1ZSkpcmV0dXJuIDE7dmFyIG89Syh0LDAsMCxpLCExLCExKTtyZXR1cm4gZ24ocixuLG8pLDJ9ZnVuY3Rpb24gQyh0LG4saSxyKXt2YXIgZSxvPUsodCwwLDAsaSxudWxsPT0oZT10aGlzLmkpP3ZvaWQgMDplLmJvdW5kKTtyZXR1cm4gdC5oKG4sbyxyKX1mdW5jdGlvbiBLKHQsbixpLHIsZSxvKXt2b2lkIDA9PT1vJiYobz1waS5zYWZlRGVzY3JpcHRvcnMpO3ZhciB1LHM9ci52YWx1ZTtyZXR1cm4gZSYmKHM9cy5iaW5kKG51bGwhPSh1PXQudik/dTp0LnMpKSx7dmFsdWU6UmkocyksY29uZmlndXJhYmxlOiFvfHx0LmwsZW51bWVyYWJsZTohMSx3cml0YWJsZTohb319ZnVuY3Rpb24gTCh0LG4pe3JldHVybnt0OnQsaTpuLG86SSx1OlB9fWZ1bmN0aW9uIEkodCxuLGkpe3JldHVybiBudWxsPT09dGhpcy51KHQsbixpLCExKT8wOjF9ZnVuY3Rpb24gUCh0LG4saSxyKXtyZXR1cm4gdC5wKG4sbSh7fSx0aGlzLmkse2dldDppLmdldCxzZXQ6aS5zZXR9KSxyKX1mdW5jdGlvbiBEKHQsbil7cmV0dXJue3Q6dCxpOm4sbzpCLHU6cX19ZnVuY3Rpb24gQih0LG4saSl7cmV0dXJuIG51bGw9PT10aGlzLnUodCxuLGksITEpPzA6MX1mdW5jdGlvbiBxKHQsbixpLHIpe3ZhciBlLG87cmV0dXJuIHQubShuLGkudmFsdWUsbnVsbCE9KGU9bnVsbD09KG89dGhpcy5pKT92b2lkIDA6by5lbmhhbmNlcik/ZTpTLHIpfWZ1bmN0aW9uIEcodCl7cmV0dXJue3Q6XCJ0cnVlXCIsaTp0LG86WCx1Old9fWZ1bmN0aW9uIFgodCxuLGkscil7dmFyIGUsbyx1LHM7aWYoaS5nZXQpcmV0dXJuIFFuLm8odCxuLGkscik7aWYoaS5zZXQpe3ZhciBhPXoobi50b1N0cmluZygpLGkuc2V0KTtyZXR1cm4gcj09PXQucz9udWxsPT09dC5oKG4se2NvbmZpZ3VyYWJsZTohcGkuc2FmZURlc2NyaXB0b3JzfHx0Lmwsc2V0OmF9KT8wOjI6KGduKHIsbix7Y29uZmlndXJhYmxlOiEwLHNldDphfSksMil9aWYociE9PXQucyYmXCJmdW5jdGlvblwiPT10eXBlb2YgaS52YWx1ZSlyZXR1cm4gZihpLnZhbHVlKT8oKG51bGw9PShzPXRoaXMuaSk/dm9pZCAwOnMuYXV0b0JpbmQpP1JpLmJvdW5kOlJpKS5vKHQsbixpLHIpOigobnVsbD09KHU9dGhpcy5pKT92b2lkIDA6dS5hdXRvQmluZCk/X2kuYm91bmQ6X2kpLm8odCxuLGkscik7dmFyIGMsaD0hMT09PShudWxsPT0oZT10aGlzLmkpP3ZvaWQgMDplLmRlZXApPyRuLnJlZjokbjtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBpLnZhbHVlJiYobnVsbD09KG89dGhpcy5pKT92b2lkIDA6by5hdXRvQmluZCkmJihpLnZhbHVlPWkudmFsdWUuYmluZChudWxsIT0oYz10LnYpP2M6dC5zKSksaC5vKHQsbixpLHIpfWZ1bmN0aW9uIFcodCxuLGkscil7dmFyIGUsbyx1O3JldHVybiBpLmdldD9Rbi51KHQsbixpLHIpOmkuc2V0P3QuaChuLHtjb25maWd1cmFibGU6IXBpLnNhZmVEZXNjcmlwdG9yc3x8dC5sLHNldDp6KG4udG9TdHJpbmcoKSxpLnNldCl9LHIpOihcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLnZhbHVlJiYobnVsbD09KGU9dGhpcy5pKT92b2lkIDA6ZS5hdXRvQmluZCkmJihpLnZhbHVlPWkudmFsdWUuYmluZChudWxsIT0odT10LnYpP3U6dC5zKSksKCExPT09KG51bGw9PShvPXRoaXMuaSk/dm9pZCAwOm8uZGVlcCk/JG4ucmVmOiRuKS51KHQsbixpLHIpKX1mdW5jdGlvbiBIKHQpe3JldHVybiB0fHxxbn1mdW5jdGlvbiBVKHQpe3JldHVybiEwPT09dC5kZWVwP1M6ITE9PT10LmRlZXA/TToobj10LmRlZmF1bHREZWNvcmF0b3IpJiZudWxsIT0oaT1udWxsPT0ocj1uLmkpP3ZvaWQgMDpyLmVuaGFuY2VyKT9pOlM7dmFyIG4saSxyfWZ1bmN0aW9uIEYodCxuLGkpe2lmKCFvKG4pKXJldHVybiBJdCh0KT90OnModCk/JG4ub2JqZWN0KHQsbixpKTpBcnJheS5pc0FycmF5KHQpPyRuLmFycmF5KHQsbik6dih0KT8kbi5tYXAodCxuKTpsKHQpPyRuLnNldCh0LG4pOlwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dD90OiRuLmJveCh0LG4pO2codCxuLEduKX1mdW5jdGlvbiB6KHQsbixpLHIpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gJCgwLGksbixyfHx0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIHZvaWQgMD09PWkmJihpPSExKSxlLmlzTW9ieEFjdGlvbj0hMCxpaSYmKHJpLnZhbHVlPXQsT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJuYW1lXCIscmkpKSxlfWZ1bmN0aW9uICQodCxuLGkscixlKXt2YXIgbz1KKDAsbik7dHJ5e3JldHVybiBpLmFwcGx5KHIsZSl9Y2F0Y2godCl7dGhyb3cgby5qPXQsdH1maW5hbGx5e1kobyl9fWZ1bmN0aW9uIEoodCxuKXt2YXIgaT1waS50cmFja2luZ0Rlcml2YXRpb24scj0hbnx8IWk7ZHQoKTt2YXIgZT1waS5hbGxvd1N0YXRlQ2hhbmdlcztyJiYodXQoKSxlPVooITApKTt2YXIgbz17TzpyLEE6aSxnOmUsXzpmdCghMCksUzohMSxNOjAsVjpuaSsrLE46dGl9O3JldHVybiB0aT1vLlYsb31mdW5jdGlvbiBZKG4pe3RpIT09bi5WJiZ0KDMwKSx0aT1uLk4sdm9pZCAwIT09bi5qJiYocGkuc3VwcHJlc3NSZWFjdGlvbkVycm9ycz0hMCksdHQobi5nKSxhdChuLl8pLGJ0KCksbi5PJiZzdChuLkEpLHBpLnN1cHByZXNzUmVhY3Rpb25FcnJvcnM9ITF9ZnVuY3Rpb24gUSh0LG4pe3ZhciBpPVoodCk7dHJ5e3JldHVybiBuKCl9ZmluYWxseXt0dChpKX19ZnVuY3Rpb24gWih0KXt2YXIgbj1waS5hbGxvd1N0YXRlQ2hhbmdlcztyZXR1cm4gcGkuYWxsb3dTdGF0ZUNoYW5nZXM9dCxufWZ1bmN0aW9uIHR0KHQpe3BpLmFsbG93U3RhdGVDaGFuZ2VzPXR9ZnVuY3Rpb24gbnQodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBoaX1mdW5jdGlvbiBpdCh0KXtzd2l0Y2godC5SKXtjYXNlIHNpLms6cmV0dXJuITE7Y2FzZSBzaS5UOmNhc2Ugc2kuQzpyZXR1cm4hMDtjYXNlIHNpLks6Zm9yKHZhciBuPWZ0KCEwKSxpPXV0KCkscj10LkwsZT1yLmxlbmd0aCxvPTA7bzxlO28rKyl7dmFyIHU9cltvXTtpZihjaSh1KSl7aWYocGkuZGlzYWJsZUVycm9yQm91bmRhcmllcyl1LmdldCgpO2Vsc2UgdHJ5e3UuZ2V0KCl9Y2F0Y2godCl7cmV0dXJuIHN0KGkpLGF0KG4pLCEwfWlmKHQuUj09PXNpLkMpcmV0dXJuIHN0KGkpLGF0KG4pLCEwfX1yZXR1cm4gY3QodCksc3QoaSksYXQobiksITF9fWZ1bmN0aW9uIHJ0KHQsbixpKXt2YXIgcj1mdCghMCk7Y3QodCksdC5JPW5ldyBBcnJheSh0LkwubGVuZ3RoKzEwMCksdC5QPTAsdC5EPSsrcGkucnVuSWQ7dmFyIGUsbz1waS50cmFja2luZ0Rlcml2YXRpb247aWYocGkudHJhY2tpbmdEZXJpdmF0aW9uPXQscGkuaW5CYXRjaCsrLCEwPT09cGkuZGlzYWJsZUVycm9yQm91bmRhcmllcyllPW4uY2FsbChpKTtlbHNlIHRyeXtlPW4uY2FsbChpKX1jYXRjaCh0KXtlPW5ldyBoaSh0KX1yZXR1cm4gcGkuaW5CYXRjaC0tLHBpLnRyYWNraW5nRGVyaXZhdGlvbj1vLGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj10LkwsaT10Lkw9dC5JLHI9c2kuayxlPTAsbz10LlAsdT0wO3U8bzt1Kyspe3ZhciBzPWlbdV07MD09PXMuQiYmKHMuQj0xLGUhPT11JiYoaVtlXT1zKSxlKyspLHMuUj5yJiYocj1zLlIpfWZvcihpLmxlbmd0aD1lLHQuST1udWxsLG89bi5sZW5ndGg7by0tOyl7dmFyIGY9bltvXTswPT09Zi5CJiZ2dChmLHQpLGYuQj0wfWZvcig7ZS0tOyl7dmFyIGE9aVtlXTsxPT09YS5CJiYoYS5CPTAsaHQoYSx0KSl9ciE9PXNpLmsmJih0LlI9cix0LnEoKSl9KHQpLGF0KHIpLGV9ZnVuY3Rpb24gZXQodCl7dmFyIG49dC5MO3QuTD1bXTtmb3IodmFyIGk9bi5sZW5ndGg7aS0tOyl2dChuW2ldLHQpO3QuUj1zaS5UfWZ1bmN0aW9uIG90KHQpe3ZhciBuPXV0KCk7dHJ5e3JldHVybiB0KCl9ZmluYWxseXtzdChuKX19ZnVuY3Rpb24gdXQoKXt2YXIgdD1waS50cmFja2luZ0Rlcml2YXRpb247cmV0dXJuIHBpLnRyYWNraW5nRGVyaXZhdGlvbj1udWxsLHR9ZnVuY3Rpb24gc3QodCl7cGkudHJhY2tpbmdEZXJpdmF0aW9uPXR9ZnVuY3Rpb24gZnQodCl7dmFyIG49cGkuYWxsb3dTdGF0ZVJlYWRzO3JldHVybiBwaS5hbGxvd1N0YXRlUmVhZHM9dCxufWZ1bmN0aW9uIGF0KHQpe3BpLmFsbG93U3RhdGVSZWFkcz10fWZ1bmN0aW9uIGN0KHQpe2lmKHQuUiE9PXNpLmspe3QuUj1zaS5rO2Zvcih2YXIgbj10LkwsaT1uLmxlbmd0aDtpLS07KW5baV0uRz1zaS5rfX1mdW5jdGlvbiBodCh0LG4pe3QuWC5hZGQobiksdC5HPm4uUiYmKHQuRz1uLlIpfWZ1bmN0aW9uIHZ0KHQsbil7dC5YLmRlbGV0ZShuKSwwPT09dC5YLnNpemUmJmx0KHQpfWZ1bmN0aW9uIGx0KHQpeyExPT09dC5XJiYodC5XPSEwLHBpLnBlbmRpbmdVbm9ic2VydmF0aW9ucy5wdXNoKHQpKX1mdW5jdGlvbiBkdCgpe3BpLmluQmF0Y2grK31mdW5jdGlvbiBidCgpe2lmKDA9PS0tcGkuaW5CYXRjaCl7bXQoKTtmb3IodmFyIHQ9cGkucGVuZGluZ1Vub2JzZXJ2YXRpb25zLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXTtpLlc9ITEsMD09PWkuWC5zaXplJiYoaS5IJiYoaS5IPSExLGkub25CVU8oKSksaSBpbnN0YW5jZW9mIGFpJiZpLlUoKSl9cGkucGVuZGluZ1Vub2JzZXJ2YXRpb25zPVtdfX1mdW5jdGlvbiBwdCh0KXt2YXIgbj1waS50cmFja2luZ0Rlcml2YXRpb247cmV0dXJuIG51bGwhPT1uPyhuLkQhPT10LkYmJih0LkY9bi5ELG4uSVtuLlArK109dCwhdC5IJiZwaS50cmFja2luZ0NvbnRleHQmJih0Lkg9ITAsdC5vbkJPKCkpKSwhMCk6KDA9PT10Llguc2l6ZSYmcGkuaW5CYXRjaD4wJiZsdCh0KSwhMSl9ZnVuY3Rpb24geXQodCl7dC5HIT09c2kuQyYmKHQuRz1zaS5DLHQuWC5mb3JFYWNoKChmdW5jdGlvbih0KXt0LlI9PT1zaS5rJiZ0LnEoKSx0LlI9c2kuQ30pKSl9ZnVuY3Rpb24gbXQoKXtwaS5pbkJhdGNoPjB8fHBpLmlzUnVubmluZ1JlYWN0aW9uc3x8bWkod3QpfWZ1bmN0aW9uIHd0KCl7cGkuaXNSdW5uaW5nUmVhY3Rpb25zPSEwO2Zvcih2YXIgdD1waS5wZW5kaW5nUmVhY3Rpb25zLG49MDt0Lmxlbmd0aD4wOyl7MTAwPT0rK24mJihjb25zb2xlLmVycm9yKFwiW21vYnhdIGN5Y2xlIGluIHJlYWN0aW9uOiBcIit0WzBdKSx0LnNwbGljZSgwKSk7Zm9yKHZhciBpPXQuc3BsaWNlKDApLHI9MCxlPWkubGVuZ3RoO3I8ZTtyKyspaVtyXS4kKCl9cGkuaXNSdW5uaW5nUmVhY3Rpb25zPSExfWZ1bmN0aW9uIGp0KCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlttb2J4LnNweV0gSXMgYSBuby1vcCBpbiBwcm9kdWN0aW9uIGJ1aWxkc1wiKSxmdW5jdGlvbigpe319ZnVuY3Rpb24geHQodCl7cmV0dXJuIGZ1bmN0aW9uKG4saSl7cmV0dXJuIGUobik/eihuLm5hbWV8fFwiPHVubmFtZWQgYWN0aW9uPlwiLG4sdCk6ZShpKT96KG4saSx0KTpvKGkpP2cobixpLHQ/T2k6amkpOm8obik/QShWKHQ/XCJhdXRvQWN0aW9uXCI6XCJhY3Rpb25cIix7bmFtZTpuLGF1dG9BY3Rpb246dH0pKTp2b2lkIDB9fWZ1bmN0aW9uIE90KHQpe3JldHVybiAkKDAsITEsdCx0aGlzLHZvaWQgMCl9ZnVuY3Rpb24gQXQodCl7cmV0dXJuIGUodCkmJiEwPT09dC5pc01vYnhBY3Rpb259ZnVuY3Rpb24gZ3QodCxuKXtmdW5jdGlvbiBpKCl7dChvKX12YXIgcixlO3ZvaWQgMD09PW4mJihuPU1uKTt2YXIgbyx1PW51bGwhPShyPW51bGw9PShlPW4pP3ZvaWQgMDplLm5hbWUpP3I6XCJBdXRvcnVuXCI7aWYobi5zY2hlZHVsZXJ8fG4uZGVsYXkpe3ZhciBzPV90KG4pLGY9ITE7bz1uZXcgeWkodSwoZnVuY3Rpb24oKXtmfHwoZj0hMCxzKChmdW5jdGlvbigpe2Y9ITEsby5KfHxvLnRyYWNrKGkpfSkpKX0pLG4ub25FcnJvcixuLnJlcXVpcmVzT2JzZXJ2YWJsZSl9ZWxzZSBvPW5ldyB5aSh1LChmdW5jdGlvbigpe3RoaXMudHJhY2soaSl9KSxuLm9uRXJyb3Isbi5yZXF1aXJlc09ic2VydmFibGUpO3JldHVybiBvLlkoKSxvLlooKX1mdW5jdGlvbiBfdCh0KXtyZXR1cm4gdC5zY2hlZHVsZXI/dC5zY2hlZHVsZXI6dC5kZWxheT9mdW5jdGlvbihuKXtyZXR1cm4gc2V0VGltZW91dChuLHQuZGVsYXkpfTpTaX1mdW5jdGlvbiBTdCh0LG4saSl7cmV0dXJuIFZ0KFwib25CT1wiLHQsbixpKX1mdW5jdGlvbiBNdCh0LG4saSl7cmV0dXJuIFZ0KFwib25CVU9cIix0LG4saSl9ZnVuY3Rpb24gVnQodCxuLGkscil7dmFyIG89XCJmdW5jdGlvblwiPT10eXBlb2Ygcj9kbihuLGkpOmRuKG4pLHU9ZShyKT9yOmkscz10K1wiTFwiO3JldHVybiBvW3NdP29bc10uYWRkKHUpOm9bc109bmV3IFNldChbdV0pLGZ1bmN0aW9uKCl7dmFyIHQ9b1tzXTt0JiYodC5kZWxldGUodSksMD09PXQuc2l6ZSYmZGVsZXRlIG9bc10pfX1mdW5jdGlvbiBOdCh0LG4saSxyKXt2YXIgZT1UbihuKSxvPXNuKHQscilbS25dO2R0KCk7dHJ5e0VuKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe28udSh0LGVbdF0sIWl8fCEodCBpbiBpKXx8aVt0XSl9KSl9ZmluYWxseXtidCgpfXJldHVybiB0fWZ1bmN0aW9uIFJ0KHQpe3ZhciBuLGk9e25hbWU6dC50dH07cmV0dXJuIHQuTCYmdC5MLmxlbmd0aD4wJiYoaS5kZXBlbmRlbmNpZXM9KG49dC5MLEFycmF5LmZyb20obmV3IFNldChuKSkpLm1hcChSdCkpLGl9ZnVuY3Rpb24ga3QodCl7dmFyIG49e25hbWU6dC50dH07cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiB0LlgmJnQuWC5zaXplPjB9KHQpJiYobi5vYnNlcnZlcnM9QXJyYXkuZnJvbShmdW5jdGlvbih0KXtyZXR1cm4gdC5YfSh0KSkubWFwKGt0KSksbn1mdW5jdGlvbiBFdCgpe3RoaXMubWVzc2FnZT1cIkZMT1dfQ0FOQ0VMTEVEXCJ9ZnVuY3Rpb24gVHQodCl7ZSh0LmNhbmNlbCkmJnQuY2FuY2VsKCl9ZnVuY3Rpb24gQ3QodCl7cmV0dXJuITA9PT0obnVsbD09dD92b2lkIDA6dC5pc01vYlhGbG93KX1mdW5jdGlvbiBLdCh0LG4pe2lmKHZvaWQgMCE9PW4pe2lmKCExPT09YW4odCkpcmV0dXJuITE7aWYoIXRbS25dLm50LmhhcyhuKSlyZXR1cm4hMTt2YXIgaT1kbih0LG4pO3JldHVybiBjaShpKX1yZXR1cm4gY2kodCl9ZnVuY3Rpb24gTHQodCxuKXtyZXR1cm4hIXQmJih2b2lkIDAhPT1uPyEhYW4odCkmJnRbS25dLm50LmhhcyhuKTphbih0KXx8ISF0W0tuXXx8SW4odCl8fHdpKHQpfHxjaSh0KSl9ZnVuY3Rpb24gSXQodCl7cmV0dXJuIEx0KHQpfWZ1bmN0aW9uIFB0KG4pe3JldHVybiBhbihuKT9uW0tuXS5pdCgpOkhpKG4pfHxKaShuKT9BcnJheS5mcm9tKG4ua2V5cygpKTp1bihuKT9uLm1hcCgoZnVuY3Rpb24odCxuKXtyZXR1cm4gbn0pKTp2b2lkIHQoNSl9ZnVuY3Rpb24gRHQobixpKXtyZXR1cm4gYW4obik/bltLbl0ucnQoaSk6SGkobil8fEppKG4pP24uaGFzKGkpOnVuKG4pP2k+PTAmJmk8bi5sZW5ndGg6dm9pZCB0KDEwKX1mdW5jdGlvbiBCdChuKXtpZihhbihuKSlyZXR1cm4gbltLbl0uZXQoKTt0KDM4KX1mdW5jdGlvbiBxdCh0LG4saSl7cmV0dXJuIHQuc2V0KG4saSksaX1mdW5jdGlvbiBHdCgpe3QoXCJ0cmFjZSgpIGlzIG5vdCBhdmFpbGFibGUgaW4gcHJvZHVjdGlvbiBidWlsZHNcIik7Zm9yKHZhciBuPSExLGk9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShpKSxlPTA7ZTxpO2UrKylyW2VdPWFyZ3VtZW50c1tlXTtcImJvb2xlYW5cIj09dHlwZW9mIHJbci5sZW5ndGgtMV0mJihuPXIucG9wKCkpO3ZhciBvPVh0KHIpO2lmKCFvKXJldHVybiB0KFwiJ3RyYWNlKGJyZWFrPyknIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgdHJhY2tlZCBjb21wdXRlZCB2YWx1ZSBvciBhIFJlYWN0aW9uLiBDb25zaWRlciBwYXNzaW5nIGluIHRoZSBjb21wdXRlZCB2YWx1ZSBvciByZWFjdGlvbiBleHBsaWNpdGx5XCIpO28ub3Q9PT1maS5OT05FJiZjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIrby50dCtcIicgdHJhY2luZyBlbmFibGVkXCIpLG8ub3Q9bj9maS5CUkVBSzpmaS5MT0d9ZnVuY3Rpb24gWHQodCl7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHBpLnRyYWNraW5nRGVyaXZhdGlvbjtjYXNlIDE6cmV0dXJuIGRuKHRbMF0pO2Nhc2UgMjpyZXR1cm4gZG4odFswXSx0WzFdKX19ZnVuY3Rpb24gV3QodCxuKXt2b2lkIDA9PT1uJiYobj12b2lkIDApLGR0KCk7dHJ5e3JldHVybiB0LmFwcGx5KG4pfWZpbmFsbHl7YnQoKX19ZnVuY3Rpb24gSHQodCxuLGkpe3ZhciByO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBpLnRpbWVvdXQpe3ZhciBlPW5ldyBFcnJvcihcIldIRU5fVElNRU9VVFwiKTtyPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aWYoIXVbS25dLkope2lmKHUoKSwhaS5vbkVycm9yKXRocm93IGU7aS5vbkVycm9yKGUpfX0pLGkudGltZW91dCl9aS5uYW1lPVwiV2hlblwiO3ZhciBvPXooXCJXaGVuLWVmZmVjdFwiLG4pLHU9Z3QoKGZ1bmN0aW9uKG4pe1EoITEsdCkmJihuLmRpc3Bvc2UoKSxyJiZjbGVhclRpbWVvdXQociksbygpKX0pLGkpO3JldHVybiB1fWZ1bmN0aW9uIFV0KHQsbil7dmFyIGkscj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24ocixlKXt2YXIgbz1IdCh0LHIsbSh7fSxuLHtvbkVycm9yOmV9KSk7aT1mdW5jdGlvbigpe28oKSxlKFwiV0hFTl9DQU5DRUxMRURcIil9fSkpO3JldHVybiByLmNhbmNlbD1pLHJ9ZnVuY3Rpb24gRnQodCl7cmV0dXJuIHRbS25dfWZ1bmN0aW9uIHp0KHQpe3JldHVybiB2b2lkIDAhPT10LnV0JiZ0LnV0Lmxlbmd0aD4wfWZ1bmN0aW9uICR0KHQsbil7dmFyIGk9dC51dHx8KHQudXQ9W10pO3JldHVybiBpLnB1c2gobikscigoZnVuY3Rpb24oKXt2YXIgdD1pLmluZGV4T2Yobik7LTEhPT10JiZpLnNwbGljZSh0LDEpfSkpfWZ1bmN0aW9uIEp0KG4saSl7dmFyIHI9dXQoKTt0cnl7Zm9yKHZhciBlPVtdLmNvbmNhdChuLnV0fHxbXSksbz0wLHU9ZS5sZW5ndGg7bzx1JiYoKGk9ZVtvXShpKSkmJiFpLnR5cGUmJnQoMTQpLGkpO28rKyk7cmV0dXJuIGl9ZmluYWxseXtzdChyKX19ZnVuY3Rpb24gWXQodCl7cmV0dXJuIHZvaWQgMCE9PXQuc3QmJnQuc3QubGVuZ3RoPjB9ZnVuY3Rpb24gUXQodCxuKXt2YXIgaT10LnN0fHwodC5zdD1bXSk7cmV0dXJuIGkucHVzaChuKSxyKChmdW5jdGlvbigpe3ZhciB0PWkuaW5kZXhPZihuKTstMSE9PXQmJmkuc3BsaWNlKHQsMSl9KSl9ZnVuY3Rpb24gWnQodCxuKXt2YXIgaT11dCgpLHI9dC5zdDtpZihyKXtmb3IodmFyIGU9MCxvPShyPXIuc2xpY2UoKSkubGVuZ3RoO2U8bztlKyspcltlXShuKTtzdChpKX19ZnVuY3Rpb24gdG4odCxuLHIsZSl7dm9pZCAwPT09ciYmKHI9XCJPYnNlcnZhYmxlQXJyYXlcIiksdm9pZCAwPT09ZSYmKGU9ITEpLGkoKTt2YXIgbz1uZXcgS2kocixuLGUsITEpO2Moby5udCxLbixvKTt2YXIgdT1uZXcgUHJveHkoby5udCxDaSk7aWYoby52PXUsdCYmdC5sZW5ndGgpe3ZhciBzPVooITApO28uZnQoMCwwLHQpLHR0KHMpfXJldHVybiB1fWZ1bmN0aW9uIG5uKHQsbil7XCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXkucHJvdG90eXBlW3RdJiYoTGlbdF09bih0KSl9ZnVuY3Rpb24gcm4odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpc1tLbl07bi5hdC5yZXBvcnRPYnNlcnZlZCgpO3ZhciBpPW4uY3Qobi5udCk7cmV0dXJuIGlbdF0uYXBwbHkoaSxhcmd1bWVudHMpfX1mdW5jdGlvbiBlbih0KXtyZXR1cm4gZnVuY3Rpb24obixpKXt2YXIgcj10aGlzLGU9dGhpc1tLbl07cmV0dXJuIGUuYXQucmVwb3J0T2JzZXJ2ZWQoKSxlLmN0KGUubnQpW3RdKChmdW5jdGlvbih0LGUpe3JldHVybiBuLmNhbGwoaSx0LGUscil9KSl9fWZ1bmN0aW9uIG9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXMsaT10aGlzW0tuXTtpLmF0LnJlcG9ydE9ic2VydmVkKCk7dmFyIHI9aS5jdChpLm50KSxlPWFyZ3VtZW50c1swXTtyZXR1cm4gYXJndW1lbnRzWzBdPWZ1bmN0aW9uKHQsaSxyKXtyZXR1cm4gZSh0LGkscixuKX0sclt0XS5hcHBseShyLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHVuKHQpe3JldHVybiB1KHQpJiZEaSh0W0tuXSl9ZnVuY3Rpb24gc24odCxuKXt2YXIgaTtpZihiKHQsS24pKXJldHVybiB0O3ZhciByPW51bGwhPShpPW51bGw9PW4/dm9pZCAwOm4ubmFtZSk/aTpcIk9ic2VydmFibGVPYmplY3RcIixlPW5ldyBRaSh0LG5ldyBNYXAsU3RyaW5nKHIpLGZ1bmN0aW9uKHQpe3ZhciBuO3JldHVybiB0P251bGwhPShuPXQuZGVmYXVsdERlY29yYXRvcik/bjpHKHQpOnZvaWQgMH0obikpO3JldHVybiBhKHQsS24sZSksdH1mdW5jdGlvbiBmbih0KXtyZXR1cm4gWWlbdF18fChZaVt0XT17Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbS25dLmh0KHQpfSxzZXQ6ZnVuY3Rpb24obil7cmV0dXJuIHRoaXNbS25dLnZ0KHQsbil9fSl9ZnVuY3Rpb24gYW4odCl7cmV0dXJuISF1KHQpJiZaaSh0W0tuXSl9ZnVuY3Rpb24gY24odCxuLGkpe3ZhciByO251bGw9PShyPXQuc1tDbl0pfHxkZWxldGUgcltpXX1mdW5jdGlvbiBobih0KXtnbihpci5wcm90b3R5cGUsXCJcIit0LGZ1bmN0aW9uKHQpe3JldHVybntlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tLbl0ubHQodCl9LHNldDpmdW5jdGlvbihuKXt0aGlzW0tuXS5kdCh0LG4pfX19KHQpKX1mdW5jdGlvbiB2bih0KXtpZih0PnRyKXtmb3IodmFyIG49dHI7bjx0KzEwMDtuKyspaG4obik7dHI9dH19ZnVuY3Rpb24gbG4odCxuLGkpe3JldHVybiBuZXcgaXIodCxuLGkpfWZ1bmN0aW9uIGRuKG4saSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIG4mJm51bGwhPT1uKXtpZih1bihuKSlyZXR1cm4gdm9pZCAwIT09aSYmdCgyMyksbltLbl0uYXQ7aWYoSmkobikpcmV0dXJuIG5bS25dO2lmKEhpKG4pKXtpZih2b2lkIDA9PT1pKXJldHVybiBuLmJ0O3ZhciByPW4ucHQuZ2V0KGkpfHxuLnl0LmdldChpKTtyZXR1cm4gcnx8dCgyNSxpLHBuKG4pKSxyfWlmKGFuKG4pKXtpZighaSlyZXR1cm4gdCgyNik7dmFyIG89bltLbl0ubnQuZ2V0KGkpO3JldHVybiBvfHx0KDI3LGkscG4obikpLG99aWYoSW4obil8fGNpKG4pfHx3aShuKSlyZXR1cm4gbn1lbHNlIGlmKGUobikmJndpKG5bS25dKSlyZXR1cm4gbltLbl07dCgyOCl9ZnVuY3Rpb24gYm4obixpKXtyZXR1cm4gbnx8dCgyOSksdm9pZCAwIT09aT9ibihkbihuLGkpKTpJbihuKXx8Y2kobil8fHdpKG4pfHxIaShuKXx8Smkobik/bjpuW0tuXT9uW0tuXTp2b2lkIHQoMjQsbil9ZnVuY3Rpb24gcG4odCxuKXt2YXIgaTtpZih2b2lkIDAhPT1uKWk9ZG4odCxuKTtlbHNle2lmKEF0KHQpKXJldHVybiB0Lm5hbWU7aT1hbih0KXx8SGkodCl8fEppKHQpP2JuKHQpOmRuKHQpfXJldHVybiBpLnR0fWZ1bmN0aW9uIHluKHQsbixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9LTEpLGZ1bmN0aW9uIHQobixpLHIsbyx1KXtpZihuPT09aSlyZXR1cm4gMCE9PW58fDEvbj09MS9pO2lmKG51bGw9PW58fG51bGw9PWkpcmV0dXJuITE7aWYobiE9bilyZXR1cm4gaSE9aTt2YXIgcz10eXBlb2YgbjtpZighZShzKSYmXCJvYmplY3RcIiE9PXMmJlwib2JqZWN0XCIhPXR5cGVvZiBpKXJldHVybiExO3ZhciBmPXJyLmNhbGwobik7aWYoZiE9PXJyLmNhbGwoaSkpcmV0dXJuITE7c3dpdGNoKGYpe2Nhc2VcIltvYmplY3QgUmVnRXhwXVwiOmNhc2VcIltvYmplY3QgU3RyaW5nXVwiOnJldHVyblwiXCIrbj09XCJcIitpO2Nhc2VcIltvYmplY3QgTnVtYmVyXVwiOnJldHVybituIT0rbj8raSE9K2k6MD09K24/MS8rbj09MS9pOituPT0raTtjYXNlXCJbb2JqZWN0IERhdGVdXCI6Y2FzZVwiW29iamVjdCBCb29sZWFuXVwiOnJldHVybituPT0raTtjYXNlXCJbb2JqZWN0IFN5bWJvbF1cIjpyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudmFsdWVPZi5jYWxsKG4pPT09U3ltYm9sLnZhbHVlT2YuY2FsbChpKTtjYXNlXCJbb2JqZWN0IE1hcF1cIjpjYXNlXCJbb2JqZWN0IFNldF1cIjpyPj0wJiZyKyt9bj1tbihuKSxpPW1uKGkpO3ZhciBhPVwiW29iamVjdCBBcnJheV1cIj09PWY7aWYoIWEpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBufHxcIm9iamVjdFwiIT10eXBlb2YgaSlyZXR1cm4hMTt2YXIgYz1uLmNvbnN0cnVjdG9yLGg9aS5jb25zdHJ1Y3RvcjtpZihjIT09aCYmIShlKGMpJiZjIGluc3RhbmNlb2YgYyYmZShoKSYmaCBpbnN0YW5jZW9mIGgpJiZcImNvbnN0cnVjdG9yXCJpbiBuJiZcImNvbnN0cnVjdG9yXCJpbiBpKXJldHVybiExfWlmKDA9PT1yKXJldHVybiExO3I8MCYmKHI9LTEpLHU9dXx8W107Zm9yKHZhciB2PShvPW98fFtdKS5sZW5ndGg7di0tOylpZihvW3ZdPT09bilyZXR1cm4gdVt2XT09PWk7aWYoby5wdXNoKG4pLHUucHVzaChpKSxhKXtpZigodj1uLmxlbmd0aCkhPT1pLmxlbmd0aClyZXR1cm4hMTtmb3IoO3YtLTspaWYoIXQoblt2XSxpW3ZdLHItMSxvLHUpKXJldHVybiExfWVsc2V7dmFyIGwsZD1PYmplY3Qua2V5cyhuKTtpZih2PWQubGVuZ3RoLE9iamVjdC5rZXlzKGkpLmxlbmd0aCE9PXYpcmV0dXJuITE7Zm9yKDt2LS07KWlmKCFiKGksbD1kW3ZdKXx8IXQobltsXSxpW2xdLHItMSxvLHUpKXJldHVybiExfXJldHVybiBvLnBvcCgpLHUucG9wKCksITB9KHQsbixpKX1mdW5jdGlvbiBtbih0KXtyZXR1cm4gdW4odCk/dC5zbGljZSgpOnYodCl8fEhpKHQpfHxsKHQpfHxKaSh0KT9BcnJheS5mcm9tKHQuZW50cmllcygpKTp0fWZ1bmN0aW9uIHduKHQpe3JldHVybiB0W1N5bWJvbC5pdGVyYXRvcl09am4sdH1mdW5jdGlvbiBqbigpe3JldHVybiB0aGlzfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB4bj17fSxPbj1PYmplY3QuYXNzaWduLEFuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsZ249T2JqZWN0LmRlZmluZVByb3BlcnR5LF9uPU9iamVjdC5wcm90b3R5cGUsU249W107T2JqZWN0LmZyZWV6ZShTbik7dmFyIE1uPXt9O09iamVjdC5mcmVlemUoTW4pO3ZhciBWbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUHJveHksTm49T2JqZWN0LnRvU3RyaW5nKCksUm49ZnVuY3Rpb24oKXt9LGtuPXZvaWQgMCE9PU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsRW49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3Qub3duS2V5cz9SZWZsZWN0Lm93bktleXM6a24/ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpKX06T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsVG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnN8fGZ1bmN0aW9uKHQpe3ZhciBuPXt9O3JldHVybiBFbih0KS5mb3JFYWNoKChmdW5jdGlvbihpKXtuW2ldPUFuKHQsaSl9KSksbn0sQ249U3ltYm9sKFwibW9ieC1zdG9yZWQtYW5ub3RhdGlvbnNcIiksS249U3ltYm9sKFwibW9ieCBhZG1pbmlzdHJhdGlvblwiKSxMbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dm9pZCAwPT09dCYmKHQ9XCJBdG9tXCIpLHRoaXMudHQ9dm9pZCAwLHRoaXMuVz0hMSx0aGlzLkg9ITEsdGhpcy5YPW5ldyBTZXQsdGhpcy5CPTAsdGhpcy5GPTAsdGhpcy5HPXNpLlQsdGhpcy5vbkJPTD12b2lkIDAsdGhpcy5vbkJVT0w9dm9pZCAwLHRoaXMudHQ9dH12YXIgbj10LnByb3RvdHlwZTtyZXR1cm4gbi5vbkJPPWZ1bmN0aW9uKCl7dGhpcy5vbkJPTCYmdGhpcy5vbkJPTC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdCgpfSkpfSxuLm9uQlVPPWZ1bmN0aW9uKCl7dGhpcy5vbkJVT0wmJnRoaXMub25CVU9MLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB0KCl9KSl9LG4ucmVwb3J0T2JzZXJ2ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gcHQodGhpcyl9LG4ucmVwb3J0Q2hhbmdlZD1mdW5jdGlvbigpe2R0KCkseXQodGhpcyksYnQoKX0sbi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnR0fSx0fSgpLEluPWgoXCJBdG9tXCIsTG4pLFBuPXtpZGVudGl0eTpmdW5jdGlvbih0LG4pe3JldHVybiB0PT09bn0sc3RydWN0dXJhbDpmdW5jdGlvbih0LG4pe3JldHVybiB5bih0LG4pfSxkZWZhdWx0OmZ1bmN0aW9uKHQsbil7cmV0dXJuIE9iamVjdC5pcz9PYmplY3QuaXModCxuKTp0PT09bj8wIT09dHx8MS90PT0xL246dCE9dCYmbiE9bn0sc2hhbGxvdzpmdW5jdGlvbih0LG4pe3JldHVybiB5bih0LG4sMSl9fSxEbj1BKHt0Olwib3ZlcnJpZGVcIixvOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LHU6ZnVuY3Rpb24oKXt0KFwiJ1wiK3RoaXMudCtcIicgY2FuIG9ubHkgYmUgdXNlZCB3aXRoICdtYWtlT2JzZXJ2YWJsZSdcIil9fSksQm49RygpLHFuPXtkZWVwOiEwLG5hbWU6dm9pZCAwLGRlZmF1bHREZWNvcmF0b3I6dm9pZCAwLHByb3h5OiEwfTtPYmplY3QuZnJlZXplKHFuKTt2YXIgR249RChcIm9ic2VydmFibGVcIiksWG49RChcIm9ic2VydmFibGUucmVmXCIse2VuaGFuY2VyOk19KSxXbj1EKFwib2JzZXJ2YWJsZS5zaGFsbG93XCIse2VuaGFuY2VyOmZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gbnVsbD09dHx8YW4odCl8fHVuKHQpfHxIaSh0KXx8SmkodCk/dDpBcnJheS5pc0FycmF5KHQpPyRuLmFycmF5KHQse25hbWU6aSxkZWVwOiExfSk6cyh0KT8kbi5vYmplY3QodCx2b2lkIDAse25hbWU6aSxkZWVwOiExfSk6dih0KT8kbi5tYXAodCx7bmFtZTppLGRlZXA6ITF9KTpsKHQpPyRuLnNldCh0LHtuYW1lOmksZGVlcDohMX0pOnZvaWQgMH19KSxIbj1EKFwib2JzZXJ2YWJsZS5zdHJ1Y3RcIix7ZW5oYW5jZXI6ZnVuY3Rpb24odCxuKXtyZXR1cm4geW4odCxuKT9uOnR9fSksVW49QShHbik7T2JqZWN0LmFzc2lnbihGLFVuKTt2YXIgRm4sem4sJG49T24oRix7Ym94OmZ1bmN0aW9uKHQsbil7dmFyIGk9SChuKTtyZXR1cm4gbmV3IG9pKHQsVShpKSxpLm5hbWUsITAsaS5lcXVhbHMpfSxhcnJheTpmdW5jdGlvbih0LG4pe3ZhciBpPUgobik7cmV0dXJuKCExPT09cGkudXNlUHJveGllc3x8ITE9PT1pLnByb3h5P2xuOnRuKSh0LFUoaSksaS5uYW1lKX0sbWFwOmZ1bmN0aW9uKHQsbil7dmFyIGk9SChuKTtyZXR1cm4gbmV3IFdpKHQsVShpKSxpLm5hbWUpfSxzZXQ6ZnVuY3Rpb24odCxuKXt2YXIgaT1IKG4pO3JldHVybiBuZXcgJGkodCxVKGkpLGkubmFtZSl9LG9iamVjdDpmdW5jdGlvbih0LG4scil7cmV0dXJuIE50KCExPT09cGkudXNlUHJveGllc3x8ITE9PT0obnVsbD09cj92b2lkIDA6ci5wcm94eSk/c24oe30scik6ZnVuY3Rpb24odCxuKXt2YXIgcixlO3JldHVybiBpKCksbnVsbCE9KGU9KHI9KHQ9c24odCxuKSlbS25dKS52KT9lOnIudj1uZXcgUHJveHkodCxraSl9KHt9LHIpLHQsbil9LHJlZjpBKFhuKSxzaGFsbG93OkEoV24pLGRlZXA6VW4sc3RydWN0OkEoSG4pfSksSm49TChcImNvbXB1dGVkXCIpLFluPUwoXCJjb21wdXRlZC5zdHJ1Y3RcIix7ZXF1YWxzOlBuLnN0cnVjdHVyYWx9KSxRbj1mdW5jdGlvbih0LG4pe2lmKG8obikpcmV0dXJuIGcodCxuLEpuKTtpZihzKHQpKXJldHVybiBBKEwoXCJjb21wdXRlZFwiLHQpKTt2YXIgaT1zKG4pP246e307cmV0dXJuIGkuZ2V0PXQsaS5uYW1lfHwoaS5uYW1lPXQubmFtZXx8XCJcIiksbmV3IGFpKGkpfTtPYmplY3QuYXNzaWduKFFuLEpuKSxRbi5zdHJ1Y3Q9QShZbik7dmFyIFpuLHRpPTAsbmk9MSxpaT1udWxsIT0oRm49bnVsbD09KHpuPUFuKChmdW5jdGlvbigpe30pLFwibmFtZVwiKSk/dm9pZCAwOnpuLmNvbmZpZ3VyYWJsZSkmJkZuLHJpPXt2YWx1ZTpcImFjdGlvblwiLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMSxlbnVtZXJhYmxlOiExfTtabj1TeW1ib2wudG9QcmltaXRpdmU7dmFyIGVpLG9pPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4obixpLHIsZSxvKXt2YXIgdTtyZXR1cm4gdm9pZCAwPT09ciYmKHI9XCJPYnNlcnZhYmxlVmFsdWVcIiksdm9pZCAwPT09byYmKG89UG4uZGVmYXVsdCksKHU9dC5jYWxsKHRoaXMscil8fHRoaXMpLmVuaGFuY2VyPXZvaWQgMCx1LnR0PXZvaWQgMCx1LmVxdWFscz12b2lkIDAsdS53dD0hMSx1LnV0PXZvaWQgMCx1LnN0PXZvaWQgMCx1Lmp0PXZvaWQgMCx1LmRlaGFuY2VyPXZvaWQgMCx1LmVuaGFuY2VyPWksdS50dD1yLHUuZXF1YWxzPW8sdS5qdD1pKG4sdm9pZCAwLHIpLHV9dyhuLHQpO3ZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLmRlaGFuY2VWYWx1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5kZWhhbmNlcj90aGlzLmRlaGFuY2VyKHQpOnR9LGkuc2V0PWZ1bmN0aW9uKHQpeyh0PXRoaXMueHQodCkpIT09cGkuVU5DSEFOR0VEJiZ0aGlzLk90KHQpfSxpLnh0PWZ1bmN0aW9uKHQpe2lmKHp0KHRoaXMpKXt2YXIgbj1KdCh0aGlzLHtvYmplY3Q6dGhpcyx0eXBlOlRpLG5ld1ZhbHVlOnR9KTtpZighbilyZXR1cm4gcGkuVU5DSEFOR0VEO3Q9bi5uZXdWYWx1ZX1yZXR1cm4gdD10aGlzLmVuaGFuY2VyKHQsdGhpcy5qdCx0aGlzLnR0KSx0aGlzLmVxdWFscyh0aGlzLmp0LHQpP3BpLlVOQ0hBTkdFRDp0fSxpLk90PWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuanQ7dGhpcy5qdD10LHRoaXMucmVwb3J0Q2hhbmdlZCgpLFl0KHRoaXMpJiZadCh0aGlzLHt0eXBlOlRpLG9iamVjdDp0aGlzLG5ld1ZhbHVlOnQsb2xkVmFsdWU6bn0pfSxpLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcG9ydE9ic2VydmVkKCksdGhpcy5kZWhhbmNlVmFsdWUodGhpcy5qdCl9LGkuQXQ9ZnVuY3Rpb24odCl7cmV0dXJuICR0KHRoaXMsdCl9LGkuZ3Q9ZnVuY3Rpb24odCxuKXtyZXR1cm4gbiYmdCh7b2JzZXJ2YWJsZUtpbmQ6XCJ2YWx1ZVwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LG9iamVjdDp0aGlzLHR5cGU6VGksbmV3VmFsdWU6dGhpcy5qdCxvbGRWYWx1ZTp2b2lkIDB9KSxRdCh0aGlzLHQpfSxpLnJhdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmp0fSxpLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldCgpfSxpLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHQrXCJbXCIrdGhpcy5qdCtcIl1cIn0saS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIGQodGhpcy5nZXQoKSl9LGlbWm5dPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVPZigpfSxufShMbiksdWk9aChcIk9ic2VydmFibGVWYWx1ZVwiLG9pKTtlaT1TeW1ib2wudG9QcmltaXRpdmU7dmFyIHNpLGZpLGFpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuKXt0aGlzLlI9c2kuVCx0aGlzLkw9W10sdGhpcy5JPW51bGwsdGhpcy5IPSExLHRoaXMuVz0hMSx0aGlzLlg9bmV3IFNldCx0aGlzLkI9MCx0aGlzLkQ9MCx0aGlzLkY9MCx0aGlzLkc9c2kuayx0aGlzLlA9MCx0aGlzLmp0PW5ldyBoaShudWxsKSx0aGlzLnR0PXZvaWQgMCx0aGlzLl90PXZvaWQgMCx0aGlzLlN0PSExLHRoaXMuTXQ9ITEsdGhpcy5kZXJpdmF0aW9uPXZvaWQgMCx0aGlzLlZ0PXZvaWQgMCx0aGlzLm90PWZpLk5PTkUsdGhpcy5OdD12b2lkIDAsdGhpcy5SdD12b2lkIDAsdGhpcy5rdD12b2lkIDAsdGhpcy5FdD12b2lkIDAsdGhpcy5vbkJPTD12b2lkIDAsdGhpcy5vbkJVT0w9dm9pZCAwLG4uZ2V0fHx0KDMxKSx0aGlzLmRlcml2YXRpb249bi5nZXQsdGhpcy50dD1uLm5hbWV8fFwiQ29tcHV0ZWRWYWx1ZVwiLG4uc2V0JiYodGhpcy5WdD16KFwiQ29tcHV0ZWRWYWx1ZS1zZXR0ZXJcIixuLnNldCkpLHRoaXMuUnQ9bi5lcXVhbHN8fChuLmNvbXBhcmVTdHJ1Y3R1cmFsfHxuLnN0cnVjdD9Qbi5zdHJ1Y3R1cmFsOlBuLmRlZmF1bHQpLHRoaXMuTnQ9bi5jb250ZXh0LHRoaXMua3Q9ISFuLnJlcXVpcmVzUmVhY3Rpb24sdGhpcy5FdD0hIW4ua2VlcEFsaXZlfXZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLnE9ZnVuY3Rpb24oKXshZnVuY3Rpb24odCl7dC5HPT09c2kuayYmKHQuRz1zaS5LLHQuWC5mb3JFYWNoKChmdW5jdGlvbih0KXt0LlI9PT1zaS5rJiYodC5SPXNpLkssdC5xKCkpfSkpKX0odGhpcyl9LGkub25CTz1mdW5jdGlvbigpe3RoaXMub25CT0wmJnRoaXMub25CT0wuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0pKX0saS5vbkJVTz1mdW5jdGlvbigpe3RoaXMub25CVU9MJiZ0aGlzLm9uQlVPTC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdCgpfSkpfSxpLmdldD1mdW5jdGlvbigpe2lmKHRoaXMuU3QmJnQoMzIsdGhpcy50dCx0aGlzLmRlcml2YXRpb24pLDAhPT1waS5pbkJhdGNofHwwIT09dGhpcy5YLnNpemV8fHRoaXMuRXQpe2lmKHB0KHRoaXMpLGl0KHRoaXMpKXt2YXIgbj1waS50cmFja2luZ0NvbnRleHQ7dGhpcy5FdCYmIW4mJihwaS50cmFja2luZ0NvbnRleHQ9dGhpcyksdGhpcy50cmFja0FuZENvbXB1dGUoKSYmZnVuY3Rpb24odCl7dC5HIT09c2kuQyYmKHQuRz1zaS5DLHQuWC5mb3JFYWNoKChmdW5jdGlvbihuKXtuLlI9PT1zaS5LP24uUj1zaS5DOm4uUj09PXNpLmsmJih0Lkc9c2kuayl9KSkpfSh0aGlzKSxwaS50cmFja2luZ0NvbnRleHQ9bn19ZWxzZSBpdCh0aGlzKSYmKHRoaXMuVHQoKSxkdCgpLHRoaXMuanQ9dGhpcy5DdCghMSksYnQoKSk7dmFyIGk9dGhpcy5qdDtpZihudChpKSl0aHJvdyBpLmNhdXNlO3JldHVybiBpfSxpLnNldD1mdW5jdGlvbihuKXtpZih0aGlzLlZ0KXt0aGlzLk10JiZ0KDMzLHRoaXMudHQpLHRoaXMuTXQ9ITA7dHJ5e3RoaXMuVnQuY2FsbCh0aGlzLk50LG4pfWZpbmFsbHl7dGhpcy5NdD0hMX19ZWxzZSB0KDM0LHRoaXMudHQpfSxpLnRyYWNrQW5kQ29tcHV0ZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuanQsbj10aGlzLlI9PT1zaS5ULGk9dGhpcy5DdCghMCkscj1ufHxudCh0KXx8bnQoaSl8fCF0aGlzLlJ0KHQsaSk7cmV0dXJuIHImJih0aGlzLmp0PWkpLHJ9LGkuQ3Q9ZnVuY3Rpb24odCl7dGhpcy5TdD0hMDt2YXIgbixpPVooITEpO2lmKHQpbj1ydCh0aGlzLHRoaXMuZGVyaXZhdGlvbix0aGlzLk50KTtlbHNlIGlmKCEwPT09cGkuZGlzYWJsZUVycm9yQm91bmRhcmllcyluPXRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuTnQpO2Vsc2UgdHJ5e249dGhpcy5kZXJpdmF0aW9uLmNhbGwodGhpcy5OdCl9Y2F0Y2godCl7bj1uZXcgaGkodCl9cmV0dXJuIHR0KGkpLHRoaXMuU3Q9ITEsbn0saS5VPWZ1bmN0aW9uKCl7dGhpcy5FdHx8KGV0KHRoaXMpLHRoaXMuanQ9dm9pZCAwKX0saS5ndD1mdW5jdGlvbih0LG4pe3ZhciBpPXRoaXMscj0hMCxlPXZvaWQgMDtyZXR1cm4gZ3QoKGZ1bmN0aW9uKCl7dmFyIG89aS5nZXQoKTtpZighcnx8bil7dmFyIHU9dXQoKTt0KHtvYnNlcnZhYmxlS2luZDpcImNvbXB1dGVkXCIsZGVidWdPYmplY3ROYW1lOmkudHQsdHlwZTpUaSxvYmplY3Q6aSxuZXdWYWx1ZTpvLG9sZFZhbHVlOmV9KSxzdCh1KX1yPSExLGU9b30pKX0saS5UdD1mdW5jdGlvbigpe30saS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnR0K1wiW1wiK3RoaXMuZGVyaXZhdGlvbi50b1N0cmluZygpK1wiXVwifSxpLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gZCh0aGlzLmdldCgpKX0saVtlaV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZU9mKCl9LG59KCksY2k9aChcIkNvbXB1dGVkVmFsdWVcIixhaSk7IWZ1bmN0aW9uKHQpe3RbdC5UPS0xXT1cIk5PVF9UUkFDS0lOR19cIix0W3Quaz0wXT1cIlVQX1RPX0RBVEVfXCIsdFt0Lks9MV09XCJQT1NTSUJMWV9TVEFMRV9cIix0W3QuQz0yXT1cIlNUQUxFX1wifShzaXx8KHNpPXt9KSksZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0LkxPRz0xXT1cIkxPR1wiLHRbdC5CUkVBSz0yXT1cIkJSRUFLXCJ9KGZpfHwoZmk9e30pKTt2YXIgaGk9ZnVuY3Rpb24odCl7dGhpcy5jYXVzZT12b2lkIDAsdGhpcy5jYXVzZT10fSx2aT1bXCJtb2J4R3VpZFwiLFwic3B5TGlzdGVuZXJzXCIsXCJlbmZvcmNlQWN0aW9uc1wiLFwiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsXCJyZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZVwiLFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIixcImFsbG93U3RhdGVSZWFkc1wiLFwiZGlzYWJsZUVycm9yQm91bmRhcmllc1wiLFwicnVuSWRcIixcIlVOQ0hBTkdFRFwiLFwidXNlUHJveGllc1wiXSxsaT1mdW5jdGlvbigpe3RoaXMudmVyc2lvbj02LHRoaXMuVU5DSEFOR0VEPXt9LHRoaXMudHJhY2tpbmdEZXJpdmF0aW9uPW51bGwsdGhpcy50cmFja2luZ0NvbnRleHQ9bnVsbCx0aGlzLnJ1bklkPTAsdGhpcy5tb2J4R3VpZD0wLHRoaXMuaW5CYXRjaD0wLHRoaXMucGVuZGluZ1Vub2JzZXJ2YXRpb25zPVtdLHRoaXMucGVuZGluZ1JlYWN0aW9ucz1bXSx0aGlzLmlzUnVubmluZ1JlYWN0aW9ucz0hMSx0aGlzLmFsbG93U3RhdGVDaGFuZ2VzPSExLHRoaXMuYWxsb3dTdGF0ZVJlYWRzPSEwLHRoaXMuZW5mb3JjZUFjdGlvbnM9ITAsdGhpcy5zcHlMaXN0ZW5lcnM9W10sdGhpcy5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnM9W10sdGhpcy5jb21wdXRlZFJlcXVpcmVzUmVhY3Rpb249ITEsdGhpcy5yZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZT0hMSx0aGlzLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uPSExLHRoaXMuZGlzYWJsZUVycm9yQm91bmRhcmllcz0hMSx0aGlzLnN1cHByZXNzUmVhY3Rpb25FcnJvcnM9ITEsdGhpcy51c2VQcm94aWVzPSEwLHRoaXMudmVyaWZ5UHJveGllcz0hMSx0aGlzLnNhZmVEZXNjcmlwdG9ycz0hMH0sZGk9ITAsYmk9ITEscGk9ZnVuY3Rpb24oKXt2YXIgaT1uKCk7cmV0dXJuIGkuX19tb2J4SW5zdGFuY2VDb3VudD4wJiYhaS5fX21vYnhHbG9iYWxzJiYoZGk9ITEpLGkuX19tb2J4R2xvYmFscyYmaS5fX21vYnhHbG9iYWxzLnZlcnNpb24hPT0obmV3IGxpKS52ZXJzaW9uJiYoZGk9ITEpLGRpP2kuX19tb2J4R2xvYmFscz8oaS5fX21vYnhJbnN0YW5jZUNvdW50Kz0xLGkuX19tb2J4R2xvYmFscy5VTkNIQU5HRUR8fChpLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEPXt9KSxpLl9fbW9ieEdsb2JhbHMpOihpLl9fbW9ieEluc3RhbmNlQ291bnQ9MSxpLl9fbW9ieEdsb2JhbHM9bmV3IGxpKTooc2V0VGltZW91dCgoZnVuY3Rpb24oKXtiaXx8dCgzNSl9KSwxKSxuZXcgbGkpfSgpLHlpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LG4saSxyKXt2b2lkIDA9PT10JiYodD1cIlJlYWN0aW9uXCIpLHZvaWQgMD09PXImJihyPSExKSx0aGlzLnR0PXZvaWQgMCx0aGlzLkt0PXZvaWQgMCx0aGlzLkx0PXZvaWQgMCx0aGlzLkl0PXZvaWQgMCx0aGlzLkw9W10sdGhpcy5JPVtdLHRoaXMuUj1zaS5ULHRoaXMuQj0wLHRoaXMuRD0wLHRoaXMuUD0wLHRoaXMuSj0hMSx0aGlzLlB0PSExLHRoaXMuRHQ9ITEsdGhpcy5CdD0hMSx0aGlzLm90PWZpLk5PTkUsdGhpcy50dD10LHRoaXMuS3Q9bix0aGlzLkx0PWksdGhpcy5JdD1yfXZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLnE9ZnVuY3Rpb24oKXt0aGlzLlkoKX0sbi5ZPWZ1bmN0aW9uKCl7dGhpcy5QdHx8KHRoaXMuUHQ9ITAscGkucGVuZGluZ1JlYWN0aW9ucy5wdXNoKHRoaXMpLG10KCkpfSxuLmlzU2NoZWR1bGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuUHR9LG4uJD1mdW5jdGlvbigpe2lmKCF0aGlzLkope2R0KCksdGhpcy5QdD0hMTt2YXIgdD1waS50cmFja2luZ0NvbnRleHQ7aWYocGkudHJhY2tpbmdDb250ZXh0PXRoaXMsaXQodGhpcykpe3RoaXMuRHQ9ITA7dHJ5e3RoaXMuS3QoKX1jYXRjaCh0KXt0aGlzLnF0KHQpfX1waS50cmFja2luZ0NvbnRleHQ9dCxidCgpfX0sbi50cmFjaz1mdW5jdGlvbih0KXtpZighdGhpcy5KKXtkdCgpLHRoaXMuQnQ9ITA7dmFyIG49cGkudHJhY2tpbmdDb250ZXh0O3BpLnRyYWNraW5nQ29udGV4dD10aGlzO3ZhciBpPXJ0KHRoaXMsdCx2b2lkIDApO3BpLnRyYWNraW5nQ29udGV4dD1uLHRoaXMuQnQ9ITEsdGhpcy5EdD0hMSx0aGlzLkomJmV0KHRoaXMpLG50KGkpJiZ0aGlzLnF0KGkuY2F1c2UpLGJ0KCl9fSxuLnF0PWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7aWYodGhpcy5MdCl0aGlzLkx0KHQsdGhpcyk7ZWxzZXtpZihwaS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKXRocm93IHQ7cGkuc3VwcHJlc3NSZWFjdGlvbkVycm9yc3x8Y29uc29sZS5lcnJvcihcIlttb2J4XSB1bmNhdWdodCBlcnJvciBpbiAnXCIrdGhpcytcIidcIix0KSxwaS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuZm9yRWFjaCgoZnVuY3Rpb24oaSl7cmV0dXJuIGkodCxuKX0pKX19LG4uZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuSnx8KHRoaXMuSj0hMCx0aGlzLkJ0fHwoZHQoKSxldCh0aGlzKSxidCgpKSl9LG4uWj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZGlzcG9zZS5iaW5kKHRoaXMpO3JldHVybiB0W0tuXT10aGlzLHR9LG4udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlJlYWN0aW9uW1wiK3RoaXMudHQrXCJdXCJ9LG4udHJhY2U9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9ITEpLEd0KHRoaXMsdCl9LHR9KCksbWk9ZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0sd2k9aChcIlJlYWN0aW9uXCIseWkpLGppPVYoXCJhY3Rpb25cIikseGk9VihcImFjdGlvbi5ib3VuZFwiLHtib3VuZDohMH0pLE9pPVYoXCJhdXRvQWN0aW9uXCIse2F1dG9BY3Rpb246ITB9KSxBaT1WKFwiYXV0b0FjdGlvbi5ib3VuZFwiLHthdXRvQWN0aW9uOiEwLGJvdW5kOiEwfSksZ2k9eHQoITEpO09iamVjdC5hc3NpZ24oZ2ksamkpO3ZhciBfaT14dCghMCk7T2JqZWN0LmFzc2lnbihfaSxPaSksZ2kuYm91bmQ9QSh4aSksX2kuYm91bmQ9QShBaSk7dmFyIFNpPWZ1bmN0aW9uKHQpe3JldHVybiB0KCl9LE1pPTA7RXQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTt2YXIgVmk9RShcImZsb3dcIiksTmk9RShcImZsb3cuYm91bmRcIix7Ym91bmQ6ITB9KSxSaT1PYmplY3QuYXNzaWduKChmdW5jdGlvbih0LG4pe2lmKG8obikpcmV0dXJuIGcodCxuLFZpKTt2YXIgaT10LHI9aS5uYW1lfHxcIjx1bm5hbWVkIGZsb3c+XCIsdT1mdW5jdGlvbigpe3ZhciB0LG49dGhpcyxvPWFyZ3VtZW50cyx1PSsrTWkscz1naShyK1wiIC0gcnVuaWQ6IFwiK3UrXCIgLSBpbml0XCIsaSkuYXBwbHkobixvKSxmPXZvaWQgMCxhPW5ldyBQcm9taXNlKChmdW5jdGlvbihuLGkpe2Z1bmN0aW9uIG8odCl7dmFyIG47Zj12b2lkIDA7dHJ5e249Z2kocitcIiAtIHJ1bmlkOiBcIit1K1wiIC0geWllbGQgXCIraCsrLHMubmV4dCkuY2FsbChzLHQpfWNhdGNoKHQpe3JldHVybiBpKHQpfWMobil9ZnVuY3Rpb24gYSh0KXt2YXIgbjtmPXZvaWQgMDt0cnl7bj1naShyK1wiIC0gcnVuaWQ6IFwiK3UrXCIgLSB5aWVsZCBcIitoKysscy50aHJvdykuY2FsbChzLHQpfWNhdGNoKHQpe3JldHVybiBpKHQpfWMobil9ZnVuY3Rpb24gYyh0KXtpZighZShudWxsPT10P3ZvaWQgMDp0LnRoZW4pKXJldHVybiB0LmRvbmU/bih0LnZhbHVlKTooZj1Qcm9taXNlLnJlc29sdmUodC52YWx1ZSkpLnRoZW4obyxhKTt0LnRoZW4oYyxpKX12YXIgaD0wO3Q9aSxvKHZvaWQgMCl9KSk7cmV0dXJuIGEuY2FuY2VsPWdpKHIrXCIgLSBydW5pZDogXCIrdStcIiAtIGNhbmNlbFwiLChmdW5jdGlvbigpe3RyeXtmJiZUdChmKTt2YXIgbj1zLnJldHVybih2b2lkIDApLGk9UHJvbWlzZS5yZXNvbHZlKG4udmFsdWUpO2kudGhlbihSbixSbiksVHQoaSksdChuZXcgRXQpfWNhdGNoKG4pe3Qobil9fSkpLGF9O3JldHVybiB1LmlzTW9iWEZsb3c9ITAsdX0pLFZpKTtSaS5ib3VuZD1BKE5pKTt2YXIga2k9e2hhczpmdW5jdGlvbih0LG4pe3JldHVybiBGdCh0KS5ydChuKX0sZ2V0OmZ1bmN0aW9uKHQsbil7cmV0dXJuIEZ0KHQpLmx0KG4pfSxzZXQ6ZnVuY3Rpb24odCxuLGkpe3ZhciByO3JldHVybiEhbyhuKSYmKG51bGw9PShyPUZ0KHQpLmR0KG4saSwhMCkpfHxyKX0sZGVsZXRlUHJvcGVydHk6ZnVuY3Rpb24odCxuKXt2YXIgaTtyZXR1cm4hIW8obikmJihudWxsPT0oaT1GdCh0KS5HdChuLCEwKSl8fGkpfSxkZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbih0LG4saSl7dmFyIHI7cmV0dXJuIG51bGw9PShyPUZ0KHQpLmgobixpKSl8fHJ9LG93bktleXM6ZnVuY3Rpb24odCl7cmV0dXJuIEZ0KHQpLmV0KCl9LHByZXZlbnRFeHRlbnNpb25zOmZ1bmN0aW9uKCl7dCgxMyl9fSxFaT1TeW1ib2woXCJtb2J4LWtleXNcIiksVGk9XCJ1cGRhdGVcIixDaT17Z2V0OmZ1bmN0aW9uKHQsbil7dmFyIGk9dFtLbl07cmV0dXJuIG49PT1Lbj9pOlwibGVuZ3RoXCI9PT1uP2kuWHQoKTpcInN0cmluZ1wiIT10eXBlb2Ygbnx8aXNOYU4obik/YihMaSxuKT9MaVtuXTp0W25dOmkubHQocGFyc2VJbnQobikpfSxzZXQ6ZnVuY3Rpb24odCxuLGkpe3ZhciByPXRbS25dO3JldHVyblwibGVuZ3RoXCI9PT1uJiZyLld0KGkpLFwic3ltYm9sXCI9PXR5cGVvZiBufHxpc05hTihuKT90W25dPWk6ci5kdChwYXJzZUludChuKSxpKSwhMH0scHJldmVudEV4dGVuc2lvbnM6ZnVuY3Rpb24oKXt0KDE1KX19LEtpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbih0LG4saSxyKXt2b2lkIDA9PT10JiYodD1cIk9ic2VydmFibGVBcnJheVwiKSx0aGlzLkh0PXZvaWQgMCx0aGlzLlV0PXZvaWQgMCx0aGlzLmF0PXZvaWQgMCx0aGlzLm50PVtdLHRoaXMudXQ9dm9pZCAwLHRoaXMuc3Q9dm9pZCAwLHRoaXMuRnQ9dm9pZCAwLHRoaXMuZGVoYW5jZXI9dm9pZCAwLHRoaXMudj12b2lkIDAsdGhpcy56dD0wLHRoaXMuSHQ9aSx0aGlzLlV0PXIsdGhpcy5hdD1uZXcgTG4odCksdGhpcy5GdD1mdW5jdGlvbih0LGkpe3JldHVybiBuKHQsaSxcIk9ic2VydmFibGVBcnJheVsuLl1cIil9fXZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLiR0PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmRlaGFuY2VyP3RoaXMuZGVoYW5jZXIodCk6dH0saS5jdD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5kZWhhbmNlciYmdC5sZW5ndGg+MD90Lm1hcCh0aGlzLmRlaGFuY2VyKTp0fSxpLkF0PWZ1bmN0aW9uKHQpe3JldHVybiAkdCh0aGlzLHQpfSxpLmd0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSxuJiZ0KHtvYnNlcnZhYmxlS2luZDpcImFycmF5XCIsb2JqZWN0OnRoaXMudixkZWJ1Z09iamVjdE5hbWU6dGhpcy5hdC50dCx0eXBlOlwic3BsaWNlXCIsaW5kZXg6MCxhZGRlZDp0aGlzLm50LnNsaWNlKCksYWRkZWRDb3VudDp0aGlzLm50Lmxlbmd0aCxyZW1vdmVkOltdLHJlbW92ZWRDb3VudDowfSksUXQodGhpcyx0KX0saS5YdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmF0LnJlcG9ydE9ic2VydmVkKCksdGhpcy5udC5sZW5ndGh9LGkuV3Q9ZnVuY3Rpb24obil7KFwibnVtYmVyXCIhPXR5cGVvZiBufHxuPDApJiZ0KFwiT3V0IG9mIHJhbmdlOiBcIituKTt2YXIgaT10aGlzLm50Lmxlbmd0aDtpZihuIT09aSlpZihuPmkpe2Zvcih2YXIgcj1uZXcgQXJyYXkobi1pKSxlPTA7ZTxuLWk7ZSsrKXJbZV09dm9pZCAwO3RoaXMuZnQoaSwwLHIpfWVsc2UgdGhpcy5mdChuLGktbil9LGkuSnQ9ZnVuY3Rpb24obixpKXtuIT09dGhpcy56dCYmdCgxNiksdGhpcy56dCs9aSx0aGlzLlV0JiZpPjAmJnZuKG4raSsxKX0saS5mdD1mdW5jdGlvbih0LG4saSl7dmFyIHI9dGhpcyxlPXRoaXMubnQubGVuZ3RoO2lmKHZvaWQgMD09PXQ/dD0wOnQ+ZT90PWU6dDwwJiYodD1NYXRoLm1heCgwLGUrdCkpLG49MT09PWFyZ3VtZW50cy5sZW5ndGg/ZS10Om51bGw9PW4/MDpNYXRoLm1heCgwLE1hdGgubWluKG4sZS10KSksdm9pZCAwPT09aSYmKGk9U24pLHp0KHRoaXMpKXt2YXIgbz1KdCh0aGlzLHtvYmplY3Q6dGhpcy52LHR5cGU6XCJzcGxpY2VcIixpbmRleDp0LHJlbW92ZWRDb3VudDpuLGFkZGVkOml9KTtpZighbylyZXR1cm4gU247bj1vLnJlbW92ZWRDb3VudCxpPW8uYWRkZWR9aWYoaT0wPT09aS5sZW5ndGg/aTppLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHIuRnQodCx2b2lkIDApfSkpLHRoaXMuVXQpe3ZhciB1PWkubGVuZ3RoLW47dGhpcy5KdChlLHUpfXZhciBzPXRoaXMuWXQodCxuLGkpO3JldHVybiAwPT09biYmMD09PWkubGVuZ3RofHx0aGlzLlF0KHQsaSxzKSx0aGlzLmN0KHMpfSxpLll0PWZ1bmN0aW9uKHQsbixpKXt2YXIgcjtpZihpLmxlbmd0aDwxZTQpcmV0dXJuKHI9dGhpcy5udCkuc3BsaWNlLmFwcGx5KHIsW3Qsbl0uY29uY2F0KGkpKTt2YXIgZT10aGlzLm50LnNsaWNlKHQsdCtuKSxvPXRoaXMubnQuc2xpY2UodCtuKTt0aGlzLm50Lmxlbmd0aD10K2kubGVuZ3RoLW47Zm9yKHZhciB1PTA7dTxpLmxlbmd0aDt1KyspdGhpcy5udFt0K3VdPWlbdV07Zm9yKHZhciBzPTA7czxvLmxlbmd0aDtzKyspdGhpcy5udFt0K2kubGVuZ3RoK3NdPW9bc107cmV0dXJuIGV9LGkuWnQ9ZnVuY3Rpb24odCxuLGkpe3ZhciByPSF0aGlzLkh0JiYhMSxlPVl0KHRoaXMpLG89ZXx8cj97b2JzZXJ2YWJsZUtpbmQ6XCJhcnJheVwiLG9iamVjdDp0aGlzLnYsdHlwZTpUaSxkZWJ1Z09iamVjdE5hbWU6dGhpcy5hdC50dCxpbmRleDp0LG5ld1ZhbHVlOm4sb2xkVmFsdWU6aX06bnVsbDt0aGlzLmF0LnJlcG9ydENoYW5nZWQoKSxlJiZadCh0aGlzLG8pfSxpLlF0PWZ1bmN0aW9uKHQsbixpKXt2YXIgcj0hdGhpcy5IdCYmITEsZT1ZdCh0aGlzKSxvPWV8fHI/e29ic2VydmFibGVLaW5kOlwiYXJyYXlcIixvYmplY3Q6dGhpcy52LGRlYnVnT2JqZWN0TmFtZTp0aGlzLmF0LnR0LHR5cGU6XCJzcGxpY2VcIixpbmRleDp0LHJlbW92ZWQ6aSxhZGRlZDpuLHJlbW92ZWRDb3VudDppLmxlbmd0aCxhZGRlZENvdW50Om4ubGVuZ3RofTpudWxsO3RoaXMuYXQucmVwb3J0Q2hhbmdlZCgpLGUmJlp0KHRoaXMsbyl9LGkubHQ9ZnVuY3Rpb24odCl7aWYodDx0aGlzLm50Lmxlbmd0aClyZXR1cm4gdGhpcy5hdC5yZXBvcnRPYnNlcnZlZCgpLHRoaXMuJHQodGhpcy5udFt0XSk7Y29uc29sZS53YXJuKFwiW21vYnguYXJyYXldIEF0dGVtcHQgdG8gcmVhZCBhbiBhcnJheSBpbmRleCAoXCIrdCtcIikgdGhhdCBpcyBvdXQgb2YgYm91bmRzIChcIit0aGlzLm50Lmxlbmd0aCtcIikuIFBsZWFzZSBjaGVjayBsZW5ndGggZmlyc3QuIE91dCBvZiBib3VuZCBpbmRpY2VzIHdpbGwgbm90IGJlIHRyYWNrZWQgYnkgTW9iWFwiKX0saS5kdD1mdW5jdGlvbihuLGkpe3ZhciByPXRoaXMubnQ7aWYobjxyLmxlbmd0aCl7dmFyIGU9cltuXTtpZih6dCh0aGlzKSl7dmFyIG89SnQodGhpcyx7dHlwZTpUaSxvYmplY3Q6dGhpcy52LGluZGV4Om4sbmV3VmFsdWU6aX0pO2lmKCFvKXJldHVybjtpPW8ubmV3VmFsdWV9KGk9dGhpcy5GdChpLGUpKSE9PWUmJihyW25dPWksdGhpcy5adChuLGksZSkpfWVsc2Ugbj09PXIubGVuZ3RoP3RoaXMuZnQobiwwLFtpXSk6dCgxNyxuLHIubGVuZ3RoKX0sbn0oKSxMaT17Y2xlYXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcGxpY2UoMCl9LHJlcGxhY2U6ZnVuY3Rpb24odCl7dmFyIG49dGhpc1tLbl07cmV0dXJuIG4uZnQoMCxuLm50Lmxlbmd0aCx0KX0sdG9KU09OOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2xpY2UoKX0sc3BsaWNlOmZ1bmN0aW9uKHQsbil7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkoaT4yP2ktMjowKSxlPTI7ZTxpO2UrKylyW2UtMl09YXJndW1lbnRzW2VdO3ZhciBvPXRoaXNbS25dO3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuW107Y2FzZSAxOnJldHVybiBvLmZ0KHQpO2Nhc2UgMjpyZXR1cm4gby5mdCh0LG4pfXJldHVybiBvLmZ0KHQsbixyKX0sc3BsaWNlV2l0aEFycmF5OmZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gdGhpc1tLbl0uZnQodCxuLGkpfSxwdXNoOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXNbS25dLG49YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShuKSxyPTA7cjxuO3IrKylpW3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gdC5mdCh0Lm50Lmxlbmd0aCwwLGkpLHQubnQubGVuZ3RofSxwb3A6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcGxpY2UoTWF0aC5tYXgodGhpc1tLbl0ubnQubGVuZ3RoLTEsMCksMSlbMF19LHNoaWZ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3BsaWNlKDAsMSlbMF19LHVuc2hpZnQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpc1tLbl0sbj1hcmd1bWVudHMubGVuZ3RoLGk9bmV3IEFycmF5KG4pLHI9MDtyPG47cisrKWlbcl09YXJndW1lbnRzW3JdO3JldHVybiB0LmZ0KDAsMCxpKSx0Lm50Lmxlbmd0aH0scmV2ZXJzZTpmdW5jdGlvbigpe3JldHVybiBwaS50cmFja2luZ0Rlcml2YXRpb24mJnQoMzcsXCJyZXZlcnNlXCIpLHRoaXMucmVwbGFjZSh0aGlzLnNsaWNlKCkucmV2ZXJzZSgpKSx0aGlzfSxzb3J0OmZ1bmN0aW9uKCl7cGkudHJhY2tpbmdEZXJpdmF0aW9uJiZ0KDM3LFwic29ydFwiKTt2YXIgbj10aGlzLnNsaWNlKCk7cmV0dXJuIG4uc29ydC5hcHBseShuLGFyZ3VtZW50cyksdGhpcy5yZXBsYWNlKG4pLHRoaXN9LHJlbW92ZTpmdW5jdGlvbih0KXt2YXIgbj10aGlzW0tuXSxpPW4uY3Qobi5udCkuaW5kZXhPZih0KTtyZXR1cm4gaT4tMSYmKHRoaXMuc3BsaWNlKGksMSksITApfX07bm4oXCJjb25jYXRcIixybiksbm4oXCJmbGF0XCIscm4pLG5uKFwiaW5jbHVkZXNcIixybiksbm4oXCJpbmRleE9mXCIscm4pLG5uKFwiam9pblwiLHJuKSxubihcImxhc3RJbmRleE9mXCIscm4pLG5uKFwic2xpY2VcIixybiksbm4oXCJ0b1N0cmluZ1wiLHJuKSxubihcInRvTG9jYWxlU3RyaW5nXCIscm4pLG5uKFwiZXZlcnlcIixlbiksbm4oXCJmaWx0ZXJcIixlbiksbm4oXCJmaW5kXCIsZW4pLG5uKFwiZmluZEluZGV4XCIsZW4pLG5uKFwiZmxhdE1hcFwiLGVuKSxubihcImZvckVhY2hcIixlbiksbm4oXCJtYXBcIixlbiksbm4oXCJzb21lXCIsZW4pLG5uKFwicmVkdWNlXCIsb24pLG5uKFwicmVkdWNlUmlnaHRcIixvbik7dmFyIElpLFBpLERpPWgoXCJPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvblwiLEtpKSxCaT17fSxxaT1cImFkZFwiO0lpPVN5bWJvbC5pdGVyYXRvcixQaT1TeW1ib2wudG9TdHJpbmdUYWc7dmFyIEdpLFhpLFdpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLGkscil7dm9pZCAwPT09aSYmKGk9Uyksdm9pZCAwPT09ciYmKHI9XCJPYnNlcnZhYmxlTWFwXCIpLHRoaXMuRnQ9dm9pZCAwLHRoaXMudHQ9dm9pZCAwLHRoaXNbS25dPUJpLHRoaXMucHQ9dm9pZCAwLHRoaXMueXQ9dm9pZCAwLHRoaXMuYnQ9dm9pZCAwLHRoaXMudXQ9dm9pZCAwLHRoaXMuc3Q9dm9pZCAwLHRoaXMuZGVoYW5jZXI9dm9pZCAwLHRoaXMuRnQ9aSx0aGlzLnR0PXIsZShNYXApfHx0KDE4KSx0aGlzLmJ0PV8oXCJPYnNlcnZhYmxlTWFwLmtleXMoKVwiKSx0aGlzLnB0PW5ldyBNYXAsdGhpcy55dD1uZXcgTWFwLHRoaXMubWVyZ2Uobil9dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkucnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHQuaGFzKHQpfSxpLmhhcz1mdW5jdGlvbih0KXt2YXIgbj10aGlzO2lmKCFwaS50cmFja2luZ0Rlcml2YXRpb24pcmV0dXJuIHRoaXMucnQodCk7dmFyIGk9dGhpcy55dC5nZXQodCk7aWYoIWkpe3ZhciByPWk9bmV3IG9pKHRoaXMucnQodCksTSxcIk9ic2VydmFibGVNYXAua2V5P1wiLCExKTt0aGlzLnl0LnNldCh0LHIpLE10KHIsKGZ1bmN0aW9uKCl7cmV0dXJuIG4ueXQuZGVsZXRlKHQpfSkpfXJldHVybiBpLmdldCgpfSxpLnNldD1mdW5jdGlvbih0LG4pe3ZhciBpPXRoaXMucnQodCk7aWYoenQodGhpcykpe3ZhciByPUp0KHRoaXMse3R5cGU6aT9UaTpxaSxvYmplY3Q6dGhpcyxuZXdWYWx1ZTpuLG5hbWU6dH0pO2lmKCFyKXJldHVybiB0aGlzO249ci5uZXdWYWx1ZX1yZXR1cm4gaT90aGlzLnRuKHQsbik6dGhpcy5ubih0LG4pLHRoaXN9LGkuZGVsZXRlPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7aWYoenQodGhpcykmJiFKdCh0aGlzLHt0eXBlOlwiZGVsZXRlXCIsb2JqZWN0OnRoaXMsbmFtZTp0fSkpcmV0dXJuITE7aWYodGhpcy5ydCh0KSl7dmFyIGk9WXQodGhpcykscj1pP3tvYnNlcnZhYmxlS2luZDpcIm1hcFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LHR5cGU6XCJkZWxldGVcIixvYmplY3Q6dGhpcyxvbGRWYWx1ZTp0aGlzLnB0LmdldCh0KS5qdCxuYW1lOnR9Om51bGw7cmV0dXJuIFd0KChmdW5jdGlvbigpe24uYnQucmVwb3J0Q2hhbmdlZCgpLG4uaW4odCwhMSksbi5wdC5nZXQodCkuT3Qodm9pZCAwKSxuLnB0LmRlbGV0ZSh0KX0pKSxpJiZadCh0aGlzLHIpLCEwfXJldHVybiExfSxpLmluPWZ1bmN0aW9uKHQsbil7dmFyIGk9dGhpcy55dC5nZXQodCk7aSYmaS5PdChuKX0saS50bj1mdW5jdGlvbih0LG4pe3ZhciBpPXRoaXMucHQuZ2V0KHQpO2lmKChuPWkueHQobikpIT09cGkuVU5DSEFOR0VEKXt2YXIgcj1ZdCh0aGlzKSxlPXI/e29ic2VydmFibGVLaW5kOlwibWFwXCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsdHlwZTpUaSxvYmplY3Q6dGhpcyxvbGRWYWx1ZTppLmp0LG5hbWU6dCxuZXdWYWx1ZTpufTpudWxsO2kuT3QobiksciYmWnQodGhpcyxlKX19LGkubm49ZnVuY3Rpb24odCxuKXt2YXIgaT10aGlzO1d0KChmdW5jdGlvbigpe3ZhciByPW5ldyBvaShuLGkuRnQsXCJPYnNlcnZhYmxlTWFwLmtleVwiLCExKTtpLnB0LnNldCh0LHIpLG49ci5qdCxpLmluKHQsITApLGkuYnQucmVwb3J0Q2hhbmdlZCgpfSkpO3ZhciByPVl0KHRoaXMpO3ImJlp0KHRoaXMscj97b2JzZXJ2YWJsZUtpbmQ6XCJtYXBcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCx0eXBlOnFpLG9iamVjdDp0aGlzLG5hbWU6dCxuZXdWYWx1ZTpufTpudWxsKX0saS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGFzKHQpP3RoaXMuJHQodGhpcy5wdC5nZXQodCkuZ2V0KCkpOnRoaXMuJHQodm9pZCAwKX0saS4kdD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5kZWhhbmNlcj90aGlzLmRlaGFuY2VyKHQpOnR9LGkua2V5cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ0LnJlcG9ydE9ic2VydmVkKCksdGhpcy5wdC5rZXlzKCl9LGkudmFsdWVzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxuPXRoaXMua2V5cygpO3JldHVybiB3bih7bmV4dDpmdW5jdGlvbigpe3ZhciBpPW4ubmV4dCgpLHI9aS5kb25lO3JldHVybntkb25lOnIsdmFsdWU6cj92b2lkIDA6dC5nZXQoaS52YWx1ZSl9fX0pfSxpLmVudHJpZXM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLG49dGhpcy5rZXlzKCk7cmV0dXJuIHduKHtuZXh0OmZ1bmN0aW9uKCl7dmFyIGk9bi5uZXh0KCkscj1pLmRvbmUsZT1pLnZhbHVlO3JldHVybntkb25lOnIsdmFsdWU6cj92b2lkIDA6W2UsdC5nZXQoZSldfX19KX0saVtJaV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbnRyaWVzKCl9LGkuZm9yRWFjaD1mdW5jdGlvbih0LG4pe2Zvcih2YXIgaSxyPU8odGhpcyk7IShpPXIoKSkuZG9uZTspe3ZhciBlPWkudmFsdWU7dC5jYWxsKG4sZVsxXSxlWzBdLHRoaXMpfX0saS5tZXJnZT1mdW5jdGlvbihuKXt2YXIgaT10aGlzO3JldHVybiBIaShuKSYmKG49bmV3IE1hcChuKSksV3QoKGZ1bmN0aW9uKCl7cyhuKT9mdW5jdGlvbih0KXt2YXIgbj1PYmplY3Qua2V5cyh0KTtpZigha24pcmV0dXJuIG47dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KTtyZXR1cm4gaS5sZW5ndGg/W10uY29uY2F0KG4saS5maWx0ZXIoKGZ1bmN0aW9uKG4pe3JldHVybiBfbi5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHQsbil9KSkpOm59KG4pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBpLnNldCh0LG5bdF0pfSkpOkFycmF5LmlzQXJyYXkobik/bi5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gaS5zZXQodFswXSx0WzFdKX0pKTp2KG4pPyhuLmNvbnN0cnVjdG9yIT09TWFwJiZ0KDE5LG4pLG4uZm9yRWFjaCgoZnVuY3Rpb24odCxuKXtyZXR1cm4gaS5zZXQobix0KX0pKSk6bnVsbCE9biYmdCgyMCxuKX0pKSx0aGlzfSxpLmNsZWFyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztXdCgoZnVuY3Rpb24oKXtvdCgoZnVuY3Rpb24oKXtmb3IodmFyIG4saT1PKHQua2V5cygpKTshKG49aSgpKS5kb25lOyl0LmRlbGV0ZShuLnZhbHVlKX0pKX0pKX0saS5yZXBsYWNlPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXM7cmV0dXJuIFd0KChmdW5jdGlvbigpe2Zvcih2YXIgcixlPWZ1bmN0aW9uKG4pe2lmKHYobil8fEhpKG4pKXJldHVybiBuO2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIG5ldyBNYXAobik7aWYocyhuKSl7dmFyIGk9bmV3IE1hcDtmb3IodmFyIHIgaW4gbilpLnNldChyLG5bcl0pO3JldHVybiBpfXJldHVybiB0KDIxLG4pfShuKSxvPW5ldyBNYXAsdT0hMSxmPU8oaS5wdC5rZXlzKCkpOyEocj1mKCkpLmRvbmU7KXt2YXIgYT1yLnZhbHVlO2lmKCFlLmhhcyhhKSlpZihpLmRlbGV0ZShhKSl1PSEwO2Vsc2V7dmFyIGM9aS5wdC5nZXQoYSk7by5zZXQoYSxjKX19Zm9yKHZhciBoLGw9TyhlLmVudHJpZXMoKSk7IShoPWwoKSkuZG9uZTspe3ZhciBkPWgudmFsdWUsYj1kWzBdLHA9ZFsxXSx5PWkucHQuaGFzKGIpO2lmKGkuc2V0KGIscCksaS5wdC5oYXMoYikpe3ZhciBtPWkucHQuZ2V0KGIpO28uc2V0KGIsbSkseXx8KHU9ITApfX1pZighdSlpZihpLnB0LnNpemUhPT1vLnNpemUpaS5idC5yZXBvcnRDaGFuZ2VkKCk7ZWxzZSBmb3IodmFyIHc9aS5wdC5rZXlzKCksaj1vLmtleXMoKSx4PXcubmV4dCgpLEE9ai5uZXh0KCk7IXguZG9uZTspe2lmKHgudmFsdWUhPT1BLnZhbHVlKXtpLmJ0LnJlcG9ydENoYW5nZWQoKTticmVha314PXcubmV4dCgpLEE9ai5uZXh0KCl9aS5wdD1vfSkpLHRoaXN9LGkudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgT2JzZXJ2YWJsZU1hcF1cIn0saS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzKX0saS5ndD1mdW5jdGlvbih0KXtyZXR1cm4gUXQodGhpcyx0KX0saS5BdD1mdW5jdGlvbih0KXtyZXR1cm4gJHQodGhpcyx0KX0seShuLFt7a2V5Olwic2l6ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ0LnJlcG9ydE9ic2VydmVkKCksdGhpcy5wdC5zaXplfX0se2tleTpQaSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIk1hcFwifX1dKSxufSgpLEhpPWgoXCJPYnNlcnZhYmxlTWFwXCIsV2kpLFVpPXt9O0dpPVN5bWJvbC5pdGVyYXRvcixYaT1TeW1ib2wudG9TdHJpbmdUYWc7dmFyIEZpLHppLCRpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLGkscil7dm9pZCAwPT09aSYmKGk9Uyksdm9pZCAwPT09ciYmKHI9XCJPYnNlcnZhYmxlU2V0XCIpLHRoaXMudHQ9dm9pZCAwLHRoaXNbS25dPVVpLHRoaXMucHQ9bmV3IFNldCx0aGlzLmF0PXZvaWQgMCx0aGlzLnN0PXZvaWQgMCx0aGlzLnV0PXZvaWQgMCx0aGlzLmRlaGFuY2VyPXZvaWQgMCx0aGlzLkZ0PXZvaWQgMCx0aGlzLnR0PXIsZShTZXQpfHx0KDIyKSx0aGlzLmF0PV8odGhpcy50dCksdGhpcy5GdD1mdW5jdGlvbih0LG4pe3JldHVybiBpKHQsbixyKX0sbiYmdGhpcy5yZXBsYWNlKG4pfXZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLiR0PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmRlaGFuY2VyP3RoaXMuZGVoYW5jZXIodCk6dH0saS5jbGVhcj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7V3QoKGZ1bmN0aW9uKCl7b3QoKGZ1bmN0aW9uKCl7Zm9yKHZhciBuLGk9Tyh0LnB0LnZhbHVlcygpKTshKG49aSgpKS5kb25lOyl0LmRlbGV0ZShuLnZhbHVlKX0pKX0pKX0saS5mb3JFYWNoPWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBpLHI9Tyh0aGlzKTshKGk9cigpKS5kb25lOyl7dmFyIGU9aS52YWx1ZTt0LmNhbGwobixlLGUsdGhpcyl9fSxpLmFkZD1mdW5jdGlvbih0KXt2YXIgbj10aGlzO2lmKHp0KHRoaXMpJiYhSnQodGhpcyx7dHlwZTpxaSxvYmplY3Q6dGhpcyxuZXdWYWx1ZTp0fSkpcmV0dXJuIHRoaXM7aWYoIXRoaXMuaGFzKHQpKXtXdCgoZnVuY3Rpb24oKXtuLnB0LmFkZChuLkZ0KHQsdm9pZCAwKSksbi5hdC5yZXBvcnRDaGFuZ2VkKCl9KSk7dmFyIGk9WXQodGhpcyk7aSYmWnQodGhpcyxpP3tvYnNlcnZhYmxlS2luZDpcInNldFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LHR5cGU6cWksb2JqZWN0OnRoaXMsbmV3VmFsdWU6dH06bnVsbCl9cmV0dXJuIHRoaXN9LGkuZGVsZXRlPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7aWYoenQodGhpcykmJiFKdCh0aGlzLHt0eXBlOlwiZGVsZXRlXCIsb2JqZWN0OnRoaXMsb2xkVmFsdWU6dH0pKXJldHVybiExO2lmKHRoaXMuaGFzKHQpKXt2YXIgaT1ZdCh0aGlzKSxyPWk/e29ic2VydmFibGVLaW5kOlwic2V0XCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsdHlwZTpcImRlbGV0ZVwiLG9iamVjdDp0aGlzLG9sZFZhbHVlOnR9Om51bGw7cmV0dXJuIFd0KChmdW5jdGlvbigpe24uYXQucmVwb3J0Q2hhbmdlZCgpLG4ucHQuZGVsZXRlKHQpfSkpLGkmJlp0KHRoaXMsciksITB9cmV0dXJuITF9LGkuaGFzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmF0LnJlcG9ydE9ic2VydmVkKCksdGhpcy5wdC5oYXModGhpcy4kdCh0KSl9LGkuZW50cmllcz1mdW5jdGlvbigpe3ZhciB0PTAsbj1BcnJheS5mcm9tKHRoaXMua2V5cygpKSxpPUFycmF5LmZyb20odGhpcy52YWx1ZXMoKSk7cmV0dXJuIHduKHtuZXh0OmZ1bmN0aW9uKCl7dmFyIHI9dDtyZXR1cm4gdCs9MSxyPGkubGVuZ3RoP3t2YWx1ZTpbbltyXSxpW3JdXSxkb25lOiExfTp7ZG9uZTohMH19fSl9LGkua2V5cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSxpLnZhbHVlcz1mdW5jdGlvbigpe3RoaXMuYXQucmVwb3J0T2JzZXJ2ZWQoKTt2YXIgdD10aGlzLG49MCxpPUFycmF5LmZyb20odGhpcy5wdC52YWx1ZXMoKSk7cmV0dXJuIHduKHtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG48aS5sZW5ndGg/e3ZhbHVlOnQuJHQoaVtuKytdKSxkb25lOiExfTp7ZG9uZTohMH19fSl9LGkucmVwbGFjZT1mdW5jdGlvbihuKXt2YXIgaT10aGlzO3JldHVybiBKaShuKSYmKG49bmV3IFNldChuKSksV3QoKGZ1bmN0aW9uKCl7QXJyYXkuaXNBcnJheShuKXx8bChuKT8oaS5jbGVhcigpLG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGkuYWRkKHQpfSkpKTpudWxsIT1uJiZ0KFwiQ2Fubm90IGluaXRpYWxpemUgc2V0IGZyb20gXCIrbil9KSksdGhpc30saS5ndD1mdW5jdGlvbih0KXtyZXR1cm4gUXQodGhpcyx0KX0saS5BdD1mdW5jdGlvbih0KXtyZXR1cm4gJHQodGhpcyx0KX0saS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzKX0saS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBPYnNlcnZhYmxlU2V0XVwifSxpW0dpXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx5KG4sW3trZXk6XCJzaXplXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXQucmVwb3J0T2JzZXJ2ZWQoKSx0aGlzLnB0LnNpemV9fSx7a2V5OlhpLGdldDpmdW5jdGlvbigpe3JldHVyblwiU2V0XCJ9fV0pLG59KCksSmk9aChcIk9ic2VydmFibGVTZXRcIiwkaSksWWk9T2JqZWN0LmNyZWF0ZShudWxsKSxRaT1mdW5jdGlvbigpe2Z1bmN0aW9uIG4odCxuLGkscil7dm9pZCAwPT09biYmKG49bmV3IE1hcCksdm9pZCAwPT09ciYmKHI9Qm4pLHRoaXMucz12b2lkIDAsdGhpcy5udD12b2lkIDAsdGhpcy50dD12b2lkIDAsdGhpcy5ybj12b2lkIDAsdGhpcy5idD12b2lkIDAsdGhpcy5zdD12b2lkIDAsdGhpcy51dD12b2lkIDAsdGhpcy52PXZvaWQgMCx0aGlzLmw9dm9pZCAwLHRoaXMuZW49dm9pZCAwLHRoaXMub249dm9pZCAwLHRoaXMucz10LHRoaXMubnQ9bix0aGlzLnR0PWksdGhpcy5ybj1yLHRoaXMuYnQ9bmV3IExuKFwiT2JzZXJ2YWJsZU9iamVjdC5rZXlzXCIpLHRoaXMubD1zKHRoaXMucyl9dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkuaHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubnQuZ2V0KHQpLmdldCgpfSxpLnZ0PWZ1bmN0aW9uKHQsbil7dmFyIGk9dGhpcy5udC5nZXQodCk7aWYoaSBpbnN0YW5jZW9mIGFpKXJldHVybiBpLnNldChuKSwhMDtpZih6dCh0aGlzKSl7dmFyIHI9SnQodGhpcyx7dHlwZTpUaSxvYmplY3Q6dGhpcy52fHx0aGlzLnMsbmFtZTp0LG5ld1ZhbHVlOm59KTtpZighcilyZXR1cm4gbnVsbDtuPXIubmV3VmFsdWV9aWYoKG49aS54dChuKSkhPT1waS5VTkNIQU5HRUQpe3ZhciBlPVl0KHRoaXMpLG89ZT97dHlwZTpUaSxvYnNlcnZhYmxlS2luZDpcIm9iamVjdFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LG9iamVjdDp0aGlzLnZ8fHRoaXMucyxvbGRWYWx1ZTppLmp0LG5hbWU6dCxuZXdWYWx1ZTpufTpudWxsO2kuT3QobiksZSYmWnQodGhpcyxvKX1yZXR1cm4hMH0saS5sdD1mdW5jdGlvbih0KXtyZXR1cm4gcGkudHJhY2tpbmdEZXJpdmF0aW9uJiYhYih0aGlzLnMsdCkmJnRoaXMucnQodCksdGhpcy5zW3RdfSxpLmR0PWZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9ITEpLGIodGhpcy5zLHQpP3RoaXMubnQuaGFzKHQpP3RoaXMudnQodCxuKTppP1JlZmxlY3Quc2V0KHRoaXMucyx0LG4pOih0aGlzLnNbdF09biwhMCk6dGhpcy51KHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9LHRoaXMucm4saSl9LGkucnQ9ZnVuY3Rpb24odCl7aWYoIXBpLnRyYWNraW5nRGVyaXZhdGlvbilyZXR1cm4gdCBpbiB0aGlzLnM7dGhpcy5vbnx8KHRoaXMub249bmV3IE1hcCk7dmFyIG49dGhpcy5vbi5nZXQodCk7cmV0dXJuIG58fChuPW5ldyBvaSh0IGluIHRoaXMucyxNLFwiT2JzZXJ2YWJsZU9iamVjdC5rZXk/XCIsITEpLHRoaXMub24uc2V0KHQsbikpLG4uZ2V0KCl9LGkubz1mdW5jdGlvbihuLGkpe2lmKCEwPT09aSYmKGk9dGhpcy5ybiksITEhPT1pKXtpZighKG4gaW4gdGhpcy5zKSl7dmFyIHI7aWYobnVsbD09KHI9dGhpcy5zW0NuXSk/dm9pZCAwOnJbbl0pcmV0dXJuO3QoMSxpLnQsdGhpcy50dCtcIi5cIituLnRvU3RyaW5nKCkpfWZvcih2YXIgZT10aGlzLnM7ZSYmZSE9PV9uOyl7dmFyIG89QW4oZSxuKTtpZihvKXt2YXIgdT1pLm8odGhpcyxuLG8sZSk7aWYoMD09PXUpcmV0dXJuO2lmKDE9PT11KWJyZWFrfWU9T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfWNuKHRoaXMsMCxuKX19LGkudT1mdW5jdGlvbih0LG4saSxyKXtpZih2b2lkIDA9PT1yJiYocj0hMSksITA9PT1pJiYoaT10aGlzLnJuKSwhMT09PWkpcmV0dXJuIHRoaXMuaCh0LG4scik7dmFyIGU9aS51KHRoaXMsdCxuLHIpO3JldHVybiBlJiZjbih0aGlzLDAsdCksZX0saS5oPWZ1bmN0aW9uKHQsbixpKXt2b2lkIDA9PT1pJiYoaT0hMSk7dHJ5e2R0KCk7dmFyIHI9dGhpcy5HdCh0KTtpZighcilyZXR1cm4gcjtpZih6dCh0aGlzKSl7dmFyIGU9SnQodGhpcyx7b2JqZWN0OnRoaXMudnx8dGhpcy5zLG5hbWU6dCx0eXBlOnFpLG5ld1ZhbHVlOm4udmFsdWV9KTtpZighZSlyZXR1cm4gbnVsbDt2YXIgbz1lLm5ld1ZhbHVlO24udmFsdWUhPT1vJiYobj1tKHt9LG4se3ZhbHVlOm99KSl9aWYoaSl7aWYoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy5zLHQsbikpcmV0dXJuITF9ZWxzZSBnbih0aGlzLnMsdCxuKTt0aGlzLnVuKHQsbi52YWx1ZSl9ZmluYWxseXtidCgpfXJldHVybiEwfSxpLm09ZnVuY3Rpb24odCxuLGkscil7dm9pZCAwPT09ciYmKHI9ITEpO3RyeXtkdCgpO3ZhciBlPXRoaXMuR3QodCk7aWYoIWUpcmV0dXJuIGU7aWYoenQodGhpcykpe3ZhciBvPUp0KHRoaXMse29iamVjdDp0aGlzLnZ8fHRoaXMucyxuYW1lOnQsdHlwZTpxaSxuZXdWYWx1ZTpufSk7aWYoIW8pcmV0dXJuIG51bGw7bj1vLm5ld1ZhbHVlfXZhciB1PWZuKHQpLHM9e2NvbmZpZ3VyYWJsZTohcGkuc2FmZURlc2NyaXB0b3JzfHx0aGlzLmwsZW51bWVyYWJsZTohMCxnZXQ6dS5nZXQsc2V0OnUuc2V0fTtpZihyKXtpZighUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnMsdCxzKSlyZXR1cm4hMX1lbHNlIGduKHRoaXMucyx0LHMpO3ZhciBmPW5ldyBvaShuLGksXCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiLCExKTt0aGlzLm50LnNldCh0LGYpLHRoaXMudW4odCxmLmp0KX1maW5hbGx5e2J0KCl9cmV0dXJuITB9LGkucD1mdW5jdGlvbih0LG4saSl7dm9pZCAwPT09aSYmKGk9ITEpO3RyeXtkdCgpO3ZhciByPXRoaXMuR3QodCk7aWYoIXIpcmV0dXJuIHI7aWYoenQodGhpcykmJiFKdCh0aGlzLHtvYmplY3Q6dGhpcy52fHx0aGlzLnMsbmFtZTp0LHR5cGU6cWksbmV3VmFsdWU6dm9pZCAwfSkpcmV0dXJuIG51bGw7bi5uYW1lfHwobi5uYW1lPVwiT2JzZXJ2YWJsZU9iamVjdC5rZXlcIiksbi5jb250ZXh0PXRoaXMudnx8dGhpcy5zO3ZhciBlPWZuKHQpLG89e2NvbmZpZ3VyYWJsZTohcGkuc2FmZURlc2NyaXB0b3JzfHx0aGlzLmwsZW51bWVyYWJsZTohMSxnZXQ6ZS5nZXQsc2V0OmUuc2V0fTtpZihpKXtpZighUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnMsdCxvKSlyZXR1cm4hMX1lbHNlIGduKHRoaXMucyx0LG8pO3RoaXMubnQuc2V0KHQsbmV3IGFpKG4pKSx0aGlzLnVuKHQsdm9pZCAwKX1maW5hbGx5e2J0KCl9cmV0dXJuITB9LGkuR3Q9ZnVuY3Rpb24odCxuKXtpZih2b2lkIDA9PT1uJiYobj0hMSksIWIodGhpcy5zLHQpKXJldHVybiEwO2lmKHp0KHRoaXMpJiYhSnQodGhpcyx7b2JqZWN0OnRoaXMudnx8dGhpcy5zLG5hbWU6dCx0eXBlOlwicmVtb3ZlXCJ9KSlyZXR1cm4gbnVsbDt0cnl7dmFyIGkscjtkdCgpO3ZhciBlLG89WXQodGhpcyksdT10aGlzLm50LmdldCh0KSxzPXZvaWQgMDtpZighdSYmbyYmKHM9bnVsbD09KGU9QW4odGhpcy5zLHQpKT92b2lkIDA6ZS52YWx1ZSksbil7aWYoIVJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy5zLHQpKXJldHVybiExfWVsc2UgZGVsZXRlIHRoaXMuc1t0XTt1JiYodGhpcy5udC5kZWxldGUodCksdSBpbnN0YW5jZW9mIG9pJiYocz11Lmp0KSx5dCh1KSksdGhpcy5idC5yZXBvcnRDaGFuZ2VkKCksbnVsbD09KGk9dGhpcy5vbil8fG51bGw9PShyPWkuZ2V0KHQpKXx8ci5zZXQodCBpbiB0aGlzLnMpLG8mJm8mJlp0KHRoaXMse3R5cGU6XCJyZW1vdmVcIixvYnNlcnZhYmxlS2luZDpcIm9iamVjdFwiLG9iamVjdDp0aGlzLnZ8fHRoaXMucyxkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCxvbGRWYWx1ZTpzLG5hbWU6dH0pfWZpbmFsbHl7YnQoKX1yZXR1cm4hMH0saS5ndD1mdW5jdGlvbih0KXtyZXR1cm4gUXQodGhpcyx0KX0saS5BdD1mdW5jdGlvbih0KXtyZXR1cm4gJHQodGhpcyx0KX0saS51bj1mdW5jdGlvbih0LG4pe3ZhciBpLHIsZT1ZdCh0aGlzKTtlJiZlJiZadCh0aGlzLGU/e3R5cGU6cWksb2JzZXJ2YWJsZUtpbmQ6XCJvYmplY3RcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCxvYmplY3Q6dGhpcy52fHx0aGlzLnMsbmFtZTp0LG5ld1ZhbHVlOm59Om51bGwpLG51bGw9PShpPXRoaXMub24pfHxudWxsPT0ocj1pLmdldCh0KSl8fHIuc2V0KCEwKSx0aGlzLmJ0LnJlcG9ydENoYW5nZWQoKX0saS5ldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ0LnJlcG9ydE9ic2VydmVkKCksRW4odGhpcy5zKX0saS5pdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ0LnJlcG9ydE9ic2VydmVkKCksT2JqZWN0LmtleXModGhpcy5zKX0sbn0oKSxaaT1oKFwiT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uXCIsUWkpLHRyPTAsbnI9ZnVuY3Rpb24oKXt9O0ZpPW5yLHppPUFycmF5LnByb3RvdHlwZSxPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKEZpLnByb3RvdHlwZSx6aSk6dm9pZCAwIT09RmkucHJvdG90eXBlLl9fcHJvdG9fXz9GaS5wcm90b3R5cGUuX19wcm90b19fPXppOkZpLnByb3RvdHlwZT16aTt2YXIgaXI9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihuLGkscixlKXt2YXIgbzt2b2lkIDA9PT1yJiYocj1cIk9ic2VydmFibGVBcnJheVwiKSx2b2lkIDA9PT1lJiYoZT0hMSksbz10LmNhbGwodGhpcyl8fHRoaXM7dmFyIHU9bmV3IEtpKHIsaSxlLCEwKTtpZih1LnY9aihvKSxjKGoobyksS24sdSksbiYmbi5sZW5ndGgpe3ZhciBzPVooITApO28uc3BsaWNlV2l0aEFycmF5KDAsMCxuKSx0dChzKX1yZXR1cm4gb313KG4sdCk7dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkuY29uY2F0PWZ1bmN0aW9uKCl7dGhpc1tLbl0uYXQucmVwb3J0T2JzZXJ2ZWQoKTtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0KSxpPTA7aTx0O2krKyluW2ldPWFyZ3VtZW50c1tpXTtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLnNsaWNlKCksbi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB1bih0KT90LnNsaWNlKCk6dH0pKSl9LGlbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3ZhciB0PXRoaXMsbj0wO3JldHVybiB3bih7bmV4dDpmdW5jdGlvbigpe3JldHVybiBuPHQubGVuZ3RoP3t2YWx1ZTp0W24rK10sZG9uZTohMX06e2RvbmU6ITAsdmFsdWU6dm9pZCAwfX19KX0seShuLFt7a2V5OlwibGVuZ3RoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbS25dLlh0KCl9LHNldDpmdW5jdGlvbih0KXt0aGlzW0tuXS5XdCh0KX19LHtrZXk6U3ltYm9sLnRvU3RyaW5nVGFnLGdldDpmdW5jdGlvbigpe3JldHVyblwiQXJyYXlcIn19XSksbn0obnIpO09iamVjdC5lbnRyaWVzKExpKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj10WzBdO1wiY29uY2F0XCIhPT1uJiZhKGlyLnByb3RvdHlwZSxuLHRbMV0pfSkpLHZuKDFlMyk7dmFyIHJyPV9uLnRvU3RyaW5nO1tcIlN5bWJvbFwiLFwiTWFwXCIsXCJTZXRcIl0uZm9yRWFjaCgoZnVuY3Rpb24oaSl7dm9pZCAwPT09bigpW2ldJiZ0KFwiTW9iWCByZXF1aXJlcyBnbG9iYWwgJ1wiK2krXCInIHRvIGJlIGF2YWlsYWJsZSBvciBwb2x5ZmlsbGVkXCIpfSkpLFwib2JqZWN0XCI9PXR5cGVvZiBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyYmX19NT0JYX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0TW9ieCh7c3B5Omp0LGV4dHJhczp7Z2V0RGVidWdOYW1lOnBufSwkbW9ieDpLbn0pLGV4cG9ydHMuJG1vYng9S24sZXhwb3J0cy5GbG93Q2FuY2VsbGF0aW9uRXJyb3I9RXQsZXhwb3J0cy5PYnNlcnZhYmxlTWFwPVdpLGV4cG9ydHMuT2JzZXJ2YWJsZVNldD0kaSxleHBvcnRzLlJlYWN0aW9uPXlpLGV4cG9ydHMuX2FsbG93U3RhdGVDaGFuZ2VzPVEsZXhwb3J0cy5fYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZD1PdCxleHBvcnRzLl9hbGxvd1N0YXRlUmVhZHNFbmQ9YXQsZXhwb3J0cy5fYWxsb3dTdGF0ZVJlYWRzU3RhcnQ9ZnQsZXhwb3J0cy5fYXV0b0FjdGlvbj1faSxleHBvcnRzLl9lbmRBY3Rpb249WSxleHBvcnRzLl9nZXRBZG1pbmlzdHJhdGlvbj1ibixleHBvcnRzLl9nZXRHbG9iYWxTdGF0ZT1mdW5jdGlvbigpe3JldHVybiBwaX0sZXhwb3J0cy5faW50ZXJjZXB0UmVhZHM9ZnVuY3Rpb24odCxuLGkpe3ZhciByO3JldHVybiBIaSh0KXx8dW4odCl8fHVpKHQpP3I9Ym4odCk6YW4odCkmJihyPWJuKHQsbikpLHIuZGVoYW5jZXI9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOmksZnVuY3Rpb24oKXtyLmRlaGFuY2VyPXZvaWQgMH19LGV4cG9ydHMuX2lzQ29tcHV0aW5nRGVyaXZhdGlvbj1mdW5jdGlvbigpe3JldHVybiBudWxsIT09cGkudHJhY2tpbmdEZXJpdmF0aW9ufSxleHBvcnRzLl9yZXNldEdsb2JhbFN0YXRlPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGxpO2Zvcih2YXIgbiBpbiB0KS0xPT09dmkuaW5kZXhPZihuKSYmKHBpW25dPXRbbl0pO3BpLmFsbG93U3RhdGVDaGFuZ2VzPSFwaS5lbmZvcmNlQWN0aW9uc30sZXhwb3J0cy5fc3RhcnRBY3Rpb249SixleHBvcnRzLmFjdGlvbj1naSxleHBvcnRzLmF1dG9ydW49Z3QsZXhwb3J0cy5jb21wYXJlcj1QbixleHBvcnRzLmNvbXB1dGVkPVFuLGV4cG9ydHMuY29uZmlndXJlPWZ1bmN0aW9uKGkpeyEwPT09aS5pc29sYXRlR2xvYmFsU3RhdGUmJmZ1bmN0aW9uKCl7aWYoKHBpLnBlbmRpbmdSZWFjdGlvbnMubGVuZ3RofHxwaS5pbkJhdGNofHxwaS5pc1J1bm5pbmdSZWFjdGlvbnMpJiZ0KDM2KSxiaT0hMCxkaSl7dmFyIGk9bigpOzA9PS0taS5fX21vYnhJbnN0YW5jZUNvdW50JiYoaS5fX21vYnhHbG9iYWxzPXZvaWQgMCkscGk9bmV3IGxpfX0oKTt2YXIgcixlLG89aS51c2VQcm94aWVzLHU9aS5lbmZvcmNlQWN0aW9ucztpZih2b2lkIDAhPT1vJiYocGkudXNlUHJveGllcz1cImFsd2F5c1wiPT09b3x8XCJuZXZlclwiIT09byYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb3h5KSxcImlmYXZhaWxhYmxlXCI9PT1vJiYocGkudmVyaWZ5UHJveGllcz0hMCksdm9pZCAwIT09dSl7dmFyIHM9XCJhbHdheXNcIj09PXU/XCJhbHdheXNcIjpcIm9ic2VydmVkXCI9PT11O3BpLmVuZm9yY2VBY3Rpb25zPXMscGkuYWxsb3dTdGF0ZUNoYW5nZXM9ITAhPT1zJiZcImFsd2F5c1wiIT09c31bXCJjb21wdXRlZFJlcXVpcmVzUmVhY3Rpb25cIixcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsXCJvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvblwiLFwiZGlzYWJsZUVycm9yQm91bmRhcmllc1wiLFwic2FmZURlc2NyaXB0b3JzXCJdLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QgaW4gaSYmKHBpW3RdPSEhaVt0XSl9KSkscGkuYWxsb3dTdGF0ZVJlYWRzPSFwaS5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbixpLnJlYWN0aW9uU2NoZWR1bGVyJiYocj1pLnJlYWN0aW9uU2NoZWR1bGVyLGU9bWksbWk9ZnVuY3Rpb24odCl7cmV0dXJuIHIoKGZ1bmN0aW9uKCl7cmV0dXJuIGUodCl9KSl9KX0sZXhwb3J0cy5jcmVhdGVBdG9tPV8sZXhwb3J0cy5kZWZpbmVQcm9wZXJ0eT1mdW5jdGlvbihuLGkscil7aWYoYW4obikpcmV0dXJuIG5bS25dLmgoaSxyKTt0KDM5KX0sZXhwb3J0cy5lbnRyaWVzPWZ1bmN0aW9uKG4pe3JldHVybiBhbihuKT9QdChuKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblt0LG5bdF1dfSkpOkhpKG4pP1B0KG4pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuW3Qsbi5nZXQodCldfSkpOkppKG4pP0FycmF5LmZyb20obi5lbnRyaWVzKCkpOnVuKG4pP24ubWFwKChmdW5jdGlvbih0LG4pe3JldHVybltuLHRdfSkpOnZvaWQgdCg3KX0sZXhwb3J0cy5leHRlbmRPYnNlcnZhYmxlPU50LGV4cG9ydHMuZmxvdz1SaSxleHBvcnRzLmZsb3dSZXN1bHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGV4cG9ydHMuZ2V0PWZ1bmN0aW9uKG4saSl7aWYoRHQobixpKSlyZXR1cm4gYW4obik/bltLbl0ubHQoaSk6SGkobik/bi5nZXQoaSk6dW4obik/bltpXTp2b2lkIHQoMTEpfSxleHBvcnRzLmdldEF0b209ZG4sZXhwb3J0cy5nZXREZWJ1Z05hbWU9cG4sZXhwb3J0cy5nZXREZXBlbmRlbmN5VHJlZT1mdW5jdGlvbih0LG4pe3JldHVybiBSdChkbih0LG4pKX0sZXhwb3J0cy5nZXRPYnNlcnZlclRyZWU9ZnVuY3Rpb24odCxuKXtyZXR1cm4ga3QoZG4odCxuKSl9LGV4cG9ydHMuaGFzPUR0LGV4cG9ydHMuaW50ZXJjZXB0PWZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gZShpKT9mdW5jdGlvbih0LG4saSl7cmV0dXJuIGJuKHQsbikuQXQoaSl9KHQsbixpKTpmdW5jdGlvbih0LG4pe3JldHVybiBibih0KS5BdChuKX0odCxuKX0sZXhwb3J0cy5pc0FjdGlvbj1BdCxleHBvcnRzLmlzQm94ZWRPYnNlcnZhYmxlPXVpLGV4cG9ydHMuaXNDb21wdXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gS3QodCl9LGV4cG9ydHMuaXNDb21wdXRlZFByb3A9ZnVuY3Rpb24odCxuKXtyZXR1cm4gS3QodCxuKX0sZXhwb3J0cy5pc0Zsb3c9Q3QsZXhwb3J0cy5pc0Zsb3dDYW5jZWxsYXRpb25FcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEV0fSxleHBvcnRzLmlzT2JzZXJ2YWJsZT1JdCxleHBvcnRzLmlzT2JzZXJ2YWJsZUFycmF5PXVuLGV4cG9ydHMuaXNPYnNlcnZhYmxlTWFwPUhpLGV4cG9ydHMuaXNPYnNlcnZhYmxlT2JqZWN0PWFuLGV4cG9ydHMuaXNPYnNlcnZhYmxlUHJvcD1mdW5jdGlvbih0LG4pe3JldHVybiBMdCh0LG4pfSxleHBvcnRzLmlzT2JzZXJ2YWJsZVNldD1KaSxleHBvcnRzLmtleXM9UHQsZXhwb3J0cy5tYWtlQXV0b09ic2VydmFibGU9ZnVuY3Rpb24odCxuLGkpe2lmKHModCkpcmV0dXJuIE50KHQsdCxuLGkpO3ZhciByPXNuKHQsaSlbS25dO2lmKCF0W0VpXSl7dmFyIGU9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpLG89bmV3IFNldChbXS5jb25jYXQoRW4odCksRW4oZSkpKTtvLmRlbGV0ZShcImNvbnN0cnVjdG9yXCIpLG8uZGVsZXRlKEtuKSxhKGUsRWksbyl9ZHQoKTt0cnl7dFtFaV0uZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHIubyh0LCFufHwhKHQgaW4gbil8fG5bdF0pfSkpfWZpbmFsbHl7YnQoKX1yZXR1cm4gdH0sZXhwb3J0cy5tYWtlT2JzZXJ2YWJsZT1mdW5jdGlvbih0LG4saSl7dmFyIHI9c24odCxpKVtLbl07ZHQoKTt0cnl7bnVsbCE9bnx8KG49ZnVuY3Rpb24odCl7cmV0dXJuIGIodCxDbil8fGEodCxDbixtKHt9LHRbQ25dKSksdFtDbl19KHQpKSxFbihuKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gci5vKHQsblt0XSl9KSl9ZmluYWxseXtidCgpfXJldHVybiB0fSxleHBvcnRzLm9ic2VydmFibGU9JG4sZXhwb3J0cy5vYnNlcnZlPWZ1bmN0aW9uKHQsbixpLHIpe3JldHVybiBlKGkpP2Z1bmN0aW9uKHQsbixpLHIpe3JldHVybiBibih0LG4pLmd0KGkscil9KHQsbixpLHIpOmZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gYm4odCkuZ3QobixpKX0odCxuLGkpfSxleHBvcnRzLm9uQmVjb21lT2JzZXJ2ZWQ9U3QsZXhwb3J0cy5vbkJlY29tZVVub2JzZXJ2ZWQ9TXQsZXhwb3J0cy5vblJlYWN0aW9uRXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHBpLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5wdXNoKHQpLGZ1bmN0aW9uKCl7dmFyIG49cGkuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmluZGV4T2YodCk7bj49MCYmcGkuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnNwbGljZShuLDEpfX0sZXhwb3J0cy5vdmVycmlkZT1EbixleHBvcnRzLm93bktleXM9QnQsZXhwb3J0cy5yZWFjdGlvbj1mdW5jdGlvbih0LG4saSl7ZnVuY3Rpb24gcigpe2lmKGw9ITEsIXAuSil7dmFyIG49ITE7cC50cmFjaygoZnVuY3Rpb24oKXt2YXIgaT1RKCExLChmdW5jdGlvbigpe3JldHVybiB0KHApfSkpO249dnx8IWIocyxpKSxkPXMscz1pfSkpLCh2JiZpLmZpcmVJbW1lZGlhdGVseXx8IXYmJm4pJiZhKHMsZCxwKSx2PSExfX12YXIgZTt2b2lkIDA9PT1pJiYoaT1Nbik7dmFyIG8sdSxzLGY9bnVsbCE9KGU9aS5uYW1lKT9lOlwiUmVhY3Rpb25cIixhPWdpKGYsaS5vbkVycm9yPyhvPWkub25FcnJvcix1PW4sZnVuY3Rpb24oKXt0cnl7cmV0dXJuIHUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWNhdGNoKHQpe28uY2FsbCh0aGlzLHQpfX0pOm4pLGM9IWkuc2NoZWR1bGVyJiYhaS5kZWxheSxoPV90KGkpLHY9ITAsbD0hMSxkPXZvaWQgMCxiPWkuY29tcGFyZVN0cnVjdHVyYWw/UG4uc3RydWN0dXJhbDppLmVxdWFsc3x8UG4uZGVmYXVsdCxwPW5ldyB5aShmLChmdW5jdGlvbigpe3Z8fGM/cigpOmx8fChsPSEwLGgocikpfSksaS5vbkVycm9yLGkucmVxdWlyZXNPYnNlcnZhYmxlKTtyZXR1cm4gcC5ZKCkscC5aKCl9LGV4cG9ydHMucmVtb3ZlPWZ1bmN0aW9uKG4saSl7YW4obik/bltLbl0uR3QoaSk6SGkobil8fEppKG4pP24uZGVsZXRlKGkpOnVuKG4pPyhcIm51bWJlclwiIT10eXBlb2YgaSYmKGk9cGFyc2VJbnQoaSwxMCkpLG4uc3BsaWNlKGksMSkpOnQoOSl9LGV4cG9ydHMucnVuSW5BY3Rpb249T3QsZXhwb3J0cy5zZXQ9ZnVuY3Rpb24gbihpLHIsZSl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGh8fEppKGkpKWFuKGkpP2lbS25dLmR0KHIsZSk6SGkoaSk/aS5zZXQocixlKTpKaShpKT9pLmFkZChyKTp1bihpKT8oXCJudW1iZXJcIiE9dHlwZW9mIHImJihyPXBhcnNlSW50KHIsMTApKSxyPDAmJnQoXCJJbnZhbGlkIGluZGV4OiAnXCIrcitcIidcIiksZHQoKSxyPj1pLmxlbmd0aCYmKGkubGVuZ3RoPXIrMSksaVtyXT1lLGJ0KCkpOnQoOCk7ZWxzZXtkdCgpO3ZhciBvPXI7dHJ5e2Zvcih2YXIgdSBpbiBvKW4oaSx1LG9bdV0pfWZpbmFsbHl7YnQoKX19fSxleHBvcnRzLnNweT1qdCxleHBvcnRzLnRvSlM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uIHQobixpKXtpZihudWxsPT1ufHxcIm9iamVjdFwiIT10eXBlb2Ygbnx8biBpbnN0YW5jZW9mIERhdGV8fCFJdChuKSlyZXR1cm4gbjtpZih1aShuKXx8Y2kobikpcmV0dXJuIHQobi5nZXQoKSxpKTtpZihpLmhhcyhuKSlyZXR1cm4gaS5nZXQobik7aWYodW4obikpe3ZhciByPXF0KGksbixuZXcgQXJyYXkobi5sZW5ndGgpKTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihuLGUpe3JbZV09dChuLGkpfSkpLHJ9aWYoSmkobikpe3ZhciBlPXF0KGksbixuZXcgU2V0KTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihuKXtlLmFkZCh0KG4saSkpfSkpLGV9aWYoSGkobikpe3ZhciBvPXF0KGksbixuZXcgTWFwKTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihuLHIpe28uc2V0KHIsdChuLGkpKX0pKSxvfXZhciB1PXF0KGksbix7fSk7cmV0dXJuIEJ0KG4pLmZvckVhY2goKGZ1bmN0aW9uKHIpe19uLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwobixyKSYmKHVbcl09dChuW3JdLGkpKX0pKSx1fSh0LG5ldyBNYXApfSxleHBvcnRzLnRyYWNlPUd0LGV4cG9ydHMudHJhbnNhY3Rpb249V3QsZXhwb3J0cy51bnRyYWNrZWQ9b3QsZXhwb3J0cy52YWx1ZXM9ZnVuY3Rpb24obil7cmV0dXJuIGFuKG4pP1B0KG4pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG5bdF19KSk6SGkobik/UHQobikubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbi5nZXQodCl9KSk6Smkobik/QXJyYXkuZnJvbShuLnZhbHVlcygpKTp1bihuKT9uLnNsaWNlKCk6dm9pZCB0KDYpfSxleHBvcnRzLndoZW49ZnVuY3Rpb24odCxuLGkpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aHx8biYmXCJvYmplY3RcIj09dHlwZW9mIG4/VXQodCxuKTpIdCh0LG4saXx8e30pfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vYnguY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJhc3NlcnQubm90RXF1YWwgPSBub3RFcXVhbFxuYXNzZXJ0Lm5vdE9rID0gbm90T2tcbmFzc2VydC5lcXVhbCA9IGVxdWFsXG5hc3NlcnQub2sgPSBhc3NlcnRcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NlcnRcblxuZnVuY3Rpb24gZXF1YWwgKGEsIGIsIG0pIHtcbiAgYXNzZXJ0KGEgPT0gYiwgbSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbn1cblxuZnVuY3Rpb24gbm90RXF1YWwgKGEsIGIsIG0pIHtcbiAgYXNzZXJ0KGEgIT0gYiwgbSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbn1cblxuZnVuY3Rpb24gbm90T2sgKHQsIG0pIHtcbiAgYXNzZXJ0KCF0LCBtKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHQsIG0pIHtcbiAgaWYgKCF0KSB0aHJvdyBuZXcgRXJyb3IobSB8fCAnQXNzZXJ0aW9uRXJyb3InKVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbnZhciBzYWZlRXh0ZXJuYWxMaW5rID0gLyhub29wZW5lcnxub3JlZmVycmVyKSAobm9vcGVuZXJ8bm9yZWZlcnJlcikvXG52YXIgcHJvdG9jb2xMaW5rID0gL15bXFx3LV9dKzovXG5cbm1vZHVsZS5leHBvcnRzID0gaHJlZlxuXG5mdW5jdGlvbiBocmVmIChjYiwgcm9vdCkge1xuICBhc3NlcnQubm90RXF1YWwodHlwZW9mIHdpbmRvdywgJ3VuZGVmaW5lZCcsICduYW5vaHJlZjogZXhwZWN0ZWQgd2luZG93IHRvIGV4aXN0JylcblxuICByb290ID0gcm9vdCB8fCB3aW5kb3cuZG9jdW1lbnRcblxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAnbmFub2hyZWY6IGNiIHNob3VsZCBiZSB0eXBlIGZ1bmN0aW9uJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiByb290LCAnb2JqZWN0JywgJ25hbm9ocmVmOiByb290IHNob3VsZCBiZSB0eXBlIG9iamVjdCcpXG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoKGUuYnV0dG9uICYmIGUuYnV0dG9uICE9PSAwKSB8fFxuICAgICAgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLnNoaWZ0S2V5IHx8XG4gICAgICBlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVyblxuXG4gICAgdmFyIGFuY2hvciA9IChmdW5jdGlvbiB0cmF2ZXJzZSAobm9kZSkge1xuICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IHJvb3QpIHJldHVyblxuICAgICAgaWYgKG5vZGUubG9jYWxOYW1lICE9PSAnYScgfHwgbm9kZS5ocmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlKG5vZGUucGFyZW50Tm9kZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlXG4gICAgfSkoZS50YXJnZXQpXG5cbiAgICBpZiAoIWFuY2hvcikgcmV0dXJuXG5cbiAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSBhbmNob3IucHJvdG9jb2wgfHxcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICE9PSBhbmNob3IuaG9zdG5hbWUgfHxcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnBvcnQgIT09IGFuY2hvci5wb3J0IHx8XG4gICAgICBhbmNob3IuaGFzQXR0cmlidXRlKCdkYXRhLW5hbm9ocmVmLWlnbm9yZScpIHx8XG4gICAgICBhbmNob3IuaGFzQXR0cmlidXRlKCdkb3dubG9hZCcpIHx8XG4gICAgICAoYW5jaG9yLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykgPT09ICdfYmxhbmsnICYmXG4gICAgICAgIHNhZmVFeHRlcm5hbExpbmsudGVzdChhbmNob3IuZ2V0QXR0cmlidXRlKCdyZWwnKSkpIHx8XG4gICAgICBwcm90b2NvbExpbmsudGVzdChhbmNob3IuZ2V0QXR0cmlidXRlKCdocmVmJykpKSByZXR1cm5cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGNiKGFuY2hvcilcbiAgfSlcbn1cbiIsIiFmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLnRhYmxlPW5ldyBVaW50MTZBcnJheSgxNiksdGhpcy50PW5ldyBVaW50MTZBcnJheSgyODgpfWZ1bmN0aW9uIGYoZix2KXt0aGlzLnNvdXJjZT1mLHRoaXMuc291cmNlSW5kZXg9MCx0aGlzLnRhZz0wLHRoaXMudj0wLHRoaXMuTT12LHRoaXMuSj0wLHRoaXMubz1uZXcgdCx0aGlzLnU9bmV3IHR9dmFyIHY9bmV3IHQsYj1uZXcgdCxNPW5ldyBVaW50OEFycmF5KDMwKSxKPW5ldyBVaW50MTZBcnJheSgzMCkscj1uZXcgVWludDhBcnJheSgzMCksZT1uZXcgVWludDE2QXJyYXkoMzApLGE9bmV3IFVpbnQ4QXJyYXkoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxuPW5ldyB0LGk9bmV3IFVpbnQ4QXJyYXkoMzIwKTtmdW5jdGlvbiBvKHQsZix2LGIpe3ZhciBNLEo7Zm9yKE09MDtNPHY7KytNKXRbTV09MDtmb3IoTT0wO008MzAtdjsrK00pdFtNK3ZdPU0vdnwwO2ZvcihKPWIsTT0wO008MzA7KytNKWZbTV09SixKKz0xPDx0W01dfXZhciBzPW5ldyBVaW50MTZBcnJheSgxNik7ZnVuY3Rpb24gdSh0LGYsdixiKXt2YXIgTSxKO2ZvcihNPTA7TTwxNjsrK00pdC50YWJsZVtNXT0wO2ZvcihNPTA7TTxiOysrTSl0LnRhYmxlW2ZbditNXV0rKztmb3IodC50YWJsZVswXT0wLEo9MCxNPTA7TTwxNjsrK00pc1tNXT1KLEorPXQudGFibGVbTV07Zm9yKE09MDtNPGI7KytNKWZbditNXSYmKHQudFtzW2ZbditNXV0rK109TSl9ZnVuY3Rpb24gYyh0KXt0LnYtLXx8KHQudGFnPXQuc291cmNlW3Quc291cmNlSW5kZXgrK10sdC52PTcpO3ZhciBmPTEmdC50YWc7cmV0dXJuIHQudGFnPj4+PTEsZn1mdW5jdGlvbiBoKHQsZix2KXtpZighZilyZXR1cm4gdjtmb3IoO3QudjwyNDspdC50YWd8PXQuc291cmNlW3Quc291cmNlSW5kZXgrK108PHQudix0LnYrPTg7dmFyIGI9dC50YWcmNjU1MzU+Pj4xNi1mO3JldHVybiB0LnRhZz4+Pj1mLHQudi09ZixiK3Z9ZnVuY3Rpb24gZCh0LGYpe2Zvcig7dC52PDI0Oyl0LnRhZ3w9dC5zb3VyY2VbdC5zb3VyY2VJbmRleCsrXTw8dC52LHQudis9ODt2YXIgdj0wLGI9MCxNPTAsSj10LnRhZztkb3tiPTIqYisoMSZKKSxKPj4+PTEsKytNLHYrPWYudGFibGVbTV0sYi09Zi50YWJsZVtNXX13aGlsZShiPj0wKTtyZXR1cm4gdC50YWc9Six0LnYtPU0sZi50W3YrYl19ZnVuY3Rpb24gdyh0LGYsdil7dmFyIGIsTSxKLHIsZSxvO2ZvcihiPWgodCw1LDI1NyksTT1oKHQsNSwxKSxKPWgodCw0LDQpLHI9MDtyPDE5OysrcilpW3JdPTA7Zm9yKHI9MDtyPEo7KytyKXt2YXIgcz1oKHQsMywwKTtpW2Fbcl1dPXN9Zm9yKHUobixpLDAsMTkpLGU9MDtlPGIrTTspe3ZhciBjPWQodCxuKTtzd2l0Y2goYyl7Y2FzZSAxNjp2YXIgdz1pW2UtMV07Zm9yKG89aCh0LDIsMyk7bzstLW8paVtlKytdPXc7YnJlYWs7Y2FzZSAxNzpmb3Iobz1oKHQsMywzKTtvOy0tbylpW2UrK109MDticmVhaztjYXNlIDE4OmZvcihvPWgodCw3LDExKTtvOy0tbylpW2UrK109MDticmVhaztkZWZhdWx0OmlbZSsrXT1jfX11KGYsaSwwLGIpLHUodixpLGIsTSl9ZnVuY3Rpb24gbCh0LGYsdil7Zm9yKDs7KXt2YXIgYixhLG4saSxvPWQodCxmKTtpZigyNTY9PT1vKXJldHVybiAwO2lmKG88MjU2KXQuTVt0LkorK109bztlbHNlIGZvcihiPWgodCxNW28tPTI1N10sSltvXSksYT1kKHQsdiksaT1uPXQuSi1oKHQsclthXSxlW2FdKTtpPG4rYjsrK2kpdC5NW3QuSisrXT10Lk1baV19fWZ1bmN0aW9uIHkodCl7Zm9yKHZhciBmLHY7dC52Pjg7KXQuc291cmNlSW5kZXgtLSx0LnYtPTg7aWYoKGY9MjU2KihmPXQuc291cmNlW3Quc291cmNlSW5kZXgrMV0pK3Quc291cmNlW3Quc291cmNlSW5kZXhdKSE9PSg2NTUzNSZ+KDI1Nip0LnNvdXJjZVt0LnNvdXJjZUluZGV4KzNdK3Quc291cmNlW3Quc291cmNlSW5kZXgrMl0pKSlyZXR1cm4tMztmb3IodC5zb3VyY2VJbmRleCs9NCx2PWY7djstLXYpdC5NW3QuSisrXT10LnNvdXJjZVt0LnNvdXJjZUluZGV4KytdO3JldHVybiB0LnY9MCwwfSFmdW5jdGlvbih0LGYpe3ZhciB2O2Zvcih2PTA7djw3Oysrdil0LnRhYmxlW3ZdPTA7Zm9yKHQudGFibGVbN109MjQsdC50YWJsZVs4XT0xNTIsdC50YWJsZVs5XT0xMTIsdj0wO3Y8MjQ7Kyt2KXQudFt2XT0yNTYrdjtmb3Iodj0wO3Y8MTQ0Oysrdil0LnRbMjQrdl09djtmb3Iodj0wO3Y8ODsrK3YpdC50WzE2OCt2XT0yODArdjtmb3Iodj0wO3Y8MTEyOysrdil0LnRbMTc2K3ZdPTE0NCt2O2Zvcih2PTA7djw1OysrdilmLnRhYmxlW3ZdPTA7Zm9yKGYudGFibGVbNV09MzIsdj0wO3Y8MzI7Kyt2KWYudFt2XT12fSh2LGIpLG8oTSxKLDQsMyksbyhyLGUsMiwxKSxNWzI4XT0wLEpbMjhdPTI1ODt2YXIgcCxRLE89TztmdW5jdGlvbiBnKCl7fU89bW9kdWxlO2Zvcih2YXIgQT1uZXcgVWludDhBcnJheSgxMjMpLFM9MjU7Uz49MDstLVMpQVs0OCtTXT01MitTLEFbNjUrU109UyxBWzk3K1NdPTI2K1M7QVs0M109NjIsQVs0N109NjMsTy53YXNtPWZ1bmN0aW9uKHQsTSl7dmFyIEoscixlPW5ldyBmKHQsbmV3IFVpbnQ4QXJyYXkoMTE2MjEwKSk7ZG97c3dpdGNoKEo9YyhlKSxoKGUsMiwwKSl7Y2FzZSAwOnI9eShlKTticmVhaztjYXNlIDE6cj1sKGUsdixiKTticmVhaztjYXNlIDI6dyhlLGUubyxlLnUpLHI9bChlLGUubyxlLnUpO2JyZWFrO2RlZmF1bHQ6cj0tM31pZigwIT09cil0aHJvdyBFcnJvcihcIkRhdGEgZXJyb3JcIil9d2hpbGUoIUopO3JldHVybiBlLko8ZS5NLmxlbmd0aD9cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLk0uc2xpY2U/ZS5NLnNsaWNlKDAsZS5KKTplLk0uc3ViYXJyYXkoMCxlLkopOmUuTX0oKHQ9Pntjb25zdCBmPW5ldyBVaW50OEFycmF5KDcyMzc0KTtsZXQgdixiPSExLE09MDtmb3IobGV0IEo9MDtKPDcyMzc0O0orKyl2PXQuY2hhckNvZGVBdChKKSwxMyE9PXYmJjEwIT09diYmKDYxIT09dnx8Yj8oYiYmKGI9ITEsdi09NjQpLGZbTSsrXT12PDQyJiZ2PjA/disyMTQ6di00Mik6Yj0hMCk7cmV0dXJuIGYuc3ViYXJyYXkoMCxNKX0pKFwiw5bDpzXCukdcdTAwMDHCo1x1MDAxMcKhw6VcdTAwMTnCpVx1MDAxOMOHw4PDiFEwXS1cXGbCni0uwrFOMsKsTF7CrlxcXCIsRMKmwqtKb8KTd1x1MDAxYsKPw5nCksKkwoFAXHUwMDBmwqUxw54rOHpcXGI/wqvCq8Odw55tw7HDtsKwdcOrW8KVwoE/w518w5TCvMKUwrXDmHzCm8KPw5nDlMOWw67DmsO1wr/DojzCg8KMfnTDrFx1MDAwNFx1MDAwMsOfwrbCgVx1MDAxNcKSw4fDsVxcXFw/w49cdTAwMTZcdTAwMDfCv8O3JihcXHTCoSTDuEfCusO+wpjCj8OBVnYhXHUwMDE3aMK5XHUwMDE5w4ZcdTAwMWTDp8O5wqHDqMOYJ8O+XHUwMDFkw5HCvcKEw5fDgMKmW1fDiHPDocOgwrzDl8KRXHUwMDE0woXCoHPDoMKUw7lew6JcdTAwMGbCvH7CucKVw7leXHUwMDFmwq7ClcKnXHUwMDE1w4xIfMONwqTDsMOZw6BcdTAwMDdcdTAwMTJ7w5XDpHPCiHLCiMOaLEFYw77DiFx1MDAxM8OwIcKke8K/w4/DhFx1MDAxZnzCn8Kma8OnwofCpsOQwoHCv8OmesOnw6TDsn3CpMOnw7LDmcOUw4c1wqQ/w6VcXFxcwopcdTAwMWXCnH5dw6zDo2/DsShcdTAwMTYswpdcdTAwMTPCg8OXIHbCqcOWOnlkw7/Dl8KEw5tYXHUwMDE2w7NvScKOV1x1MDAwM3TCoWHCvMOJdMKow5Q9QFx1MDAxMVx1MDAxOVxcdMOaw6nCqcOdw4BcdTAwMWEhXcOfcCfCr8O5UXNXw5fDn8K8cHzDhcKVXsKUXHUwMDE3I1x1MDAxMGzDhMOOwrVcdTAwMWbChGHDk8KfwrzCpMKXw5xcXGLDgsOCw5TDjz19w6XCpMO9dcKTw7zCliDDnFx1MDAxMFx1MDAxOMODXHUwMDBmwr9Ow5dfw7zChMO8csKBZV9cdTAwMTjDhcOfwpDDjV/Ch8OhKcKEXcO3woBcXFxcw4PDv8O8wpDDmXvDlVx1MDAwMWXDtz1Aw4jDk8KzwqTDlcO/XHUwMDEzXsO9wphXw5NcdTAwMTfDl8KvwpBNd1x1MDAxY8KYw7zCklBpw4HDjlPDr8K9dVx1MDAxM8OPw57Dv8KPIMO0wqFcXGImw6fDnlx1MDAwMcOow6DDhSZeXHUwMDE3wqnDoMKgeVx1MDAxY8KWXHUwMDE3woxcdTAwMWPDo1x1MDAwNMKvXHUwMDBlwpHClFlOwq1cdTAwMDRcXHR0wrDDn8Opw4fClsO+XHUwMDA0M3VcXHTCl1HDn1xcXFxcdTAwMTNPw4nDiVxcXCLDq8KJXmgpwqFEc8KnVcOOXHUwMDBmw4/DsFFEw7FtV05Lw7fDvFx1MDAwZnrDhVx1MDAxOFx1MDAxYk1HXHUwMDBlXHUwMDFmw77DiGjCiT1Aw7lcdTAwMDZcdTAwMDFiw5hJwqhBwpTCo1x1MDAwNHnCpMO+dnjCmClcXGZ8aUjDvMK6XHUwMDA2fsOVXHUwMDA3wojDjcKIw4M2wpzDhFx1MDAwZXzDjsOUYsOzwrl6wqnCmsOcPUBcdTAwMTXDu8KAw6fCplxcdnbDu1LDmcO+wqI6RFx1MDAwZlx1MDAxYmvDuzZTIVxcYsOwwoTChMKFeStswqHCt1x1MDAxZsOeXFx2wqHDh1x1MDAxZsOePU3CoSdcdTAwMWbDnlx1MDAxOcKhXHUwMDAzwqTDhCNcdTAwMDcmwqRkXHUwMDE5wqF1XHUwMDE1XHUwMDEzwrxcXHTDl8OYw5HDlcKoQT1Aw709SsKhJVx1MDAwMcO9J8Kow6HDoMOIw5gjXHUwMDA3w6tcdTAwMWZcdTAwMWXDilxcdEfCiHk5JVx1MDAwN8K7XHUwMDFmXHUwMDFlwrJcXHRHwod5wrkkXHUwMDA3w4dcdTAwMTVcdTAwMTPDh8K2XHUwMDE2XFxcIsK6wrsrWWFvJDPCt8KyXHUwMDAxwrd5dlBlw4p5w7TCsMKQKj1Kw6NTw7zCsVLDkcKzw5TDgcK3McOhw5HCt8KJw63DjDvClMKNwrnDmMOIc8OldcKYw5nCkyjDonXCmcOZw4/CqMKBw6nDp8KAw6nDpMOBNMOEZDfCqMO6wqTDvj1NwrRmwopcdTAwMGbClMOnccK9w7DCgMOSW30vwpnDuFx1MDAxMXdcdTAwMDfCscOme8KYQzpcdTAwMWbDpsKPV8OVcHIwXj/DhEXCr1dMw5LDuzRcdTAwMWbDi1DDgi/DnsOlOsKUXHUwMDAzXHUwMDFmS1x1MDAxN8OnN2/ClsObw7DDs8Knw5ZXZzUrwrzCi8KTworDvibCvMK+wpTCrsOAw71cdTAwMWJcdTAwMTFsw4EkXFxcIi1kV1x1MDAwNcKIw5pbKMKGw61cdTAwMThcdTAwMWPDplx1MDAwZSE6XHUwMDBlLFxcXCLDhMKkXHUwMDFiwqMxQsKLQS1EPnY5P1x1MDAxZsOiwphfwpLCs8KJw4rCu1g3w4RcdTAwMTPDrlx1MDAwMXNcdTAwMDNJP1x1MDAwNmdUMkhcdTAwMTMswoxcdTAwMTMsw5BcdTAwMTPDvMORwppgw5RgacOkwoVEXHUwMDA3w5fCgHczXHUwMDFhXVx1MDAwZsO8XHUwMDAzw4xoLsK+wopcdTAwMTfCsCTDqsKBXFxcIm5cdTAwMTfDoGRHXHUwMDEybMO1w6Qqw4FYXHUwMDE0ZnrCssOAwqxcdTAwMTRcdTAwMTc/XHUwMDE4wpLDn8OoLXXCi8Ojwq5Vw6zDhWTDgsKAXsOew5TCvsOXWz4nwpjDgEHDuVx1MDAwZcOEIVx1MDAxMC3CvsKNwozDqnvDksOSworCnFU8XFxmRDw3w4nCvy1Tw6psw5gvVcKJw71uLEnCt1x1MDAxZG1cdTAwMWbCo1x1MDAwMjrCqMOww5TDpDDDjXJkw5/DlCpcdTAwMTPCjcKoXFx2Nlx1MDAxZHdvwotcdTAwMDTCg8ONXFxiPlx1MDAxOGxdw6p/w77DtCHClElhw5pcdTAwMTVcdTAwMTHDqy9tXHUwMDFkwpx5w5JnwoVOw61cdTAwMWTCjz1NwqNUw4/DhcOtXHUwMDFjKcOUN8KiKFxcYlxcYsK5eT1AwopuXHUwMDBmX2vCmX3Dp3fCoiVcXHTDnMOww59cdTAwMWNCWcK4Z8Oiw7xVSsOHd8Kow6lcdTAwMWY5w73Cq8OdwrLChCNgIWA4wq1fw44wwrBqXHUwMDEww5h7w6gnwpDDlMKpXHUwMDAxXHUwMDAxwpVRwqooYcKoXHUwMDEzb8KQw6RcdTAwMDHDpXXChnrCgsOZw5vCtTpCXHUwMDA1I0zCo8OacsK3XHUwMDAxW2HCs8KawoUyWVxcXFx1wrBLwodbw5ZhwobDqcKtw5HCtsOdwohQwrnCgsKTwoDDocKmXHUwMDExYMONwr7DsMOKXHUwMDE2wo7Dt8OMwqBxw4xwwpTCm8O6JMKDPUDCpCZcdTAwMTfCp8OZw7PClFx1MDAxOMOVwqt1b8Knw6lLNcOif8KoaHl9w6JcdTAwMTfCsSnDucKWJlx1MDAwNMOhwpTDrcOTwrNwwqdUw4N0w5HDkFx1MDAwNMOHw4TCgsKUfMKowo1cdTAwMTnCmsOUw7/DhsOEXHUwMDE0eMOfSsO6w44mQMOpw71cdTAwMTjDrsOOQELChlx1MDAxM8K1RMOCw5XDqMOSXHUwMDA1XHUwMDAyPjnClFFRJUTDocOXwpZcdTAwMWPDmsKowpJvXHUwMDExJT19acOUwoDCnMK8cHHDn1x1MDAxNsKxwpRXXHUwMDFmw6Vpw5w9QMOadkjDhMOGXHUwMDFhw5wnwqhcdTAwMTFcdTAwMTTDnMObXHUwMDA2wqfCvcOew5M9QMKLw7XDtsK/XFx2YFXCpHrCt0XCvGBcdTAwMTI/w5ZBwphcdTAwMTDDl8KCwoo3w7ZcXHZbwozCrsOhN8Oaw5PCplx1MDAxMXTCl8Oaw4vCicOHw5zDo2NSwrk2w5w9QMOcWnM1LylcdTAwMDNWXHUwMDA0w4t/wojDtDDDml7CtMOtamzDncKmw5HDoFtCwr7CqX5FXHUwMDBlNz1Aw6RnwqpLNCEuw6XCmHjDl8KCwqlcXGZcdTAwMWRswoLChMKSOMO0dcOBWCfCkVkyw71+woslwoHDtcKCwpjCu254woVcXFxcXHUwMDBlw41pwozDsj5cdTAwMDEqwrpaw5/CqFx1MDAxZG11K8K4d8KrdF9cXGLCgcK0wqPDn8Khw5UnJMKxw6AqZMOVL8KOwonDl8OJKMOyw6/CpMKyw5zDoHzDqy7DvzFhw7HDnkJcdTAwMWLDusKGeVVre19Mw6vDgDdqXHUwMDE0w54hw7XCt8Oew6PCv8KIXidcXHYrQsKDwrTChizCt8OhTFNAV8OyMcOgWsKqwqvCvjrCl1x1MDAwM8KjwpJcdTAwMGZpRsOlw5LDrVhcXFwiwpFcdTAwMTZcXGZhwohUXHUwMDA0w4nCrsOQwoPDpsKgwpIpXHUwMDE3w4xcdTAwMWZ8XFxieFnCsD1Aw4FcXHbCjsO4dsKKOVo6RUNGwoLCtsOPWlDDtDrDnWXCtcKww7rDvFx1MDAwM8KLw4/Ctlx1MDAxMsKEw5vDrcOQZ8OKXFxiwqF/ecK2WVRYw7BIw5PDkcOlwrhiL8OUf8KSw4lywojDvMKGwrdcdTAwMWLDjsK1XHUwMDFhw47CiShlXFxmKMOmJsOvwojDu2h7JVvCmlHDqMO4woXDp8O6JFx1MDAwZcKnw6fDsMKbwrDDviTChcKJSDQ9SsOkKzPCvD1AVcOyw69mbFx1MDAxNS7CgsKiw5NcdTAwMWJTLlx1MDAwZcOJw75cdTAwMTJWN8O3JcONwpRcdTAwMGYtwpNzwqU7w5/DjiHDncKswp9Nd8O0Tzt/OTnDnMOlw57DnlZcdTAwMDLDsVF9wrrCs8K/bzDDrlx1MDAxMcKKwq/DiFFmwrEndcOww6nDmcKnSMOuIDclf8OnQUTDp1x1MDAxOXHDr8KqI8OKw6bDkH9MwoQswoRkw7BcdTAwMTDDusOAXHUwMDA2XHUwMDFlw7rCsFPDi8OQwqV0OVx1MDAxZmTDvMK7XHUwMDE0w5BRw7/Crz1KXHUwMDA1XHUwMDE0wpLCh8OCw7ZvOlx1MDAwNmHCs1xcXFxcdTAwMWMrwoRcdTAwMTI6w7Y9QFx1MDAwNl3CkVx1MDAxZl3DmMK0czdfXHUwMDE3w53CqMOwwr9Pw7vDgcK0w4xcdTAwMTYywqEuwrNiw6NEwrTDn8OOXHUwMDFmPUBrYcK/w4AuwoBrVcKAwpPDlsKPXHUwMDA3wo9fwpfDg8K2w5nChEXCmVV/IWpmwpTCtMOIwqBcdTAwMTTCtsKKw43CusOuw6VCwpVcXFxcQEjDq8KOw5JeYMOwbHd1e1xcXCJcdTAwMTnDhXMxw5zDvFx1MDAxZU7Cg8K5w7N2wpbDkMOcwqDCs8KkwpnDnGzDjlJgQlx1MDAxMzhvMsOkwpXDgUfCm8OowrvCnEvDtsKsw68/V8O7bmHDnjDCo8Kxw7RHwoE5bFx1MDAwMT82fjFcdTAwMWXDi2tcdTAwMTLCkiNSXHUwMDAzworDqsKGwrZqwp5fXFx2w7VcXFwiXHUwMDEzLirCp8OAekA8fUDCqlx1MDAwNMK+LzN7d8Kswr7Cr158aU3DmcOSacKvJMO9wpHCtcOQfcKpwp1uJz7Cn1x1MDAxNHnDi8Kow6fCryTDhU1cdTAwMTR5Sz8owrMkwoV4XFx0wr/DnMOKXHUwMDEzXFxcXMKPw6tcdTAwMTPDvsO2wrRyw5HDmERcdTAwMTd+QMKEw5hWwpLDmsKbwr/CsMKoUcKNwrPCu2cuw5tcdTAwMDLDslx1MDAxN8OcZ8KcfcOcw4LDq8O6wo/CuHDClMK8XHUwMDEzwoFcXGLDiVx1MDAxNMOhw7VPbsK5MEbDhSFTw4/DgMKAwqnCkcKpKcOpwpHDmFx1MDAxOF3CgSk9SsODw73ChcKQOMKuwqQpw7ZfKMOnwpDDmDvCkXgtwpfCrsOQwrrDuMOww4ZcdTAwMWZOZ8OGMcOeT8KERsKowoTClWnDnsK8X8KKXHUwMDExwoNlTjxOwpNcdTAwMTnDv8Kgw7xfP8KXU8OJX1x1MDAxM8OBecO0XFxiwqRYw4Fow4hcdTAwMDZcdTAwMTl2LUjDvMO4KMKQw4PDulxcXCLClsKDZcK/IcK3wpXCnsO/ccK9aVx1MDAwNlx1MDAxNVvDqcOcXFxcXGPCncOJwqhmKmttJlx1MDAxM8Ozc8OQw5PClSDChsOkc1x1MDAwMcOEw5/CkMK4w5hrw4PDusKJw7PDkcOiwrvDvCpcdTAwMTd3w4RaakNmwrFow7pcdTAwMDXDtlx1MDAxMMOTw7LDjVx1MDAxOMO4cT19XHUwMDBmXHUwMDFlw4NcdTAwMWPDlXF3M8OGUkVcdTAwMTFcXGZnw5fDicO3UcOsflx1MDAxMsKzN1x1MDAxZsKGWcKSwq7Dk8KdwqPDvcKKw7fDrMO+wpDDuzFkw6rDhFfDoS5cdTAwMTXClmhnXHUwMDE0w59Jw4RcdTAwMDUnw69Jwp1MJ8OjasOPwp12wrA6acORJcO6XHUwMDA2Nj19XHUwMDE0w5TCicOQwpE9SsOvw71cdTAwMGY9QMOzwqbCsDXCr8ORbTnDjMO4XHUwMDFjwqjDgsKzIMKSwolfwp3Cq8OswoZcdTAwMTA3Klx1MDAxM8KTeMKUw5vChcOKZMKxXHUwMDFjZcOfQ0RcdTAwMDNcXHTDisKld8KSIVx1MDAxNMORw7DDnsOrwoXDt8KNNWzDicOywqDDvcOnXHUwMDFlXcOWdcOEwo0gwrorXSXCuiDCgMOfXHUwMDEywoVcdTAwMGbCjMKkLcKdL3/Cl8KkeihcdTAwMDbDg8KLw7tcdTAwMDfDmcKfwpTCsn93w4HDn8KxS1RwwqDDvFxcXCLCpMKHOSvCpE3DgXBiw5PCgzPDvUXCi8KQSsO/w5fCtUQ6UFx1MDAxN2BDXHUwMDA2wro9QMK4wqzCuSdaw5PCk8OIXHUwMDFlwpPDiDhdJF/DjcKJRF7CncOLS3jDlVx1MDAxZGliVMOIw6HDncORQ8Ofw786woE5JykqwofCtHPCqsKLwrjCicOLw59JXHUwMDE3wqbDuMOQw45Td3xSw6PCg8KOw6zCtcKdb1nDhcKRL8KlXHUwMDExwqcvXHUwMDExw57DksO8bMOMQsKXREBFWMKUw7DDhWzDpFByMcOIwodbTl0uRcOVwo1cdTAwMWTClsOYw4bDoHPClEnCoSTCucKpJ8OhXHUwMDFjOFx1MDAxN1x1MDAxZsKSwrJcdTAwMWbDq8K4bMKhX8KFw4fDm8Kuw7jCjzfDscO7Xm47wrjCt8OdwoPCmGdJUMO4XsOtbsOZIWLClsOxd8OBLldZU8OpKcKlwphCw41Nw6R2w7PDvVx1MDAxY8OvwqlQwozDl35cdTAwMWJ6XHUwMDA1UsKJXHUwMDFjUXzDscOPwo3DlcOMwpPCs8KCwpjCjHPCrVxcYmfDu0LChVfCvMKRw7cowq/DrsKxXHUwMDExwrtcdTAwMDMnXHUwMDFkw5hcdTAwMWHDucONw6LCtcOnwpdMe8O/XHUwMDFjwr9pw5NcdTAwMDNUw79Jwq7DjTjDtcOpcsKww6fCqcK6bsOJcFxcdMOaw4PDhXbDnMKGeFhcdTAwMTbCjsKAw4lbw4XDk8KqwoZAw7nCmGjDklxcZsO7w7U7wrfChsOCMEfClWzDhULClTZnXsO4wqxOXHUwMDFmwpxcdTAwMTDDjsKTwoVHwrRMwqTDhVjCmMOvLcObO11cdTAwMWTCrk5cdTAwMTHChz9Bw5rDtlHDkD7CncOBXHUwMDAyXHUwMDA2X8O4XHUwMDFlKHvCvD1KwovDllZjJF7ClVx1MDAwZcOuPUA9fcOQLcKXZylwcsOIwoJrwq9zwqk9TcOuwqXDv8Kpw5/CiTbDs33DvMOew6nClsKYY31cdTAwMThcdTAwMTbDqcOXwoZ0w4JcdTAwMTTDh8Ksw7bCvT19w5/DkXTDo27DvFxcdsKZwq5cdTAwMGXDm8K/w7NcdTAwMWLCvEvCpz1NLDnDr1x1MDAxNCrChk7CisOXw4MwWz1Awr1WwqRQPX1SwojCqsKVdcKDUilcdTAwMWPCjFx1MDAxOVxcdMOew73Cs8OXJMOvPX3ChVEoJsOMZj7CuUDDmsOvwpPCgDdxw4JcdTAwMWJYwpNcdTAwMWXDpnJIP8Klw6nDqMK4McK3w6U9fcKFw75wVS13XHUwMDFhwoxqXHUwMDA1w4vDk19rIcK+I8KwXHUwMDEzTnjDmD9cXGbDkHtcdTAwMThnccKHVsOcS0bDljtfN8KpYcKJw55vwrzDp8KcXHUwMDBmTsOkwpHDkSbDjykvwqPDglx1MDAxN8KMbMKkw4vCnX3Cl0Mzw59cXFxcUlx1MDAwNMKkXHUwMDAzw4pGX8OAwprCimszw5bCnX3DtsKywo/ChsK7cm/CrFhrUlZcdTAwMWTCrn9ewolOb1x1MDAwNMOWO8KBXHUwMDE0wrMywqTDhMO1wphcdTAwMTLDlsO/QMK1w6Q2wqdcdTAwMTLCjsOnw6DDknFsOMOywoJKw7vCgMOJJXBcdTAwMTLDmsOsw4Npw69cdTAwMTliScOkw6zCt8OAwpVsXHUwMDEww5XChEZcdTAwMDdcdTAwMTdEXHUwMDA3V8K3XHUwMDE4wqDDncKIw5DCh1vCkMOQS8OlXFx0PzEoXHUwMDFlw50lw4NOwpbDtMOUMz7Cr8O4I8OUP8Kowo4mXHUwMDFhwrDDjmxcdTAwMWHCjWFcdTAwMTbDocKGbztVQUPDllx1MDAxMHJ0ZsKCw6XCiC3CscOFwqLDgMKqw7nCkMOnT1xcZnDDr20yXHUwMDEwPX1NwpZcdTAwMTbCksKUw443wrV9w77Ch1x1MDAwNcKWcsKawqfDpcKgacKdwqzCoHp/wrvDlsOSwrTDjMOXXHUwMDA0ZnjCgsKRf8KbwpPDkTchXHUwMDExwozCq1x1MDAwMcO6VsOrKcKgI1x1MDAxNylcXGbDqSRcdTAwMDHCt1x1MDAxMcO1wolcXFwiwrnCiFx1MDAxNjbDucK+w4HDoigmQ3/CvcOoVVx1MDAxY8K8XFxiwoNcdTAwMTPDpVx1MDAxOcKxasOnwoRbK1xcXFzCkMKCPsOww53Cr8KAbEZSbMKUwpU1wrRcdTAwMTbDnSbCn1ZFwoEgdzHCoFx1MDAxZcOab8K2wp7DisKfwr8qw53Cn8KPw6/Dt8Ohwo9cdTAwMTVUwqV4XHUwMDBmwpfDnz1NNnTDtsOEwo16wqfCqn5aKz1AdGDDm8KQacKyw4XDv8O1w5fCsXdTW3zDksOpwptcXHbDoCTCi13Di1FLwp7DvsKzXHUwMDFlwr3CtsOPXFx0XHUwMDAyw6wjwqrDqX/Cj8KUccO8wr1ZXHUwMDEyXHUwMDE5w61BNMKew4XDkWpcdTAwMGZedsKcwqlcXGZ8QFx1MDAxZVx1MDAxMcO7wr9ZIT1KYcOMYsOGOFx1MDAxZlx1MDAxNmjCk1x1MDAxM1pgw5fDmFx1MDAxYsOVw4MuXFx0w4fCmz19w5skwpfCrMO8w4bCilxcYsKscGbCvXQrdFtad1nDmMOJw7BcdTAwMWI9fcOBw4p8woXDq1rCl2DDgT1KU8OQWm/CiyrCsTtIw6dZUcOcXFx0WX7DpnTCsMOEwqVvw7jDk21XcFx1MDAxZcK0w7I8c3lcdTAwMTBcdTAwMTfDpC7ChcKsw6bCs8KMw5TDo0vCt1x1MDAwMWZWby1cdTAwMWLCnMO5KcO9XFxcIlx1MDAxMsObw7VjwrDDnXYsw4Rtwrs3XHUwMDEzMUBUw6TDmXQ8w5PCiiE1w6RcdTAwMDVcdTAwMTN+wpvCpVh0w5JcXGJvUzlfVsKkTj1NWcOse03CjcKPwrZcdTAwMDUmV8OOQcK0PnVlw6NcdTAwMWHDgsKjbMO8QcOwwojCiMK6e8OAwrZbw7dBXHUwMDBmMcKifsOWwr/CpMKNw7lZYlxcYsOOQcKkwo12XHUwMDFjUcONXHUwMDEywpwjS8O5XHUwMDA0LVx1MDAxMMK8wqDCk8KXPUDDg8OewpluLMOZe8KYw7tgw7fCj1LCpF45WMK3w6TCqXV2YsOLwq7DjsK9wokkwoNcdTAwMDVuw43DosOWfW83w5TCun7DvcOPSz9iwoTCq1xcXCLDg07CgcONW8OCWkxcdTAwMWRcdTAwMTjDrMORw6vCicOmwrhzwp5JRcKywpBHw6DDl8O9wpbDscOZI8ObwolcdTAwMGYhfUbCkcOnXFxiw6nChHYlwoVcdTAwMTc1w7jDt1FrXHUwMDFkczvDuDxBPU3CvERjw5ZcdTAwMDXDrlx1MDAxOMK+wrPCmlx1MDAxZXRfwq/CqMKUwq3DhEhcdTAwMWTCi8KYXFx2wqNcdTAwMDU8w75KQsO8w7spPUDDncOJUlDDnE3DhFx1MDAwNVxcYsKEJEMnwqNwwqlKwpQww587w5DCusKAw4XCrW0zQsO8N8KHMMKYdMKfwqk6XHUwMDE0UXfCosOQw5HCgHZQdsKrTyhhw6BcdTAwMDJtXHUwMDA1X8KjRmzDiW/DunDCr3LDvsKQccKXw61Kw7TCrlxcXFx2XHUwMDA0wqPCgMO2PUBSXHUwMDE5dD19Vz19XHUwMDFkwqtdcFx1MDAxM8KZwrrDjlx1MDAwMsOVw6LCusOaw6lZXFxmw41cdTAwMTFzXHUwMDE2w6HClsKHwopdTcOSXHUwMDE5JMOdwrPCk8Ogwp5/w698eMOuXHUwMDE3ND7CkVx1MDAwNFxcdsOPwoZkwplcdTAwMTA1w6RgXFxiw7bCoVx1MDAxM2TDuXbCnFx1MDAxM8OFw6PCl1DCtFYzesO+woJcdTAwMWRuIzXCgcKUw6zDhzjCh1/Ci8KeXHUwMDExwrDCo8Oxwpdnwp7DnsOASMOqw6h6w5/ChVrCq11jaMOxwq/CpVx1MDAwMiBnwqTDg3jCoMOvZVx1MDAxNcKQP2s6UcOQYVbCpMOgb8OQXFx2PU3Dvm7CgsO1XHUwMDFjw4s3U1x1MDAxZcOtXFxcXGfCh8OaOMOLwp3CnC99RGQuw5nDo8ONwolnwp5cdTAwMDHDoT7DvMOAVj19OsKYwoHCksKJwoA5dW/CvFx1MDAxN1x1MDAxMMOHXHUwMDEwSiAtwrXDsMOpw5HDp8K8WsObw4w3w4bCnFx1MDAxM8O+NFx1MDAxYXw9fcOgPX1Afj19w68pRlx1MDAxZsOCXHUwMDEzwp1cdTAwMDJ2wofDo2TDp8K3w7jColPClUnChcKyw4xsYy3Dilx1MDAxNMKuXHUwMDFiwoHDhz1Kwrx3SFx1MDAwMlx1MDAxOMOTw4/DiHBawqBcdTAwMTPCkMKUw6VNwo4xNCzDvVc8w412SSjCjEXChcKQXHUwMDA2wpJowqLCt1xcXFzCvUdTw7B6c0Qtw7l5wovCjsKfwoPDusO0w5zDhMK6O8KTIMKEw7M+wpfCm8KTPU3ClGPDtcO/w5ZcdTAwMWR3XHUwMDA2LMKMXHUwMDE0w73Cm8OFT8OJw7Bow4TDmz/CisK4woFcdTAwMDZOw5Rzw6VAwpBEw5HDicO1wpjDr1IwXFxcImbDi1x1MDAxNlbDtcKKw4B9wqtcdTAwMTPCtnvCi1V/XHUwMDFlXHUwMDE3cF9cXFwiw7FMd8OyXHUwMDE0wpJcdTAwMGbCh8OCwpzCtXvDn8O+wqZxeMOHSMKWQMK2wop0McK4SsOfeXU6wqxXw6lMwoDCtUMqRFx1MDAxMsOzwq47worDuzzDhcOfwpzDvsOMXHUwMDE3wp1iKMO3wrJ7w501PUBaw7fDvFx1MDAxMsOVw6ZJw5k9fcK8YVx1MDAxOSPDrcKZaMKmXHUwMDE2w7/CpsK7wrhYXHUwMDE2wqNcdTAwMGbDqsO9w5bCsMOkw6bCnlxcZsO9VVDCvlx1MDAwZmApS8O9M1x1MDAwNMOLNMKSOMOGw4rDj1xcZmHCsFx1MDAxYUk/aMOAWVx1MDAxZcOsw4xcdTAwMDfCr8KvwonDp8OGWcO7wqFRLC4yR8K3Nm5Dw6rCiE7DiMKlwqzDj1x1MDAwMsKnI1x1MDAxOUDCtcOpw4x8w4lcXFwiXmdXwqhvwojCgcKbXHUwMDFiw4nDsVPDjjjDpT42w5dhwrXDr8OawpLDrMKQwoFcdTAwMDJHQFnDqTTCrz1Kw7bDu3BcdTAwMTlsPUo/OV5SfcK7ZFDCmXbCp8OZwo3CsMKSPX3DpsOVw6NcdTAwMDZcdTAwMGbDrk5VdDdZWlx1MDAxOMKMS1bChsKowr9gI8OFWcOCXHUwMDAywrJAwoJfw6xGwr92wr97LsO3RMOdwpNjIMKUw5vCjsKXw5TCgSrCpH/DusKHw7hBwot9wrzDnkfDtMOLI8KTw6Z9woLDjFTCgVbDvcOJw7RgXFx2wr0gamdBVcOBK8KoI1x1MDAxY8O9w6/DvjRXw5dcdTAwMWHCrUXDvnPCgMOHw4V4w4JJwolQw4Vqw77CncO/w6FswqLDl2Q/wrxCwrBGw6FDLMOpwrbDpXLCr1x1MDAxZsOLWMKvL8Kxwp57XHUwMDFkQDdxQcO8PU3CksKxwqLDjG97wqHCnsOcwqF2NcOwwqLCpFxcYsOEXHUwMDAzwqtew53DnDXDtzs5w6vDs8K0w55kwozCk8O4wrMww7nCtSPCvsKlw7nDhcOMw5lXSsO0w5/DinfDm8Ovw7rCn1x1MDAwNsOjwpzDpcKDwrFcdTAwMWJcdTAwMDNzZ8OdMT19LVx1MDAxMn7Dv1XCq8K2PU3Dr0RAX2bCuVx1MDAxYsKracOqwr7DosOiXHUwMDBlPX09QMKuYcOaXHUwMDA3w5LDiHjCgnHCpGrCvcOgw7nCnVTDsTPCrDZcdTAwMTjClD5Dwq92d8K7wrvCsjjCp8OUwpLCt8OhK1x1MDAwMlxcXFxJw6Erwr1Bwq/CqWVkw7xdw5XCj8Onwo55RcOxw5oqLlx1MDAxYsOrXHUwMDE2w7HDt8Kfw59/WzLDvXbCmsO1Zi9CXSXDn8OzLcOVw7owIMOgw4nDj1HDkCzDtV7DscOpXHUwMDE3wpvCr8OewpI/w5/CvcK2RSfCgMOOaVxcYsOpwrbCiyjCtzDClMOWw4DCqWXCqsO+XcOVXHUwMDBmasOYw7rCpcOZXHUwMDEyw7I1fj1Aw7fCo8OQwpdIPX3DrsKzXHUwMDEwP1jCgMKYw7PDqVDDpsOCwrPCt8Oqw7vCjsO+wp1cdTAwMDVSw5BtIT1NVcKjUElIw5jCvjbDksKbw5LCrsKDP1x1MDAxZMO6MFx1MDAwM8OJO11UQsKQw5Y7wpdcdTAwMWRdXHUwMDE0w4TDksKzXHUwMDE3woHDsyHDkMK/wpDDl8OXw6jCv8K6w69MXHUwMDAxNcKowrPCi8Oyw4hZw53Dt1xcXFxlXHUwMDExeFx1MDAwNMKXw6wvw5HDj8OGK8K1I3w3XHUwMDAyw7bDoSjDhFx1MDAwZlx1MDAxOcKFw5HDoFx1MDAxM0zDt8OdwoNrwrvCg0lawqHCncKgXFxcXDY9fVx1MDAwM8Owc1s9fcOXw4vDmMK3wodcdTAwMTnCgMOqXHUwMDAxXHUwMDA0w4NLPUDCnsK8w4XDusOLXFx2w5VwXHUwMDBmXHUwMDE3XFx2w6nCvcKDwo5qPU3CpsKUw5zCv2QyXHUwMDA3wqlFXHUwMDA2XcOtSDXCq8KZwpUybFxcZsK1Plx1MDAwND1Nw4rDqzrDulxcXCI3wrTDksKrwq3Dilx1MDAwN8K5QcO3P8O+RHrClTLDklY4w53CmCRgwr3CokhcdTAwMTHCpcO/woVcdTAwMDHCs3/CgMKqw45cdTAwMTTDr13DnsOZI8Knwpovw7JPwp3ClcONw4zDoDMww53Cq8KMQWzDoVxcZsKxw59cdTAwMTRwXHUwMDAywrVrw57Ct8OnwrLDiTTCo1x1MDAxMWvCiMOjTcOqMMKOLsKmw47ClWTDgMO0w7TDhcKsd8O9Y016PUrCvlx1MDAxYsOnc3RzZSPCmlx1MDAwN8KnPUpAw7VzLsOeYGd7XHUwMDFlXHUwMDA2WUrDi8OSwqdmw55jXHUwMDExwqFcXGbDpMKhXHUwMDEyw7nCmW3DmClcdTAwMTNhKWPDuMOUwqkkw5HDqSfDucKWwpFcdTAwMWHDvMOPXHUwMDFlw7bCtMKbw6hcdTAwMTJmWsKtwo1WLsOUK8KSXHUwMDA0wqvDpMOkMcOfKcOoPUBcdTAwMTDDucOnwqPCn33ClMOqJlguTmMjw6DDncONRMOUw4PCvcKHbD7DjsOgw6XCmMOtw4knajjDgUI8wrM9TXthazhZI8OKbMKNw61MwqLCgMObwqR7XHUwMDExVnLDiyFjYUbDnsOxw5HDq8OOSFx1MDAxN09dwp9Tw77DicKPwq97cFrDpMOcX8OjXFx0wq9/wrfClsKDwoBPJGlcdTAwMDQyw5jDlcOdNFVcXFxcw71swot8wp9hPX3Co2XDlMK6wo7DtVx1MDAxY8O9KVx1MDAxMFx1MDAxMyRRw6EyLMK+wrfCmsKvw7jDrsOrwpvCgcOYw5FZT1x1MDAwZm9Nwo/CgzHDr8OnXHUwMDBmcXhBYcOBXHUwMDFmwp3Dr1x1MDAxZsOrdnxdOXjDozheQ8KYWMO9wp0jwp/Chlx1MDAxYcKTVSRcdTAwMTJcXGLCnCFcdTAwMTPDnMOowqvDjsOtwoHCqMO8woLCrGA7ccKpXFx0SUkrdsKMW8KQwqhGccKsalx1MDAwZsOyXHUwMDAzw7bDjsOZRsKKXHUwMDA0wpBZw5jDmzdbwoNBXHUwMDAzwrBcdTAwMWElXHUwMDBlwo7DkGtxXHUwMDFlw7PDrsOjwpnDsMKew61/XFxiOsKDw4TCjTdtVFx1MDAwNsOWwqlRwoFcXFxcZsK+wpBqbcOhwoPCqT1ARG/DnMKDTivCq1tUw7M2PUrCsDzDk8OvXHUwMDEwSMODwo43XHUwMDFjwrlqNMODVMOgXHUwMDFjcEktXHUwMDE1w4RcdTAwMWMlwpd2S1x1MDAwM8O2XHUwMDA2XHUwMDBmXHUwMDAxXHUwMDFlXHUwMDAzXHUwMDEyw6fCuFxcZsK+bMKFw7dcXFwiKWTDisKZXHUwMDEyW8KnRsOzXHUwMDFiQDrCvMOAwonCjcONw603WsKFw6jDjE/CisO9XHUwMDFlwpHCkyfCssK5wph0LcOcwrd9XHUwMDEwPU3DhFx1MDAxY8O5XHUwMDA0w4pDcD1Aw4nDn1x1MDAwZsODw4vDrsOnYsKVw77Dn0jDvlx1MDAxN8OvLcK9d3d6wqY+w7HCnVx1MDAwN3AoO0TDp8K5w7jCo8K4w67DmsOQKsOAwosywopTXHUwMDEww53CnCxcXHTCusKpVlx1MDAwNsOaw4nCk8KOwqLDtsOCJlx1MDAwZlx1MDAwNlx1MDAxOcOcXFxcXHLDrzDCjcOzw5tcdTAwMWJaM8ORUHs5XHUwMDFjwrlSw7DDq2DCncO+w7PDgsKSwrzCi1x1MDAxM8K9Z8OzVlIywq3Du8KRw5XDtWXDhcOqwpJcdTAwMDRcdTAwMDNcdTAwMTXCpzDDiMKrwr8ywoJcdTAwMWYqbyzCtFx1MDAxOcKIXcOcRzfDnlxcZsOOXHUwMDFhwqYxJj1AwrQrWV/Du8KwRsOLPlRcXGbDjWXDo8OcS8KoQ8OLwrfDv8OUw7DDlsKQw5fCkT1NYGXCgMKFLsKcwr7DnE7DhMKBXHUwMDE3wpXCjsKhXHUwMDE1wpvCrcOPXFxiWsKcYjfDrcKxwr/DgFx1MDAxMjvDjFx1MDAwZk14w4ZAwrJiw7lcdTAwMDdcXHZcdTAwMWM5w7tcdTAwMTPDhVx1MDAwZlx1MDAxNcKlYcO0VcKhPX3CiFx1MDAxY8OBfMK7XHUwMDE1OcOYXHUwMDAyw4dcXHbCuMOMwrvDjsKiwo7CrVx1MDAwNnbDkMO3JkvChsKHI3ErTDVhXHUwMDBlw6VqwonDrcK7wqbCmVx1MDAwMsK/XFx0w7Inw7VcdTAwMDZcXHRcdTAwMTjDmlx1MDAxME/DniR0wp3CgsOGwoo+UTTDlsOOXHUwMDFmXHUwMDFlXHUwMDBmwpDCgns+XHUwMDA0w4/CkFx1MDAwMsKXO2BcdTAwMDTDhSzCl8O6w7dcdTAwMDZaw4RWw6nCvMKZLsOQwqrDrFxcdMOHwrfDhUjDq8Oew6BIfMKowqRXwqdcdTAwMTEuXcKPw6ViwonDszFcdTAwMDNHw5tHQGzCt3rCmMODZVXCgMK0KVdcdTAwMTXCp8KJOcKIw4jDv8OmXHUwMDA2XFx0w7VJYMOuXHUwMDBmw7PCocKRP1x1MDAwZjHChcOSwqRhP1xcXCJhWVx1MDAxMH3DpsORwoTDsFx1MDAwNsO2a1x1MDAxN8KPwrTCjsKNw405XHUwMDAzf3g6w75Kw7bClsOAwqHDtMKmwpnDgMKVwqjDgzHDscO1cGgrwpBcdTAwMTJswr/DgMKAwoPDoS5kwrRcXHQkw6LCulx1MDAwNz19XHUwMDE1XHUwMDEzXHUwMDBmwoMuRkDDrFx1MDAwNcOdXHUwMDBmXHUwMDAxw5dlXHUwMDE5w5rCiXjDhsOtw5BcdTAwMTQ3w5HDhHPDjWtCw5pcdTAwMGVSwrU5w7NcdTAwMWFAw6nDoD7CiFx1MDAxZcK4U1x1MDAxMVx1MDAxYSdSMcKlwo/CncKNZydMwpdIdMKSwoNQw7ImMFlgXHUwMDFjTHxTwpjDrsOBwpFtwolyXFxcXMOfw4DDqFxcXFxFw4ptesKSw5TDpl5hUlxcdMOqMS3DgsKFwoQ2XHUwMDA1w4vCjcOEQiPCv8Olb8O5woJ5wqnCk1jCgVxcZsOBKMOiUMOOw4A5w5rCplx1MDAxOcKxX8Obw6vDoMK/w6xJw5HDgcOEQ1x1MDAxMsOMwofDvz1KXHUwMDEww7nCsyvDu8O3wr9cXHTCkMKPwo7Dn8OUXHUwMDE0wqVcdTAwMWZdwp5cdTAwMWJcdTAwMDbCpCRkw4BXXHUwMDE3woA5NMKGaMKJw77DjXhjw6vCosKIIMOhJ1x1MDAxZMK2wrjClCdcdTAwMWRcXGJcdTAwMWPDk8OLw6HCoVx1MDAxNCbDisKmwp/CjMKaw5oww4zCpnPCq1NcXFwiXHUwMDA0wo9cXFxcw5zCrsOgwoPDszrDj8KMdcOYw6bCrsORwrZcdTAwMGYqYD1Ab2nCl0Fgw57Dr8KswoNIZ8OLd2HCh8K7MMKIXHUwMDE5w5VWw73CgSpcXHbDrsOVXHUwMDAywp3CscKZdVnCuUTCk3XCjMO2woJRwohcdTAwMWVcdTAwMDdcdTAwMWLDjMKLwpF7KsKTwqTDk1x1MDAwMTvDhMKAXHUwMDE0X3TCjz1Nw4/DhMKLw7DCtcKGw5PCtMKmXHUwMDEzJ29kw5vDmTlXw7xYwoVFw67Cj8OEw6U9SsKfwqzDgmnDij4yUy5cXFxcwq9cdTAwMWJPwpXDn8OfwrPCiSvCocOpXHUwMDFhMi/Dp8KHeHXCisONwrvDs8Kewq5Yw5DDuFxcXFzCu8ORw4NFXHUwMDA1d8KWwoxMw4N4XFx0w4zColx1MDAxMsKWw6rDolx1MDAxMGFawprClzMjw7fDvWvDgsKrwr7DnsO8w4ohVT1Aw5fCpkXClsKtw6bCrMOiPUA4w4zDjcOMw7rCq8Ofw5xcXHTDmcO3wrBMXFxmPU3DiUZYKcO/wotnw6VmwoVgXHUwMDE4ccKPVsOZRlgpw7nDrWLCtnpXZcKMccKZw7fDnEVKZjB7XHUwMDExa8K9XHUwMDAxwpHDkyDCv2dcdTAwMGY5wpjDjMOuXHUwMDExXHUwMDFiwqvDkj1AwqQkw7AswrlRXHUwMDAyXFxmw73CuVnDt8OAXHUwMDE5XFxiZsOgQ8O7UUjCocOUcz1KwqfCvMK0PX1cdTAwMWR0fVx1MDAxZMOpwpx/WcKww5PCulx1MDAwMsKkJHfCjllWwqVnJyfDij1AwpjDmcOnw47DuMOow7HCrUHCny3ClCfCq8OYWXjDqmVlwpzCjnzDl8KCXHUwMDAxwqLDkCxVXHUwMDFhXFxcXMO/woXDi0ZcdTAwMGXDj1tTw7bChMKRwpHDkEvDrUtQw4dcdTAwMTTDj8OAw5HDsG9cdTAwMWNzwotQwrDDjU5UNlx1MDAxNMK5eMOCwr16w7ZOw5xeUU1gw5pcXHZHUSYkw4DDmMKJY1xcXFw9SsKZw47CkMOgwqvDh1PChFx1MDAxNWMrwr7DvcKEN0JcdTAwMTHCnsOCwobCgcOVwoxkw7B8w4pcXHTCi8KjXHUwMDBmXHUwMDE1NErDocODI8OScT1NcVx1MDAxMMOSwppZwo3Ct8OWXHUwMDA2wr7Do1xcYlFfXHUwMDAzwrvCu8OXwrPCp8OzLzdTw6ZnZVp9wqZcXFxcw6RcXFwiw6hhZTLCpcO1TsOdXHUwMDE3wrnCtMKzLcK2wpptwqJBXFx0w6dlwoXDtzbDnWNSw5BeXcKwT8KiTEhgwqNaW1x1MDAxNHhFTmnCqsOxwr9pw4bCn1xcdMK7XHUwMDFkw5/CocKRVzZtw6pyXTvCv17DtUl6bsKQwrXDkMKdWcKXw40twqZcdTAwMWbCkMODZMK0w4TCj1x1MDAxMjDDmsOFJlx1MDAxMFt7XHUwMDE5WMOGw7HDsGpNw5Y9TU4uwpvDsMKNWMOxwqE9Sk1cdTAwMDLDmMKTw6XDs8Otw44rLcKvwqYhKcK1cTDDsMOaw4Niw7fDjCbDgsKeXcOeU8KuXHUwMDAxXHUwMDFlPyvClMKtXHUwMDA3W3TChi5cdTAwMTRCXHUwMDAywpZLTFh2XHUwMDFhwpnCmWpYYTFcdTAwMDPCnVx1MDAxY8KFXHUwMDAxXFxmwq3DgcKjwppcdTAwMDRQfsK3TUrDkcKuWD1NbXpcdTAwMDPCjsODwrjCpFx1MDAwM8Kww5RaIGnChjpcdTAwMDVcdTAwMGVcdTAwMTDChVx1MDAxYnBOw4I3VXPChMODOVdNwo5Fwr/CmsOywoFSdiQ8RMKKwpNcXFwiUsO2wqlFWm1Fwp/CtybCqCPCssOkQMOPwrg9SsK+MV7ClCtcdTAwMThHw5EzQMKST3ZJdFxcYmTDm8OIw4w+XHUwMDAyJ8Khw6LCqTtHwpgvwoDDu8O+UMOaw7lgwq3DvMKGw5pZWFx1MDAwNHvCkVxcdF3CrMO6wo7DqcKbwo1Oa8ORwrMpw41cdTAwMGU0w6fCqFx1MDAxZsKAw5jDjFx1MDAwMWHCni1ww6bCpcOVwrnCnHzDtMKuwpMwwr1FcE9wN0XCuT5JQcOuYcKsTMO9XHUwMDBmwpXDnS1cXHY5SsKTwqjDtMKealx1MDAwM1snwpZUaTvDkMO6wpbDlsOKw4AuXHUwMDA3azbCl092M8KHwpowwrUjw53Dm8OqcEg7w5s3wrV4PsKnw4t0YsOtW0QpXFxiM1c5wos5I8Kkw48ww4rCkcKjejVcdTAwMDLDssK9w7Mlw6wkwoPDsVx1MDAxNnTCtcOqRsOfT8KIW8OGw7BcdTAwMWNYw4JcdTAwMDLDgcOEwq0mO8KMwonDl8KDXHUwMDEzeHrDusOcTMKXwppcdTAwMDHCuGRUw73DiMOjIzhyYcOtwrTDgsK6O8OSXHUwMDFiXHUwMDBmwqXDjMKGclRaUcOsSMK3XHUwMDFmwofDoMOZXHUwMDFhVz19w6d/XHUwMDE2fcKLPUDCvTTDll1OwotSw585w4EtUn/CpmzDosO+w5fCusO0RMO3wrDCnsOtI8OFY1TDrMK2XHUwMDBmJVx1MDAxNMOAwonCh0I9SsOVXHUwMDEzw4BZw6tdTnTDvCVcdTAwMWRDY1J/XHUwMDBmXHUwMDFjwpZbwokvbl/Cg8OMwojDgmPClcO7Y15TIUtBw5PDvlx1MDAxNlx1MDAwZk3DqMKBwpZlMcK0w7t9wqDCoSfDpy9EQHVcXGZ1w6AsdVI2w6DCun5DUsKCecK0XFxmw7zCkMOjwp7DuCFDPlx1MDAxY0TCqUnCjTHCrFfCm8Kvw5Faw6NHw4bDp8K0JlRcXHR1w7jDulx1MDAxMkjCk0spIXvCrkbDhMOxacO2wrI0UlxcdMOlcMKZw5l7V8Ovw6TDjcKkwpTDmcK5Kj1KXHUwMDFjw5nDmMKrUVZcdTAwMTXCl1x1MDAxN8K2XHUwMDFhwqzDpSAjwozCoz19XHUwMDAxLsO5w5BJPUAww5fChsOqw4vDn3vCqFx1MDAxMcOMLsORIDjDgGHDtSBjXsOYIcOpwoPDiiRwwpnCqlx1MDAxYcOZXFx2woFHOVx1MDAxY8OEw63CulnCmMO7w67DmEtcdTAwMWXCtsONwrJcdTAwMTUuUChXwrjCkVZdXHUwMDFkw7U+XFx2OVx1MDAwNcOldcK0w4xUw6nDuMKMw7dafVx1MDAwM8ORVsK2MsKxeFx1MDAxOXrDvMKKV8OiPUrDlcKdwojDv8K2dGtpwrTCocKBKsO2OUTClsKvwoPDksKzw7fCjMKpI8ORXFxcIsOiXHUwMDFlIcKWw4JcdTAwMDHDgDrCqV/Dl1x1MDAxZCzDplk3wovDs8KMw7/DjMK4w5t7wqB6O1x1MDAxMMO1w6nCvMOsw7phwq/Cq2ouwoXDkVx1MDAwZmvCklx1MDAxNWItwqfDhmwlwpIrw7nDpnFDM1RcdTAwMDZ2wqx0wop9OWjDk8O3w6Urw7Q1woHDoMKGw57CpcOBw73CnS/Dj8Kmw7fDtVx1MDAwNMO5VTNNbXXDu1x1MDAxN8KTU8KEw6DDmVx1MDAwMVxcYsO+XHUwMDE0M1JqfylcdTAwMDRMwrzCkMOUwp9cXGZcdTAwMTnDs8K/MsKyQsOcwqFcdTAwMTnChsK5w7ggPU1cdTAwMTkuQsOkXHUwMDA1wpnDqFnDnsKZwqoxwr4vw6NcdTAwMWF4XHUwMDEwwrXCtMKCM0ckw41cdTAwMTjDplhcdTAwMTdLw6UzXHUwMDE4wobDiTPCtcOowp3Dl1x1MDAwM8O3woHClz1Kw6/Dn8O+wrjDr8Otw5/DpDXDlcOEw4FLWcOAeHzCsnXCgsKHw7PCm8O0PU3Djlx1MDAwZcKQwrBnw5DCl8KJw6DDnideXHUwMDE2woEtw5XCi2tlw4LChEtUbMKEXHUwMDA0w5TCgsO7QMK8wpLDhCphwqg/d8K7PX3DhEhNRmPDnHrDscKWw689fcKjO8OqScKbXHUwMDExL1x1MDAwNMOnQsKAwrFUwrF3PX3Dv8KUOcOvw6BcdTAwMWbDnGPCvzpNXHUwMDA0wpBGSMOJKE9cXGJBw6NAwqpcdTAwMDfDtsKVw5fDgirDt8KRw6bDqXHCilxcZsKswqXCn8OywprDgj1Nw4zDrz19woTDiEPClVx1MDAwNcKJwpM5w59ae8OuUCzDsn7DlsKcw5hVaULCgMO/JWtcdTAwMDXDm8OPw63CnVx1MDAxNFx1MDAxZsO2SsKJw4wjw4PCmsOXw5BqPUAqPX3DuljDhMK2XFx0XHUwMDEwwqzCqVbDocOjTFxcXCLDi1x1MDAxMTTCg8OKwrJpXHUwMDE5wq/CrVx1MDAxZXFcdTAwMDfDkMKAwqlfXHUwMDBlYTUzMGR3PX3CrMOwQcKOXHUwMDBmXHUwMDFiwq3Cn0DCqcKQdMOUw6PDmi/CrsKtwqvDnsOgJnBRw5AmJcO8wqzDkMK0Yl7DpS5+w4VDXFx2Y8O0YTXDj3dnXFx2w5jDucOHdFx1MDAxMjbDucO4wo89QFjDrUJ8U8O0w6gvw4fCg31sZjXCjkTCrcKzdzzDm2vDq8O/XHUwMDFlV8OVw6LCjF14wrNaOm3CoiU1MT19SMKHXlx1MDAwNVx1MDAxYkzDt3TDj1x1MDAxMsK3w4RcXHQrMcO4f8Ktwo3CrsKhw7DColx1MDAwZsOnXHUwMDFhw7zCl8KQP8KqwrBcdTAwMDXCusOeL3NcXHRLw7sgwpLCrsKqwqNBbsOTXHUwMDAyw6PCtsOhwoLCiVx1MDAwNcOpUEHDusK/wpJcdTAwMDIkwobCsMOBw7PCh2NcXHZbVMOhwrJcdTAwMDPCp8KTYCUyOWLDtVx1MDAxMMKgVcK5KMKqworChMKzw7PCmFx1MDAwM8Oiw6cgwpdcdTAwMDU8XHUwMDE1SFx1MDAwZcKwdyrDo8OPw6fCgMKOTz1Nw6bCrMKMwq1cdTAwMWNVw53DoMKyR1DClMKYworClsK/w7dld8KCwpFywpLCksODw4jCkT5oRT1NS8K6V8OsUiVcdTAwMDNxw4zCplx1MDAxYkjCkjxHwobDhsOAYMOnT1x1MDAxOcKDw4dzZVx1MDAxMVx1MDAwMcK/SiNufVxcdMKjw6HDiFx1MDAwN1xcXFzDlMKTw6nDujA0M2k9fcOVQFx1MDAwNlx1MDAxNcKtJFx1MDAxOUA2bMO0w4BcXHReQFZNw7dcdTAwMGZcdTAwMTDDtcOdw7DCiTrDlVBtwotcdTAwMTVEXFxmZcOHXHUwMDFjwpVHw5BcdTAwMDVXw5PCgcOkXHUwMDBmP1bChlNQQnNHYnRcdTAwMDNVM1vChFPCtcK8a8ObecOowrw9fWrDtFxcZipcdTAwMTJcdTAwMWVjwrvCusOiRMOWXHUwMDE0woZjw6XDi1x1MDAwMkVcdTAwMDXDjsKKwoDCnMKsR8OsXHUwMDFjMMO1MWvCtE1Nw7s/d0rDi8KWXHUwMDA2w6/CsjXCkFRwPX1kP8O7XHUwMDFiw63Cs3jChcKuJsKdw4w1ZFx1MDAwNyzChMK0w4XCrFBow5dowrZSwrTDpFx1MDAwZsKFYMKGw5NcdTAwMWLDmcOFcMKVTHhlwr/DrlLCllrClMOOXFx0w4omw4RBXFxmwqvDvjPChcKGwpPDvTo+w4XDmsKMJ8K2cS9cdTAwMDTDhcKhTsO5w65vVsKXQy/DtiBcdTAwMTBVJyc5XFxiPsO0XFxiXHUwMDA1YcKVw7hcdTAwMDfCi8KKasODPX3DgcOdwobDoMOQJsOGXHUwMDAywro9QMKTSlx1MDAwNEt8PsKXU3tWJVx1MDAxYktCwoVcXFwieMOcccOgRlx1MDAwZcOra8O/wqXCh2J8U8K8w6FcdTAwMWHDvlokXHUwMDFmXHUwMDAzwozDqVx1MDAxNXcvw6Qlw6BcXHRcdTAwMWPChDTChsOVQcKJflx1MDAxOcO2dMKmw7g4w4Zbw7bCmVx1MDAwMSbDocKgXHUwMDExN8KRwq5ERMOww6FxwoJcXGY9fVN7w49KKXRzwr1CVVxcdMOcOzzCsnlad8OhJsK4woHDu8KMwpXDtcKAXHUwMDFkNC/Ckjwhw6PCumzDiizDq8OPMz4+KMOIX0bDmMOHwr7Cg8KrVsKvwpxcdTAwMDJQP0jCvsOpI8O8w6Eow4LDl8KzKSfDqSNcdTAwMTHCicKPwpUsXHUwMDBlZsKzS8O4wrDCssOMXHUwMDEyw6ozw4XCmEnDlsODQ2AmwqZpw7Y/SlrDksK1ecKcwqhlwpVcdTAwMGUlw4bDnMODwpJdw5XDisKWU8K5XHUwMDFkwo89TcKOKFx1MDAwMcOCXHUwMDA2wqM9SmZCOCrCpyPDtkPCoMKIw482w5fCuHtLwo1kw6o8wpN5wqBDwrRkw4pLw7tcXFwiwqzDhsKla8Olw5x3SjTCrVx1MDAxMcOJPyPDgiDDgMKqwrpcXGZnw5pXIz1AZMORwrVve27DmEnCmlPDvcKvdlXDrU/DnVtKUsKQw7LCmkDDi0HCuVx1MDAwNjPDosKIwp1TPX1UwqvCmcOOwocowq9+R8K4K3TDv8Krw5h6XHUwMDE3TkNcdTAwMGXDlMKcwo/Cu1x1MDAwZsKuwq3DiFx1MDAxMcOLbzjCrsOAw6DCtC9AXHUwMDFiWlx1MDAxMMOPwqzCimHDjcOxNMK/wr9Aw63Ds8K/w4jCs33Dg1xcXCLCtn9sS0rDq3vCgcOVO1x1MDAwMlx1MDAwMj7CiMONw5s/w7ZgPU3Ci0ZcdTAwMTF4ccOBw4tiwqB9wo/CnMKYwpzCv8Ozw5fCtsKlPU3CpsKmw5DCpMKYNsK0w4VSwpzDvUXCi1x1MDAxYsK3wrVRIMOmXHUwMDFlXHUwMDBmXHUwMDFjXHUwMDExw6vDnlx1MDAxNMKHXHUwMDFlXFxic8KBw59cXHbCr8KGXHUwMDFiZsKlw55cXGJcdTAwMDTCsFx1MDAxYTtcXGbCrsKLw7bCtsOaw51nw6xvRVxcdsOMwrc6aFpES1x1MDAxZsKwRMKOw5Vmw7ZKwpPDsH55XFxmL8OOwrRcdTAwMTBNw4zCkT8hK8OCwrDCqMKVw759wqt7bcOrL0BAXHUwMDA3O8KfXHUwMDE1IMOMKsOUwqLCtsKNwofDg2PDg1nCtcK0XFx2wqJcdTAwMDfDij19wrDDqD1NPU3Dllx1MDAwM8O4S8OWXFx2XHUwMDFmwpvCtT19O8ODw4bCqzPCncKlanFBw7vDksKbcEo0wppfXFx0wrvCnsOiwoY0wqFON8KXbMOYXFx2Q3zDmsK9wpvCtsKCecOkwr87WcOkwoZcXHR+VcKbWi/CozJNw7fDtjFZw7/Du8KJwrVHwqkzwphIQ8KswrtIblxcXCIlPX1cdTAwMWFcdTAwMDQ7OcKybMKuwpw9QFHCvsONworCjmzDvTBtw6HDlsOrNy/DnzzChMOZXHUwMDE3w7NiwrfDrF/CkDTCn8KJwoQpXHUwMDE0wpJgwrPDiFx1MDAwN8KZXHUwMDFiwrtcdTAwMDE4wrRvw7dTw7JIXHUwMDExflx1MDAxNcOew4pjwpclw4ZcdTAwMTBcdTAwMTnDicO9w5okwqrCpMKBwr09SsKXZsKoXHUwMDEww6pFw7VuXHUwMDE4w7s9TcKKwrJ3L0DCkmLDoUJcdTAwMTnDrsKJwqcqJcOqQsKeRj1Kw5RawopCQMOcwrnCsS3CkMKrSHTCiHTCoHzCh2/CgsKcc8Ocw6vCjy1eRXctPlxcdCtcdTAwMTbDoDnDmsOEw4RcdTAwMWLCq8KswqI0w4A9fTbDmMK5VsK4wrDCmMKtPipgfElcdTAwMDTDrCfCjW3CjcKbwoZcXFxcwqfCm0BPw75CXHUwMDE0wqjDrMOrw6bDoDjDocKrM8Kxwrw4X8Oiw54qwrB1LcKKw6LDjsOawo1Yw59GwrbDm8Kiw4wvW1x1MDAxY1x1MDAwNsKNf1Z8w6/Dkn1cXFxcwp/Du1PClFx1MDAwM1x1MDAxMWVIwrFcdTAwMWTDoWcyWMOoXHUwMDE4f8OZJ8KGw6jDp8KYwpnDqcK4w5XDv8Orw7ljwqRXwpzCt8OZwqfCssOmw7jDoMKJwrXCg8OvXHUwMDAxw7jDlnZiw6rCl0HCu1vCmsOeb8O3w7IoYn8uNcKXJMKZw5DCkMOpw4rDvlx1MDAxMsObaW7CijV4wohdZ8KSVcO4fcOqfsO+w7RWwpzDoTo7UinDm1rCoVLDozDCh8Ksw7XClMOIXHUwMDE1w5zDhlxcdMOOw7V8wqjDlVjCtSPCl8Okw7ZcdTAwMTFxwp/Dg8O3OVx1MDAxM8K8XHUwMDBmwqFcdTAwMTJcXFxcwr9cXHTDk3Vpw6l1w4HCsybCmMKHZCNbwofChCMnw6ReXHUwMDFjMcKec1x1MDAxZMK9w6TDvlx1MDAxYzFNYGjDlMO4aT8gU3DDm8OTw7XCqD1AwrTDtWs9QMK0w7U7PUDCtMO1w4fCoMKww6/CjcOpw4LDiDFhw6zDkV7CjWBrOSQmXHUwMDAzTEhBUcKML8K5QMKdVMKhwrzCk8OGXHUwMDFkfFHDp355wrlJPUrDm17Cl0hpOlHDicKXYsK+wphcXGJcdTAwMDfDqSdcdTAwMTjCqMKpwpFywqjDtsOOwrFnaGDDlMOcwpB8U1x1MDAwNsOnJ1x1MDAxOMKYwqnCkUgjw6XDoMOHXHUwMDFiwqHCt8OULls9TcKdXFx2w7hcdTAwMTfCocKhJGXCjVxcZsKhwpZdXHUwMDFiZXB/w4DDhsOrSVx1MDAwNMKowqHDksKMXHUwMDFhNcKiwpvDhifDrFrDocOsw43Cj8KQSMKBw7/DhCHChHHDocKVw7PCg1xcZlfClFXCt8Khw6HCl8Opw6XCl1x1MDAxZcOYXHUwMDE5XHUwMDE5wphcdTAwMDfCqMKhXHUwMDE1XHUwMDEyR8KRXHUwMDE4XHUwMDFmXHUwMDE4w5BcdTAwMTfCoWHCt1xcYsKbw6RwXHUwMDE5XHUwMDFjXHUwMDE3wqEjXHUwMDEyw4c+P1xcYsKvXHUwMDE3wqFLwrhqw4vDtMK8bVtaXHUwMDFhYnDCuHTDpsKhw7Y0w6jCsTVywpE8w4tcXHbCmlx1MDAwNmbDrsOCWFx1MDAwMjRsXFxmPU17wqZbXHUwMDAyXULDv1x1MDAxY2hvO8KYPX3CmsKAw7kydcOcwpJDYcKMwo/ChMODwoPCj1LDnsOiK3EjW0rCtMKCXHUwMDBlwozCtFxcYlx1MDAwNcKbw7lvOsOnIVxcYlx1MDAxMXfDg8KkOTnDs1PCnW3DsjvDvD1Aw5M0w7rCnThcdTAwMDZcdTAwMDZzwo8lSltvNsObSsOQWld1bjfCtC3DmF7Ci8O5w4U8wrbDtC5PNE7CvmvDrMOFKTpxe8OpcEJ9XFxcIsKOXHUwMDAyQVx1MDAxNUfCtjtLXFxcIifCtMOcw4BnwrTDmMKvZVx1MDAxYXRcdTAwMWFVRUdcdTAwMDdKOcOJYG3DtsOaw5zCnHMgwpLCjiDCv1xcZnRcdTAwMTbCusOGWcKHW8KeQ8Kgw6A/MVx1MDAxNMKPbsKsQMKIUsKEaz19woLDqcKlwrbDtMKEw5hIw7lBwqVcdTAwMDZFw7Mwe8OhJnDDuibDhVx1MDAxYcO2wqjCuFx1MDAxOFx1MDAxNiPCpCQ3wp3Ci8KnwoFow65bwqvCl3zDvm4gw7LDtsK9wp3DscKmV1DCnTJhw4ZSw6nDpUHDlVx1MDAwMSPDqMK+N8OmXHUwMDE4wpBcdTAwMWQ7wrw+P8OJXHUwMDFjwrlcXGJtwpHDt8OePFx1MDAwM8KjJVtaw4XDucKGfk3CsTUqwoHChMOTwqTDuzhbwpjCplxcdMKHw63CscKUw5DCsW8pU8KQVlViwpHCocK0wp89TTzCpMKCZsK0XHUwMDFkw783wqXDi2VcdTAwMTbClEFWZMOxUcKbw7Iqe8Kvw59Vw5NcdTAwMWTDosO3wrfDlsOpVsO/XHUwMDAyw7XCrjPCtS/Di0JcdTAwMWLDlsO/w7NpwrHDsU3Ctlx1MDAxZj1NwpXDq3ZsK8ONwq3CvT1AWlx1MDAxMTVcdTAwMGbDosK+w7rCu3RQw7VcdTAwMThcdTAwMTlcdTAwMTlJWzBcdTAwMDfDtcOlw5NcdTAwMDLDv8OZL8OHXHUwMDE0w6rCo8KPw4bDjybDsMOJwofCvsOWw5g0XHUwMDE0w5HCulx1MDAwMcOsfcOfw6PDkVxcZsOgwp/DmsOtYsK4w7Q+XHUwMDAyXFxcXMKZdFx1MDAwNcOyfEtyw5rDtsO2wrrCp1tJPUrCkDtSZCNLw6bCo1fCuWVdw5jDk1xcXFx+fXAhw4jCjcO+LMKKw47CqsKyw6x7eXfDkcKLwpnDucKKwqXDmSBaXHUwMDA0wo3DoSbDhEs5w50jNcKSbFHCjUbDmsKTXHUwMDFhwpZQecKSKMOEUlx1MDAxOFx1MDAwNDvDl0bDh8Kww5VewpIww5rCqFXCpsKfw47CoHbDrsK3w7hcdTAwMDIjwqNzfV97wpvDgVLCmsKPYcKBw7rClz1Kw4JSXHUwMDAzw51xR8O1SMOwwqVcdTAwMDHDvcKzYMODwoLCicOxwo9bwrnClMOiw6fDj8OUXHUwMDA2csOcwrHCjzLDt3Vjw57DssO6wptRL8KVwrF9woxcXGZUw5XClMKsw43Cg8OLwq/CtMOjXHUwMDEzw4TCrlVXPU1Vw6pcXHZ3Z1x1MDAwNk3CvFx1MDAwM0VcdTAwMDc6w6J3bmxpwqpCXHUwMDE4wppNwpVYwqBRwonDgsKWKkE9QGLCt8Ogwq9cdTAwMWbDh8KLwrnCrlx1MDAxZsOcWMOVw5LCgMKGw4BcdTAwMWTCp8OkVlx1MDAwZjHCnsKDbsK6wp3Dg3FHPUpMwofDgXXDgMKJw5XDtT4oZFgnJkDCh1B6LcOiwp46I8KGwoTCssKmWDduaMOBPsK7w7nDj8Kww7LCoVTDqHXDh01cdTAwMDbCh8KCwp1cdTAwMDM5WT1Nwpx6McKCT8OWwovCtDw9QH9Ww5pzw77DjUVcXHZcdTAwMTjCu3bCt2zDsjI8XHUwMDFkPkFcdTAwMTh7IXh1QsObOMKNw6zDssKOw5VcdTAwMGV6wr7Dl3s4e1x1MDAwZsOaw7XCh8Ozw4tcXFwiWMO0S8KgX8KGLlx1MDAxMzLDr8OgMsOMw7REw7XCjcKGwqlcdTAwMWVYXHUwMDA0T8KuwpfDhjXDoVx1MDAxYcOiXHUwMDE5wrnCmUN/MzRcdTAwMTNiQTjCmMOpZWJQw5TDmVx1MDAwN0DCkFx1MDAwMcK4w5Rue8Onw6QnwpjDnzzDv0pcdTAwMWNKacKOwowkw5h0dn1NwrTCk8K7wqfDlkvDlCE9QMOMw4LCqMOJXHUwMDAyXlnDpcOpZcOaJ1x1MDAxOMOqXHUwMDEywoc+w70lw6BcXHRcdTAwMTdFw6fCtcKMwqTCiyVcdTAwMDfDrFx1MDAxMsKHPsO9w7VcdTAwMDVcdTAwMTnChlx1MDAxOSfCoUHDvcKxXFxmw5xIfcKNw6drwpvDssKPXHUwMDFmw4vCu8OWXHUwMDE4wodPw5U5XHUwMDEzw4PDtcKUw4JcdTAwMWPDm8KKwoVUUEw0wpTDtT19fDPCl23Dj8OPN8Kyb8OkfcOuw5DDj8K7w7pcXGLCkG3CgTPCl8Onf8KnJVVJw4EkXsKJw5UnXHUwMDFmw7fCr2jCuVFqXHUwMDBmYMKiZlnCscOyOMKDwprCsVx1MDAwNcOiwpZcdTAwMTHDhcKWIMOawogyYMKkYFbCuMOaw7Egw4ZOw6DDicK+XHUwMDEwwrJwTzbDt8KNIDxUwqXDocKmw4PDqW9cdTAwMTLCjmMhaTbDjWfCm8K/w77CmcKXw7rChFx1MDAxYT9IXHUwMDExw4B4ZcKDwoPDm3zChcKYwpnDqsOOwqpcdTAwMDbCpD1AUiXDrD19wqjCrsOjZ2ZBXHUwMDE3woZcdTAwMThcdTAwMWJcXGJcdTAwMTVewrnCrFx1MDAwMz1Kw43CpMOtw7NKJ8Kuw5fChGfChcKVYE5XQ2zCvcKWRVx1MDAxMMKYSnJcXGZPwoNcdTAwMWZkccOtW8KjwpLClcOhNcKNw6PDsVx1MDAxYlHDq8Oawp8ywofCkXd4wpE5XHUwMDA1wrTCnSZcdTAwMTDDnmXCulx1MDAwNlx1MDAxYcOtOFx1MDAxNlx1MDAwNTjDpMOZw4rCs8KhNmrCvT1KwpDDusK/acOWQlx1MDAxZcKjwr1cdTAwMGbDvMKxwpbCr8KyOX9cXGbCulx1MDAxYlfCpn3Cn8KocsKXw7vCuFNtwr/DuXnDjMO9dlvCtSfCosOuw7nCn8O4Ulx1MDAxZcO3TcKzwqHClsOxwpRcdTAwMTEkT8KdIMKUw4PDsGzDqVx1MDAwMsKTwpE9TX5cdTAwMTFEw6DCjVx1MDAwNcKWwpnDpcKTeFrCl249TcKRw5rDu8ORIVx1MDAxNcOuw4Nfwr49fcOiw7XCsF7Cn3nDll3Cqlx1MDAxM8OaXHUwMDEwZcO1wpXCs8KsXHUwMDBleMKCw7grwqErw7FcdTAwMWNkw5FpwofDqFx1MDAxZsKlXHUwMDE2wrfDnlx1MDAwMcK8wrBUw5dLw7jCvcK4XHUwMDE4XHUwMDA0YMKBKj1NNz1Kw6HCuiXCp8O3wqnDsm9tTsOMXFxcXMKCX3nDncOzwphlJW/CicKFXHUwMDEww6JcdTAwMTBOw4TCtFTDgsKrUsOzXHUwMDEydEwgXHUwMDEywpBcdTAwMTfCuzfDlWfDqHQyw4w9Sj/CpMKxQEdcXHTDs1x1MDAxZUbDp1/DqcOOw5nCmMOoUTDCicOadcOfR1x1MDAwMmBcdTAwMTHCncKOw4UyXHUwMDE1w6pVMVx1MDAwZVxcYsOcwrPCusKINVx1MDAxNcKtwozCh8O+XHUwMDA0XFx2w54oXFxiw5zDocKDwojCpMOBwo/DiMK1QMKqwqDDiXrDpMOhwoXDu8KmP8K9w7LDg8OqScOGw6Euw4rDmjNiM0NtXHUwMDA1wr3Cj8OBJGlGw7/DkcK9wrTDpsODwq3Cn8ONXHUwMDA3c8ONwpMlwrXDqcKUXHUwMDE5w4LCrMOoMcKhwqHCtjTCq8OQw488w6tjdsKsw6DDusK6J3htw50+RMK/wqI9QMK6wrJcdTAwMDPDmktcdTAwMWZDPD19w63CgCREwofCgcKtXHUwMDE0wrkwf8ODXHUwMDE1RCzCpWrDrsOQXHUwMDA1OsKWQcK8w7RcdTAwMTfCnS5QXHUwMDEywpFfMsOsPl7CssO4IEokLMOCa1x1MDAxZcKXOiDCgVx1MDAxMVxcZsOwMCtcdTAwMGVoLsKSXHUwMDExwrjCrsKiw6J6XHUwMDEyW8OSw5zCjcOZTmx4w6bCuHrCgX3Dk8OqSMOrXHUwMDA3w5zDl3jDqz1NRyPDmMO8wrg4w7fDhEsgw6BXw799w49cdTAwMTbDmcOHJH1TJcKlP15NJsOpXHUwMDA3LF7DrETCrsKeUlx1MDAxYnp4w4zChW/CrlE2wrVWwrjCtFx1MDAxYcOoJcKfMMKQXHUwMDA1w6FcXGLDvlx1MDAxOE7Crlx1MDAxNmtJw6vDjGVcdTAwMDRIw7rCq27DmWxkKsOdNFx1MDAxNMOKVitGXFx2cGDCn0TCtMO7wrPCiDrDo8OYM2t9UFxcXFzCqsOlwrtNXUDDgWzDlsOaKEvCtsKMwr4+PX3CjcKVXHUwMDA3w5TDrMKCM8Ozw4wsXHUwMDA2wos6PUDDnGs/XHUwMDFhL8OKwrbDuVxcZsOTwpghPX1cdTAwMTbDjVx1MDAxYcKBaz19w6fCjGHDlMKUwokkw5tcdTAwMDVKPU1cdTAwMWJxWFdcdTAwMTJcdTAwMDZtwo1GNMODwqXDkFx1MDAxMUJNTMOEdlDDiMOqwp4hTFx1MDAxZsKfwqNcdTAwMDJ5XsOuw5hcXHbDncKWd8Oww5pRTMOSw7zDnVx1MDAxNMOBQ8OSJD9cdTAwMWV/w6nDiFxcYm7Dq8KQw5rCuWJQwpnDsMKsw6xxw6N2w45cdTAwMTXCpW1wwqTDt8OUV8OswrHDoMOxwopaXHUwMDE2PUDCjMOyw7vCpGnDsTZmdEHCiGtcdTAwMDTDksOZwp7DtmHDsMONQcKRYcK+UsKtw4LCj2/DkFJcdTAwMWPCgcOLwppsbsOcXHUwMDE1wrbCsTbCpcKqXFxiJT1KXHUwMDFmYsOMwp8sworCpMOLw7bDkT7CrVx1MDAxZXQ9fcOgd8KVfcOswrHCg8KIw7XDtcOSelx1MDAxNjfDoTNiw4vChsKISiBcXGIsw7Njw70ow5xcdTAwMGYxw5suwqpFw7/DmMK+wrjDrWfDjsO3SUfDm8OKw4pcdTAwMTM6w6Uww4Z7TTHDuMKqw41mN1x1MDAxYsKewqDCjlfCtS/Dh0fCs1x1MDAxZMKIw7jCgirCocKfXHUwMDE1K8O+L1vCuVx1MDAxZDTCpsKGwqfCoHo8w7LCisKrXFxcIlx1MDAwZsOpSizCpcOqKMKqw4fDqMKPw4PCssOLw7nDkU7DqsOhMsO5XHUwMDEww4/DisKBXHUwMDE3w5zDicKfwrTDgFx1MDAwNClBwq7Cv1XDuFRgw5Raw6UmSC8kw5BDMcOSwqrCuDxcdTAwMTTChiUjZcO1w45cdTAwMTTCpy7DrMKYfMOJwpxcdTAwMWXCocKBw6LDkMKRwptcdTAwMTR2w7zCj8OHw7JcdTAwMDM/wpXCj1TDtUnCvzfDqkHCoMKDYMObw7d9b8Oww5t6wrjCuMKCXHUwMDEzXsKawoJ1a8OKbsOXXHUwMDE1w7rDq8K0bDNcXFwiP1fCj8OjXmgwXHUwMDFiwqhOw55cdTAwMTfDosKBTmxcdTAwMDHCj1x1MDAwNCE/b8OiXHUwMDE5dsKbwo3Cv8KQU8OwXHUwMDE4w6HCoMOwXHUwMDE4w6E+w4XCgDXDkcOMacKKPj1NwpPDq1x1MDAxN303wqxmfcOMXHUwMDFlUcKDdlhdwobCqsKKw7g4wpbCvjXDrsOaSWBcdTAwMWTCnmDCulx1MDAxNSF8w4xfwrHCg8KnXHUwMDFiwoVkwoXCnFNDwo49fSjDvG1cdTAwMTDCqVjDqMKow7fCiMOpw7VrXsOsXHUwMDFjwoIzw7VKwpzCucKcwoFGw6AnwrVcXGZEw5bChX00Yisnw6htMsOmNiFiUEYgfMKgwrZcdTAwMGZDRCglPUBaw4U8XHUwMDE0QXPDksOewpg6IF9cXHZkJlthWMKVP8O0w4HDjmbCpsK8w6zDqcOdw4HCiVx1MDAxNsK0w5VWw5XCo8OCXHUwMDA2w7XDtD1KPX1yV8OWwqfChMKZXHUwMDE1XFxcIlrDrGIvw63DvjjCu0d1w6N9JsKFw6VDWyR7wpFgwpbDvShFwqVcdTAwMTPCkmxcXHZcdTAwMTA9QGPCkXzCnkzCr11TMjXChSBcdTAwMTZwMUJ/XFxcIsK4XHUwMDBlb1HCtFvCvD1KUsKLw753wo1xSsOFwq9cdTAwMTYjwpvDgsKlJ3Iuw41nZsKswrrDnsKpPX3DtMKCw6tcdTAwMTfCtT1Kw5skw6ZcXGJww5XCsm9cdTAwMWTDnVx1MDAxNsKcMsOXSVx1MDAxYT1Aw6PCtjhIXHUwMDE2XHUwMDFjXHUwMDFkWmTCgsOTw65sw6VuwqlhcsOKw6hcdTAwMTNcdTAwMTHDulx1MDAxN35/ecO5McOvWFx1MDAxMcOEw4Rrw6TDu8KLwrLCqCNcdTAwMTUwasOawo8+wqjDqcOSTsO2w5Jjb2JcdTAwMTZbwpHDv8KmTjjDnj1AXFxiwqvDuCjDl1XDjlx1MDAwM8O+NMKDY8KNR2TCjsKnJ1rDiFxcdsO7a8OpwprDpyfDosKQw6pTw4ZcdTAwMTUjXHUwMDEzIzfDnEU6Wlx1MDAxYlx1MDAxZcK6woLDhsOQXHUwMDFmwqRywq7CqWTCkcKOXHUwMDAzWVx1MDAxOFfCicOTw4l+XHUwMDA2w5JQw6zDjMOLwpfDmcKlXHUwMDAxwrDDnMOhwoPCklNxwrElw55Gwp1xwo9lXHUwMDEww6pcdTAwMWPClcK2w7zChl5HNip8w7TCh8K0LMK5eF/Ch8KZO007TMKAw6vDksO6XHUwMDFjWsKSSlx1MDAwMcKDwpBLw5RwOsOxwoDDrsKEbFbCkH9cdTAwMTkqYFxcYiXDkl1cXFwiw554csKUScKawqZcXFwiw4hcdTAwMTXCqsK2w4plUcOvO8KUw7c9fcOlQ0bCtj1Nw7fCpcKYwoTDolxcdiDDtcOpwqdcdTAwMTnDqSZcdTAwMDLDqSjDlT19wrEoXHUwMDFlXHUwMDAywqnDg8O/XHUwMDFjw7HCnlx1MDAxNsKYw61cdTAwMWTDsj1Aw6zCjcOpwr9pwqg/w6jDusONXHUwMDFhXHUwMDBmwpt1bsK/XHUwMDE2w645w77Ct8KuO8KcwqdNe3g+w6/CnFxcYsKTccKPPMOPw4JLw5lcdTAwMDXCpMKkw5lCwrtcdTAwMWPDombDmT19wqtcdTAwMDQ9QCjCvsOHPUrDm2dcdTAwMThmfV1Ge8K9I8K6wrssw4V3XHUwMDAzwq7CvX7CqMOEeSNmVsOLwojDqsObw6PCj8O7w4dOw4IzQFxcdDt9UcKDXFxmb0/CqcOSeDl9PsOkw5vDplx1MDAwNcORw4JcdTAwMTfCiFx1MDAxOUnDkcKTwrXDviBGXHUwMDExdjNNw5bCm8KQe1x1MDAxM1x1MDAxY8KAYlx1MDAxZMOULsOIRkJvwoRUd8KxSVx1MDAxMD1NPMO+XHUwMDFkw4Bpw7Raw7LCvsOrYCRcdTAwMDJYwp9Ww7dPYTfCvMKLw7RTXHUwMDBma1xcdDTCo8OuwoTDnz4/w7fChsKWNMKWw61cXFxcPUpcdTAwMTbDg8KRXHUwMDExK8OkwqDCnsObe8KfbyPDlMOmPMOxw5pcdTAwMTNzaT1KWsKgwrxcdTAwMDd8PU3DusKfw6nDtMKzbcKZU1x1MDAxZMOSw61cdTAwMDRGw6haVMK8w6fDs2ZcdTAwMTLDtsOVUcO2S8OvXFx0XHUwMDA1w5PDj8Oaw4DDiktFw7pcdTAwMTBqwrN0V8Kjwpl2I3LCkMKVw7fCtMKcdFXDp1bDilx1MDAwNSN4XcOZwr7Cr1x1MDAwN8OEYsOLwo59wplVfXPDlyHDpcOHwp58PX3DkW7CjHbDm8OcNDTCtVx1MDAxMlx1MDAxZcOQw4TDoMO8J3jCq8KOXHUwMDE0UShyw7lcdTAwMTJcdTAwMTbCkSbDq053XHUwMDAzwrlcdTAwMTXClVdHw5V/wrxcXGZcdTAwMDQ+IMOAXFx0w7fDjMKSwoVcdTAwMWNcdTAwMDRzXFxcXGrCuypAw4bCt1XDjsKNwrLDoGzCuMOnJWdcXHbCgsOJP8K2ccOcw7LCn8KSY0nDssOSfcOPesO7wpLCssKGw5M9TSTDn1x1MDAwZcO4w4AwcsOjfcOWw6zDlMKPw6ZcdTAwMWXCjsKOw4DCrcO2w5tcdTAwMDU5w5NcXGZWw6B2VcO0wpzDkMOGwpDDgMOpwoJfXFxcIj/CiVx1MDAxNMOBw5V/w4ZcdTAwMGV+PU0lw5V9w4p/dFx1MDAxNMOfXHUwMDFlV8K4wrrCssKpVU51wozDrsKzw7pcdTAwMWPDm8K6wqZtw7RbwoPCksKww4zCqSHDl8OOXHUwMDBlc21RXHUwMDFkXHUwMDE2a1xcZsK3w7R1wpgmw44mw5FUwqrDlFlaw51zXHUwMDFjwonDlcOCw5zCocKkTEHCrcKdJcOjw7xnJVx1MDAxNcKjXHUwMDBlwqrDh8Kgw7XDgMKWIEbCrlx1MDAxOTzDkMO0wptQw4nDtnvCnMKXw53Dp8K2YVx1MDAwMsKzXHUwMDA2NsKIeFxcXFw1w7l+XHUwMDE5wqt1Ln1TwoFVXHUwMDE1X8KMwqtcXGI3XFxiNGVMw5XCusO2V8KVXHUwMDAxeT1ALcKyN0HCuE/DjMKrwohWw53DkMKPWMOgw4bDrnTCl1x1MDAwZlNKZ8OdXHUwMDA2csOMJHtcdTAwMThcdTAwMTJePUojw4/CuMOPw4/Dn8K6KsO7wrBTwqpcXFwiw7jDk2bDtCQ2XHUwMDBmwq3DqsO2XHUwMDAxw47DvMK0wrvCucKCwoLCtCDClmPCu0pwNcOTdE1cdTAwMDbCl0/Dmk5TwoPDn1bDgEVywoNsRcKNVcOMwobDisKbb1bDr8OiwoBcdTAwMGU8XFxiSFfDs8KlwqlIw4HCrsKjUUnDgFx1MDAxMFx1MDAwN8Ocwo5cdTAwMDJcdTAwMTJEZVx1MDAxMWfDoMOKwpjDrsOcRcOAb13CtMKPT8Odw5zCtj9cdTAwMTgww5xcdTAwMWVmw4h5w7l9KMKRXHUwMDE2XHUwMDFiwpZcdTAwMDNzwoHChS9gw75WLcK/N8O7w5zCjkLCuGAxUcOgwr7Dtn1jd8OOccKGdMK/wqvDvsO8acKEUFDCiUVcdTAwMTFyMFLCsnTCrFjDhW7CgMKDPX1dJFxcXCIqdsOqQHvClsKtwrDDrcOewrzDm8OFw6TCmcKEw47DuFx1MDAxN0LCsMKmXHUwMDFhwqRcdTAwMTN+w5lGW8OBRD8uwrR2w63DvSxBIz1Nwr4tw7lcdTAwMDXCk8O/XHUwMDE3woLDmzd8c8K2Z8Ozw6RRw6jCmcKmesOYXHUwMDFmw4Jww6fDh8OOXHUwMDE3woTDpVxcYsKKwpU9SnHDkVxcZijCvsORXFxmwrjCg8OyOTnDtF/Dr8OEX8OMwojDjD89SsKCw69cdTAwMDfCm0vDjn9cdTAwMDPCh0lcdTAwMWY9Sl7ChD1KwrlyXHUwMDFmRz19wp/DtcOIwqfCqcOMXHUwMDE4e1PDhcONXHUwMDE0wppTf1Y5wqMjw6XCpcKLcz19w47CvlxcZj7DjsOfw6xxWTZ/aGZcdTAwMDdhwrvDjFx1MDAwNDVPIcOEXHUwMDAyX1x1MDAxN8OWwqdyaFx1MDAxOVnDj3PDtTxcXGJVI3knwoPDqGnDulghwoTCsFMlw5ZxVCzDmcKdXHUwMDE4woDDp0Nwc1x1MDAxNMKMW03CuXJcdTAwMWTCj8O4PsKGwqBFPC0gLVx1MDAwZn/DmFx1MDAwZlx1MDAxZMK8w5LDgMK7LcOFXHUwMDAzwqDCg1x1MDAxNCTCuislf8KKw4TChsOFXFxidsKWa8K/w6bCuC9cdTAwMGbDgG/CkmbCtcOaw509fVx1MDAwMcK2XFx0bcOwN0LCosOlwo7DlyBHVsKKwp8xSsOgw7/Dnj19wrpgwrfChMOKw7h4asOywq11woA4wqvDmzcuXFxmwrVcdTAwMWQwwpZuw4RZRlx1MDAxZcKgw7TCvsOxw40hw71cdTAwMDZTYUFSw4TCusKHwoTDlcOKw5ZpXHUwMDFmXcOFwoTCo0fDi8OxwrJiw61pdcKJwoXCoMOWNjE9TcOPwqXCmkTDsHXCgi/DhMOSwqXCrFnCjCzDqFxcdMOgPMOLw6DDk2zDp1x1MDAxOcOuXHUwMDA2wpZcdTAwMWHCm8K1woJcdTAwMWQuwpfDosKFwoteW8OkPHzDoFx1MDAwZV7DtH9Mw4c0wrvDv8Oiw5bDjk7DmMKldcKtw5ZcdTAwMTXCoT1Nw5xPwoJ9JEfCl8KQXHUwMDE5wprCn1VcdTAwMTHDhUzCusO2w7nCkcOowqVcdTAwMWTCisOKb8OSwrnDglxcXFzDlMOSwqNhw55cdTAwMWJcdTAwMTnDvsK3w5zCnMKCRsObXHUwMDAzYsK0TVx1MDAxMMOqPsKTXHUwMDA2SD1AO1NNwqZcdTAwMWNGZ8ORZsKhdMKawobCs35iNMOjN8KWXHUwMDFmMcKQTcOuw54xw4DCt8KLXHUwMDFlUFx1MDAxMGhcXFwiwp5cdTAwMTnCvcKEOmA9TcOywrXCjzLDmMK2PnZcdTAwMTZcXHQnJsKww5xswovDoMOJVSnDscOCw4XCvkvCiMOkXHUwMDFlw4kmdVx1MDAwZcOZXHUwMDA2w40oIMOmaFnCrMKhw7pgVFx1MDAxZcOMIcOBwrfDnsOlw7/DpD1KXHUwMDAzwrLDs8K7S8OYwowobGk5wq3DtcOFw7pqXFx0XFxcIsK/XHUwMDBlw7pOXFxmXHUwMDA3wrTDo8Kowo3CklFQw6hgXFxcXMKXME8zw59bXHUwMDA0U1x1MDAxNcOIwpjDkMOHwqfDsEc5NMKUdCtBw61sc8KPwoDCmsOuwoJcdTAwMTVkw7pKwqHDjcORU8OtYcOYwrfDoMKiw55Ew5nDicKMw4dcdTAwMTZmw4XDplx1MDAxNlx1MDAxYzt5w4HCt8OdXHUwMDA0XHUwMDA3w4ErcMKswr/DosKjw5dJwp1OXHUwMDA0w7x/wqN1V8OCX2jDiVx1MDAxYl/DrTFxw4Z2w7JYwo1cXFxcw7dcXFwiw5w7ScOwwqtiXHUwMDFkwpzChFx1MDAxY0fCsSvCg2LDoMOLXHUwMDEzwo3Dmm7CnizCoVx1MDAxNsO1M0jDhHbDqsOcOFrCglx1MDAxMMKFwpvCnMO1WsOOw65Zw4bCnUFiXHUwMDE2wp7CnGRcdTAwMTEww67DjnxXwrgrw4/CscO0wo7DnT19woLDnMKyMlxcXFxPw5jCg8Oiw7bCiMKUwq4+JcKqXHUwMDA0LsK9azPCjcOPQzZFw5M0Y8KoKcKSX3RFWTc9SsKawoHDnsOCwrjDh8K2wpnDv8OsZHjCrcOZwoZuLsO8w5rCv8OKclXCl8OJbXvDrsOde25ywqfDnFx1MDAwNUTDisKrw7fChj19QXXCoEzDiVx1MDAxYcOkIcKWw4pUw4VcXFxcw5nDv8Ona8Ocw4cmwofDlHDCn8Oww6/CnUbCqMODw7lpXHUwMDFiXHUwMDA3ViViMHI9SnPDgMKtwrgsw65cdTAwMDbCosKkw5JXw4FSwq3Cg8K1w71KSnlawqXCnsKqa0bCi09cdTAwMTnCtXXCnC1Zw57Dulx1MDAxNVx1MDAxMk1cXGJSw6RAw53CscOHw43Ct0/CkVHDlsOQb8ODw51cdTAwMDHCkXPDq8K+XHUwMDAzwrHCp0p1wqfDi1x1MDAxMTRcdTAwMDXDncODwrrCvFnDjTfDuCBpwoNIXFx2woHCjz1Nw4lcXFwiw7nCocOCwqjDqcKPc1x1MDAwZlAvwo7DnnzCoCrCinRASsOUw4dTXShMbcK0XFx2wpXDiD1Kw5rDmsOWRMKsw4w0MMKRX8O3w7RcdTAwMTk0J1x1MDAwZlx1MDAwNsOiwpvCvlxcXFwvTyRjXHUwMDBmXHUwMDFmXHUwMDA3XHUwMDE5OGViw7DCncK7w4HDg0RcdTAwMWbDunRcdTAwMTlcdTAwMDFcdTAwMWJpf8KDwrFvXHUwMDE0NyU4wqvCvMOjUsKvw6nCvsOFOMK7wp4kw7jCu09KwoDCkHrCi8KLw77DmsOPwonCojDCi1Nrw5A+wqU4w5rDgmbCgiRcdTAwMTPChMKOwohefsKIJFXDh8O/wo3Co2U6OcKRMMO5dVx1MDAwN2bDtcOJXHUwMDExwofCiUTCk2c0wrXDmm5vw6fCiVx1MDAxMDZcdTAwMWUvR3Elwp1cXGZuecKlJH9cdTAwMWRcdTAwMGZSwpHDn8OWaMO1XHUwMDEyXHUwMDE0aDDDrk5bdlx1MDAxMMKNSsKLSMKlwrBbOsOvw5xcdTAwMDbCqjRcdTAwMTfDtSZ7NEvCqMKIIMKGwpRcdTAwMTdZUj/Cu2daLsK2wqhcdTAwMTXCpGbDvVxcZsKLPUo3ccOqKSHCkVx1MDAxNMOJXHUwMDAyXHUwMDE0wodywojCssKRXHUwMDAxPiHCmFx1MDAxNCbDl1xcdsKEKWDCvMKHw453VMKtw4xDc1x1MDAwMcOyw7RPXHUwMDAzwq7DnmJcdTAwMThFI8OkWMK0V1x1MDAxYT7DkEXCjsOQWsKow7RBaMOOwrvCvHF3PUDCicKFw48sUEbDgcKte8K9w4JcdTAwMDc2wqXCr1x1MDAwM8K9wosgwqhcdTAwMTBrJcKeXHUwMDFhOMOPw4jDn3bDgcKTI8KZVlx1MDAxNcK8fMOxw5xRw67DscKHw6pUTC4mXHUwMDFkWMOhXHUwMDA0XHUwMDExwofCvsKjRMOZwo9YXFxiwrLDmMKnbjQhw7HDjjjDiFx1MDAwZUPDpWnCocOqw5rCkGEzecOmwr9FKMOrw6PCmkbCsMOnw7DCgi/Cr8OPc8OFworDhnUtwpdcXFwiw5plwovDt8KFw6XDgENcdTAwMTPChMKnN8Krelx1MDAwM8Kww4zCqVhHw7F+w63Dh2LCoMKkw6vDvFDCg8Kcw6hcXFwiX18jLMOCw7nCocKcXFxcIm3Dm3XChMOAZnVkwrzDsmkkXHUwMDExw6ZWJz19w4NLPU3DpcKqXFx2YT7Cs3hcdTAwMGVqTFx1MDAxOEnCvlx1MDAxZMKHXHUwMDFkU3TDvis2fsK/wodcdTAwMGZcdTAwMDVjw7rCq8KwMEfCvHnDulx1MDAwM8KIw7bDmFx1MDAxY1fCoMOGXHUwMDAzKsOnT0hqwrg6woRoV8Kyw6xLwrY8w7BVPMKQTD19aVx1MDAxMcKyw4RRXHUwMDAyS8OSw41cdTAwMDLCh8KEXHUwMDFjSMOoQ8OMXFx0ccO3ccK1Pj19ScO6XHUwMDAzwrU3w4ctwo1rK8KMw6rDo8KXw5vCrMKNJsOjwpxWXHUwMDE2wojDqyltP8O8XHUwMDE0NFx1MDAxOMOow7vCi8OtLsOGwqzDinLCnsOcTU0mUnXCpG1WcTsnwqLCosKNw5xWw4Z9RFx1MDAxOcKGSsOGwqfCsMOHwrVjbVx1MDAxY1HDrMK2XFxcIsOxwo3CiVJIOcK5wrFRaMOnXFxmY8KOw6HCscORN8KxW8KrTyPDr2lKSj/Cv8OyXFxifnfCocODwpN4wqPDkcOYZcKqw7DCmMKTwrYzXHUwMDA0XHUwMDEwwoXCncOsw7TDg8KrYyhUwphnwqRFXHUwMDEwwrDDplBcdTAwMTheVDI7wo7Dj1x1MDAxYcKUXHUwMDE2w7Y2w7/DklxcXFxtwrtZwp82w7xWw4DDiF3ChMO3wrjClMKBw5FkPUBewqhKMFfCgMKmMMO4wqlcXGLCm39cdTAwMTXClMODwqJefcKwOcKwRltjXHUwMDAzwojCicKmw5ZuwoY3ZcOAwojCtMOMPU3DskhwwphTamvDqcKDwp12wovDvGbDlcOXwrc1wothw5LDlT1Nw7NbQcOWw5/CicKKXHUwMDE2b8OgworCk1VXwr/Dl2DCgcOUXHUwMDFhw5Jzwq/CusKqS3bDo8KRQMOeXHUwMDAywpPCh8Ozw6zCnD1Awr3DucOFw7piwqBjwojChixcdTAwMDLCtsKIwpxcdTAwMDTCi8OTw7o3JsOXw5NZw5vCjlx1MDAxYsOCw51YXHUwMDFkw71cdTAwMTM9fXrCgcKhVyfCiMKHQy50J3/Dnlx1MDAxZcK9OcKtQi7DjsOKKGoywobCp8OnNMKuw7FoLjI/PUDCpV0uw58/w7zDsmhVPUDCqW3CpFxcXCLDiDFcdTAwMTTDgV5Iw6bCvjDCv8K0QsKSdsOFw55Iw4TDjlx1MDAwM1x1MDAxMMOFISZcdTAwMTbClifDuMO1wrDDo8K5wofDmMK+XHUwMDBmw5vCjXpuwovClEvCk8Opwrsnw57CkcOvwqZWwrzCssOnwrR3wrDDsVx1MDAxOCNcdTAwMTbCkWnDlcKTW1xcXCLDsFHDvGLDo20/wrTDsWZdw5HDkcKfXHUwMDBlw7PDq1xcZsKbwqVsL8OTwq8oJMOcXFxiXHUwMDE2WUjDjcOCw6hDYSDCmsO3SFx1MDAxNMKFwpXCqlx1MDAxNcK5I1x1MDAwNyHDjsOGwrkjXHUwMDBmwps/w7ZcdTAwMWNJXHUwMDAxw4/DiSnCn8KHZCPDkcKfwpNcdTAwMGV5XHUwMDE1fMO1wql8wrPDpsONSMOLw4/DnEMjM8KQXHUwMDBlw7HDrcK9w4HDrcKJOXnChzjDiTh5woY4eV1RXFx2UcKbNcKxw4nCon8pM1x1MDAxNsORXHUwMDFjUcOtPX0jfVxcdsObJsKzXHUwMDFhYsO9XFxcIj19wp5Cf8K1w6LCiGxzXHUwMDAzw5jCvVx1MDAwZcKhwrvCv2PCg8OodsKiw4nCly9VfVx1MDAwM8OoXFxcIjctXHUwMDBmZiQkaH11WVx1MDAxNyDCil4nf1x1MDAxOCnDtHlcdTAwMTjCvMObJsOQwqNaw4x/w7NRYkvDucObw7zCvcKBwr8oXFx0dsK6w7DCgMOXXlx1MDAxZcOBw7pyIznCvFx1MDAxNnNjwrkmw4jCkcKJXFx0YcOywoJ3wrvDuGEgXHUwMDEzYmnDkMOXJyTDpClcdTAwMDTCu3c9fcKXMjjChcOPXHUwMDAzw7rDq8K8wozCgMOxwq/DkEpcdTAwMDRcdTAwMDMrw4l4fMOMYcOHXHUwMDBmXHUwMDA0I8OCZkzCmlx1MDAxNGfDgH7DhTnCgsOmPUDDtkhBRCfDuMOZQ1x1MDAxOHDDgsKpw7XCp140w5PCosOXw7PDmTRgQ8KNP27DiMOTw5p/KE3Cj1DCg8OwwqvClMKuw5B9XHUwMDE5fFxcYknDlcO2LT1Nw7LCiTLDtGA1woBpXHUwMDFiwq/CpcKYw6dcdTAwMWY9QMKNw4HDiT1Aw7slUT1Kw7tsw4ZcdTAwMTTCg37CjVx1MDAwN1xcdMKewo/DicOXQ0XDqSvDoGQzw5VbKW0jQMOoRsKsMMKaw49CIMOFXFx2w7FcXGLCiVxcYl5cdTAwMWVcdTAwMTXCqytAKMKqXFx2w5fDmcKzwod8w7DCjCXDmsOww6BLwp/DjVxcZsKLw7HCrjbCkVx1MDAxZX7DomHDtntDw5Jew7bCmcKROcO/aMK1wpvCmlJ4wrLCjsOMJlx1MDAxMybCqsKIYcKxw65+w6AtwrvDg8KccMOLdMK9w4zCp1x1MDAxOcOaw7prLVxcZlTCkcKyw7vCuMO3VHpEcMK0wrDCvHXDuFx1MDAwN8ODPX3DnMKXXHUwMDFjw67Dg8Obw74yNSt6w7hHwr3CkMK/XHUwMDEywpBcdTAwMDV8w7QtI3vCiFxcdMKFXFx2wrxdXHUwMDEyXHUwMDFjX8OtwpLCr1JySsK/dVx1MDAxMsO7w4TCqkbCosKzXFxmU8OBwophw6XDrFhcdTAwMGZdwrZcdTAwMTZww7PDu8OUw7BcdTAwMDMjw6BcdTAwMDZcdTAwMTQ6dMKtw6PCqVxcZsOIKSTDoMKJJGTCjibCkCvCk2dcXHbDhlggw51lUMKuwod8wphmwpRcdTAwMWPCr8OMwofDnijDvUxQJcKDdsOCwpY7K8OnXHUwMDE1JsOoNMOScD19XFxmPX0vwqBcdTAwMGVcdTAwMTDClMOkwoPCtMKObcKUejglwoQ6OFx1MDAwMyPCr8O6wrQxw6DDu20mfcKAXHUwMDEzQ8O1wrw9QGLCtcObPjM0w4XCvFHDh8OdNEBcdTAwMWNRw4nDnVEnw53Dr8Kfw789fcKcw5TDm8K5JDhcdTAwMTM4XHUwMDBlwolDwo5EXHUwMDEzSFxcXCJcdTAwMGY3XHUwMDEzXcOow7VcdTAwMTBpaD1Nwpw9QMKpwqZ4aSDCrlx1MDAxNVx1MDAxNsOxwrDCkcODXHUwMDAxQ8Oww4xFLcO4bDlcdTAwMWLDmTrClzx0w61oNnzDjE5Wd8OYYMOYXsKqw7HDlcOrw4VWe8KawrLCm1xcXFzDvcOTwotyPU09fSpHw7xcdTAwMWI9TcOoXHUwMDFkwrPCv29xw79hLMKDwqN1w5bDqFFGw67CpVx1MDAxNVx1MDAwNsKHZ8KCwqTDtMKNWsOkwrvDjSvDkHTCosK/ZMOzw43DuMOtLMO8w7vCvWbDqSfCp8O5w4lORsKQwobDk8OCwp8jw7nDs1x1MDAxMSfDg8KpT294PUDCjMOXwptcdTAwMDbCgyDCvWzDlMOxwpJ2woxcdTAwMTLDs8ORwoHDrD1Nw6kkIWrCvMKGw4Zsw5kvfEbDojhAJcKEdVx1MDAwMTzClT1Aw4shw4zDpSzDm3XCm8OqwrpOVVLCscKhQlx1MDAxMDJWPX1xw4DDkcOUb1HDjlXCs1x1MDAxMsOsS2fCrSRTYsOow4rDmMO2w6dUQMKPNsK9w7PDumtcXHTCpTFlO1fDjMOZw7ldLMKqw41cdTAwMTIhw4TDjDXChEPDi1NcdTAwMDbDqMOlwrfDnsKQw5/Cq8O3wp3CjVx1MDAxNkpdwoZgwoo3w4HDt8OQbsOJwrnCh1xcXCLCtMKjQT/DuMONw71/YsOpdVx1MDAwZsKIw6hEXHUwMDEzY8KZw57ChUDChcKQw5HCvMKXwq0vTcOfwqxxXFxiwp/Cuy3DgcKLwqjDrWBjw7bCo1jCkVHCsGM7LcKjw6HDoMKzwot4w67DmsKEZztbw7bCs0LDssKtw593NsOiQDDCunFvN1x1MDAwNms0w689fSpcXFwiNsKCaj1Kw709fSzDv0jCqcKwXHUwMDBmw4XDulxcZsOKYVx1MDAxZChdw6Zxb1tmw58hw4nCjcKrJ8OnQcOuwr/CgWZvw6vDuXvCusOeXFxcInnCtzTCmMKuw5HDlMKswoDCrcKswojDjW03wp/Dp2s3fj9cdTAwMTUkwrBHw57CsMKLXHUwMDE0MWzClibDrnJkwrvCh3fCinR3XHUwMDE3XHUwMDFkwphcdTAwMDfChnfCij19XHUwMDA0w54wXHUwMDFhwpHDoi3DsV8uXcK7wpPCp8OFXHUwMDA2w5TDn1x1MDAwNU/Dm8KXOCtRwrM5worCgz/Cj3DCp8OwwpbDil/CuTk7w5TCskBVTELDkcOvwptcdTAwMTY3w5DCgFx1MDAwN8KnY2YjwpMlUMO1wqjCoCnCv8KSPsO5JMK9PUBcdTAwMTbDvcKQasKzXHUwMDA0wo7DpVx1MDAxNEPCg8Oqw5PCj1x1MDAwMcKJJ8KlY0kyXFxcXMOxwrg4w7bDolx1MDAwMyguPU1cXGJrwqpkdkZ9XHUwMDAzSD19esKkwoRcXFwiNkPDq1xcdjFEPU0rwpfDhMKNwrnDrH3Colx1MDAxN8KSXHUwMDBlM8KVUMKYw6fCmSXChcK2KjvCmiF0XFxiVGhvw7M+wprCnlx1MDAwNyXDnHDDlsKxOVx1MDAwNWExw4JcdTAwMTVcdTAwMTbCjTzDgsO7XFxmXHUwMDFiw5ZcXGZMXHUwMDE4PU1kwqDCmDpcdTAwMWJ+XFx0wq1bXHUwMDE1wrfCriMww444VcOvw79cdTAwMWYxUMK6OMKGwo/DoVx1MDAxN8OewqPCoMOFw7VcdTAwMGYyw6xcdTAwMTPDh8KGw5bDvXZcdTAwMTlke8OEw6HDhMOnbC5Aw6kjTlHDsildZsO/w53DvcOIcULDkWxpwonCum7CoFxcdMO2OywxXHUwMDFlw4fCmcO1w6fCnMOXw7jDksKFwoRcdTAwMTZcdTAwMTbCkT/CscKfw5FPfsOew7JmwqYuSDDCksKIwojDjMODw7HDniE4XHUwMDA2wpdeXHUwMDEzdsO0wo1cXHbCs8ORw7dcXFwiXHUwMDBlw7JcdTAwMWbCglxcZsKiwpcwXHUwMDE0wo1dJD1Nw5vCg1x1MDAxMsKcNMO2VMOYfcO4wr/ChMKow5HDiVx1MDAxMcKRWcKbwoPDsX/CskXDpV1oecKeQMO1PU3Do8OXwq9cdTAwMTXDmMKUwpLCksOow5NcdTAwMTVSb8OSw7vDp1tcXFxcwrFKXHUwMDA1K8OLwoLDgErCvGJcXFxcwqZ/ZMKCXFxiTDJ2JWpDw5Noclx1MDAxY8K1w53CoMOCXFx0UVx1MDAxNcKyMcOzalx1MDAxYmPCgVx1MDAxOMOkVsK7XT1Aw6tfw63CmkfCo8K7Ulx1MDAxZlxcZlx1MDAxN8KPw4RfXHUwMDBmXFx0w7xpPsOQw4fCmlx1MDAxMsONPX1iLWZcdTAwMGbCrsKPwqlNw67DtEvDkj19w7PCkFxcdMKqRD9cXHTCjcOvw5nDq8OWXFx0wo/CpWrDmzU0woRcdTAwMDXCokNzwpZkw4V5I8OIw4jCp8Kkw65pw4DDh15YXHUwMDA2fcKlwpchXHUwMDA3QFx1MDAxMsOSwo4qw5kpPX3DvWHDi8OnwqAjf8Opw4FswrI4worDqC3Dj1x1MDAxN8OUwplcXGZxK8KXXHUwMDFlOcKHXHUwMDFhSn/DqcK1w51MU8KZw6pfXHUwMDFlPUApw5ZcdTAwMTlcdTAwMTPDg0vDjMKqwrDCoy/Ct8O0w69lw5E9fcOeJMOYw59cdTAwMTjCmMKeX8K4wqtcdTAwMDfCnFx1MDAxZlx1MDAxNl3Di8O9wqBcdTAwMTBcdTAwMDJdQiskwrfDpE3CrcONXFxcXHZcdTAwMTJcdTAwMDbDg1xcZsOif8OIw6cvY8K1IMORWjtpwqFKXHUwMDAxwo4hY1x1MDAwZsOZXHUwMDE5wpTDmcKsw5nCm0xBXHUwMDFlw7PDvcKuwp3CqsOIL3LDpTxcdTAwMGXDtFRcXHTDi8KmbMOGwrxPwqxuw6V3w6dCQlx1MDAxNHFcdTAwMDbDolx1MDAwMsKzXFxcXFx1MDAwZsK8PUrDgsOLIEpIXHUwMDFleX5SKWExXHUwMDAzwrHDhsK7UjjCosKnw6ZxwpcqZ0pSJsOtdUYxeibCmcOFwpdZw6PDgsO2w4/DisKuI8KcKsK9fWxDw7LDm19cdTAwMWE9fWbCrsOCwpFuwqLDizpcdTAwMWPDtMKoeXbDmjjDuFx1MDAwMzhgw4PCkVx1MDAxNsOZfMO/PFx1MDAwM8KSMU46wqbDiMOhXHUwMDE0w7RpXFx2w4DCucKNXHUwMDE1XWzDiMKtJsO2XHUwMDFhwqPCvERcdTAwMDPCmE1XRMOXwoPCtmcydSAwJkpcdTAwMDTDsVDDh0/Cpk7DvEdgK0VcdTAwMDfDkHBBPGHCkjdcdTAwMWHChsKRwqpcdTAwMDNcdTAwMTkow4TDnMK1w41cdTAwMDPCpFxcYsKYTsO8PX3DmcK0SFx1MDAwN8OMaGJcdTAwMTjCt8OtPlxcXFzCncO7wqM0S1x1MDAxZFo8w5xcdTAwMDFHSsOJcWh8NcK0T3zCrcKqLsOOMXtIXnPClyVSWDMzecKbanZoYynDjlx1MDAxZcO/wq7Ch1xcZsOxUVxcXCImQMOHwrdzw7g4aMKbwrAnwrfChyrDqcORw4LCpsKuw6Jzwq5ywq3CmcOiXHUwMDA2w4xcdTAwMTc7wrhzw7PDoMKKSz1Nw7jCh1x1MDAwMlF5Xlx1MDAxMVx1MDAxZlxcXFzDvMKaZjloXHUwMDFlw7jDpMOZwrlNwo09TcK+UMKNUEZcdTAwMGVawrPDh8K9w5vDkldcXHTCo1x1MDAxY0tzKcObXHUwMDA3XHUwMDAzYztcXGbCvmDDrcKIw6nCh8K2wohcXHTDslx1MDAxYcK5JMKVdX7DicOrw7pZXHUwMDE3w7TCrVTDg8O8RFx1MDAxMlx1MDAxZMKELMO8w7zDjlx1MDAwNcKaw4tJXFx0w6TDm1g9TcKRSsOOJ1xcdnPDjn9lwqfClFxcdMOnQzXCikXCscKiw7/CgsKyXFxmw4cpPU1cdTAwMDXDtVDDg0g5XHUwMDFlYsOMw7lcdTAwMTZcdTAwMTTDpsOLTFx1MDAxMcOew7p/fkfCm8OZw4XCi8Ohw5tQw7xhw5nDj8OJwo3DgMOiwq5sMUDCjMOsKjhPdMKrw5xcdTAwMDI7NVV9PUDCn0Uyw4vCvzs2aT1KVMKRw4fCvFx1MDAwNcKPXHUwMDExwrAkwpxcdTAwMGZcdTAwMTg3ZsK3ZEk9fcOlNsKzdWNcdTAwMWPCnMOtwrfDi1x1MDAwM2NcdTAwMWXCnSpcdTAwMDXCucOrw6LCicKzwrdcXFxcw7hcdTAwMDdSXHUwMDAxwolcdTAwMDLDjyvDtsK7XHUwMDA0RMK+XFxiwq8qXFx2woDDijLClMKvXHUwMDFlw71cdTAwMDPDnsOJwoNHXHUwMDA3wrzDosK7OUJTVXUmXHUwMDE4w6LDrHo5VcOfw4fCkcOzw53CrcKmw5rDmsKnw7RcdTAwMDbDrVx1MDAxOGjClVx1MDAxMsOJYFx1MDAxOUTDjVx1MDAxM8K0wplcdTAwMTI9TcOcSFPDjl1kZFx1MDAxMjtcdTAwMDTDpD19dcOaV1x1MDAwNU/Cl27Cuz19PDDDpVx1MDAxMMO6woQyXHUwMDFiw4TCr8OQXHUwMDE3wr3DtMKLZcO+woplw4TDlMKmV8KuwrbClMONdcOlXHUwMDBmXHUwMDEwN1x1MDAxYcO/w6TCmzZcdTAwMTcjXHUwMDE0LMOZw5DCg8OEUFfDj1x1MDAxY8KDwoPCmFx1MDAxZsKzXHUwMDFjwoHCmFlcdTAwMDXDlsOIw7jCvcKQw4PCrmPDhnslwqROwo7CisKwUMOtLMK3aELCnngwXHUwMDA2KDInwrbDuzzDhcO/wrHDg3poPX1iVmh0wqDCqsK5w7R8wpAyXHUwMDAxwpzDqMKzw7PDqMKAwoXCmcKVwobCmsO0XFx0w7fDsVVcdTAwMDTDjjZyNMK8XcKwwoXChlx1MDAxM8OMSVxcdE3Cv01HPUDDuVjDs8OcPU1fwqzDmFx1MDAxYlpcdTAwMTXCh1xcdFx1MDAxNj9hUlx1MDAwNMKDSC1cdTAwMGbDpHXDtSBTXFx2XHUwMDE4wpdSN8OhN2Mjw5JfwoFcdTAwMTBEXHUwMDAzw7xIwqTDqcOUwpd2XHUwMDE2wqdcdTAwMGXCsMKgXHUwMDE4w4HDnsKHw5tULsOSXHUwMDE0VEUoNsKfw6dcdTAwMTlPW8O0wqdlMMKfPX09TcOic8Ktw7zDsThcdTAwMDPCp0NAwrVkXHUwMDAxw4rDpFx1MDAwZcOJw7tcdTAwMTnDisOZSjBSwqlcXGJcdTAwMWM9TXRswpzCvEp2N3U4d1x1MDAxN1xcYsOyc1xcXCJYXHUwMDFlw4BcdTAwMDJxTjXDs8OrwpJcdTAwMDXCsMKUMsO7XHUwMDFmXHUwMDA3R8OaXHUwMDBlesKCwo5XZ8OCUFx1MDAxMFx1MDAwZlx1MDAxZCoweCjDicK9VcOMWMKOw73Cpl7CvsKOw6lHw5jCgcKcXHUwMDFiRFPCkThzRcKMw5tcdTAwMWHDrsOYwpZSwpVyw4k5cFPCjcKxw6hIa8K/XHUwMDBlKD9cdTAwMDU2wopZWMKow6XChSpHXHUwMDEwwqJnTsKyWlx1MDAxZcOuQsOGwofDusKzP0/DtMKSLkXDs1xcXFzCsTNjOcKUw6rDgcKgw4rDqsKqacOOUXFcdTAwMWM9fcOAIMKUw7zDsMKbUkhcXFxcXHUwMDFjWcK+M1xcXCLDvMKqacKOTsK8wrDDjcKtwppsXHUwMDFkwplcdTAwMGXCnMOnw6gvw7pMw5rDoMOLXHUwMDE5UcKDw4rCq8OHwrLDnTnDun7DicOLw6xcXGLDvsO4OVx1MDAxZMKcZ2LCmEnCjFxcdsOFXHUwMDFjwrTDmkDCjsK1XFx2wqTDmcOrc1xcXFxzcHfCocO5w4l7w4jDoHlcdTAwMDTDq20qflxcYkh7TXPCl1ZkclxcdMKBwp/DlcKOwqtcdTAwMWVbIMOTwrLDv31vw5Q5XHUwMDEzXHUwMDAywq1Lw5F3w7zCv8KML0TDvjHCrcOzworDkihAXj19wrHCnijCqcOSw6VcdTAwMTXCp3jDulXDlWNcdTAwMDNcdTAwMTHCncOswoNuaEtUNcKkw4nCgD1Aw4x5wr9cdTAwMWLCujNjwpQ9fcOceXU4w5FcdTAwMDTDp8OLMntKwpA9QD1Nw6bCgsOIw47Cr8Kaw6Y0IcKqwpNaRjnCq8KKwq/Dl8OGLEvCgsO6XHUwMDFlwobCucOgw4FfwrnDji3DvWbDsFRowrlGw53DvcOiIzHDozzDpEJhQMOxdFx1MDAxMsOlw4PDjcOCRMOOwqtowr3CkFx1MDAxYsO1YMO/wq9cXFxcw6NdwoB4fsKcfsOWScKYXFxmw6LDmMKpXHUwMDEywq7CvcK0PUrDsDrDvlx1MDAwNsOYwpnCicOawpDCtMOTwo5cdTAwMWIqwrLDkzvDgEvChcKfOsOSw48mwpJcdTAwMTbCqyDDglEvwoLDtsOqQ8ORw7s2UXbCgcOBMG9cXGbCjsKPXHUwMDBmZVx1MDAwZcKeP2LCp8ODw5lCwr1Ow5fDlcOLw48mfFx1MDAxNsOCc8OZM8K9w45Pw5Y8NsOywoEzXHUwMDBlwqY0w7Exw6BLw7bDiTHCjm3Dg0NtQ8KXw4xcdTAwMWPClsO7aVFNwr7Dqz1Kw4PDscKjw4vDmzzChjp6M3PCh8KQwokxOmfDty48Z1PDgcODOMOUXHUwMDFjw6M/wo8lQW3CoVU+w7hTwr5cXHZKwrxcdTAwMTjDs8OKw57DrMOcNcK/w4JgbMKVw55cdTAwMTlhLcKDQsOaJMOMwrfCisO+UcKzw589SijDg0zCrcObO8KLwr4/XHUwMDBmw4pnbGU3woNcdTAwMTHDqGNtYFbDqzvCgMKAcsKEworDj0bCiiXCjCvDtsO5aEdcXGI6wp5OYzZVfEwyXHUwMDE4w7rDu0FxJ0PCrcK/RmZRaT7CgG7DssK4UmMlPUBbbFx1MDAwNXhDw5zCiMKHacK+w604w6F+w7ZzXHUwMDFkXHUwMDEww5nDrFfDg8OeJ0wqNSTDnzIvXHUwMDBmw5ZcdTAwMDXCuMOLw4RIaMOxwrTDnFxcYsOwNcKMwrTDsHLDtsKxwo0kUsKqw7tRXHUwMDA3wp4swoPDk8OjwozCgGXDqMKOZ0Y9TSwtw6g5PsKTXHUwMDA3w7jChlx1MDAxYlx1MDAxOcO+wrTDii1lw504w7vCnsKUwrRLw7cybMKnNkXDn8K8esOUwpjCn1jCrGLCsTtcdTAwMTnDgX7DpcOzXHUwMDEwwp/ChFx1MDAxZFx1MDAxNFx1MDAxZMOxw6FcdTAwMDdqWizCtsOOwofDuizDiX49fVtSwqzCq8KjXHUwMDFhXHUwMDBlw4HDlVxcdmB5XHUwMDA0LsOGwrTDsW8pYSlmwpfCm8KWXFx0wozDuV/CpMOcwqdgLEDDq8OTw7PDpMKxOFx1MDAxY8KrSylcXGLCn23Di8KgYWxcdTAwMDUwOMKxY8KAw7rChcOWwqnClSzCk8KXwq7DrVx1MDAxZsKLPsKkfMOAwpzDhnZowq45XHUwMDEzw7DDqHfCvcOUKkFcdTAwMWbCklx1MDAxMcK9wpZwXlxcXCLDn1rDl8K7wpPDhybCvcKIw6B+wpYgwoB1P8OdPU1ZXHUwMDAzwrkzw4DDtMK/wojCqn3DvcOQNsOYclxcdlx1MDAxMcKda3RnS25cXFxcwp1Mw4hcdTAwMWNBwoVdSTVVwpPCs8KDccKYwr97w43CjGNcXGbCnMKHw7l+L8Khwpo5w7jCsV8tcVxcXCLDmmA2XHUwMDA3wpHCrlx1MDAxOMOAwprDt1x1MDAwNMOFe8KKw4xcdTAwMGXDoF/CtcOUwofCucKgXFx0TMKdTzBcXFxcw7bCg8KSw63CgFxcXFwrwqLDjMKnwrXDhjrDrsO4KFx1MDAxZVxcdnTCgcORw7HDpMOuwpE7w79yXFxcIsKRJsOmI1xcXFzDnl/Dl8KZb2NcdTAwMWbCs8K+wr/Co8KEXHUwMDA0MVx1MDAwMz1NwoBcdTAwMTfDqsKzwo7DpsO8w5Vwwr/CrcOkw7zDoFx1MDAwMWbCg1xcXCLCt8OQw7zDh8O0XHUwMDE3wpI4wrVMXFxic8KAw7Z3UlrCv8K/w47DvGw9SkvCrsOqdEdcdTAwMWbCvcK5fF7CgcOywoHDpMOLw7JawrjCvsKsWVpUw7jCi8O1XHUwMDBlw480w7zDh8OyTjtcdTAwMTE2XHUwMDE4JlrCmcO0TTHDsVx1MDAxNsObw6ZcdTAwMDUuc8Kaw4zCgVx1MDAxZMK1QcK5XHUwMDA0PUrDmcKiK8O0XFx2w7bCncKuSkBdOMOjw48swoI3wrHDuMOTXHUwMDE4NilNw5jCgcOjwoEww7x8Q1bDn8O9wozCj8OlXFx2w43DiGNqwovCkcK2wow9TcKLKcOYw4pnXFxcXMOnwr9GN38oX8OFXFxcXDbDj3vDmMKJUMO1RcOrw5NEacOEXHUwMDFme2k/ecKDR2o2wrV0w67DkVlbLcOjay/DhVxcdkJSW3PDnHDDr1x1MDAwNcKQwpZcdTAwMWI3wrhgXHUwMDEzO8O6w6LDkT/CnFx1MDAxN8KLOMKXwrXDk0F4XHUwMDFiXHUwMDA2IcOjfMO3w65cdTAwMDdcdTAwMDRrw6Fdw4ZYXFxcXDY9fVplw4ZcdTAwMTnCrDrCoMOSXFxiw7DCmVxcdMOpwpxcdTAwMTJEXHUwMDE0w65pwq/CocO8X8ORwpvDvXXCiS9iw5B9UMKKPUBYIWzCliVIJnXDo8KSQ8KowqDDp8KKw5k1w4jCh8KjXFxcIkFcdTAwMDLDhcOJK3TCgERcdTAwMTnCusOMRMONXFx2wrXCs8KXw4U2wqDCrlx1MDAxNFx1MDAwMsOVwqbCgMK+w7cyw5VkXHUwMDA2wqbDvWzCpMK4XHUwMDE0wplcdTAwMTfCocKmwqnCnmZcdTAwMTLChMOwXHUwMDE4wqJmXHUwMDA1ZMOlwoTCjcO7LMO8w7k+PUBcXFxcXHUwMDA0w4XCjFxcXCLDoHvDinlcXFxcVHrCinE+w7XCh0Y2w7dhw7IoO1cvXHUwMDEzw6DCq8KRZSxiwoBcdTAwMGXCvsK9w5TDp8OOdcOJXksxw7tcdTAwMWFcdTAwMTHDrDdtw6hcXFwiw649fcKvwpDDoVx1MDAxYcOsXHUwMDAywqs1ZcK1QVx1MDAxY8OgUU5cdTAwMTnDgn/DmlxcdMOMwqpqZsOHR0U+OXNsXHUwMDA2TirDg3DCrTfDi1l8wrBewrRcdTAwMDXCgHrCtz/ChE5sT8KxwoZkPsKbXHUwMDA2w44ywrbCm8OCPUBcdTAwMWXDr8OIw5V0U8OkXFxcXFZ+w4klXHUwMDEww4pvUVx1MDAwNsOXwq05IHVcXGLDlcKVXHUwMDE2w7VcdTAwMWFPw5HDkj/CrsKNIDw9QMO+O280XHUwMDE1w5XCgi5yUybDrMK0ST1AViPCocO5OMOyR8OxWcOvwqpGw71TdMO6w4XDn8KBdid7wrrCjcKJwq8+wpXCtlxcdsOgwr8mwovDvsKNPsKXT0XDlmk6woTCkVx1MDAxZMK5XHUwMDA1w7vDkSY7XHUwMDFjclx1MDAxYSZSw4XDlsO9wrTDrsO/XHUwMDExwot3w6VcdTAwMDVuw5rDmDdaZMKKbk9pc1B4dcOPwoDCvj1Kw5AmPX3Dilx1MDAxMVx1MDAwNCpPXsKPw4RcdTAwMWNFw4J4wpN6YsOrV0ktw5vDjcOvw4Zsw6BWW8OtVEPDk147XHUwMDE4UXzCvExnw709fTdcdTAwMGU+QynDnFxcZsKuwo8xw57CucK4Sy/CjsK+wp1Mf8KKwoJqw5XDuMKjw7nCryfDgjojLcOgd2ZBOFxcZsO6fsOwwp9jwp/Dn8OxLEMnwqnDlsOHNcK2wojCkcKnXHUwMDEwXHUwMDExw6XDtmFcXHTDtmHDgT1NXHUwMDFiwqJmIFxcXCLCnFx1MDAxMDrDqjh4wpZsPHYyc8K5d0dRK2wywqt8LMO3w5TChy/Co0bDgGLDm2/Dv8Ouw4hYO25cdTAwMDXDkjc9TcOzQMKfwoPClEvDjsO6w5jChcODw5LCj8K7w6BPQHXCk8OlRcOSXHUwMDA1cH/CoMKLw6FcdTAwMTNsVcKEw5RgXHUwMDA1w7U8dMOqJcKlw4gpwqXDuCHCtz1NS8OLwpRMw7nCoVhcdTAwMTnCo8O5wqVcXGJcdTAwMTUpJ8KJw4hxwq1cdTAwMTIwXlpcdTAwMTXCr0vDi8K6TsOyOFx1MDAxOcKgw67DgcKPP1xcdsKZclx1MDAwN8OWV3psw4JcdTAwMTLDsyjDlMK/f2rDqMONJHHDgmFTwo/ChVxcZlx1MDAxNldsw7jCvynCtcKhXHUwMDFmXHUwMDE0SibDqG/CmMK0NMO8fVx1MDAxOTswSMKnw5FTwr5cdTAwMWFWXHUwMDExwrEnXFxcIlx1MDAxZsK0wrXDnUp1J8Kjw43DuMKfcMOlXHUwMDE5XsKHwqvDg8KYW2bCp8KMw7TCuGN3w5Nsa8O5XHUwMDFlccOBRlx1MDAxMFx1MDAxN8OgTWrCgMK/VsO0wqBOwp7CpMK4acOiwqJVOz1ARHPCokrDuFx1MDAwZsOBwrx+wrRcdTAwMTHCpid3w6/DtmY3w5xoXFx0wqXCqsOfXHUwMDEywq4swo13wo3CsUrDrsKAw6xdw404w57CpWfDgsOpQ2FrV0HDj1x1MDAxNkHDk39WP8KkK1x1MDAxNMKZwpxcdTAwMDNndTw1eTTDvcK5w7/Dk8OTw4PDkMOPfMOswqc5V1x1MDAxNsKAcHxEw6JgUzfChWU5wqnCscKywqrCoT7Dq8KYWMKxwoHChcKBesOHw73CmMOsf1x1MDAxNsKqwr5Sw5tcdTAwMTbDq8KAwqNcdTAwMDPDoSvDjFXCoMOdwqXDmsKMXHUwMDEzMllcdTAwMDM3dsKFZMORdVx1MDAxZHdiPX18wq7Drlx1MDAxMMOoZXY1QsKswpB/TU1yT37DtzIrw7HCmcO8a309SmJzXHUwMDEyw4bCvSjClMKnwqjCh3rCl8Ofwp1cdTAwMWbCgTfCmVQre1LDvlx1MDAxY8Kgb8OHO1x1MDAwNMOrPyM/w4RRwpHCksOUw6jCscK4wpBuXHUwMDBlw5Irwq/DicOsw4PDnsOHecKNYcKbfMOUXHUwMDEzwrPCuWLDisKgw4fCnzprw6bDt8OnR1vCvVx1MDAxZk0qw7suXHUwMDEyVcOqXHUwMDE2w7jCu1xcZsKAX1vCrFvDnXLCrsK+wo1cdTAwMThdPUDDnyrCgcOuwpRcXFwiwr1wwoLCgFx1MDAxNsO3wpgtPUorw5lSbMKNXHUwMDA3fj1KVMO1w5lAbcK+wojDhsKyTMKEwrXCj2Fvw7TDjMOwQMOuccKfIDjDh8O3wqrDvMOueVDDtsKYwo8hNMOpw7xIesOGwrVcdTAwMDdDwr/DkyTDqTDDv1x1MDAxYsKlan9Gw6RrXHUwMDFjw65cdTAwMDVcdTAwMDNvwqI6XHUwMDE1w7fDol/Dh0fDpMKzS8OuMHjDgjxGwrIlXHUwMDFmXHUwMDE3IGfCm8KeXHUwMDE5wpfDlCDDocK7XHUwMDEzXHUwMDE4wqY9QF9Uwr3DiDhcdTAwMDM9Slx1MDAwM8OkPlx1MDAwZcOrw4REw5zDlVx1MDAxZcKzwpohw5vCnktuwqFrw4tcdTAwMGU3wqbDvj/CjMKDOMO1w77DjyPDl1x1MDAwM8OOw4Itw4YvXHUwMDE0wpnDpWNcXFxcwp/Dn0FJwqElXFxcIsKwQGLDuMOCwqXDrilcdTAwMTLDklTDniTCv8KHVMOHw57Dh8OMwrPCjMKBOFx1MDAwMVXCr1fCtFx1MDAxM15cdTAwMThcdTAwMDPCv8KmMsKZwr7CocKEXHUwMDFiwoVPd1XDjVx1MDAwN8O2TcOfw4fDqMOVcVx1MDAwZlx1MDAxMsKOw6zDucOSb8Kow7DDk8OHfsODw53CtcOvwphxUcO1wo9/f8OPKcKRdsK7N0jDg8KgwrLDlVPDnMKnW1x1MDAxMsOkccO2XHUwMDE1wqFrwpfDtsKQwr1cdTAwMDZ8QcKaIMOlV8K1w6HCrcOmRD1KwplcdTAwMTfDh8OvwoXDl1fCucO/wodiwopcdTAwMWLCmWDDiWTDhHdcXFxcw6Ysw5/ChcK5w7nChk5rJ8O8VMKZasKBw5rClGRcdTAwMTnDhELDhTXClsOKWHxYw5zCocKxw48rwrrCizbCvcOFw4ZoWsOuw55cdTAwMTMjXsOJQDopw5oudMKpwrHDmHnChcOWXHUwMDA3wotWwqfCkcKcLz1Nw5vCgzfCscK6wpfCmMKBw6nCssOXwqJSXHUwMDE4w4XCvlXCpk/CklPCvlx1MDAxZsKsw4fCuVx1MDAxZMKhfMKkw4p2a8OnwrdcXHbCpG/DgsK3wqFcdTAwMTFcdTAwMWMhXHUwMDFkw5bCqnXDtWLCqDHDnj1NXHUwMDE3w7Umw6vCj8KLb1x1MDAwMcOkw7VSKcK1wqFcdTAwMTfCqVx1MDAwNcK3woXDmcKjwrnCkMKAwqNFXFx2XHUwMDE5QFx1MDAxMVx1MDAwNDHDk8Ohw7XDp1xcXFzDi2F7ZMOQwrpcXFwiJMKhwqdcdTAwMWV7QcOHw61cdTAwMDVjwqbCgVx1MDAwZsKdX1UrwoPDh8OIw4F6w75DwrR0wrnCi2I/XHUwMDE0w5zDr8Olw63DumTDlcKhXFx2w4xcdTAwMTA9fVTCqUrCvsKww4c0XHUwMDEwwq9IXHUwMDAyw6PDmMO7NMK8w45cXFxccD19wp0+wpjCtCBKwoInXHUwMDEywqLCqmnCtMOBw5FMw7jDv1x1MDAxNFx1MDAxOMKTw5RCXHUwMDAxXHUwMDFhwo91wqg2wpzCtT19wojCgMO+fnbDsMOWfVx1MDAwNj19JsOkJCvDh8KsbMO9b8OUcEjCkFLDvMKkw4vDucKCTVx1MDAxZlx1MDAxNMODwpnDv8K9wq3DocKYwot8flx1MDAwZcK+w6TDjMOIPn0lwprCv8Okwr13MMOYLlx1MDAxZMOWXHUwMDFkwrBGXHUwMDEyw6zDk8OAXHUwMDFlQcOHwpRcdTAwMTVhXFxcXMOzwpDCvW7CjFx1MDAxZsKCXHUwMDEwPUDClcODO1jCojjCucKqwr7DlMKIwo1cdTAwMWPDkHggXHUwMDBlwpnDn8KRP8KmXHUwMDFiXHUwMDE0w4LCpcK7dcKYPUrDgFxcZjJcXFxcwqVcdTAwMTJHXHUwMDBlPX3Di8O4M1FRwqUmdGvCmFx1MDAxYsOpwpV2wqLCo8OuTlx1MDAwN8OrZMKWPFx1MDAwNU7DkVxcdsKLw59Yw6k0wr1VXHUwMDAyw7pdJMK9wrbCqHJcdTAwMTTDhcOcITtsw7dOL1LDl0Y3w6DDtMOuw61AYy7DqcOEwrXCh8KCVMOfXHUwMDFlacK0IcKkXHUwMDE1KsK8RlxcYsKjMT7Dmz19w4nCk8KTQSF+Zz/DgDXDmcOkXHUwMDA0wrw1w5nDrsOwLlx1MDAxOMO1w5FcXFwiaSlcdTAwMWPCkVx1MDAxM8OEw4vDlsOdwobCj09cdTAwMGYlXHUwMDFkXHUwMDEzwo3CiE9ow6lkXHUwMDEyKMOdw5sqXFxcXMOKWsOFScOgw7xzwqBQM8OswpZTalxcdsOsXHUwMDAxXHUwMDA1UsOPw5nDnTM/YcOkJsO0wo52RzjCtcOgXHUwMDA2wqjCjWt9w4kxw7LDp8OJw6ZcXFwiwpvDmCdcXFwiwqVcdTAwMGZcdTAwMDPDl1x1MDAwZcKowrrClVx1MDAxOVx1MDAxYcOfwqE9Slx1MDAwMUrCoUxcdTAwMTjDp8KhaEDCtcKJw5bCtSDCrlx1MDAxYSpcdTAwMTh+PUpRLSxVwofCqFx1MDAxMcKRw71yXFxiKSFcdTAwMTdcXHTDrsO1XHUwMDFlwqBcdTAwMTPDnlx1MDAxZVrDoMKeMCPDrVxcXFxcdTAwMTjDsEhtXHUwMDA1wojCtcKhw4PDlcKSwoQnb1x1MDAwNFExWFxcdlxcdsKTwrQrw4NOw7Yhw5t4wrTDh2PCtWJcdTAwMWVrW8KwP8OlRsKpw4TDsMKKwq7DtVxcdsO0XHUwMDE3PUozI1x1MDAxOVx1MDAxNcKFZMOVw4fDnsKvwqkuQ8KaYsK+IcKhfMKEXHUwMDE4XHUwMDEzw7vDv1x1MDAxMMOSU8KeQUtIXHUwMDE3PMOcwoYpw6TDqz9mXHUwMDFmKsK2w4Imw6PDny1cdTAwMTlcdTAwMTlCW1x1MDAxMMOiwoFEP1x1MDAxMU9cdTAwMWVkwrfDkljDusKrQktcXHRyMsKLXFx0V2vCm1bDqcKaw6lkXHUwMDFlRcKAw6fCqEXDlGdlcz7CjsKoTcOlw59cdTAwMDHCisOvYMKkdMOAwonDhVx1MDAwN8K/Zj5cdTAwMTc7wpvDl8OWXHUwMDAzQsO6w5DCjmgzwrLCr0rDvsOXw5lcXFxcworDnsKLTsOhwqTDrVLChjTDl8ONwrRcdTAwMDPCulnDumsnK8K3wosxwqpSJsKjwr3CmMKGw4XCicK3wq3DssOeLcKywr7DuMK4wr7Cslx1MDAxMSw0w7pcdTAwMDdJw699bcKuw7zCpDrCqWBnwp93J8KGwplcdTAwMWZQXnTDlMKcUmNcdTAwMDc5XFx0w4PDp8Kkw4s9QDHCiMO4w600wp7DuMOZw6PDhMKGRlx1MDAwMXRjXHUwMDFjScO/XHUwMDExw5Iqw6jDi1VmbsKUXHUwMDA3XFxcIjtaXFxiw4zDgcO1wozDrzE/w5TDlsKwwo7Cp8ODJsKnXHUwMDA3XHUwMDFiXHUwMDA0ND5cXHZJbcKDXHUwMDFjPU3DnsKTwoDDp0vDpVxcXFzDo8KDw7RcdTAwMWJqTcKPw6pHTsKMOy7CgMOsQXbCgVx1MDAxYXHDmcO1w5nCtsKiPsOnwq89TcKiwofCnF/DsznDslEmbVx1MDAwMcOOwopHw6XDlMK2S8Kdw6lcdTAwMWRML8KiwpF/wq7CrXsuV8ORwq3Cj8OqXHUwMDAxYMKpw7E1w7XDiijChcKpLcKlwqTDtVx1MDAxZMO9wpZnPX1kwpl9w6jDksKIwphcdTAwMTLCgnNcdTAwMTVcdTAwMWLDpMKrWD1AXHUwMDEwwr0lwpHCrEnDlMKdw7BcdTAwMWbCj8KVWyfDucOzwpBcXHbCrCxUbjrDvjE/wrdcdTAwMTNeXHUwMDA0wojDrWtcdTAwMDVcdTAwMTgrw6FJIcKOw6UnNk/DoUlNUcKGM1rDulx1MDAxMi/CjVI2w7vDhlx1MDAxOMKcNsOYXHUwMDAyw5dvb8OSRsKaPMOMXHUwMDE2WXnCuD1Nw43Dp8Otwq7CvVPDplx1MDAwM8O4NTPCtnVbXFxcXFvCk1TDtG/Cm8KBK1x1MDAxOcOaw7TCq1bCjGktw61gI8KEw5fCpFhcdTAwMTTCi1rCl8OZIcOlw43Dt1NaWmzDtMOsIMKUU8ORwo3DqsKtU3w3XHUwMDE3wpZcdTAwMTdTwpAhO0fCoCloSzJcXFwiacKuOHjDqMOFeMKYw4XDuT1AXHUwMDE5RcKkQVx1MDAxZFx1MDAwNFx1MDAxZMOxwo1BwrFxw63Dv8O3ZXrDn07DhD19w5ZcdTAwMTcoRHXCmCDCmi09fcORwqzCkcO8XnxtwpXCksKDfXTChytybStcdTAwMGVeP8Kpw5zDl8KSw7/DvX/CgGDCh2HDiDDDuDk0XHUwMDFiwoDCvMKMdsOqw7VcdTAwMTFTLUV4w4FWUsKRw57Ctz9cdTAwMTHDpsOmJmpgKsKKa8KdwoxuwrHClClOw5RcdTAwMTfDmn/ChUPDi00gw5Q9QMKawpXChUs+w4HCs8Kgw6zDhcOjLWXDoH7DhH97w5xhXHUwMDE0Ylx1MDAwNVjCv8KPw6BXwrDCusOTKXDChkNcXFxcXHUwMDFjUsKqwpTDllx1MDAxNsKMYMKQXHUwMDE0J0jDmFJcdTAwMDc2aVPCrcOawrfCnMObJlE/wqJcdTAwMGXDnMOLWHvClcOaXHUwMDE4PU1cXHR8w5jCoVxcZsO1wrBwP8O/w6XCpXLDolx1MDAwMk1lwrDDsFx1MDAxM8K/wqrDuMO8wqDDgTdcXHZxNMK3w4NcdTAwMDY4w5wlwrgyecKaJ8Kqw6PCrlHDkcK1wpbDnGPDvmrDvMO6XFxiXHUwMDA1Qj19XFxcIlx1MDAwNVJEw4vCq8OBcSPCh8Onwr0hXHUwMDA2ZsOrMWTDmklcdTAwMTnDg1x1MDAxMFx1MDAxNUs0XHUwMDFiwoDDh8KUwrLCsMOWSUjDo8ODXHUwMDE0SVdcXHbCsz1NY0dVTcKNwpnCt1x1MDAwN2LDuVPDmcKGOVxcYsKCRsO3wrJVfMKzw6JFTsKWNDtIw6vDqVx1MDAxY8Ocw4s3QsK2w6vClj1Ke8Oww7DDhVx1MDAxMVPDvMKSTMK8wrY/c0fDqkJLTcOmNsOKwpnDu1B7T8O8wr/Du8K/w59cdTAwMTHDr8KTbcKkWCbDjsOOXFxcXMKNwpAzw65Cwr7Dq8K0XHUwMDAyw45cdTAwMDfCtsOBw4vCqMOAwrLCmsO1XHUwMDE5XHUwMDE1wpXDnTTCjm1cXHRcdTAwMTjCgMO/WMKzw4rCj8KkwpTCkkjDiGnCqC1cdTAwMTfDlsOSw73DlFx1MDAwMSElXFxcIi9HXFxiPU3Cq8KIwqlcXGbCoMOXw7HDuUlRw71cdTAwMTJHw5LDgcKswqZhw7jDnsKvXHUwMDFiw4rCslV5XHUwMDAxwodcXFwiwrAqXFxcIlrDlMK+JMK5XHUwMDEwbsKzw69UwobCl1x1MDAxZcKcwrlkXlx1MDAwM8Kuw4LCgEDDpUnDkMKKbcOhe8Odw5VcXGJSIMK5w6vCm8OwZsKrXHUwMDA2PUrDqFx1MDAwNMKcUcOfwrjCq2PCqlx1MDAxYT5TwpDDnsKKwrTCi1/CjH8sw4Uxw5fDrMOnck9RXsK9X8OcwoPCpz9nMUJIT1x1MDAxZHvDgcK+S1xcYmXDm8KUw6Q7woI4SHDDl1xcXCLDlMKaw5ZcdTAwMWFgw7vChcKYwpDDkMOww4xkw51Kd8KSwqzDkFx1MDAxZGDDicOlKjV9wr1cdTAwMWbCjHXDrCXDtz1NXHUwMDE5Y3BcdTAwMTLCrcK7wqdcdTAwMTlRwrPDlcO/SsOPwrBcdTAwMWPDsMOXw4zCvT19PUrCrkt6RsOLw4NKZ1JcdTAwMDPDpDtDalxcXCLDmlx1MDAwMcK8fsK4ZcKvfDvDoFxcZjLDs1xcXCLChMO5PU1uXHUwMDAxXHUwMDE0Vl1iL8OvXHUwMDE0w6fDsMKrw6g/SMK5wq4gcMKwXFxcXFxcdMOTNnFcdTAwMDHCqVDCj8O+XHUwMDE1XHUwMDA3NGoyZGHDmsK+w7gte8K7w6ZcXHRcdTAwMWbCqCPCpypwwpXDocOlwosgbz1KdU/DocOfwp5cdTAwMDXCqHBcdTAwMWPCrsOsa8K2w6Bsw5NNw7LDrsKAXHUwMDE5YmNUw4FvwoRYY8OjXy/DvUQ7wqIzY3BcdTAwMWTDp8Oew4DDgFx1MDAxMcK9IUhlYFx1MDAwZmpwwqfDun9cdTAwMTd+LsOcYFx1MDAxMmxvw5LDmUnDkT5ZwqbDpiHCmsORw7s/XHUwMDBlw7PCg8KGdsOeV8KRw6FKw4XDvnzDocKmbsOIw49DwpRWw7Mkw7jDjjtwwoJySMOfw49cdTAwMTLDgMKRUDzDt3TDpcKmwrAnLcO9b1x1MDAxYcODO8O4w75XSSF3fsOKwqthT8OSwojCmnnDm8KqbnNnfUUkTzZTXHUwMDA0XFx0w4jDvFBuwoNcdTAwMTPDjDsqw5zDhcKfwqtfwrzDssKgwoxcdTAwMTZiwo/DtcKMwp7DnERFKlx1MDAwN8OrwrhcdTAwMTDDh1QuZi9LwrbDnn7Ck8KrXFxmXFx2w7oqXHUwMDEzwpUmWMKZw67Cg8KJXHUwMDFlw5DCumPCjz19wrNhwrYwPsOcK8K0w49cXGZ8XHUwMDFiwprCocKzw7/CgHjClGJaXHUwMDA0w7I9fUJJb8OuYsKxUcK7ITTDoMOARsO+w4Brw7XDisK0wrvCoVHCjkHCm8O1w6E9fU5BXFx2fjR/R2dOw5HDpj1Ad8KEXFxiLn1MwrJXV8KZRnLDnWAqworDvsKsw4xcdTAwMWbCpMKNMMK6KVx1MDAxMcO5LcOtfMOgfSVLJ8KoKcOmZlx1MDAwMlxcXCLCpcONwobCnFx1MDAwMyFYK8KBwrcuw5bCp8KrTcKiwrlcXGLDp8OCXHUwMDA3wpLDq1HDr1x1MDAxYSsjXHUwMDBlwrJcdTAwMTHCnjfDsMKldUDDu3Mww7TChMOpT2TCg8OpbnA1w5VIWlPCv8OETMKjwqoxwpBcdTAwMDJcXHTDiMOpwojCpFxcXCLCrsK9J1x1MDAxNiNRbj1NTcOfwqZlw5/CqMOZKsKLejV4NcOCJ8OaXFxiOMKeXHUwMDAzwrrDvX7Dg1x1MDAxNsOWXjVawrFiworCgnXDlMKAIMKQM8O2w4HDqD9Jwo7Cp0bDoMKqMsKLecKnw6fClCM1acKNwp/CsV1Mwr1QwpRcdTAwMWbDp8Odd1PCgcKow6dcdTAwMDPClGnDqsO2wp3DqcK+bVx1MDAxOFx1MDAxY8OsZlxcXFxmwo89TcKbwoVcdTAwMDXDtMKZwopcdTAwMTI5UTrDsMOtPU3CucO0N8O5YF0sUGUlw6lkXHUwMDFmJVx1MDAwMcOZJsOBNk1zwrJcdTAwMDbDh8K9J3XCrsObw6XDiTInN3fCrMOHXFx2Ulx1MDAxMXvChmzDrVx1MDAxNcKgdsKEwqFcdTAwMTdsN3ttw4HDrUE1w7Fuw7dZwrjCmSrDvMKuaVtcXHTCtsKpw6BcdTAwMTJmdlxcdMOJXFxcIsKWW1x1MDAxY1rCrC/DmMKDYWM9fVx1MDAwND5LwoYswrPCp1lVwrlGX8OXwpYpwpJ9wohAwog8w7tcdTAwMDTDjMO4RsOzwojCkDHDisOiwpJ+W8KHSMO3w7rClVx1MDAxMsO1w6M9SnHDpcKkXsO7w5BwXHUwMDE5XHUwMDE5wofDk8KqIy7CpsOxVnTCkjPCjVsrw4jCu8O6wrrCr8OLwrA9SsKVZmNeOFx1MDAxZmhcdTAwMDHCkjZFXivCvlx1MDAxZTrDrlxcXFzClDsnf8OVwobDulx1MDAxZcKzQcKPXHUwMDFlW8KNw7gzw7BPdyYrw4VyVixcdTAwMTTDvW1hRWJLIMOpYMOaw5N7w4LCrEBtw5dNXHUwMDE2w4g9fVjDvljCmsOIw4ooVsOlXHUwMDEwwovCiiFzwqHCizjCjcOkwo1cdTAwMWHDn8Osw5pLXHUwMDAywrbCrjvDkFx1MDAwMn/DqMOBw6PDhFx1MDAxMS4hwo4qw53DkMOmPU3CpcKJw4TClMK4w4fCkkVtPU08XHUwMDBlYcKNwovDi8OrwoHDkVHDjnLCr8Ktw5fCisKZworDqVxcdlx1MDAxND19JEFvw6DDnVx1MDAxMcKGwr5cdTAwMTZmO3JYw7HDm8Oww5s4RlLCpFx1MDAxYcOhwozCvTxcdTAwMWTDoDrChMO0OcK+IcONw509SjlcdTAwMDEuwqTDhXlcXGJXKnZvw4JdXFx0w4h/wpDCkVx1MDAxYsO7PUpcdTAwMDLCmMKXwopqwrXDpMOjZiHDpErDrcO/w6XCuMOrw5pww5dJw6lxwpLCrMKcU8K3w588XHUwMDE5MFx1MDAxYlLDuFliwrLCilx1MDAxNynCjVvDti5mMDLCvWJcdTAwMTbCq1x1MDAxNlx1MDAwNCnDqj1AccKIK8OiwqxeSMO/XHUwMDAzwrDCgsO+woVcdTAwMTPDtsKQwpE3ZWhPfsOdw51cXFxcXiTCklx1MDAxOE5GwovDisOXPUoow6A7J1xcYlx1MDAwNlxcXFwhwpBjT8OtXk7DlcOHwrhgXHUwMDFjXHUwMDE3XHUwMDE2w5/DuH0hXHUwMDBmOFx1MDAwNGlcXHTCqi3DtHHCm1xcXFzDg8KFS8KtwrdJwp/DkMOvw7BcdTAwMGYnwqnDpcKmwpxcXHZnwpxcdTAwMTJcdTAwMTFpwpvCqMKXwqZZUcK2w6VRZlxcXCJcdTAwMWPDo1pcXFxcw7Z9w6pjwrY5I8OwJ8Otw7nCp1x1MDAxN8Okwr9cdTAwMGZiwohcXFwiw7bCj25IJVx1MDAxYcKJwrnDiMKjLcOBSWdjwqbDm8ORXHUwMDExXHUwMDFlYMKpayfDpsK4w71cdTAwMWRkw5bDiMKJSMKiwqZtwqQmwo7DmcOhKU1cXHRTOMOuwobDmyZcdTAwMWTDr8Kww4nDvcO7V1x1MDAxOcO7aFx1MDAxY8O9wrzDnMK2PsO+w43CncK4PU3CqWVTOcKmTsKGdWssdz19csKXK1x1MDAwMWXCh0bCoFp2XHUwMDE4XHUwMDBmXHUwMDBlw7sqIVx1MDAxNEdYXFxcXMKxw5XDt8Kac8OSw4DCsH7CusK2wrbCn1x1MDAxMEoxTsKjNWldw6ZcXHYuXHUwMDA2woxcdTAwMTlRw7TDt8K4wr5cdTAwMDPDtStIesKGako/XHUwMDEzbMOIwo8pVMKjwoPDoMO1wrdwWcKUOcOMRDMtwpNcdTAwMTTDkDPCo8KGw55cdTAwMGXDjMKsw5RvdVx1MDAxYcOiw65QwoDDtcKcJVs1wrXCvnpeNWnDtVx1MDAxZVxcdMOcwrcyXHUwMDE5XFxcXDbDn1x1MDAxZcO6w43CvMOVXHUwMDEyw6rCtFx1MDAwNcOBw4zCsCrDs8Kjwr7DqVxcXFwqXlxcdG5LwrtSwo83a8K8McKjc8Kdw5/DnG/DhsK6bsO7wrxhMG09SkrDmy3Dpi51w5bCo8OHa29cdTAwMGXChjpcXFxcw4PDosO0WlxcXFwgXFxiwrlcdTAwMWFvwrvCgH/DjsOHw4tfw4cjd8O2w4pcXGZJXHUwMDAxw6XCvCFOw6N1w4pvwqTCjMOawpBlMsKGwrRHw69cdTAwMDdcXGItXHUwMDA1wovCkMObccOjXHUwMDE3Llx1MDAwNTxscH/DisOQwoxALznDsSFcdTAwMWU1w77Cn1x1MDAwNsKswod9RMKZXFxmbFx1MDAxNjhuwocxwpLDnEfCgn4swonCq8OHw7DCq3TCinPCi1ZcXGLDi8OZQMONaz1Nw5Irw7tcdTAwMGXCtlx1MDAwNWLCvFx1MDAwN8OTXHUwMDA3RcKVw6jDkHpxSMKfc8KbVsKyMlUhw7l0woxzeVLDp8Kaaz/DqMOPakvDqC3ChcO9S1x1MDAwZsO2w5Eywq7CvzROw6hswrfCgX9Fw4tCw77CvMOGw58+wqnDvVTCqcKAwqdSw6zDhsK6w6wzTFx1MDAxNMOVZ8KbWsK5woJxTMKZw7PDllxcXFxnbsOKwoZswqdrXHUwMDAzOELDijrCtELDsWlcXHbDk8KcwotUwoYxw4PCt1x1MDAxMsOQRi/Dk8Knw6PDuD5cdTAwMTUzXHUwMDE3w7BRY8O9wro3wpPDljbDt8KNQMKWXHUwMDFiRsKSQ8K+w7t6wpvDrMOCw400c8K8RVB+wp5cdTAwMWJsXHUwMDEzwq3Cs1vCpXnDmMOnwrXDti7Dgz1KSVPDqWTDlGpcdTAwMWRMXHUwMDE4w4vCq0XDhsK8fVfClMK9ISDDpcK4w7TDr8Oow4/Dr0jClX9cdTAwMTN/XHUwMDEwwppmwoxcdTAwMWLCmsKSQz9CWsKHwphuw6DCjlx1MDAxNMOEUl7DrMKXMHvDhVxcXFw9TcK+VDHCjsKXwpvDnsOMw5VcdTAwMThcdTAwMGbCm8OZPUBtNsO8w7gvwrlcdTAwMTRcdTAwMTDDlMOYdcOjRlx1MDAxNG1Rw7dcXFxcZsOmwptUMlJpwrHDu8O/wphoOMK5bcKENmo2wp5cXGLCgcOLw41cXHRKwpE+wqNMe8OWJMKUW8OFw5bDgMOdIzBFXcKBa8OEwoZcdTAwMWXCl0RcdTAwMWHDpsK2XFx2w6XDjlxcdj1NXHUwMDA0wprDty9tMsO1woBxXHUwMDE4TirDp2Qyw7NcdTAwMTjCpz1Awq/ClcOAw7tBw5Z4w7FcXHRkw5M/XHUwMDE1wqBQS1x1MDAxOSrDr8OXXHUwMDEwTSFlw7lzw5fDjGlVwrPDlVx1MDAwZW9cdTAwMTBPw7fDhcOywrbDi3Vaw4TCncK3aHXDpinCqlhrMsOJw6fClSpvwoxcdTAwMWHDr8KIccKMwo1cdTAwMDIowq/CmFUtw4dqY8Otwq7CgitcXGbCgEzCjcOVwqE1wrkwaD5cdTAwMDXCu1x1MDAwMcKkw7nDkHZsXHUwMDA2wrXDr8KaI8ONwrlcdTAwMTDDt8K/wq4qb8OtwoHDgMKRwpvCscO+PUp/wqPCssOkw6fDuTk9TcOQWihqWsOfwqXDl8OibcK6w5ZcdTAwMWY7w5l7XHUwMDFmwoVQM1x1MDAxNsKBblfDgknCr8OAJ3dFesK6aT/CmXzCqMONaMOFXFx2XHUwMDE2w4MkNlx1MDAxOcKRwqvCo1x1MDAwZsKHw7bCjsOKXHUwMDE0w4vCrFx1MDAxMcOJc8Oqw4VGXHUwMDFkecOcwq9cdTAwMTlLSMOnwoVcdTAwMWI4XFxiK1xcXFzDgsOeT0fDu8OVcMOUwoE3w5nCisK1R8OTwojDr1x1MDAwM3DDuMO8w5Viwr1ocT1KMcKsb2tcXGJcdTAwMGbDrsKrw7c7woPDkcODw4JPw4xow4lswrJJw6bDmcKYwqsuRV9TwrfDiMOywo8swqQ3wo7Dn8KMXHUwMDA3c3PChsO8XHUwMDFjS8KnwrAzU2tuwo7DtcK2w73Cn1VVw4xvwoNgwrhcdTAwMDXCtMOMciZVw4ZbPzjDtMOXXHUwMDFlVDk1QFx1MDAxZFx1MDAxMz/DmVx1MDAwNMO9MMKxfVbCtcOrwobDgFc0w65vw5bCt8KywrPCm1tLwrB2w7NSwq3DucOXw57DgMKEwoVUwrnDkVx1MDAwZTTCskXCpsOeXHUwMDA2w6XCl0pyV8KRw4nCjsOLQ1PDpnLDuHnCn2VQwoVWaFx1MDAwZcKEcWbDmcKtdjBcXFwiXHUwMDEyaj19WsOVXHUwMDFlXHUwMDE1wp7DosOYw51cdTAwMTgvwp9EXHUwMDExLMKoRMOmw5lnccOSOsK2w5xwXHUwMDBmK8Kaw4Ygw554e3rCjUrDsjvDnmvDt1MqSU5mw4BAw6XDp8OuUcKhwqLCs1x1MDAwNsKzUFxcXCJcdTAwMWVTU8KVMcKhwpTDp1xcYsKZw59swqnCqsOYU8Kvw5haXHUwMDE0YlxcdMKNwp8swr1cdTAwMTnCvjTDr8KJwq86acK2wqTDjC/CnsKUXFxmdsOiKmLCn8KQw5JcdTAwMDPCk8KfZFx1MDAxNzgpX1x1MDAxZsORw73ClmHDp37Crlx1MDAxMHHChMKaY1JPw4ZcdTAwMWPCgCrDj1x1MDAxMMOvWsKcwq1sPUpcXFwiWsOmwrvChMKxLsK+csKewrbCnzLDhMKwXHUwMDFmw5ZnPUAvwpPChCjDtMKgwpXDjzbDh8KXN8OkUMK4wqDDgD1NOEvDn3bDlzQ0XHUwMDFmw6RcXHTDtcKkUVx1MDAwNcKrMcOew7vDnMOebVXCocObPUoyYkJKwqLDg1x1MDAxMMKHOsO3WjAqcUPDmzV+YMKXwpvDn8OJw7HDq1x1MDAxZjE/wrbDgycuXHUwMDE5OcOnwozDlsOZWMKzw5HDsyTDn1x1MDAwNEJcXFxcwqfDm8O+wqNcXFxcKlx1MDAwNMKIw5l+fsKuwojCq8KLXHUwMDExMcOmw6zDmsK6XHUwMDA0XHUwMDExXHUwMDE4w5t/TMO+wpbDrcOnwqHDscOWfsKowpRrw7rDncKAwqMnwohYXHUwMDE2wr1PwoXDni12w4HCizFvPU16w6PDnMKaMsK3XHUwMDBlwq3DtsOnwpHCvcKwXHUwMDE2PsKBKMOXw7jDhWhcdTAwMDFcdTAwMDU9SsKpRsKLcSnCjlxcYiVuw5XDi1fChFx1MDAwM2Uuw5PDnsKgwr/CsMOTw4DCjVJEw6wgXFxmw4UtXHUwMDA2w6RcdTAwMDQ9QMOPV0bDosOaw4TDkX9SwpnDvlx1MDAxN8KIXFx0wox3fFx1MDAxOMKrw6DDtj1AwrA7XFxmw7I1w7cucFBFwrhcdTAwMTlgw4PCjGrDk8OcVMKEfWphw77Ctlx1MDAxOXjCsMKlwpQqXHUwMDFlwpPChcKUw4rCjFx1MDAwNMKVe8KFa2TDl8OwwpPDhzPDn1HCnj1Kw6bDj8KHwrpcXGLDk1x1MDAxN8KMwqPCqHJ5PU0zwrh0wot7NcKBw6VOLFx1MDAxZVhAw7bCjcKPXHUwMDA1wppcdTAwMWIhV8OAwqlNwrV4wqPCqCXDhU/DqsOew7XClz5cXHbCglx1MDAwM8O+wocuw7JcdTAwMWPCocOfw6tYw5lcdTAwMTFcdTAwMTYkRcOLPX1vTUxNKcOjwonDvyjDvDrDrVx1MDAwZsO9Rlx1MDAwNXt+X8Osw6HDpUJ/w6/CvnlpeMK0w7HDq2hJXHUwMDA0w7FUXHUwMDFmwpVJwqh6w4rDtMOwQ17DhMOfwrhcXFwiMsKBw5o7wqdtwqLDj8KvY8Khb8OiwpRcdTAwMGbDr1x1MDAwNiXCpMO1XHUwMDA1XHUwMDFhXHUwMDEyXj5cXGbDtlHDjFx1MDAxZMO9wqXDjlxcXFw4OibChVx1MDAxMFHCsMOYXHUwMDAxwqhLwpnCk8KVXFxiw7QuT1x1MDAwN31cdTAwMDRSwoPDjcOsw73CgMKZXcKYwpzCs2xJwrQsJ8OyJsKew4xmIcOiXHUwMDFkL1VcdTAwMDc3w5bCoV1dXHUwMDA0wq5VPsO5w5Rva8KWw7vDm1x1MDAxYcOAN1x1MDAwM8KHwqjDqsKgwpxcdTAwMDfCnMOxXHUwMDFjYcKDwq1Kw6XCvGvDuC/CscOnw5RcdTAwMTlcdTAwMDLCn8KATUTCm1x1MDAwMcKJw7nCsmzCjcKXY8OqLzRDw4vCrMODwoHDu8KGdcKPUMOpOnU6wp7DhW/DhcKnw63Cl8Kmw5pkfcOJOsOSw5bDtMKNw77Du8O+UTJFw5YkbsKtaMO7w6Jyw4lKwpNcdTAwMWXCs8Oww68kbsKtaMOraVx1MDAxZjNcdTAwMWXCpcOCwp1cdTAwMTVow4tkwqDDicO6w6Z8w4Fnw4vCnSVVwoBcdTAwMWbCs8KAXHUwMDFlM8ObPMO6acKlw4HCvFrCpWfDlyZcdTAwMTPCr20owqdEXHUwMDA0w5pew59zw4/Cp8KYwonCtsKkXHUwMDAywp3CqMOnw7tCf8KpwrpfecKIb8Kzw43DqsKkw75cXHbDujbCv8O5UljCiSTCk05DU8OHKMKrXHUwMDFkW8Kow4lcdTAwMGZhwqZqe1x1MDAwZcKOXHUwMDA1NFx1MDAxM8OHw4LDmTNbw6vCosO0w6bCjcO3w7R9JT1NwodcdTAwMTEgXHUwMDExw61Wwqh2woQ4fsK8ZzrDtcKYwrRZN3fDkWvDu8O3wr/CisKTXHUwMDAyVMKpIDVcXFxceMOewrDClnBCXHUwMDE0J8KbRWrDvcKLXHUwMDAzZMO5w7o8w7BcdTAwMTXCoFx1MDAwMzdcdTAwMDInwp7DtcKkw77CgMKjdMKFRiPCrMKwwpvDvCxcdTAwMDPDuD1AXFxiwpbCp1vDpFx1MDAxOcOuZcOvwqXDoVx1MDAxOcKuRj5xSV1cdTAwMTDCnyPCucOxLVx1MDAwMiTChMOLwpI1VSrDg3BpZVxcZnFKw6zDoMK2wqpcdTAwMDVZTWzCl8KtwovDo8KoXHUwMDEzwrnDvGTCoFx1MDAxZcO6PU1cXFxcwrZEwqzCpcOCw4TDrcKuw5ZcXGbCp1rCmcKIXHUwMDAzwpZtwpdcdTAwMWFrQcKDKlx1MDAwNFx1MDAwM1x1MDAxZjTCsF3CucOGOlx1MDAxYyHCsVx1MDAwM8O1w6TDq8Kiw5vDpsOVfWU3XHUwMDE5wpZXw5/CtVx1MDAxOMOoPX3DocK0SsKicVx1MDAxZCPDgMKVXHUwMDFkwo1cXGJvfcO1wrVcdTAwMDPDnsKXQTDDlsKywpB8wpPCqn/DgcOAw5/Dj8Oswqh2woTDkcOwf8O3wpXCi8KxXHUwMDBmw5dcXGLCpHrDh2XDo3tcdTAwMWUuZXbCjUnDmcOceiNcdTAwMDbDvVx1MDAxN2Q/XFxcIlx1MDAwNzjDmlHDqsKhw63CkGfDvz/ClcOzworDlMOMwqdERcKdaHhFesKFw7d+wppcdTAwMDRJwqxod8O1w748wqY+XFxiwpjDj8OFXHUwMDE0wp1ywq5WwqxcdTAwMDNcdTAwMWVcdTAwMTDCpsKuw5hqY8O+XHUwMDA3JMOiXHUwMDFhR1x1MDAwM8KfZsKlw5LDlcOjU8OYcFHCs3J+YcKswqIxcMKJXHUwMDA1woxjw71vZcOrQsOLJnZhSsO0SVx1MDAxNWBQwr1iwq3CpcKYXFxcXD19fcOYQF9NwpXDnj7CosO8woBPw45/VTHCjcKMw6XDvcKyw5dcdTAwMTdcdTAwMWPDhXfCgsKVL8KVw5M4wrJcdTAwMTnCtMOmw4BcdTAwMGZ0wozDpcKqw6VcdTAwMTAoXHUwMDA0wq5cdTAwMWY3Rnx8wpBcXHRcdTAwMDZcdTAwMTlqTUcoXHUwMDFmKFx1MDAwNsOmZGrDsSbCgVlQwo7Dkz81w4kuwp7Dn8KsXHUwMDBmcsOMw7lfwqBowpbCj8OcZsKaPX3DhkxeQsKcw47CvsOVwqjCr8Oiw7N4wqHDmybDqFx1MDAxYUPDrMKUwpHCpjonLk9XVMKAL8Owwp9cdTAwMTMtXHUwMDE2XHUwMDAzwo7DmkdVecOOwq/CrT49SsKTcsKwdcK8L8KoNMKywppcXFxcwqnDisKEw5LDmEggwpzCvMKrwoDDhWzDlsOVwpbCqGTDnGvDnsO7XHUwMDFjZcKCwrh/wpnCgMKDwpY3PUDDvsOwwoZYQ3RAJnrCkMO1w5ZeVsO3XHUwMDFiX23CnMKhXHUwMDE4ZXjCg11Qwrw5J8OLwpVywoPCln3DkMKHXHUwMDEwJcOIQMONZjYlcsOcfcK9XHUwMDAzwoXDlsK0w6tcdTAwMDVnKyTDklx1MDAxOXVoXFxcXCZvw7nDlMKoNcOUwrbClMOuwoDDpEHCqcOfTFx1MDAxNMKHP0fDnsKaworCvDBuw7PCuD9nXHUwMDBlWsKawoLChnXDiMOmwrxAbjlPJ8Onw7bDjTPDjHJcdTAwMDI+XHUwMDFiNlx1MDAwNMOHwrVnfcO1wpbCrGpawrrCrcKydntnw6LCosODw7rDjMOnw5pdwobDiFxcYknCoMKgw44lw5XDv8Kfw5JcXGLDlcO/w4XCksKRw5DCn3fDo1x1MDAxOG92XFxcXFxcXFzDqcOFwr/Dt8OdXHUwMDFhXHUwMDExOHI+wrrCkcKxQCzDkEYpckVCw7rDscO7wr13wrfCnyRqwrbCssKQSiBcXGI7w5vDqkHCnsKnXHUwMDEzXHUwMDEzXFx2XHUwMDAxwqPCjcKSSlxcdsKyQsO+UmlcXFwicCDCunnClsKGw4bClmBcdTAwMWVDTcKmwqPDv8OXS8K4w5zDrlx1MDAxNFx1MDAxM8OeXHUwMDFjM8K4woXCtsOQw5FcdTAwMTLCmHfDpMKeI8KdwonCl8KOScK+woLClzZLwptKXHUwMDEzQ3k5w7PCq1xcXCLCrMKRXHUwMDFhw68lOcOVw4hrwqzDvF3Ci8OlXFx0XHUwMDE5Kj7Dg8Kbw5/CuzLDiGzCs8OnwoIowq3DkVrDgMONWSomw61aw73ChcOsI0BcdTAwMTh0PU3Dllx1MDAxZsKow59Lw6VXwoNnw6HDiVx1MDAxYkHDrcOkwplseD89SmTDnEfChMOdMsKdw4lcdTAwMTLDlVx1MDAxM3thwrImw53Di8KswoxFw4HDtsK6XHUwMDEwwq1jXHUwMDE3JkxCw4vCg8K5wqRPw5zCjlx1MDAwMjnDr1xcZk9ww4M9QMK5PUDDpsK2wpN3wpbCisOlw61cdTAwMWXCisOywqVFw7JcdTAwMDHDn8KxwrJdw6PDiMOMwoTCiX41QMKEw5LDtMORYsO6wo7Cg3NCwpvDhsKaw7rDuMKEYX5cdTAwMTjDs1xcYsOaw6PCoVnCgVnCjsOkXHUwMDFiwoHCh1x1MDAxZcOMw6TDu8O9w7zCoVvCt2bDj8KJXHUwMDA0XHUwMDExc8KoT8KYwqZbw4fDrXDDjX3CqsObLcK4w7Fpw7nCoiDDkHXDicOtZiNlw5RcXHTDkmtDXHUwMDFkw63Do8Khd3zDh8K6RcO8IGxcdTAwMTDDhsO/w6ZkU8OJWsO7wrLDsMOQdEfCqERcdTAwMTHDi8OZw5NcdTAwMTLCl8KOXHUwMDE2wozCqTbDhMOGXFxmcTDChi1cdTAwMTIyPX1cdTAwMTjCmXpqTyQ2f8OCL8OedEjDvcKEw4zDscKlXHUwMDA0XHUwMDA1wpHDpUM/w4nDjsOtXHUwMDE1XSrCrMO6XHUwMDBlPlZ6w4TDgVhFXFxcXMK4XHUwMDBlw4PDmcKwX8K7wp1Dw5HDtV3CicOZw7nCl8KXZlx1MDAxZMOXJMKGXHUwMDE0w4lcdTAwMWPDtlxcdFE9QFLCkDPCnW49SmNObHtkXHUwMDE3XHUwMDFkTSFGw7tcdTAwMWJbwprDrMOLM1x1MDAwZj1Aw5tNcVx1MDAxOMK/w7wnwoLDs8OnXHUwMDFjw7bDuW/CjlxcXCJ6Y8OFWMOGXHUwMDFlwq/CpcOjw7xzwoFofsKJwrvDicK6XFxiIcKHw6lcdTAwMTnCiCfCsVx1MDAxOHQlNlx1MDAwNcKQw5vDjMOzNlXDq3XDjmDDi0ZcdTAwMWRcdTAwMDZwc1x1MDAxZsK4w6PCjXx1w75cXHTDkVxcXFxwMHAnQTFyS1x1MDAwNcOFwrLDhTjCpU4vw4PDr8OLXHUwMDFjw4PCkMKWb8Ovw6/DjcKYwrfCrFnCoMKuRsKSwrvCs2jDpC4lw4DCoMKXwoJcdTAwMTXCjsKKPUrCrsK4KsKtw44zw5NUQlx1MDAxOcOQPUBeUsKYw7bCsmvCmX7DqcOkK8OROcKzwonCoFx1MDAwNjrCmz1AfsK0eMOhNTHDjkPCvsKWw5xfXsO+alx1MDAwZcKTeFx1MDAxZsO0JcOHw55cdTAwMTnDrsKbZ8Kowq7CnEgjw4zCt8OCQVx1MDAxZlx1MDAwNcK6TMOVfMOkcsOUw5t7RsKJWX3Dr1xcZlx1MDAxNsORw7MuZ1DDiMKma2TCtylww7rCvSHDp2LDlMK6XHUwMDEwXFx2QcKdXHUwMDE3wrJhwqLDt3XChH5/wpzDpivDqsKxXHUwMDFlMMOmwrpcdTAwMWYwXHUwMDFlwqjDlVxcdMO6JVx1MDAxNnLDncKhw4xXQ0Q9SsO1wowuwrPDsVxcdMK+w57DjMOzw5VYQ8O/w7fChXzCuFHCnWdLXHUwMDA1w5xcXGLChTNcdTAwMTjDvGJCXHUwMDBlJsKgw6ZcdTAwMWVcdTAwMWHCoMOXwpQwwqcrf0xdw4xZT8KGw6HCvsKbYm7CplxcZnnDuS1cdTAwMTAgwoXDiWnCucKXScOFwrzDt8KKwqzCp1x1MDAxMsOKccKCZldcdTAwMTZcdTAwMDM9TSVcdTAwMWPCsUjCjVx1MDAxZmPDh3lGXFx0w6FcdTAwMTfDi8Oxw57Ch0dXKVx1MDAxMHVHcFXDvE/ClMKRwpDCk2PCgMKywqLDksKfXHUwMDEyXFxiw6Uyw4cjw5/Cr3bCkC/CpTjCtFx1MDAxNXrDvMObwqBcdTAwMDTDmsKiw57Ci8OAw4/DlG5KXHUwMDE2ccKGb8OUSsOTwqtrXHUwMDFjfMKOw6HCjMOFMFx1MDAxNMO0wqA8w5FKwqjDpMKDaMORZG/Cv1lUXHUwMDFkwoDCo8KHwqPDh1x1MDAwZUJvXFxiQsOAbsOnVMO7XcK/XHUwMDAxwptcdTAwMGbDgj1Kwq53woE4UcKxXkDDskpKWFx1MDAxYVxcXFzDtsKMw7clwqzChcOxe1x1MDAwNMO3PMOywqpcXGLCk3vCucOzwpxNU3jDmFbDk8OkNFx1MDAwNcODw5/CksOLeDnCkDRYZMK0w6PCm8KEw5/Dnlx1MDAxN0tcdTAwMTLDuiBfSMKkNsKNXTtcdTAwMDdiLsOKdsK2woHCgS/CvDfDglxcdsK0w7/Dg8O3w5FMeVx1MDAxMcO3w4nCqGTDiWzDnsKXwrTDjsKhw6XDoEw9fSVEScO8w4nCuVx1MDAwNsKJdsOiM8OlXFx2WWRcdTAwMWY4fsKXwpJqw5nCtcOHXHUwMDFlL8KZXHUwMDBmXHUwMDFkwoMuwpjCnFx1MDAwZjfDqMOfU8OuM8K8JcOXIFx1MDAxYlx1MDAxOMOpwr8mw5XCgS9fwoogO8KRIcK7QcOmwoJbw4UpwqxZw5jCicO+wqXDq8OFXHUwMDA0woLCoiZQwpPDtVVcdTAwMTXDnj1AbzdcdTAwMWbDu8O9PMOKPsKHw4vDgnLDn8K6Jz1NXHUwMDE0SMOnw5RpXHUwMDA1w4g/XHUwMDAzXHUwMDE1w6nDncKswoNCe0zCocKXwrZcdTAwMDXDscKnXHUwMDE5woMlJcKnXHUwMDEywqvCpyNxXHUwMDE0OMOYc3jCh8KmaMKqYMKkZ21iXFxmw5JOQ8OWIcOVd8Oiwo5Ew7FfXFx0wpLDqVx1MDAwNVx1MDAwMVx1MDAwMS/CoMOkwr/CiFx1MDAwNFxcdsKzw6vDusKQZcKkwoVcdTAwMDTDvkXCrF7DkDdeKMKLX8K+ZcK0wrHCjVx1MDAxOcOeXHUwMDEywrN5SVxcdGF/f8KYXHUwMDFjwq40w7hIw6V+M0VcdTAwMDTCkmHDtijCiMKaw7vDssOJw7jDsVlcdTAwMWM2XHUwMDA0w6XCosKPPUrDkVx1MDAxMsK/woTDlcOtwqXCo1x1MDAwNjk9TXVPw794XFxiw6jCkjhcXFwiccObXHUwMDAxwrrCpcK5TMKzwo3Do8Oawp3DjcK/woTCksOkJ8OHwrxcdTAwMGbDj8KTw4FQa1xcYsOhw4tvRMKPw5PCv8OEw4rDoVbCuMK4KyvCgE3DvsO8LlVcXFwiwofChHnCrnXDrcKAR8KXOFxcZlY0V8KLMsOkUEFTw5InwoHCuUfCu8KAw5RcdTAwMWLDq0hpwrI1bcOMYX5icSNcXHbDqW5cdTAwMTZhOyvClFPCtsO6dkHCgsKSV8KXwpwpU33CpcORXHUwMDAzwoE3QnxOwqPDhsKUYHDDulZcXFxcL8KiMWgsXFx0UTc+w5LCjsOiPUBDXHUwMDBmw4hcdTAwMWbCqXt0QGzCuXfCpMOuJsO1wq5YwrnCvHtHXFxcXDtTXHUwMDE0Ql5wXFx0XHUwMDFiw5NSwpHDpCd9w5s1wrdcdTAwMWZ5w79cdTAwMDY9TcKbwrR4w6htwpVQwpzDu8Kqf8ObOcK4w53CkWTCtcKxwpLDn8OuwqFPdsK6wqXDv8KDcMKfw5A2LsKcw4o3wqPCln/DnsOJw5BJw7I1wo9GwolcdTAwMTDDr8Ocw4HCkHnCnVx1MDAxYsO1NcO2fMOfwo3Dnlx1MDAwZsKgwpDCs8KFWMKDwrNNTlvCsMKCL8KOwqpcdTAwMDVpXHUwMDE4XsOwwprCvMO7w4DCvE/ChMKHJlx1MDAwNcOiM8Ozw5JOXHUwMDE4w45cdTAwMWHCvcO8RC3DrsOBwqE9QMOVwqfCglx1MDAwZcK3c8OmPUBnw69cdTAwMGXCjsOVw4/Dn8KGWMOaYsKIZMKowodYw7bDolx1MDAxYsKfw49cdTAwMTjDo8OJw7PDgMK5w6nCscKjd2BKXHUwMDE2XHUwMDE1wod0XHUwMDBmwr7DjsK8w69qw5DDncKgw6AxYWnDj8KXRTN4JcKSwqMrwozCncOKKmHCm8K2wqN3w47CkMKebFx1MDAxN8Oow5XDsUPDo8Kkw7JcdTAwMWMtTDZcdTAwMWMtXHUwMDFkXHUwMDFjXHUwMDFmIT7Clj1NZsOzworDqMOmdsKqWMOcN1x1MDAxNcKTw5/Dolx1MDAwNjNRd1x1MDAxY8KlwqDDslx1MDAxNsOHUijClcOBZcOjwp3Cnlx1MDAxZsKbwo3CnMKqw5BgwrjCtUTCplxcYlx1MDAwNsOGwqzDplx1MDAwZsOtXHUwMDAyw6g1wrtAS8O1f2VQUcObw65GbMOLw5/CrVvDl8OCwpvDn1QmcX/DjCDCiVx1MDAxY8OzworCpMKVPsKHZcKnXHUwMDE0w71vbVnDucOoe3/Cq8KlSMO9wrFcdTAwMDd0XHUwMDFhwpB5w4lZwqLChsKnw6F+cMKeOn/DrsKuwoNcdTAwMWY0w51cdTAwMTbDrsOVwpJgXHUwMDE0d8OUUFx1MDAxMsKqLsOQT2PDiCFcdTAwMDR9wr3DpcKow6nCnl/CombDm1x1MDAxYsOrcj1NXFxmS8KRw6V+w5R6wr/Ds8KoOHZjwpTDkMO/XHUwMDFiecKkLcKjb8KCwqDDnsOFwo1cXGIvJcOiwoJhw4rDhj1Kwq9cdTAwMTRcdTAwMTjCuVxcXFzDrcOnXFxmXHUwMDBlwqN1wqZ2eHXCkzU9SsO5QzlnK3bCl8OqXHUwMDE3w7LDv2t1ZSfDucO0w5xGOcKlw7fDlmAoPU3CuWd6w6DCs8OuwrHCmGHCrX5mw5XDjMOvw5TCrVx1MDAxNMOtw77ColR2QcO8Q8KvX1x1MDAxZcO1XHUwMDEzXHUwMDE5fMK3w4tcdTAwMTTDmng6w4RQd8KwwpQpwr7Dp3DDjcK1w6FcdTAwMTRcdTAwMTVlwpzDhsKNw4HCucKBw7bDgm9lccKIw55cdTAwMWM2woliwoZkwq5cdTAwMDNdw78lw71AXHUwMDA0w5fCq1x1MDAwN8O8wrZGcz4vwphcXFwiNsObw5DCpEHCjcKcXFxcXMOyI8KMwrXDjlx1MDAxMmDCi8K5RD1Aw6vCvWtjw5BTdMK4w5zDgMOHw7Rpw4xNwpHCulx1MDAwM1vDt1x1MDAxM8OCwqTCv23DhcKbasKnKVxcdCfDjcOQw6rCjcK0wqFiXHUwMDE0PX06w4FcdTAwMGVuYjRmwpHCgsKkwpNjezI0W8K+TilcdTAwMTNdw7HDk1x1MDAxZMKiwoDDsUDCiMOLwrNFWHHDlcKDb8Kcw7fCm3Vhw7ZUw4R5w6jCpUhlwqBcXFwiwr7ClMKSSzzCisKuezDCicOkw7RcdTAwMTlAw7jCucK4XHUwMDEzwr1cXGbCkVx1MDAxOMKSc1x1MDAxYyfCiSPCp1x1MDAwNsKOcyrDoSF7w4nCqsOGTSVmPU3Cg8OLUXbCqsOTwpJ4XHUwMDFhKWjCnSzDosOMwqJ8w7FYw4TCq8O4XHUwMDE0w4zCk1x1MDAxMGl4w71ww7tSb8KHXsKrw6XCtVx1MDAxY3dcXFwiY8OMXHUwMDE4LH91d2DDj8Kvwr/Cq1NyLVAvwpPCrMOsw5RGw53CjMKSwpxuRcKvwoxxXFxiwrPDlsKjXHUwMDFjdcOuw4trwphqwpLCp8OeMV/Cn8KKXHUwMDE5w4FcdTAwMDFhw5DCglx1MDAxNcKKw57Di1x1MDAxM8KAasOCw7xcdTAwMTnDrXfCusKnwoBdPU3DusKhXHUwMDAyw4w7TD94L3JcdTAwMTJ0XFxcIlx1MDAxM1BcdTAwMWbClMO3aFHCuV5Bw5Akw6ZEPCBcdTAwMGZvV8K2ZVx1MDAxZcK2XFxcIsKzXHUwMDFlw6FcdTAwMDY8XcKDw44uT0rCocKaw7fDmVt8wqPDnMONwqd3XHUwMDA3wpk9SsOXfMKHf8Kwf30oXHUwMDAzXHUwMDFkw4zCh2h5wrfDnDjDmlxcdsObwrnCsVx1MDAwZcKeeMK8L8KuQUbCgMKCT8K6McOYXHUwMDFiw7JMwoXCr8OBTVx1MDAwNcONWsKdUC/DsMOOXFxcXE5cXHR8w79sY1dtTMOrXHUwMDFhXHUwMDFiwp1zKsOSwpPCnG13QlhcdTAwMDTClMKLw7nCmMOewrhEZDvDqXrCpTLCuCvDiz1AXFx0UsOSVcOSwp7CpMOMw7M9fU7CosOyw7NcdTAwMGUsV8OhPlfDh1xcYsKjI8Klw4bDmEdcdTAwMTPDin9cdTAwMTFZPUDDpMOfw7zCn0xHwrRiKMO8woFcdTAwMDF0UVx1MDAwMnt8XHUwMDA2w5lpNE3ChE1cdTAwMDPCgk7DnUTDtismQXlgSMOzwpJJIz1Aw5jDg8KWXFxcXMK8wovDhG3DrcOfwqDDnFbCvFxcdsOuwrbCkT1AXHUwMDA0w7PDkE1cdTAwMDMlXHUwMDFlXHUwMDExwrzDn8K9w7duw5zDicO8ScOqYz1AdGBFw7NcdTAwMTjDnlx1MDAxN8KnXHUwMDE3wo7CncK7XHUwMDE2OCcrw4PCk8OXwo7DhU1cdTAwMDPCuVx1MDAxMzl7w4PClU89fcO/TlNcXGLDmGnCpVx1MDAwMXjDoFfCvMOnf8Kpw5jCh2VDIMKmw4/CosK9KCrCjcOewoDDnEzCvEfDnsKUfcKdwrnCvcOvwqbDgcK8wpvCm1xcXCLDjDxCw7PDusKgXFx2wrvDkzMzwqttwqzCrD5cdTAwMTV2w7LDsEg2WcOdXl5swrXDm1x1MDAxMMO6wppHw6hcdTAwMTLDssKaP8OoXFxcIsOqwpo/w6hcXFwiw6LCmj/DqFxcXCLDmsKaP8OoXFxcIsOawpo/w6hcXFwiw5rCoj1NdUVAwpDCucKkXHUwMDFiwovCm1x1MDAxN3VFQMKlwolcdTAwMDTDmsKqwq9cdTAwMTjDjzbCtWfCk8KCJsO1wqBAZcKCwrBfU8KTw4nDnMOkw7XCrsKawrrCkcKkL1x1MDAxY1x1MDAxNFx1MDAxZcKLbsOtwoxOwrrCvldUw74nwrLCp8KRw6kxwqtcdTAwMDTCoT5cdTAwMTlyPUA3XHUwMDFmSnEhw57Do1x1MDAxOXxxXFxcXCN4woTCi8OQw6g9TS5cdTAwMDJOXHUwMDAxcsO6wrMuPU3ClVBcdTAwMTJwwqzClsO3LsKNwrvCisKQw7cuPU3Cu8KKwpjDty7CvcK7worDtcOEM8O2XHUwMDA0WVx1MDAxYTDDk8OOcsO6wrcuw6IqVcKrL8KkwoLCizBUwrrDt0zDh1x1MDAxY8KsXHUwMDBlSsKow5Amw4TCuz1KcT1Admo2w5VlXFxmw4QzZMK7wopcdTAwMTnDhDMuJsOKw7jDocKQwqzDm3LDmsKRw7cuPU3Cu8KKXHUwMDAxw4QzUE3Dq8K4Xz19w47ClMOlXHUwMDBlwqxoR8O/YFx1MDAwMsORwotmw455JVx1MDAxOcKEwqdEXFx0YFx1MDAwZcO1w6pcdTAwMTbCl8OzM0Bfwq8rdMO3OUpBXHUwMDA3dMK+Wlx1MDAxMnXDqsK1woVNwpXDo8KzXHUwMDE3wrYvV8ONT8K0TsKRw799XHUwMDEzQ8Oyw4zCpMOJwpVfw7BPw4rDg8KnP8Orw7Z0J1x1MDAxN0vDgcKfRjnDsz7CslrDnT19w5bCk8KlwrnCm15Bw7jCgMOwXHUwMDEywpDDgjMhY1x1MDAwZcOdM8KlMVx1MDAwMsKRwofCuz7ClsOvXHUwMDExwrXCu1x1MDAxNkAlwoDCucK+XHUwMDE1MsOvw5J+w6NbTMONMMKbXHUwMDEyblxcYi92OMO+wqpcXHZcdTAwMWPCucOwfcK6NC3CvHnCvEDCvTjDjsKSw6fCncKbcWXCiMObwpbDgXnDv1x1MDAxMcKQXHUwMDA3WCnDjmhcdTAwMTnDil/Cj8Klw5tCYyDDmcKVPjloYVx1MDAxMFx1MDAxZFx1MDAxZXDDuMOxwqdcXGLCqcO5TsOcwqHDhULCq1/DkMOMXHUwMDFkXHUwMDExw6nCqcOow5/DlFx1MDAwN8Kue8OuPkzClcOcXHUwMDA1wrdXcVx1MDAwNFx1MDAwNsKCZzvDicOdw53Ck8KZXyAuZcOFbsOewrBVwqlcdTAwMDfCoMOew4NGQCx1TcOIw4rDtCcuwozDmsOJw6rCt8Krw4BFw6HDu2/Cn8OHXHUwMDA3w7wlw613w7fCl1x1MDAxMlxcdMOGK1x1MDAxOMKbXHUwMDBmw7FBw45oXcKbXHUwMDE4OVx1MDAxM1BBw5E5PX0hJsKbKsKHw57CkcKVKsK2XHUwMDA0woZcdTAwMDI8csKwXHUwMDE4PX1cdTAwMWLCqijDiFxcXFw2w6wqJULDiFx1MDAxM8Oow5ZSw4rCnsKfZEh7Y8OOwpRcdTAwMTY6wpTCszzCtzVJXHUwMDFkL1x1MDAwMmFlccK1w7dcXGJtXHUwMDE2w6rDo8O5wo8ow6UmOkBiVMKgw5Imw5UoXFx2KVx1MDAxM0kow7nCnlLDkcK9VS9cdTAwMDJcdTAwMDZTw5lnwq7DnWN6XHUwMDFlfGTCnsO0w6fDrFnDoMKxw51cdTAwMDLDhzdcdTAwMGbDlcOoOcOSLlx1MDAwNsKdwp7CokVcdTAwMTloaMKXXHUwMDA3wo1/fFx1MDAxNjfCgHfCuFx1MDAwMsOxW8ObMMOdMcKMXHUwMDA3ZHZRIT1Awo1WXFxmXsO9XHUwMDE0w5zCiFvCqsOTwqnCgn3CvCpcdTAwMTV2YcOUwro9fVx1MDAxZkLCoDXDs8Orf8K5eMOuw5bDmlxcYsK1NT43cWN+WsOGIcOTwoLDtcOicMO9XHUwMDA2wrlwwohTw5U4w5BKw7tEXHUwMDEyd8O4fsObcTlFdi7Dg8K0w6nDnsORw6rCoVNEw5wvwpdcdTAwMGVMO1A9fcOHOcKFXHUwMDAzclx1MDAwNVx1MDAwNcO4Ulx1MDAwMVJXPUAmXHUwMDAzwrXDgsOOL8ODaVx1MDAwMWTDrsOtw6A8woNwacK/PDFcdTAwMTZsZDXDryvDlEzCk1LDt8KiwovDrsKXPGbDosKKwoLCmsK9XFxiw4jDt8OtXHUwMDFhKMOvwoZcXGLClcKUw5lcdTAwMWEoJsO+wp4jwqkpw5PCv8OnXHUwMDA0XXHDqsOOwqbClFx1MDAwNFx1MDAxYcKow4TCvEJXwrhSXsKDw7PCgiMzXHUwMDE2RsKNXHUwMDBmUSPDtSplWsOZXHUwMDA3w4ZmScOGwqfCgsOSw6nDgkVOw7jDuyvDsMO9WmJxNDBXw7lcdTAwMGZUwrrDqE/Cu1F+w67CvcK5Vk5STGFNYcOow6bCs07CiVxcYsKew70mwovDtsK9NUV9JsK9NsKSwrZEMcKrXHUwMDA3TmrDgmJxwpnDgsK4w4XCnMKcwr87w6XCmcKswrvCkcOJN13Cn1x1MDAxZcO9w5FcdTAwMWHCmMKcK2HChMKZQsOfwpLCrD1KfTzDl1xcXCLCp1xcXFxZccOUwoPCkEXChXxmw5BtU8OuwqXCisKnw5zCqVx1MDAxMkFcdTAwMDPCmcOkw7jDisOkw6rCoVxcXFzCpcKdwoLCrWnDoMKqw6wywoXCvcO6wpTDhFx1MDAwMsOEwq7CsH7ChcODLsOtw5fDt1bDiTLCo8Ogw6jCgGdBwr9qwoTDhcKGwojDr8Kowq7Cv3PCqGXDn8K/M0JPZsKOT8KKwrFcdTAwMWU9fcOJQmwsXFx0wr1bw6nDtFx1MDAxNMO6w6FYO1XDuTpkw7DClcOsw6Rew4xsw7NcXGLCi8OlwrxAwq3CpsOuPUBPw5gvfcK0w5Z1W1x1MDAxNcO7L8Ogw4XClk/Dv8O0w5LDpMOLVsKLwr7DnCTCj1szXHUwMDA1w4JXw6c2aMKXXHUwMDE0wpfDvcKGXHUwMDExw7J7W8KIwoPCqUAwdsKvQ8KvXHUwMDAzfDvDs8KUJ8OCwr9nNTLDpH7CrVx1MDAwNcOKwofCnMORXifCpiN1wocxwrrDtcO4PD1Nw4VcdTAwMGXDgWFIw4hYw4FYY8KWw7hfXHUwMDE1WcOCX07CjiQnRX1sw4w6w45FR8O4w6FcdTAwMDNcdTAwMDXCp8OHJsKjw79cdTAwMWJZwplmw4dddVx1MDAxYSVRw6PCvkTDgWHDiMO0w4PDl1xcXCInw43Dhlx1MDAxM8K0XFx0wp0jLErCkGDDlk9cdTAwMWVcdTAwMDbDtMKPwrLCmcOCw5Z3w5DCvUvCkE45w7/DosOlw6s9QGlcXHRcXGJ6XHUwMDA3OEXCssKZw7lcdTAwMWXCmcO5fsOhw63DtFxcdlx1MDAwNXZiw7/Cl1x1MDAxM8O1wqZlXHUwMDE1XFx0PUDDlsK+wpjCpcOYwqxuw6Emw7fCscOoXHUwMDFjw6l6w4fCp1x1MDAxNXXCqcKowrDDksOew5dcdTAwMGZww7ZcdTAwMWVcdTAwMTQ+KzXDlMORwpAlecO3JFN3w5nDjEM5w7jCgMKeXFxcXEzClMOcwrLDvcOhwo9jw6rDpEnDrcOXwovDlcKST1VAwq84OlVcdTAwMTY9SirCuGs9TXvCssOGXHUwMDFhNVx1MDAwND1Kc8OOasOCPUpCwpNsZzPCvsOHwqbDhHjCrW/Cr8KPw5d7wrnDmsKvwpfDlsOnPsKYwrTCm1haXHUwMDBmKyp3RcOMwpJlKlx1MDAwMsOCw7fDsHo1w4xcdTAwMWVwRcKvw4B1VcKIwrtxw5krej1NUifCj8KdwpQlL3rDgGB+w4M9TSzDssKwwoLDilx1MDAxNMKWw4nCr8OTw7LCkMKFwpw8woXCnVxcZm9cXFwiXHUwMDAzdsKhPUrCkcK4XFxiw6rDuVbCpnomw7Yqw6PDt8O5w55AXFxcXC5zwqQww7Y0woVCRSbChkzDlmFcdTAwMWLCsMONZj9cdTAwMDfCrFx1MDAxM8KNw5jDjzTDocOBZ8Kdw5DDscK2LS3CsFx1MDAxMcOzw6tcdTAwMThaQcO2wpzDnMOxXHUwMDE5w4/DucOQaFvDqMOUecKSwqBaSsKnPMKBYcORw6hKwoNcdTAwMDMhYFx1MDAxZlx1MDAxOcKXw5RcdTAwMTYgw5MlQsKgw4xcXHTCp05GwqXDrHpcXHQzwqfCk8O/wqHDnsOrw7TDkVfCiSNcdTAwMWPCnidyWHHCq8ONbHfDmcOcRcK3wqVBXHUwMDE5ecKkLsOYwqRcdTAwMDfChcKBw6FkwrHDiMOALjbCuWZkwoPCuHtnwrNvwojDoMKgwpDDtzTCqMO4wq7Dn8KWwopQPX1cdTAwMTXCiMO/wp0lXHUwMDE5wrNnUsKjK1x1MDAwN8O/IcKXworDoMOfNnfCl1x1MDAwNFx1MDAxOHfDlsK3XHUwMDEww6PCmsOcwoIkO1czw4TDkFx1MDAwZV/Dl0k9QC/Co8O8w5XDtUQ0w7DDlcKvdlx1MDAxOCPDjnfDqMKgXHUwMDFkXHUwMDFiw57Dk8KjwqRcdTAwMWPCssOYwrNJwrbDvMKTw5bCqivClWpcdTAwMTF0wq5cdTAwMWEhWFpNXUpcdTAwMTTCucKIwrLCty/DmGYzfGrCj2PCqSjCkcOCwpIjwr7ChGDCv23CtmpMXHUwMDA0XHUwMDFjw7DDjiFcdTAwMGXDtCd6wotkasKLw4DDncKsw4Qge2dHccOBwqY9TVx1MDAxNUU5w6zCkcOJwpnDp8Okw6PDnlpcdTAwMTJkTMK2w6RcdTAwMWHDuFx1MDAxY3o2XHUwMDFjXHUwMDBmwrhrMMKNbsOIwo/CplrDvsO5w4xcdTAwMDM5IMKpcMO7w4FhwrJyc8KtXHUwMDFhwrXDo8KtSMK2XHUwMDEzNMK5Wzh3woAgwqnCpsOkwpw5d33DncOvVsOuUX5cdTAwMTBcdTAwMWTDlFx1MDAxM8Oew4vCgVx1MDAxMsOpa1x1MDAxZcKTZsKjXFxiw4A9SjTCssOJKknCty7ConHCp0/Dt1x1MDAxOMOHO8Kdw5zCtMKXRMOrTMOSw7nCvVx1MDAxMXVjUFx1MDAxMsOUw4zDm8OlXHUwMDFiw6hcdTAwMDHCjcODw65cdTAwMTjDncOdwpvDkcKvw7U6w6ZcdTAwMTfCo8KuwrBcdTAwMDLDncKxNMKswrLCrcOOwr/DrMKFw5tcdTAwMTHDqmLCrVx1MDAxZnJcdTAwMWPCi8O+wo7DocOswpPCo2TDscONwodfOcKWQcKCbcK3w4LDqMOIJklcdTAwMWPDv8K+w7dzwqDDhMOPwplow5PCuMOCam1cXGLDicKQPMOQw65oT8Klw4Qyc8OMwrM6XHUwMDAzwozDtj19XFx2PUpxb2bDq8KBw6jCrcOrcsOlw5PDssKjXHUwMDEzw7VcXHRcXHbCp8Ouwpcow6rDtlDCicOCw4PCr2Z8w6dcdTAwMWFlJMOVworCljvDjMO/w4zDp8KWJsOAwqZxw5HCrcOPVG7DpsK6XHUwMDEwVsKRw7NcXFwiJsK6XHUwMDE1Sl9WwqXDgsKvTMOuc2tZXHUwMDEzd8KWN1x1MDAxY8OMXFxiw4VuworDssKZXHUwMDA1w4vDu2pcdTAwMDE/wr81TcOpw4TCs1xcXCLCrFx1MDAxMFx1MDAwN8K8bVTDgcK+w6pcdTAwMDPCkjFcdTAwMTZ3PU3DgsKqMnA5w6VcdTAwMTBcdTAwMTM1XHUwMDEwJsKhwog0XHUwMDFjXHUwMDEwaFx1MDAxYVliwolcdTAwMDTCtVx1MDAwMVJGccKsO8KrRsOSwrbCjVx1MDAxZsK9woI1WMKifFx1MDAxMkdmXHUwMDA2w5NJeMO6w7nClsO5R0pubFx1MDAwNcOJwqVJwphgZTnCisOiwplcdTAwMDXDjUzDvcOxO3vDrMKIY1xcXCLCmTfCvVx1MDAxNGLDpD5ewrJlM1x1MDAxYsOHw6RcdTAwMGVcXGLCj8OxdMK9woMtIMKvXHUwMDA1wpdGMMKBw4lcdTAwMTPDhsK7T1xcZsOjwrTCnH3CnMO4XHUwMDFhKFHCqVx1MDAxNVxcdsKBw5diw53CjMKib8K4w7dVw6TDr1x1MDAwZcKvw5vCh1x1MDAxMU3DhkU7csKoNsOawqhuw6pcdTAwMWPDjsKDN8OsNMKXXHUwMDE4w4RbV8KDXHUwMDFjK8OKw6VcdTAwMDXColHDksKVLMORwoA/woHDhcOAJFx1MDAwZcOOesOTw4HDmCnDryhRw67DvMKowq9twoXCicKkdlVLw5dcXHTDrcODblxcdsOaclXDvFfCqsKMw5bCk8K1w4lYw53DglrCt1x1MDAwZsOsw5jCkmxQeSdawp7CnztbeXNmw4PColxcYsKBw4rDlcKMXHUwMDEyXHUwMDFmw70tcsKhw6PCkm1cdTAwMTLDmMO6w57Dpm/CklxcdsKcW1bDqMKhNsOUZFx1MDAxN1ZBw4fDqnfDsFxcXCJ5w6JcdTAwMGbCnFs8UsO1wrLCpsKswoDCoGjDkiHCgFx1MDAxNMKGwrrDrXPCg1x1MDAxMUzDkEDDh8OQwobDrmbDksO9w6vChsOkwrt1w6FCR8O2b1x1MDAxOUXDsk9cXFxcw5fCncKzdjHCncOrwqPChsOjw4rDmUTDtk9cXGLCgFx1MDAxMTzDgz1Aw6Nuw5DDuG9Iw61cXGLDl1x1MDAxYsONwqPCk1x1MDAwN8K3w5zDmsKxelDDrcKmXHUwMDE5wrM4w4pMwo05wq7CscK0YMK3bkJWRMKOwpdiw4bCjSfDrcKCwrfDiEMmw6AuXnNcdTAwMGZ1wq3Ds8ONwrBcdTAwMWU6wrrDk1x1MDAwN8OQXHUwMDFlw71vXHUwMDFjXFx2w5HCt1x1MDAwZcOtw7k6XFxmwr7CgsKDw5/ChVx1MDAwMW9uSE/Dg1x1MDAxZkZofFx1MDAxMkAgbD7CpGRcdTAwMDLDomw2wpdbw4/DmT7CvMOww6TCv8KmwqTDo8OCPUDCgTTCn8OFw71cdTAwMWbDtcOvwqTCp0/Cu8OMZMO3w4DCtXbCiVPDisKYXHUwMDBmODjCtMKSwqU1w7powrTCn8K7NcKSwrojPsORU8OBXHUwMDFmbFxcXCJcdTAwMGZeXHUwMDBmwoxcdTAwMTbCk3h9WMOywpvClFpcdTAwMTHDvFfCkDDCnVx1MDAwM8OaZMOBw7LDnsO4T1xcXFzDh0XDssKPRl1Zw6PCtkFqwrd+wolew7dcdTAwMDXDnMOrwoY6JiTDo8O2wrvDk3jCh0Bywodsw4HDqzlcXHZcdTAwMWXCtlxcXFzCgMOrw4jCq1x1MDAxYcKFwpzDusKMw75HwptiwpZ5aGbCrnjCicK0PENARScmwp3ClcKbw5bDhsKzwqFcdTAwMWPCrU0tPX3CuWpcdTAwMTnDq1x1MDAxMcK1woFCwrnDhsOQw7w5wpvDpCfCgcKWwoYnNMOpw5spNMOpw5vCpC/DslvCpC9cXHbDuMKoL3piLcKjLX7CmGRcdTAwMDdTTMKpwr9cdTAwMTkww68uecKdw4zChmFcdTAwMTTCjsOnXHUwMDFhw7cnNHhcXFxcLzI1w54vw7BYwp/Dnlx1MDAxMlx1MDAxOCrCn1xcdlx1MDAxMMOKKEFcdTAwMTFcdTAwMDdcdTAwMTTDpkVcdTAwMTE9TcO/I8Oiw7hRMXLDhkPCmcKtRsO4wqxgw5rDuHdow5LDg1x1MDAwM8OOwoHCjXVKXHUwMDBlw7RTKcOocHFYw6dcdTAwMDTDojBgwoJcXGLCpsOpPUBBY8KnwrRVT8OXwoPCrFx1MDAwM8KeasOXK8OlRkU8wqLDp20gemBcXHTCqiNtVVx1MDAwZVcmwqLCmTo6elx1MDAxNcOyb8KaKsKYw6zDk3ZoIzPDiGPDi3/DoTInwpnDmcKCcMK8dMO1wrtcXHTCosOxUsKyb8O2wp3DplHCmlx1MDAxNMODwoElXHUwMDE4JsOpwoLCrzwmSlxcXCLDjmx1wpdcdTAwMWPDhsKgKCzChTLCsitPNMKvU8Ksw4TDpsOZwoUxw7fCgnfDiS5cXHTCv0nCiDdcdTAwMGVywqTDj1LDo1bDiGN4w7xKdMKodCglwqLDqsKBwoNWTEnCicKXwqrDplx1MDAwZWJpQSTDjsKYLMKIfMKQwqDDusKAXHUwMDA3w7t4wrdEwp3DkyFcdTAwMTHDvyHCllt4wq1Nwphvw7jCvHJMXHUwMDAyw690w5vDusKawpZZwoLCnFx1MDAwNMOgwpVRw61xXHUwMDAzw43Dqnc4w4I1wqtTM8Omw7N0wq51wrzDjMO2w4J6woTCmizCrMOLw4lUwo7CjFxcXCJkRj7CmsKzw4vDh0Y4w5BRwqrCpMK3elx1MDAwMnJsw7tZc8KRwoXCumNPWD19wrXCisOBQlx1MDAxOcOIXHUwMDBmwpfCi0Y8wqM9QMKpw4nCly0rw5zCtMOmQMOQw7d8RWp5TsK4woV8OcK6w7jCo8OzwojCu8KQwq7DucKFwqHCr8O9w5nDpcK2wobCpcOfwoUqXFx0bcK7PMKWw7hcdTAwMGbDh8KfOXsuwoFjKFxcdCzDk1x1MDAxYmnCpEnDkFx1MDAwNEhyXidLw6VDOmAqw7DCtlU7Z03CksKWPU1IZi5Vw7VJd1x1MDAxYXJcdTAwMWNxXHUwMDE1aFRQZifCsizDnlx1MDAxY0jDsE/Du8OnQVxcdELCucKZw409QFx1MDAxZcKzw5xNw75cXFxcXHUwMDEzMMKkwqE9Slx1MDAwMjhdOsOLwrLCoTtcdTAwMGbCr3xcdTAwMTPDqMOuTMKTwotJXHUwMDA2X8OzPmF1w7/CkMK4KEDDhldkbFnCtMK8wojDnMODPsK+O8KrWMO2QFVhwq9Jw4xcdTAwMWLCt8OZw6kuNzHDssOAXHUwMDE1QDvDrFfCsWVcdTAwMTJcdTAwMTJYw4ZSXHUwMDE1dSzCvlPDqTR7wpvDrCFSw4nCqS3Dol9cdTAwMTNuw5wwSMKww6o2YFh2TcO2w6XCnsOkXHUwMDAywqV6wojDgFx1MDAxMsOIXHUwMDBmw4A9QGbDpnRcdTAwMWbDtmRVwqJFccKsL8Kpw4TCnsKVS1BcdTAwMTRMPU09SsKaZ8KdMlx1MDAwMlrDukVcdTAwMWbCvz/Cu8OaXHUwMDBmVH9cXHTDikHDpsKjOlx1MDAxNcKzTFxcZsK9TMOGwolZKWfDnlx1MDAwZcK2w7Z0w4PCjz/DgMKFXHUwMDA0fS3Cj1x1MDAxOSXCplHCrsK1SSTCv1x1MDAxNH7CtE41wr09fW5yw6d5YMOSL8K9SDsxXHUwMDE1V8KKSCjCiMKFVDlZI8O3w4tyXHUwMDAxw55SXHUwMDA3ZydZwqt4wovCiTV8wo7Cm8KeUsKSw7dGR1x1MDAwMnnCqsOgwqF+wpnCtjt2woHDsFxcYsO7fsOLWcOcXHUwMDFhRj19XFxmw5o6w40vwrdLUMOKK8OWwrbCmnjCvWLDkyXDp13DvcO3wrdRw6ByMCxOd8KQwrcuwqIqwrLChFx1MDAxNsKCOsKew657w5cge1rDicKHwrDCmsO3RMObLMKGaFx1MDAxYsKcYHZcdTAwMTRmRmPDl8KXXHUwMDE4RsKAw6NMPUrDtMO2wposbMObXHUwMDFjRsOYwr/DknjClnxcdTAwMTBdRMOhXFxcXMOFXHUwMDFmbMOFw7jDrDvCocOMWkDDlsKYaVx1MDAwNyrCt8OLwpNxwqbDh8K2QFFcdTAwMDVtw7dwdVx1MDAxMjzDuMKww6DCtcK8blx1MDAwNnFcXFxcw6vDi8KKw73CssKvw5tcdTAwMWF8wp5aw4XCqlxcdsOzL8ORw4nCmSA6flx1MDAxZUrDoMKof8KhTsKTQcOFw6bDvsOgwr9OO8K6ck5Zw6BcdTAwMTTCkTHDlsKAdzpSXFxmwqt3w7UzXHUwMDEwwpHDiMKuZcK2wrnCssKxbsO0wpV9w6hcdTAwMGbCjsOkw5fDgVTDicOXI8OmXHUwMDAxwp5cdTAwMTFHw5nDqcOew6MxwpDChcOpTMKtX8ObwrPCu1HCj8OqXVxcXCI4alRcdTAwMDFuVMOTXFxiQUJsw7RkwpxcdTAwMDZcdTAwMTZGS3J8MMKdVE1cdTAwMTDDi3LDtsKtw4HDjDdcdTAwMDV+P2zCj8Ouw5/Cqz7ConTDjlxcXFzCmMOzPU09fcOIw5LDtGJ6w5x+woR7NcK0wpHDlsKsXHUwMDFjwrbDs3TDiMOCwoQjMVTCpsKNaMKhw4nCm3k+XHUwMDFmXHUwMDBmw6fDlj5KwprCi8ObwpF5Qlx1MDAxZivCgH8+JMOzwrTDgVd9LMK4w6TDksOuI8ODVVx1MDAxY8KPw4EswpY5w6hVw6jCv1x1MDAxNcKXw5TDj8OPVMKywpDChnDDlzPCgGfDgcOUw5TCiD1Kw4J5XHUwMDFjXHUwMDE3d8O1w689QH5fesKLw4jDjjzDoFx1MDAxMSPDs2xJw4zCj8Ohw7LCicKgwrzDgcOMw7JmXHUwMDEzwoHCs8OIwpt1w5jDhMO7XHUwMDA3wqJTwpxnXHUwMDAzwpnCn1HCklxcdsKtw7jCgcKYRsKqw5lhwqvCnsOsw4hvwp/DkkpWd1VcdTAwMWFmQmRcdTAwMTdow6AqXHUwMDE2wqnDryVlwrtYwqrDscORNURsw4NcdTAwMTPDjFx1MDAwZXbCsVx1MDAxMcOpbCQ/w7V0wo/CtzLDvMOww5zCu1x1MDAwZWrCosO2w6vCvGxTw5XCh8OtVW9Zw455XHUwMDA1wr/DqTwre3HChcKfw4vCh8KWa8KMwrDCgHfCscOBWUHCmsObXHUwMDE0w4hiw4TDskXCjSDCpFx1MDAwN8KiY8K8w41YwpnDncKGwoLDtlx1MDAxZHI7TFx1MDAxMcO1wqLDscOewrN7XHUwMDA0w68gP8OdLHtdwpBcdTAwMDFcdTAwMDNuVFx1MDAwNMKMw6smZH0jVVx1MDAxMjPDpcKAw4pdXHUwMDAyw5zCnMOcXHUwMDAyw6R2w4fCmMO1wqHDmWrDn2jDuWPDn8OGw6nClsKvwoRcXGLDrsOzXHUwMDEwwpJqazBWXHUwMDBlw4HDojDDpVx1MDAxNMOWw5jCp1x1MDAwMmlcdTAwMWPDtcO+TMKYQsO/wqPDhcKVwo7DmEBTw750w7tcdTAwMGVdwpQ7aTU3Pjc/w6xdwoAwV8Odw51cdTAwMDQ9fT1KwpVSXHUwMDA1UVx1MDAxZsKVworCicOOw5lkw5DCglx1MDAxZFx1MDAxYcOww55bwrnCuFRuw5bCq8KDa8OHXjXDkFx1MDAwM1x1MDAwNMK7PCfDmUJ6w75Sw7ZcdTAwMWRcdTAwMTfCr8OBw71cdTAwMGZcdTAwMDfCrMODwqjDnsKJw5XDhMO2wrTCpyDDssKYWF9Sw4vDsVRtW8OUwpBcdTAwMDVQw7fCriAmXHUwMDA1w4zDr8K0wr/Dhlx1MDAxNcKXw5RcdTAwMDRcdTAwMTfDj1x1MDAxNFx1MDAwNFhcXHZIIXlcdTAwMDcwecOwXHUwMDA3QXPCicOhZ0B+I3vDsyvCl1x1MDAxNMOZwqHDmEpcdTAwMWHDlcOMS8Ktw4rCn1x1MDAxMMOTXFx0w7dVw4xcdTAwMTg9TW7Dn8KIw5E9QEjCi8K1dcK7TsK2d8KoXHUwMDAyXHUwMDFmY8OXYMONXHUwMDFjwoHCosOBNFx1MDAxNj7DvVhNwqHDoMO9PFs3MnfChiHDvSZhdEh0PX1lOsOfwq7CrMOTwpIzXHUwMDFlXHUwMDFlJMKmYXDCulx1MDAxZsKUw6DDocKJwqDChyc/csKmfinCkn8nesOCN35pwpLCgn7DqcK6cipcdTAwMTZ+V2pPw5jDpMKrL8O5w6dDQTvCicOnXsOYw6hUWsKUw5HDlcKQw4w7w7xqPX3CjsKrd8O9w73CqyTCsXxcXGLDl8OQOjXDn8OYZcO5wrBtXFxcXHNcdTAwMTItw77CnVx1MDAwZUPDhsOywqbDp8KDw7FmRkVcdTAwMTTCgcO9XHUwMDE0PsKUwrDCocOOLDY/woFcdTAwMTA9fcOkXHUwMDFmNMKqw4XCniTDtMKSXFxcXDfDrsKHw6pmbMO/woNPw6ZWw7BcdTAwMDVcdTAwMGbDksKJwp7CtHrChjfDqVx1MDAwN8O1w5rDhsO3XHUwMDFlw6nClMOSwqLCo8K2w6TCl8Oww6hEwrTDs8K6XHUwMDE4PUrDi2RNNsKwVMKLSMKtw4c4PU3Dh1x1MDAxMj1Aw5TDrVbClVTCp8K3esONTsKTXHUwMDE4wovDjsKIw6PDrMOqw7zCmlx1MDAwNyx7KcKPVcK2ZsK5f8O3PFx1MDAwNcKdXHUwMDEwwq7Cl1x1MDAxZUg3w6XDl8Kjw6jDjFx1MDAwM8K6PX3CkMO4wpc/JVx1MDAwZTh5wrTDhEBYXHUwMDFmOlbCnFxcYsObKlx1MDAxNcOyw7gmwrQ/w6LCmMKJLVjCgcOLe1fCnlx1MDAwNGfChsOnbsKBw6FcdTAwMTNcdTAwMTRmOVx1MDAxOcO0wqHDvcKxXHUwMDFmwprDtsOhZsKGdzXChVx1MDAxY8OCf15Xw67DjmbDqy0+XFxmw7zCpsOlwrUlwpRcXFxcXFxmR2U9TUdbOXbCmsOBXHUwMDE2wqDDjmxcdTAwMTlLM1lcdTAwMDZDWcK2c8KNw4LCuMOXX3tcdTAwMDfDqcKEw6HDvcOOwrvCpFZYMcKUwqHCrMORXHUwMDA2NVx1MDAxZcKNwofCicOpw5nCtH95wpFcdTAwMTU9fWJJwrzCsizDuU7Do8OSwonDmV3CmsKkXHUwMDE5XVx1MDAxMmUvb8KVwrfDhibDklx1MDAxN8KPLsKew5jCvig8XHUwMDA0w7gpw6/CgVnDocOEw5xQI8OdLsOPw7NHwqPDgMKiU1x1MDAxN0nCrcKMNcKHwoBcdTAwMTbDpC0tw6LCl8Kvw4vDmkDClSdNwpRtw6t+OcOww4pRwrLCj1PDrEzCjMOmdMOlJsKaaCDCkltcdTAwMTTDn8O2w45BLsO/w47Ct1x1MDAxY8O3MsOKLcKFwo1NcMOVJsO8wqFcdTAwMTTDpT19w6BcdTAwMTDDqsOXwoxmw6BSbDBHw7fCpcKbPMOlPU3DlErDs8O4wpPDo8K1KcODXcKAwpJJw4zCrX41w5BpIzMrXHUwMDBlIcKkw6nDilTClXLDssKGPMKVVsO4UXXDsmpuw5UyXHUwMDBlw7PDvMOYPU3CtFx1MDAwNcOvw5JXw7xzwphdw7/DjWzDjcOUwqzCuHRTw7vCm0dcdTAwMWbDnsODWVtUL8O7w41cdTAwMTlzViBcdTAwMDdcdTAwMDJcdTAwMTI5w6xPw41cdTAwMTDCv1tfIMKnMMO8ZsK+J8KCw75xXsKuwp5TVsODXHUwMDAyXHUwMDE2PldcdTAwMTgzXFx0YFx1MDAxNHpcXHbDjF7CmsK1XFxcIsK2QMOTw6rDgiPCtsOuccOCOlx1MDAxOMO6c8KjwrB0LD7CvsKzw7vCnjzCvmdfVMOmw4dow55cXFxcw5ZCVcK1XHUwMDA0w4LDtlx1MDAwZsK6acOzwpjCs8Onw5lcdTAwMDZcdTAwMWPDgsK6XHUwMDE5XcOPwqLDn8KPw4Qyw5smPMOkPX3Di2ZcdTAwMTYkwqrDm3tEwo7Cnng7w4bDkcKDw45jMsOKPX3ClmTDrFrCi2hgwr7Cs8KeXHUwMDAxIHzCvcKcOF7CtVx1MDAxNsK/w7xcdTAwMWXDrcKhwrPCg8OrwqpcdTAwMWJMXHUwMDFmwpxOwqxCNnfCvE1uLcKVZMKuw5xcXHZcdTAwMWFFwqfChsKqMMKrL07DtD4lXHUwMDAxwofCtTgzOMOuXHUwMDE2P1x1MDAxNExcdTAwMWYkw6UkY2vClsOEw4g9Sm/DiXVFw4Ytwrhqw7AxcD19Ylx1MDAxMSTDkTs+w4/CvMKVwqzDgMKHXHUwMDFmw7VTwp3DoXpad1x1MDAxMHZcdTAwMWVcXGLDhcOZJHrDqMOxWMKTwovCuFtFw6fCtHAvw5HDjMOrTVx1MDAxZHxoc8KVwoTDicO/w7fCpcO1wrLCosOmwoJcdTAwMTc0e1/DtMK/w5TCgsOIwpfDusKWw6bDmsKmw4AnbmBcdTAwMDdcdTAwMDHDpsOLwpvDllx1MDAwMlx1MDAwZcKMb8OhcMOQaDVSw67Dq8K8YznDpcK2wpXDnXA3T1x1MDAxNsK/wqhcdTAwMDfDqcOeOcOGw4vCgcOIwpXCqlLCklx1MDAxMMKFKMOzw73Cs8KDNXlxw7fClcKjfcKaXHUwMDE2wrQqbsOvwovDhjbCl35/wox2UcOuRmPDnsKAw7pcXFxcRHRuw7vCosKBZ289QDtnw6/DmMO/cF4qP1x1MDAwZnVFf0vCnnNNbsOEI1x1MDAxNjPCu0w9TVx1MDAxZcOTSlx1MDAwNMOEPFx1MDAwM1xcdEVcdTAwMDLDp1txwpVkTGbDssK+VMO8cXxWS8OQLcOMPX1cXGLCjH3Dik9UworCl0xJw7/Cv3nDoMOFXHUwMDE3MXDDj8KzXHUwMDEywrPDrGXDmlx1MDAwZl9WPk1VwqbCo3dXwqbCvcKONcOEYsKWVivDrUPDrcO8wph3wqLDrXJcdTAwMTfCgSvDqVxcXFzDk8KidFxcZsK1XHUwMDBlPMOPwrp7w7dTwotcdTAwMTBcdTAwMDPCqVx1MDAxMcOoeXjDmlTCn8KtXHUwMDFkfVx1MDAwZnHCqcOXelDDg2LDlMOlTSfDpcOCecKAwqJhwpfDnsOMwqE5w6zDrcO0wrQ/dcOkPsOiK1x1MDAxOMKOZ07Cl8KtXHUwMDE2wr3DoVx1MDAxOcKAwqLCiVJiMMOQNMKpfk/DvMOywr5ZeSplM3xuwqd3UC/DjyExayhtw4cuw6LCuMK+w41TXFxcIirDhcOccT5yXHUwMDEyw6wow5tcXHbCpj1KXHUwMDFkMGgqw5PChknCulx1MDAxMFx1MDAwNXQlbMKFQiNawpPCi0zCvHfCj2vDkETDssOyXHUwMDFiwoFcdTAwMWV9RcKWTFFnw6NUYWtDXHUwMDE1w6g2wqzDllHDuF92XHUwMDBmw5XDtcOTw5rDj1x1MDAxMiDCk8OmbiN6w5E5w5rCkcO1a8Oiw4zDs8KLc8ORXHUwMDAxKXFeMsOIwrVpSDjChHdqNsOOwqx6wppcdTAwMTLDkcKHNMOTRsOON8KUw41cdTAwMDLCg8K3XHUwMDAxKMK6w57CusKqwoBew4Qww5vDocO0woFDwo/CmTU/w7dTXFx2w7bCo1x1MDAxOF5cXFxcdFx1MDAwNsKGw7ZcXGLDkFx1MDAwN1x1MDAxZMKKXHUwMDFjwoXCqcKKXHUwMDFjwoXCt3ljwrrChlx1MDAwZcKRwpVRwqnDlcKrwpfDlMOuw6B6XHUwMDAxw5NZckVcdTAwMTDClcK3XHUwMDAyXHUwMDFhXFx0wpU0JWHDnsK3XHUwMDFlbVxcdCXCrTvDgFTCgFx1MDAxOH3CsiHCtMKJw53CgFx1MDAxMVLCsD1NXHUwMDFjXHUwMDE2P1xcXCLCqMKPw63CkEvCk1XCnlx1MDAxNi1KwpRqwoxwXHUwMDA1wpUmNj1NYcKJWMOnRDPDtjRYw7fDilx1MDAxOMK0w6LDvFFEIHt7wp/Cky3DkcOKZMKuw5/ClsOCT8KfR3QteVx1MDAxYTvCjDB3cCPDs8KiwrvCmcKEw4fCjsK+VMODwp03Y8ODXHUwMDEywrhnYVx1MDAwMTvCmlx1MDAxMlxcXFzCpcKiUkw9TcKjw4zDvMK1XHUwMDBlXHUwMDE2PUp3MsOdRS82wr/DgcO2wqjDrcO8SErDqzJRXHUwMDA0ainCgcKRXHUwMDE2w6LDjsKbw6rChUxYPMKJw6fDj2bCn8K/w5jDlUUtIcOMdSrDpcKJw7NPIDXCn1RcdTAwMWFmw5jDuk92VSbDq8OWXHUwMDE4w5U9SiFcdTAwMTNUwoBcdTAwMWZNwrRFecK5w7nDkMOxwq9cdTAwMDI9QFNcdTAwMWLCpFx1MDAxZX9ye0wxwpZlw4fCnFxcXFzCh1x1MDAxN8Ouf0PCu1xcXCJ9XHUwMDBmw6VXwr9zw5BITMO4fcOowp1/w6jCoi3Cn3TDpX/CnMOfwoVcdTAwMGY1U8KXw5HDhnfCgcOxw5TCvMKLRkRYUX04OsKybjgqwqHCoHQycMKnwp/DpsO0K8O8PU14w6NXwofDh8OWwpzCusKOwo1cdTAwMWHDnMKawocgw7nChibCijHDvzlKPUDCrcK7w6MtTsOUw4J/wq0wMMODZcOAXHUwMDE2w6Qrw497w5RcXGZcdTAwMWTDn2R4dFx1MDAxYlIvw5suwpQ9SsK8wqDDlcKZXHUwMDAyw5/ChsKcw6fCuz/DvMKSQVx1MDAxZcKAacO8w6fDtsKmVyQsw5TDjS7Dp2fDsDB1XHUwMDEywrxUXHUwMDA0SsKdw5XDvcOvwqXDrGpGayzDomzDssK9eMOUwoTCrXJ0wpI4WUXDjEnDgMO6XFxcXHVTwrbCn8OVwqfDtlx1MDAwNXrDucOGK8OiwrzDgD/Cl27DoTVcdTAwMWZ9McOHRcOrXHUwMDExOTE1w6NwwrDColx1MDAxOFvCh8Oew77DgSbCrlfCgsKeLsKnw5FjXHUwMDAyQFx1MDAxZEDCn0rDuTdVw6PCtynCgzvDlcOKw5jCvMORw7g9SsK+w5HCqMKKXHUwMDEywoPDosKhw4JcdTAwMTlIXHUwMDE1LlQtYsOrJMOOw4tcdTAwMWNVRUrCvVx1MDAxM1x1MDAxNVx1MDAwZcOteVx1MDAxZUXDvVTDnj1Nw6NFXHUwMDBmXHUwMDE5w6LCuFx1MDAxMz1NK8OdIyVoLy8yOTvCo8KwXHUwMDAyIcOzwoDCsWx+w5jCiHvDrCPCs8OuwpFZwoFcXGbClcKww7jCljJdwrrDoE3CnSHDs8K3XHUwMDFhw75cdTAwMGZcdTAwMWJzw5clwp5cdTAwMDHCs8OJwrfDsE7CiCnDtsKwbcOkw4TDpsKCwpfCiMK+w49bekM5wr9cdTAwMDZIw7LDpcKAw7VlwpvCrG9SacORXsOkwp7CpMKtwoorwq1uaElcdTAwMDRfXHUwMDFlwo9SwozCm8KtXHUwMDFkw4bCjFx1MDAxOFx1MDAwM0JTwrtewrRhwqFewqXCpVx1MDAxZsOSwofCjFx1MDAxZcKoRTJsRDx4w4XDicK8acK4w7fCrsK7woVcdTAwMDPDn8Kbd8KlZsO0IcOGaTFcdTAwMDfCk8O+woXDhsKUPU3Ck1x1MDAwZcOtUlx1MDAxYkvDgT19b8Oww4zDlcOcwqhPPm9cdTAwMTNlKMKqJXs1XHUwMDE3LcOww7NcXFwiXHUwMDE5w7jCscOzw45cdTAwMTFxwrRcXHbDtVxcXCJOXHUwMDE3LcOTXHUwMDFkTlx1MDAwZcKuwp7DncONI1/DlHjCscK3XHUwMDFjw75Iw4HDujY+woDCiDjDgSnCt8K2wrHCoWHDiEvDqlxcdnpjwrRcdTAwMTfCtkg/w5bCsVx1MDAwNsK7XHUwMDBmw5TChlx1MDAxY23DtDLDkcOSw7BbZTXCo0vDrFPCn2TDhMK0w4hyMcKewonCjsOnwqjDp8KcRVjDicKew7/CvVx1MDAxNMOGfcODXHUwMDE2w6FmXHUwMDExYMKlwqbDlMOYIT1KR1x1MDAwZcOlPMOXa8OCwonCsDnCv8OpXFx2w7F9bXLDpMKjwqBUwqbDvsKAX8Ogw4nCvybDsSHDiVx1MDAwNWpPNcKewq4hJkt5w6EtwpLDjnvCqEskw5R1w4rClMO8aHrDolfDuCTClFx1MDAxNHHCm1tYXHUwMDAyw4ljwo/CnjHCi18hXFxcXMKnXHUwMDEzeiNVw6jDmENcXGbCjcKLw7/DvMOcO8KiUMK5XFxcIsOALMOIXHUwMDE4PUBwwrnCrCfCtjZww5zCjETDj2FcdTAwMGXDoylHw5PDpsKAXHUwMDEzJsO5w719K8OKfFx1MDAwN2FEdClYVcOGw77CjjTDvVx1MDAxYcKoccKKXHUwMDFhwo7DkTjCsXs0wq/DjWvCqsO9XFxiXFx0w6fCusOQwqcgwpxlwqjDtGpcXFwiwqFoPsKqw53Dhlx1MDAwZcKbQSjDj1x1MDAwMWJcdTAwMDLDiCBpw5TCjcKjw6TDmFx1MDAxZMOmw79iPMO4PU3DrFvDulDCgj1KLlx1MDAxY8OSXcKZw41bwoDCjsOIecObZDPCjsKFasKzcMK0K2Jzf8KfwobDisOgcFx1MDAwNMOrKXXDvsKXZMKmw47Du1x1MDAxMcKZw6U6w5x3amjCi1x1MDAwM8KAwoBhw5TChVx1MDAwMcKwwpfDqcOLQ8OAwpvCqmfCozgye3M2w6VcXGZcdTAwMWZcXFxcwrJKwqvDqnjCjMOtwprDoMOdwqFlXFxcIlvCuMOdNDHCpUPCoMO/Sl/DiMOAXHUwMDExfiRcXFwifVx1MDAwNU8kUjpow6ZcXGIwwr9DbVx1MDAwZsKZPUo6XHUwMDEywpnColx1MDAwZT19NCZcdTAwMTQnJVx1MDAxYsOwwqRdIFJcdTAwMDXDmVx1MDAxN1l+a0ZnLcOcw41qMU1OwrPClMKGwqTCl8KiOcKePUDCly3CvcORZsKlT8Oyw4A/PUDCi2pcdTAwMTfDtC9qw6Uzw6jCoMKLVMO7LVDCvn3Dr8KqMsKTT8OqwoXCi8O+wopcdTAwMDNBWFx1MDAxYy3DssOJTVx1MDAwZsKZw63CssODwofCjcOCeMKGw4vCksK0wpzDvVx1MDAwN0xpezYueMOZwqZTwq5Nc1x1MDAxZcOJdsOKXHUwMDE5XcOww7dcdTAwMDY6csO8LcKjNcKxXHUwMDBmwqhcdTAwMGZEdsOEw5vCumrDrXPDl8OTw4dcdTAwMDNcXFxcw4NcXFxcwonDp3g+wrA0wqRrXFxiXcOrw5BcdTAwMTE1wpXDrcKKw4VPPX1Tw73DllMqw4bCiMKAwq5Fw64+VFBhwpBuU1NcXFwiwrBcdTAwMTZXwrLClSA9QG5hwo3CgMOQXHUwMDE2worCnF7CqsKOM8K4w4Y2TcK6wrLCicKEXHUwMDBmw5DDrXxNScKQfcKtflx1MDAwNsKfU0/CuVxcZsKUw6xeY8K7w5nCvcK1f1FKRcKEenEzw4PCjcK6R0NcXFxcNcOXwpVsw5bDgD1NMsKZw4PDgcOFw4w2w7XDqsKnw7s+w7zCs1x1MDAxMsOFw6NTwrlFwpRcdTAwMGYww6BqTcKwRD/ClCvDkFx1MDAxZMKfw5zCvcO8e0Z9XHUwMDBlwpfClMKvwpHCmcKVeD1NworDiDPDo8KvcDtaN1x1MDAwNcKXwrfClz1AXHUwMDAyb8KGwozDuz1KPUrClMKdwpLCi8OAdMKlQCpSbD1AXi89fVxcZsOOwohcXGLCvEjCrVDDmsK9w49EXHUwMDFhwrs9QFx1MDAwNynDsFRqwrNZw7I9fXzCoVx1MDAxMsK3w5vCoWtcdTAwMDbDjcO+wrVcdTAwMDNAwrBXw4nDvDA8b8KITsK2wqF2wp0kWMKXwqg+wpI8wqXCi1x1MDAxMMK6wq1wXHUwMDE5w5TChGTCoMKzwpzCgkPCv8KYd3jDjMKUdDR5McOxXFx0PX3DkjFAwqZcdTAwMGXCvVldTlx1MDAxN8OFJ8KxXHUwMDA3XHUwMDFjw4bCokRdw41SZ13CnjkpwrrDnFx1MDAwZsO9XHUwMDE0XHUwMDFlw45ecWYodD5JSkpOwoxcdTAwMTdswq9cdTAwMDNcdTAwMDHDqMKRw4jDsizCnkBcdTAwMTbDusOww7TCmcO7LU5vKV/DqcOdw57DqXrCvcKPwr7CoMOLw7Q9TUw9SkrDlFDCgcKewrQ6w404wp3Cq8OHw5fCksOKa3nCrFx1MDAxN8OBXHUwMDA0XFxcIsOVwrtcdTAwMWNZw4vDpjrCqHZUw7PDplx1MDAwNSFIemshwrzClj1Nw7/Dt2fCs0pRQsObXm/CsMKGwqtbd1x1MDAxYcKpXHUwMDA0PX00U8O3w7xMwps3XHUwMDE1wpfCuWDCjMKhw6nCrMKxfsOrLMO9OyZeQ8KiYWBUWWtReVDDj8OreMKwwppqf8KFwrTCl8Ooc8OEXFx2wpEtOcO2wqtrXjxtw5HDlVDCvcOPw4lcdTAwMTJvwr8ww5k9fXTDrj1KwrUow5Fow4/Ds8OSwpPCtMKpw53DqMOFwrnDsy3CvGfCs8O0w4xqUsKdw7PDs8K6OMKiwpg4ccOKw6tcXGYwTFxcZsOyw7rCqsO7wrxdanpcXFxcXHUwMDBmwqvCoCN2wq7DpV5vw5FhcipcdTAwMWXCmiojU1xcYsO6w5hcXGJKIWMzw75sbcO7dcOkwqTDs1TCu3tPXHUwMDAxdDTDrGbDi39cdTAwMWI8w57CgFx1MDAxM0/ChMKQwqlcdTAwMWHChVxcZsKdw6dcdTAwMWTCpcKTwpnCk1x1MDAxZVxcdMOsIMOmwqg1w79ow5dbwrRgMXx4JXd7w6lwwpw9fcKga8OSwq9WUMKDUz1KLMKaQsK+w7dcdTAwMTPDr8KswpXCnH9cdTAwMDPDl3bCjMKDw6BVwrrDtMKSPUB0w7s6w4zDgMK6XHUwMDA1VcOKXHUwMDAzSkN6woBcdTAwMGbCncOxa8ONwqZ4w7vCt8KYw5tcXGJYwqXDvHLCr8O2XFxmw47Cn8OpXFxmXFx2wr3Dijgzw6LCp8Kow557OlxcYlx1MDAwMsKJw55cdTAwMGZNMcKjV1xcdsKmwoh1OjtvdVx1MDAwNlIpw4tcXGZawoAmwrHDusOAw6o/wr9cXHRWWC7DskFhw4V2Qlx1MDAxMTXCpMKVcsO8wqJcXGZHwrs6w6vDmEE2flPDlsOvw7h6XFxmPX1PXHUwMDAyTsKbwpEzw4F+NEFcXGYzwrJoYsOQVjzDs8KUQTdAQlx1MDAwNFPDjnrDl8KqesOPXHUwMDAyLMKyw4YrwpfDlGc9QMOTwpVcdTAwMTnCgsOEXHUwMDE2MlTDkTzCq8KSMMOdw5lgXHUwMDE3w5bDssKzXHUwMDEww6vDtcOjXHUwMDA0XHUwMDE2L8ODUkjCi0o9fcK/a344w4vDqsOkWj19NcKow6jDi8OjZMOmTlx1MDAwN3dsXFxmPUDDgHJcdTAwMTTCocOvfVx1MDAxYW/DnsKrw6h8w5hmwqbCj8OBNSjDmCpcdTAwMDLDgE/CiHlcdTAwMTVVwo1ZTcO3wqUuXFxmwp/DnE3CuCRdZcOmczfCrMOWXHUwMDA0WsOdYknDsMKYw7FlMibDklx1MDAwMjfDjizChGzDmk5BZcOjbsOnV0rCmMKZw57Dmkh0wrR1Z1x1MDAwNMOrw5PDmMK0wrRZa1fDpydSwq/DpsOxLHN6wqQvw4DDnsOCwr3DljzDnVxcYnNmwrd/wqtMTm3Cilx1MDAwZsKQNTjCkMKjw4F2wpjCiidkw43CicOIwoFcdTAwMTEmXHUwMDE4XHUwMDFiXFxiw5XDrFNcdTAwMTnDisOswppeWcKAw4dgw6vDoVxcdlxcdsKOwoptesO5XHUwMDEwwqXDmWBnLsK8w4PCilxcXCJfXHUwMDA2bsOqXHUwMDA2XHUwMDAyXHUwMDE2QjVbwro9fWDCjkZcdTAwMDfDpkvClCjDsMKXwrXDp1lewpt3NcOrw6/CminDpsKTNMK9w4FOXFxiwpnCqMOrw7LDu15cdTAwMWHCosKEW8O3woXDs25HacOUw6PDkcOvw4DDisOCw4fCmX3Cv1x1MDAxY1FcdTAwMWLCq1x1MDAwZcKHPMOywqHCrzo2XHUwMDFiXHUwMDBlwrBuw7PCi8Kgw4cvSsK9wrPCsizCkUIrwpvDosKmXHUwMDFhXHUwMDE1wpDCqcOKXHUwMDE1aMKdwoDDpjjCscO1wrFcXGbDtFpcdTAwMWXDoMKJPU3Dk8K4w5DCisKNRsKVwqZIwrrComLDnlx1MDAxOcO7w6h+RCzDk8KIVMK3wr01w7FcdTAwMWHCoFxcdsOSw4TDmTFjbUrDpsK5K0pjwoYoXmbCi1x1MDAxNHNSMMK8ZnjDny5cdTAwMWHDqD19OcOBw5HDqMOsw5ZuXHUwMDE0w6ZDw5w9TcO+wpV7w5tFQ8Klw4EuU33ClsKTw4/CkiHDqMO9wpQ4SVx1MDAxOcOOwoTCvsOIQMOTMFHCnXk0w75cXGJIJsK1wrHClybCqkArXHUwMDE4wrnDmsKBeFx1MDAwMcO4XHUwMDEzcMOGblx1MDAxZnrCtkDDrlVcdTAwMTZdw57DpcK7XFxmw5B4aXrCtlx1MDAxOUXDpFx1MDAwN1x1MDAwMsKfLCDDscOfwqHDqELDtVgxwrF5XFxmwoBvXHUwMDEwXHUwMDA2w6PDty3ClMK8ccO3XHUwMDBmTU9awo42wro/wpotw5bDpcOgwrIlYsKtwr1LO8OsbcK6wqrCuMKINGPDl8Kww6jDnsKdMsKGOVx1MDAxMjc0w5JcdTAwMWXCrsODw7/Dt2PDmm9uXHUwMDFkw6DDosOpw4RcdTAwMDM9QCPCr3MrU1xcXCLDh8K2XHUwMDEzw6Jhw6jDmVx1MDAxYsOYwqPCt8Oaw6DCgsOfLyfDmMKsXHUwMDBlwr12wo8lw6jCp8OGw6HDvcOLw53DvSbDtMKJwo1cXHRZwqfDqcKfw6nDlsKkwrxIwpnCrTXChivDqFxcXFzCtGNyY8Kow4oyw5Fkwr5DwrdcXFxcV3wrXHUwMDE5KMOMw6B3U8OIw6FJwq1cdTAwMDVxw504ZjLCoyXCoMOow4lhXHUwMDEzwrTCskU6woxcdTAwMWQzO05KwoBcdTAwMTjCllx1MDAxN8Oyw5o4wpPCmsOgw4rCiMOqw5rDqkfCvnvDtG7CrjHCplx1MDAxZCrClWnDkMO4McK0w7sxwqZ9wrTCpVx1MDAxMkx2w743w6nCrsOuTjJRwqxcdTAwMWTCscOCIUolI8KHwpdGwo1cdTAwMTjCr2/DnyBHNMOnw4DDl307woI0woXCrmTCt0XCgMKkwoTDr8K9wpPDpVx1MDAxM1xcXCLDnGltX1XCllx1MDAxMsO3XHUwMDEywrbDnsKzwoNcdTAwMTVQZWgvwpXCg8KOUsKPwqxbwqPCh1x1MDAxZVx1MDAwNVx1MDAxYzcjXHUwMDFhw5jDi1MmcMK3w7bCl23CssOMTVx1MDAxZT1AKlx1MDAxOMK0XHUwMDE4wqJcdTAwMDN6woDDqDTDr2DDglx1MDAxYsKAf0rCpsKFw4bCs1PChsKRXHUwMDBlUVxcdsOcwq9Ew7NZSC3DuFrDqsKRajbDnm/DpcOXw6Jdw4spXFx0wp3DssOGfsOEw4nDrcOiw5tcdTAwMTTDq3vDksKDwpbDvlx1MDAxMMOuRUdDfFx1MDAxY8KLe2LDk1U2RFxcYsKkw6fCuHJ/wqTDp8O3w7NnZHXDqlx1MDAxOSU8XFxcImXCqcKoTMO7w4HCncO9w7pcdTAwMThcdTAwMGbDscKLw5nCmlx1MDAwN8OEXFxmfsOFUMOZf1x1MDAwNFx1MDAwM8KpdsOuQMObXHUwMDA1w74uw4Ugw6BMwqlzwovCqGbDtcO8LWrCrsKowq09QFx1MDAwZi1CNcOON8KJPD19w4vCvyo2XHUwMDFmwrHDosO5XFx2w7/DtzHDlS0ww5VcdTAwMWUtwqTCq8OoJFxcdk9cdTAwMDM4wqLDlFdKwpczwrvCnD1AN1x1MDAwNErDh8KzTzHDn8KWXU9+wp5cdTAwMDLCvMKjW0TDp8OJXFx0XHUwMDAywoTCocOMwp1GMcKPwqlcdTAwMWHCjjxgRsOPQ8KOLMKwwp7ChsKCQV0vQj7CpijDjj7CiMKhck/DjsOfPUrCpcOyXFxiMMOcwrbDt8KWUz1Kw7p6wotTXHUwMDEwdUbCs8Kzc0o7OVx1MDAxNsK/Y0ZKw55hw7QkOMKzw7MoLMOuw6tcdTAwMDJ2w4UxwrvCsn1bw71cXHY/S8OiwpJ8ZjHDmcK2w5Jxwo/CjcK+w4DCh8OJasKWOMK2TFx1MDAxNsK8wqPDocOiXHUwMDEyw7svXHUwMDE3OcKqPUDDkSDDtcOAQsOHw6vDhl7ChiVTI8Oxw7TDv29eakzDn1PDkCzDpkbDiMOFTDvDv8OKM8Kzw4DCp2jCgmbDtsOfwqzDtcO5w7g9QCXCtHd8wo7DrsKow4rCjcKPRX0ww5RRYEwjw5DCli3Dk8ORX8O8wpFcdTAwMWTDsFx1MDAxM8KMwr3DmFx1MDAwN2Apw4LDlsKyw5DDjsKDwow9SsOow7lJwr/DjFx1MDAxOVxcZsK9wqxhM1x1MDAwM201RMK6PUB1w5EmP13DpsKlw53DmlLDtcOPXFx0w5pOW8OxeHlNJCnDnSHDicKLey7DtUlaZG1cXGLCh8Kcw7hjTcKsw4pOXHUwMDAzwpPCvC4/P2t6asKzPE4ywrxPVlLCrMOCwp1sWzF+w7bCg8ODQMKdMD19wpDDr8OGP8OdSsOyw5fDiMKHw7ljKSVcXGI5IVx1MDAxNcKnw4jDtcKEXHUwMDE4XHUwMDE2wq7DiFx1MDAxOMOUJMKfwoHCgcKhwp/CnVfDnkvCsU9cXFxcLmvCgF9LRTPCukIxOcOScMKLXHUwMDAza1x1MDAxMlxcdmzDr1x1MDAxY8OpwpVxwpzCs8KOwrxXZmrCvsOpJ8Ozwqwww7rCjsK9NzvDosKfeMOjwqbCusOyf8Oyw4ZUXHUwMDEzw6PDq8KDwozClyrCkVXCi8KRL1gkwrPCtsOxw6wtRsOZc8KJwqtWwoTDg8KWw7RJMsOfNVx1MDAxYcKwwpoxQMOewq1cdTAwMTh1w7B4w5LDkD1Kwrplf8KWw5R3IMOiwrtcdTAwMTYmXHUwMDFhwqnCiWrCtlPDmMKdeXwlXHUwMDE5RcKSWMKHWsOmw4pcdTAwMWNcXFwiw4lcdTAwMDchT8OoZVslwrJcdTAwMTXCgibDt8K3VHPCiG9cdTAwMWNsXFxiIMOJXHUwMDA2esK8w5bDqsKdWlx1MDAwMjI/w6lOXsKuw6Jww7LCuGzCjnbCsMOSUcKew7vCijkwwpjDlELDoVx1MDAxY8KzPsOhw7U6XHUwMDAyNcKOe1JXwpvDhsKOZjN+w49jeMK9Ky7CkXPDnXJAXHUwMDE4XHUwMDBmYEo8XHUwMDE5YsOOWWDCn1R2XHUwMDFmw6HDhMOswptCXHUwMDAzMcKAXHUwMDE0acOdwrRzZC5Ww7zCjMOhUmZRXHUwMDAzR3JqwqBcdTAwMDIkwqFsw6ZcdTAwMDU6woNpw4BtOsODYXbCqjjCnEpcXHTDmlx1MDAxOcK3wr7DicKyUjwhwr9NwoA/wptIN8OvwoVzwppNw5/Cjlx1MDAwNTlcdTAwMWNkwpvDoX/DrEtcdTAwMDPCq3zDhT4ywrXDosKEQ2DDlUrChT19wrXDhVxcdilcdTAwMTDCsF3CpCl9eMKYRVnCm0zChj1KNsOxW8KHw7wjw4wowqXCvcOTRsKew5diw5dfXHUwMDBlwoDCrEFxw4A8wp3CgcOmwrXDlCxcdTAwMTNcXGLCusKrwpYvXHUwMDE4Q8OPc8O6w77Dg1x1MDAxNHHCu8OHwpTDolx1MDAxZsK+w7JfXFxcXMKydlx1MDAwNGPCm8OcwrzChcOww4JVw6rCrHHCjsKzfsOCwqHCjMO4UVx1MDAxNcO4wrzCh8Oew7NcdTAwMTTDklx1MDAwNsKaNVx1MDAxMcOIPUpgw5LCumZPw7jCtm7Dm8Ovw6rCnS3DgUPCtjXDkzwwwqxcdTAwMGY1XFx2TsK8wrbDhcK9w6fDhHZcdTAwMWbDrXPDqTBEwpDDjMOwPMOAw4TClMKdNijDocOpOkNcdTAwMTkxW8KcXFxmPUDCrjNAwrpiXHUwMDAxUS/DgMOTZHTCiMOvb2fCtHkjJlx1MDAxMcK+w45cdTAwMTTDpVXClzgnOsKMw5E8b1xcZsKUTcKyK1xcZmDCvk7Dnz57wpdqw4XDlFnCkWPDhT7CqsKPdcKgw5svZyvDuT5cdTAwMTHCnsKqSMKqRlx1MDAxM3DCnCHCssKhwpXCrEzCs1xcdDBVPU3CnUXDoMKywoErUUg1w4zCvcOawp9KwqzDlMK9wpYhTsO7fMOzQ1x1MDAxYjB9VFx1MDAwNlIxXHUwMDAzw5DCgcOMdy4/w65cXHbDq1x1MDAxM8OUYsKFTsOqwrRFwokvw4Z0VHZlXHUwMDEzOMKTwp1HWH47ZsK/w7xKesOSZXLDnzImwqzDv1xcXCJPwoTDmDfCtHlcdTAwMTBcdTAwMDE9fcK5w6NTwqFhwpvCunXCojggwrjDl8OjWMObworCnsO3worChsO8w4Itw6NWwrYpw6tcdTAwMDRcdTAwMWVkXFxmwrfDpMKywpcvXcOJa0PCikVVwqfCjEtcdTAwMDPDrMKmwqhcdTAwMDJcdTAwMWN0w782wp5FKFx1MDAxM8KcX1fDhsO6X1x1MDAwMT1NXHUwMDE2XFxcXH1Pw5zDvkNWXHUwMDFkwo12PUAkWzDDicKEw4/Cm3A9fcO+w6hcdTAwMGXCvMOTXFxiwoDCjMKxwrJ/S8ODwpJowqM5cypUwpLCo3/Dglx1MDAxM8Otwr88XHUwMDFlwrfChcOPXHUwMDEwwqlcXFxcwpUxXHUwMDFkw6JzKE9cdTAwMDVQwrvChsK8wofDqlxcdlx1MDAxN1x1MDAxYcKtw6bCh1x1MDAwMX7DqDPDpFtOT8Oaw5rDo2A1w4DDiUpnc8KYXHUwMDE1VsKHXHUwMDEyXHUwMDBlwppcdTAwMGbCq3rCmMO8w4c6eTZcXGLCk3AmwospwrnDnVrDi3shwqnCtsOpXFxcXMKsOHzCrVx1MDAxOU5hw63Dn8KcK8KLRVx1MDAwM1nCrT19MMOadUFWwodcXGYuXHUwMDAzwpPDlHVWwpXDvEzCq8Owwp1WKXlNUVx1MDAwM8KYdcKGWsO8eFx1MDAxM8K7TFx1MDAxNcK9XHUwMDE2VTLDtlx1MDAxZsOiZ8OiTlx1MDAwZsKsIDXDgMO2wrrDgnjCq3pnwr1Mw4RcdTAwMTPCtEdOwrzDpMOxw4F2NntaXFxcIsOhe1x1MDAxYinCuz7Cg8KAwoc8w7vDlHTClipcXGZPwq/Dk8KYJilcXGJcdTAwMWHCucO7XHUwMDA2w5DCiVxcZsO6woFpXHUwMDAywoByRVx1MDAxYcOXJynDsDlow7PDjsOONlx1MDAwNk3ChnjDi1BKwpVcdTAwMTQmw7XDjmLCsHnDjEHChsKVb8KUcX0nKcKMw4JcXFwiXHUwMDFmw6t0wq8oLTLCusO1XFxcXMKePUrCi2vCgsO4PX1cdTAwMTFVd8KUVytcdTAwMWUqY8KtwojDpmtCwpZ/csKAaUxcdTAwMThoXHUwMDE4SFtcdTAwMDJOX1PDsTTCn8O4XHUwMDA0XHUwMDEwVHrDuMK6wrHDg27CjFxcXCLCu03DksOQXFx2wqnDm09NwpjDncOywpnDmsKFPUrCqW1cdTAwMWNJW8KtPUpcdTAwMTUpw4JrworDpMKbwojCg1xcZkDCq1x1MDAxZsOow6LCulbDvMKZwq7DiDHCg8OuK8KUwp18NcOtw5wnwo5BbMO8XHUwMDBlKynDolx1MDAxZE7DrMK4w4VcdTAwMWMqwo9NO3hcdTAwMDbClsKPTFZcdTAwMTM2wonDo8KmwoxcdTAwMWbCtcKRR0TCu1NXXHUwMDA2QMOwXHUwMDFhw616XHUwMDA2SsOywpHDhMOTwrvCjHR4wqzDvMOsLHTCjsOTQMKYTMODwqJUacODwqFuw5BVXHUwMDFjwqY5w751w4zDs8KKw4NPbcKSUSHCssKpwr3Dg8ObwoZ+w7Mpw7hQwqwnw7tzZkR2VVrCvsKWwrRmwq8mWkxpw6LCk8KgKUDDtkDDoVNcXGZbY1x1MDAxYsOWUcKiOlx1MDAwNnRcdTAwMDZcdTAwMTdcdTAwMDbCusK9Yk3ChlxcXFzChjZUwqFuRFx1MDAxZSlcdTAwMDNcdTAwMDREYMOZT1x1MDAxNzZ+w5RnworDrcK6w6R8XFxcXMOIN8KTPX3CqV7DocKwZmHDi8K0XHUwMDE2R0zCqDPDtlx1MDAxOCRBwpLDr8O3fcKrwpM+XHUwMDBlw4/CvMKKT1x1MDAxYkw8w4pGJMKGw5A9SsKbc8OCUcKDIcKqw7U9TcKpSVHDiENcXGY0JVx1MDAxOT1NTlx1MDAxMSnCuVHCilDDuynCo8Ksw4XDi1x1MDAxYsOpeTZcdTAwMGbDsHBqacOvSGzCqz1Kw53DiMK+w6Nyw4XCllx1MDAwNiw9QGBBWlx1MDAxZsOJWDDDtsOzTMKnw5jCqcK7w4HChinCrMOWI0rDo3YmdynDpFBcdTAwMDbDjsKBw4LDg2skw7VcdTAwMDbChE4pwqRFXHUwMDA2NMO1XHUwMDBlMsK8XTHDmVxcXFzDjitnf19cXGYzTj19S8KKw6TDgFx1MDAxOcOzwp3Cjlx1MDAwMUdCw7gjXHUwMDE5w6YuU1x1MDAxOE5cdTAwMTZcdTAwMDHDqmPDsGMxOsOiw6/DrsKFwqbDhVTCnMOlXHUwMDBmwrxcdTAwMTDDrsKtJsKsXyDDtsOXw7JUN1x1MDAwNlvDocO0w4jDv8KAw7zDlcOSPnPDiMKqwpPCrlx1MDAxMMOGw6bCssK+w67ClcKOwpo9TcKZXFxmwoc/w7NcdTAwMTjCgFx1MDAwNsOCSMKewrFiw7nDjsK2XHUwMDE0OjrDn8KiwpzDvsOpwofDjcOuR8KGPFxcXFxTwqDDocK7KzXCs8O1L8KAw4JLw5c7wr43ZsOPw67CujHCuS9yw4B8wr0xwq0rNljDvMKHK8OhQVx1MDAxM1Q9fXFRQ8KzTsOpw4rCh399wrHDgV/Ct0DDmVxcZsO4XHUwMDFmwpPDq8KJcTDChcOrNS/DhW3Cu3J8wpPCmH3DmEo8wpLDrsKXPX0ywrDDjcKiw6VZw6IsdcOfwrQtwqTDsjZoPFx1MDAxZC9XLVx1MDAwMjPCjMORRmHDmjnDn1JTw49cXFwie8KbXHUwMDE2acOiMMOGS0guwobCjlxcZsKnTsOXck/DuMKPXHUwMDE5WEJXw7hcdTAwMDY9QMOPwpzCisKEOsOqw4J8fXLCuSRpMMOJXHUwMDAydS5cdTAwMTPCu8KdKVx1MDAxNsK1KcKRw7jDssK2esOaw5zDr8KDS8O1XHUwMDFlw63CkHMpwobCr8KGwrjCjCldwrFtwqbDrcOpXHUwMDA3XHUwMDA0w47Dij1NVcOPVDnCvcOAwqvCjcOOw7ltwpDDlcK6W13CmCN2wpjCuD5BwrMvw4dcdTAwMGXCqcKlIMKTwpzDqk3CgFJSw7kswppKNXLDlMOGwoPDizHDn8Okw6NAXHUwMDEzwrTCumdlw69cdTAwMTgscsOCXVsvw6hdw4tJcMKgek/CqGTDnHA2YVx1MDAxYsO0w6E8w7hEw6zCg8OCVMKNwphuQMKZLsK4wqtcdTAwMDU7w55cdTAwMDJCw7jCiMKqw51QKcO4wqxXUVx1MDAwZj1NWFx1MDAwN3PCkFx1MDAwNm3Dv29MwqRrflx1MDAxMERuwp7Djlx1MDAxZMKXUcOHwo1cdTAwMTBww6jDhsO3XHUwMDA2w6PCr1x1MDAxN3JRw7rDtn41UFBtw6HCt8OSw45jXHUwMDFlw7LDrsOlw4bCs2HChlxcdsKsw4rDrzRTSMKOwrDCs8Ksw5Rrwo5cdTAwMTJ8w5zDhi3CvnU/wp51ZsOwNlx1MDAxNE9cdTAwMTNcXGbCrSjCrMKcwqtcXFxcw4NcdTAwMDXDosKtwrnCtGDCr1k5UsObN1x1MDAwMlbCjELCmi3CgD1KVFxcZsK8Wl4xfXTDq1x1MDAwNsOrw77CsGLCpsOKw6/Cm1DCu8OOOmF3w4A9TUpLw4fCjsOoU0NbL1ExdjU9SibCnlx1MDAxY8OQYFx1MDAxMMKgwpDDmjpWfn7DoMKKM8K+w4XChTs5R3tAYsKqwqLCh8KdwoVcdTAwMWHDucKbNz/CksOAw4PCv8KiJVZcXGZbw51NUMKtw5fDg01hwrXCgcO0w744ZFk9QMKoP8KOw6V+XHUwMDE1w5fCulljTHvClcObS8KRwo/CkFfDoMK1TsOFw4PCvHjDilAmw55cdTAwMTDDgMOYWsKfwr7CgsKiwrpULsORwoLDgV0ubFx1MDAwNsOnPUrDrj19XHUwMDE5w7FTcVx1MDAxMMK9ak0xMC9cdTAwMDPDkcK9ZXxPwqTDuEdrXHUwMDA1OMOowoTDuCw9TcKgeC/CtsK9R8Khw6Ijw67DrsOzUS1Dw4vDtcO2RnfDlytKwqDDkCfDqsKxdkZjworDoMKFwrXCh8KmPUpcdTAwMDM9fWtSRTbDr8K0w6Nzw6TDhcOgwoxcdTAwMDHDiD/DrsOSKsKrwpXDuXjDpi80XFx2RcOiIMOuwonDusOqw7TCtT19O2XDmcOiT8K7w65gV8KOecKcwo51w5zDsUfDgzzDncK/ZcKswozCqkBywrMhXHUwMDA0w4BcdTAwMDIrw4Z3MjZDUsOPNFx1MDAxOS97wrVPwpXCj1x1MDAxNGrDtnoxwrJew4zDi8KUwqoyUMKYXHUwMDFjwr5QwqbCg3hcXFxcw71cdTAwMWLDjcO2RsOvfWfDssOOcVxcXFzCgWvDpsOvw5ZLcsOHw7HDg3JcXGbCrzlywolJbsOMc8OmwqM6w5FRw4jCiDXDl2LDg3p1w7pcdTAwMWTCmXdpXFxcXMO4w7h3V1DDrcKZw7o0wqvCsyvDrVDDriY7XHUwMDE5w6fCk8OyP35cdTAwMTbCpz1Nw4RzXHUwMDFiw5DDo8Ouw7zCrMOrwolCwq3Du8Kuw7Q1w4BMfl9cXGbDsC4ow7HDukxcdTAwMDXCpcKcXHUwMDE1XHUwMDFjwprDocK8Rm3CqWorwozDjj1KNSzDkmouJ2PCvcKzw4LChcOGdSzDhHMqSlx1MDAwZsKla1TCrVx1MDAxNsKGw7ZcdTAwMTM8XHUwMDFiXHUwMDA3wrx/blxcdMOqcsK1w4LCh8KOX0rDjELCin5qwpnDkHJcXGZFSkjCiVx1MDAwMsK4wrltTMOhR8OcS15cdTAwMWXDrmdtw5RIw5rDk8OuwpjCm3dcdTAwMWJBQsOCPFnDiEZrwrrCv8OTRsK7K1rChsK4XHUwMDBlwrxiwo9Lw4FcdTAwMWFPw7PDj8KiSULDnMKnLltcdTAwMWRzw6FcdTAwMDHDg8KFXHUwMDAxf8OmXHUwMDA1Tk7DizUhwro7QFVdccOMwoNgfD/CqExcXGbCmVxcZsOGWSnDiExcXGJcdTAwMDTCqMO6dsKqXHUwMDEww6t/woV6wqbDvcKow5pcXHZXXHUwMDFlJGtxw5fDtcOrdVl9OMOLwocnw6rCuFx1MDAwMcKxQsOTwqhuQWvDv2pJMMKuRcK+M2rCvynDj8KOwphrw4DCgsO/wq9eMlJrRMKgw5DDoFx1MDAwZsOawpnCv8OTwpdDXHUwMDA2wpdvXHUwMDA2Mlx1MDAxYVbDhsKsTsOtw6PCn0nCllxcdsOmRsOGJsKxwpdcXFxcWnFcdTAwMTBuJj19OD53w4FcdTAwMWFGasKXTTDDnzcrX8Kaw59pwo45w4DCtFx1MDAxMlnCgCzDksK0TjLDoU1vUXPCmsKlXHUwMDAzK8Kaw7fDlsOvXHUwMDE1w4N0ZizDhnDCsjFOOntbQ3zDg8K7w7NcdTAwMTLDilx1MDAxMsOKw6DDjmDCrzpkfE/CunLCgcOaw65fXFx2w7XDuMO+wrDDlTdOXHUwMDA1ZsOtRcOWS2p2w4FiXHUwMDA2XHUwMDBlLMO3U8OyMMOKw707JnrCqsKXWDPChcOYfD1NwoQsw7LCvMOTwrfDgy3Du8KAclx1MDAxMklhwpfDscOyfsOCOErCgsOBw7bDh8KZXFxcXFx1MDAxZD1KwporfcONw6LCrMKtWFx1MDAxNMOEw6UkXHUwMDFmw7dcdTAwMTbCv1x1MDAxZcONTE81w4fDg8OkJMOrwop6w4PDg8ORwqLCgT5Cw6RLwpRcXHZvwpA3wpozwrrCt1x1MDAxNGJle8OGOMOJw47CjcKZXHUwMDE0c8OKNcKYa3d9XHUwMDAyeyzCuMKywqQ3Xlx1MDAxZlRhXHUwMDE1McK7wowgw5DDmFx1MDAwZlx1MDAxMHhMwp1BwptpwpZKwrLDssO+b8KOXHUwMDA0wrnCtm/DgiBdw51Mwog3wqrDocOdw5M9fVx1MDAwNlx1MDAxNMKOXHUwMDE0fHvCmMKYOcKNLVx1MDAxYVxcXFzCpWlETjdcdTAwMDHDlnJ7w4dqPUDCkMKtalx1MDAxOCDDkMKtw7Bfw4NkJcO7X8O/XHUwMDFhPlx1MDAwNn4tJGxISD7CmHo4W8KzXFxmXHUwMDEywqTCicOuw6vDu8K0ZsKPecOow5DDhWPCu8OOw7JcdTAwMTVKO8KiwqYkUj1KPMOjWMO1J8KZwpR5XHUwMDFlw7LCk2TDkcKewprDo0A8KVxcdMOOw4pcXFxcXHUwMDFmWsOfVMKxLFx1MDAxZU3Dg07CtMKUdcO0wpd3w57DucO+wqTCtivDvikuwoXCjMKhNVvCsCjCocKvccOMJz1AbsORwo8nblx1MDAwZS9uwrXDozVAesKLKFlcdTAwMTLDr8KYdMOCPGzDmlx1MDAxOSrCnDHChzZdw4Fbwqo6cHhPJCnDiUQqw4RVejjDgsK0woxNPUB1w7osRX0xwpo5wpo0a8OFZCbDkcKHTcK9w68ow483bC7CnXHCuF3CocK+w6vCgcONLVx1MDAxMMOMw65tXHUwMDFkXFx0w6gxwpPDuVx1MDAwZnZHwrJcXGYsw4JqXHUwMDE5Yn3CtVx1MDAwNXvDhkU/TTc9fWE5wq3Dnlx1MDAwM8O6wokmXHUwMDExw7pLw6HDrTBcdTAwMGbChsKdT8KAwoFcdTAwMWLDnMO8XFxmw5PCk8KOQ8KVw7jCoMO8wqrDp8KEw7fCi8ONwoAywqrCv1x1MDAwMlnDusKPTMKXRUbDg8OCRHXCuMOqwrnCkzFwwrRlwpLCrTBWQlJbeHZcdTAwMWbDomhWwpdcdTAwMTR4VjBdXHUwMDEyQMKtwofDjDlYMVx1MDAxMlxcZnNWLsKFwoxPw4TDpMK7aFjCkU88wrlcXFxcXsOgXHUwMDA2aFx1MDAwMik0w7RcdTAwMDNIw47Cv8ORMXQvw4HCuynCscOBwrVhwrhNXHUwMDEwM0NRw5g+wqvDgcKzXHUwMDAywoU1w44pw73CrsKbXHUwMDA3W1xcZks9TVBZOnk9fcOiwrnCisOZccObezhtMcKKMMK8wqPCnFx1MDAwNsKTwrNcdTAwMWJxMD1Aw6NcdTAwMDfClGNcXHRUQ0k9TXDChMO/worCvkBcdTAwMThcXHZQWmtRbWbCnXDDvFxcdj1KQMKSXHUwMDBlwqBUwrDCsMK3bmXCnMKGwq1Hw4Rpw7bCvcOcw4vCpsOVPi57VDRcdTAwMWNcXFxcOiNZw4/DrsOBwr89TVPDvT55eMKEcMKAwqvDgMK8aXzDm8OUwo5/c3TDtMK7NFx1MDAwMWbCtMK8wq3DiMOVNjrCllx1MDAxMDNcdTAwMDXCo3TCsiXDjSVcdTAwMTJow5PDqXzCqcOPwqVcXHZGRsOsOVx1MDAxM8Opw5rCkSh9L8OrY8KEwrTDvjU+N0FOOSYhwqlcdTAwMWJ7w4k+wobCq23CnMOFYl9cdTAwMWPDmcK5wrAuKXRcdTAwMWZ0cyEgciHDssOyJsK7XHUwMDE3KE1cdTAwMDFPUcOVXHUwMDFhXHUwMDE1w6lZXHUwMDE4wq0tXHUwMDE4wphcdTAwMWPCqMK8L8KibjRIXFxcIsKhLSFww7JGw7ZzT8OjTEPCvVx1MDAxNMK9KCVBXHUwMDFjcFjCssOdXHUwMDA0US/CoyclwoFww5DCgcOgw6Fxw5hxeCDCuWwhw4lYSFZrK1NcdTAwMWHCjlx1MDAwZcKPUsKTb8KjOj1NSMOoworCu8OUJ1x1MDAxOFx1MDAwNUHChSXCplJfVMOTWcKrwoAnw6XCu8OcwpvCksK4w6ZcdTAwMDFRccOvesK7wqfDsVJHw5TDnFx1MDAxMcOOXHUwMDE4XHUwMDA3w7rCucKnOSV8w5LDl8KnwpkkwqxcdTAwMTPCukgvw6g/TcO4e1x1MDAxN8KjXFx2b0nDlMK8w5RcdTAwMTPDncOOXHUwMDA2wpLDlGHCgsO0w7/CnMOyOm9iw414d1x1MDAxM13Dj8KRIcOXXHUwMDE3W3pXXHUwMDFmXFxcIsOxXHUwMDAzXlPDjzVpJcKWwoo9QMOzwrfDqMOHwqfDr8O+O1x1MDAxNFx1MDAxNlxcdFx1MDAxMcOnXFxcXMOcXFxcXMKEw7p3wq7DqcKBw7bDo11cXHTCqsKZw4TCvmhPdWdcdTAwMTfDpVx1MDAwN1x1MDAwMcO9XHUwMDExdW99XHUwMDFjwrppwq/DqMKFwqfCi3x4wpwtI1x1MDAxMT8pw48hTHQgw5ZeXHUwMDFmw59cdTAwMTltXFx0w4FoU3TCucOcLFx1MDAxNFx1MDAxNmVcdTAwMDTDocOewpnCmcOJNcKPc3nDgMKUw4HCgMK6Z0wlXHUwMDE5KE9Dw5PCkcO+w6o9fcONKlx1MDAwNiRcdTAwMDMhw5hcdTAwMTnCg8KJMSZZN8Odw5fCvcOTwpfDvmF0csOBw713XHUwMDFlIynCkmxdw5/Dl2HCh1TDn8OSwqp0XHUwMDEyw6VcdTAwMWJxS8KpSlx1MDAxZsKyXHUwMDA0IF1pw6XDkXl3XHUwMDE0XHUwMDA3XHUwMDAxw4FTwpfCp2nDj1x1MDAxMMKewphIw6nDkcOZeMOkPUrDncKGXFxcIsOEw6hVw7zDvWjDkS5XXHUwMDE3ZVlnw6XDvcKQXHUwMDFhw7TDqHRcdTAwMTPCrsOZw6UkwplcdTAwMTjCvcK/wpgnaMOrJsKSwonCvMO+JMKJVcOewplcdTAwMWVfw7xcdTAwMTXDpTkyUsO9w6lQaXdcXGLDg1x1MDAwNl9jwo/DnMO3wo7DkHPDjMKzw4EzXFx0XHUwMDBlw5hcdTAwMWJkPU1uwo3CnT1NwrFwNcK2JsK2aENYXVx1MDAxZVxcXFzDpsKVWsOvwqrCmcOawoRcXHTCiCnCqsOIw4FcXGIzwofCmVx1MDAwN21kJ8KfPUDCk8OVwpTCgcKSw6fDu0bDi8OjcW1/TcKFJ8Ksw4TDm8KEw6hcdTAwMTRjP8KXwr/Cjlx1MDAwZsKHdMOpP8KnPsOVL0FcXFwiwqYoelxcYlbCr8KdXHUwMDFjfFx1MDAxY8K2wobDm1x1MDAxNmjDg8Khw7xcdTAwMTDDvMO7fMK1XHUwMDEydXpsw6HDqFx1MDAxNsOpwoXCpEkhwpIhwrZcXFwiXcOdJX5cdTAwMDFcXHRcXHTCiMOpNcKpRyQjXHUwMDFkwrHDscK5w5xcdTAwMTlRw6lTwqZFJ8KfXHUwMDFmw4HCocOHwojDh8KdaGklXHUwMDBlXHUwMDFiwpPDu8Oxw7g5w41oXHUwMDE2wqXDmSXCqFx1MDAwNMOlw7jDoVx1MDAxYsKZwpnDpkMkXHUwMDEww7ZcdTAwMTXCqlx1MDAwMVx1MDAxMcKIN8Kpw78oXFxcXCNcdTAwMGbDuUFcdTAwMWTCiFx1MDAwMsOoYiHCpsO8wp1cdTAwMWZcdTAwMTFcdTAwMTbDncOGwpHDgMO5SGnCl8KiRCnDviBcdTAwMTPDucK4wp1HN0fDr0fCjWXDgjhcdTAwMDU4XHUwMDE3OMKowrF+McO/w5tpwrM0XHUwMDFjwppaPUB8TsKaw47DuMKZwoh6w4A/STtOwp7Dn2HDv3t7w4rDqGbDp8KjKFxcXCJcdTAwMTh3VVx1MDAxMX/DgXhzwrlJZVRcdTAwMDLDscO9w4/DicOfw4PCu8OYw5DDlEx5woDCtGRSeXtRwqtcdTAwMDTCqsOyw4nCtsOGw5hmMkV+wofDu8O6eMOTXHUwMDExw4HCtMOnw4hcXFxcJ8OBw5slXHUwMDFmw700woBwXHUwMDE4w4BcdTAwMWLCvSnDl8OUwpZcdTAwMDfClSB5w6h0XHUwMDA0YGTCtMKnw4BoMFx1MDAwN8KHwqbCoTFfwrJWw47Ck8OjSW0xJyRcdTAwMThoJsOlbMOZXHUwMDFlwqLCrUjCp8OFw6vDvMOpw4/DknorXHUwMDE5w6HCoMOpwpjCo8KFw4jDqF7DmXXCncKMw4HCtlx1MDAxZcKZwqXCp1x1MDAxNMK1woPCqsK+w7jCiSEowql/w44lw55+XHUwMDE3w6Q3wq5gw5xpXHUwMDE2w7HDtMO6wqnDp8KnXHUwMDBmwqQkKMKuwqLDusOpXlBCJ8OMPsK9XHUwMDBlwo4+aMOQXHUwMDFlKTBcdTAwMWbCvMOePlx1MDAxOcKnblx1MDAxYcORSSfDvVxcYlPDksKFZVx1MDAxNXrDh8KrXFx2XHUwMDE5L8OcaTTDnsKpwqFcdTAwMTU+wqbDgcOAKEfCkVJcdTAwMWR9T8O+JXXDiXZDYsKKw5dNwp7CiXVTXHUwMDAzVcODwpJcdTAwMWbColx1MDAxZVx1MDAxOVx1MDAxNcOdQiN3w43DtcKhXHUwMDE2w5nDmcOEXFxcXMKLLcOIwpV8w63DjmnDtShcdTAwMTRBJcOFXHUwMDE4w79IwozDvEfCkSHChz1Aw7DCicOfwrHDkMOkwrVcdTAwMDdJwqhcdTAwMTVhf1x1MDAxMHfDgsOWasKEwojCtFxcZlx1MDAxYsOxwqxcXGZ9w7hqwr9qXHUwMDBlecO7w6xlZsOdwqTDt8KrwpVZfnZcdTAwMDdtUcOAWVxcdMKnXHUwMDFiw5PCsMOnXFx0w6JTwp9FwrjChsKpw4/Dklx1MDAxMTzDhnrDpsKiXHUwMDExwq9RJCfCsG55w5PCh8KlPUpcdTAwMTR9T1x1MDAxN2vDjVB3woXCpz1KXHUwMDE0NT/Dp8KoaMO7wqNcdTAwMWTDoMOHwqPDlsOLw7XCtnhYwojDosK3wpdcdTAwMDFgwptDw4PChMOmwqYlXHUwMDBmXHUwMDExwoRwwrjDqMK9w7TDgFx1MDAxN2LDvcKLZsKKwoJsw7PDpsO3w7HDmMOpw77DukVCYmjCqSjDgMK9OVx1MDAxZcO3w4PCizPCrzXDocOIw6TDkcKRXHUwMDEwO0LCvWXCqVx1MDAxZMODUcKEXHUwMDEww5jDqzMvNcKhw4bCo8OWwpNcdTAwMGVcXGZJwofDmsKKXHUwMDA1XHUwMDAzcVx1MDAwNFDDuMKowpsvwrU9SkfDpMKQw5jDiyNfNzFYwp7CkkMwcHdUwoXDpCfDvmfCp8Oda2hcXHYvVcOEw5hmX1ohwrfDtcOWw5RcXHTCnz1Nw5PDkMKowpp8XHUwMDE4XHUwMDFlf8KlWGZawqE6wrhCacOPwqhcdTAwMTnDv8OBZHDCmDPCj8OdYFx1MDAxOMOpKMO8XHUwMDAyXHUwMDA0wo3ChsKLf8Otw6g1w5nDn8K2MMOKW8K9XHUwMDExwpfClsKjwpY9SkbDhGTDjcKLKcODZcKZwrbDhsKwUMK/V1xcdMKdXHUwMDE4XFx2cV3CpVxcdlx1MDAxYVx1MDAxYk9cdTAwMWbDpcKEw4lEN8K0w7TDg8OjwpQlwrPDoFx1MDAxMcOkw7AtTcOQWVx1MDAwNcKcXHUwMDE2XHUwMDFjdVXCkcOJwrLDnsOsw7/CpVnDqDQ9fVx1MDAxYcKjXHUwMDBlXHUwMDFkwoNcXHbDnSzDiVx1MDAwMcONw4otccOrLHfCqF45w6tcdTAwMDPCkTRcXGbDuUzCr8OtZnVcXFwiwrJcdTAwMTlPccKyXHUwMDExw6zChcOKwqLCt1loJXbDi3PCi8OXw6zCl8OiwplfwpllwobCtcOAwqY6WT/DmFjCgVx1MDAxND7CtsKuXHUwMDE1XFxmw57DssKlwphVXHUwMDA2ekbDjHJcXGLCnMOIwqXCnDvCpiY+Un/Cg8K/UC/CmcOoYcOJZm/DiD1AwoHDgsOOw6J9O1x1MDAxYsOEPsOkwqLDvcOiYT/DqyfCpsOPwp90woVcXFwiwrU9SsKnw5VLQcKyw6HCgMKLwrrCrDVZw4nDkcOtw6djw4klw5bCsD1Nw73DtMK4w7TDvcKieT1KwrLDpsOhMVxcYm1TRnzChsOTw6LCvMKZVsOCOcKhIcOqw6PCkTRNP8OaXFxmNcOvQCh5KMKmw7JcdTAwMDHCl8KvXHUwMDFkwprCkMK6wqzDkcKKw51Kwq55XHUwMDFjXHUwMDE5w6zChS5cdTAwMTHDuG0owoBUw4BVwrBcdTAwMWFfI8O5PsKQw6pcdTAwMTlQXFxcIsK2wrEmwqd8ZiojJ8KBYHzCuEvCtEE+woFcdTAwMWTCvj1KXHUwMDAxQ8KiIcKLw7IjNsKvJ3RhPiPDpmMmUsOow4Jpw4DDpsK7NMKbdMOXdMK5L8OHwqxIwq8wI1AzwqHCsFXCg1VcdTAwMDNSwrJcXFwiw4gsfMOMwpE0XHUwMDA1wqNJwqLCpcK+XHUwMDAxU1/DslFcdTAwMWTDrS55YsOYw5bCsMKmXFxiPMKGwqohMDU4XHUwMDFhUWvCqGlVRsKtRnfCgDh7wqhVw6lBXHUwMDE4w4Ytw6Nmw61cdTAwMWLDjcKAwpvCtsK8NVx1MDAxYVvCgjpWw5rCrsOmw4bCgVIsKMKDVUM1SFx1MDAxY8KfwqLCvcOiZiVTUsKrXHUwMDA2wqXDin5vasKyQSzDucO5XFx2wqFrXHUwMDAzw5ErXHUwMDExwpnCnU/Dn8KuXHUwMDA2YsOrXHUwMDAzw7HCrMOHwrRpXFx2w6dcdTAwMDVLd8KScMKrZcOtXFx2SMKbSMO4XHUwMDFhXFxiXHUwMDFjXFx0wqxcdTAwMWVewqvCmcObw7R/w7TDsT4kw7XDuXrCklxcdsKZXFx2XHUwMDExXHUwMDFjw5nCrcK+XFxiXHUwMDFjw7FUwpjCq8KewrcvXHUwMDAxwqtNw7tcdTAwMWFcdTAwMDY2wq/ChSXDgH7Cj8OwwrlDZ1xcXFx+Ylx1MDAwMsO9w63Cn8Kqw53DjcOnw4fDl8Ofw4/DozN+w5LCpsKTw4RcdTAwMTQlXHUwMDFiJ8OtXHUwMDA1w5EhWMOdwqXCoMOZwolkw53CpnR0dsKCwrohajE1bXc3wp9vwqtWw5/CqT1Aw4ZPw7XDgcOYwobDqFtcXHTCqVx1MDAxZT1KXHUwMDAyPUpcdTAwMGXCm8Obw5pcXGbDmsOoPUpfw5d0wpTCsU5pdXXCnXVcdTAwMWHCksODwrE5w5tGwpLDiMOJPEI6w5pRT0rDqlx1MDAwNsKhdmrCrsKPKFx1MDAwNj/DncOhwoFJacKcw6HDmMOkwpVcdTAwMDXDu1x1MDAwM8KTU8OzKyslXHUwMDE4SWfDpCclXHUwMDA3PU3DscOhwqlpwqgmw6vDlsO+JE1xXHUwMDE1XHUwMDFjOVx1MDAwMcOZw4LCg8KnXHUwMDE5w7LCu1x1MDAxN8OFXHUwMDE4XHUwMDE3w5LDiSfDp1x1MDAxYsOyw7tcdTAwMTfDhVx1MDAxOGjDo2nDlcKnKMKzJVx1MDAwNcOow7nDh8KDw6nCp1x1MDAwNcOWwrE5wpDCmcKkwppcdTAwMTPCmFx1MDAwN8Ogwo1pwrnDuMO4aSQ9Slx1MDAxMsOWXHUwMDBlXHUwMDBlw4RcdTAwMGU+XHUwMDFkwqrCqlx1MDAwZcKqwpfDgUlcdTAwMDdcXHTDoMKfw7/DtsOew6p3acKhw77Dt8OYw5XDqSnCisKgXFx0XFx0XFxiecO0w7zCisKTXHUwMDFmJ1x1MDAxN8OjwplLaFx1MDAxMsKYRVbDrUcmZj/DrlExZ0k4wrnCgD1KOFxcYknCssKATTHDqWXCoE5Cw7XCusKlaF7Dr8KDw7NtXHUwMDE2XHUwMDA0c23Dq1FPWlx1MDAxM8OQw7VXXHUwMDBlw6TCpknDsMOVw67CnTHDkcOsXHUwMDFmwqxIwrvCrTdLXHUwMDEwwqhFPUolcG/CssKtwpE9fUbChlY5wpwgw4QwMcKFw5xtZsODw55FwqfCp8KpdMKnXHUwMDA3LcK8wqFyNmjCtFx1MDAxNDDDjXw4wrLCpsOqXFxiXFxmaMKBw6vDklrDj1xcXCLCvsKQKcKOXHUwMDA0w4Nxe2PCpsK0XHUwMDE0Lm3DsMKDwrPDjHArwp8sI1J9w74sSsKjR8KVw6FLwo3CvFx1MDAxZMORWVxcYsOaw5nDj1x1MDAxN8OzwpFPZ2UhS1xcdsKzY8OMwqPClcKgRsOpJlx1MDAxYcKtNMO+wr/DrDvDm8K9VMKQw5hcdTAwMDLCpFx1MDAxZVx1MDAxNMO9eMOow4DDjzVEQ8OBwodbwqF3fVx1MDAxZMO/cUnDv17Dl8KGMcK5QsOBe8KEw53ClsO9wrvDlUfDh8KmP33CgSnDmlxcXCLDhsOUwqM3d8O3woFIwqh6w7rDnMKcXHUwMDFmR8ODw4LChVvDlcKoXHUwMDA1KMK9XHUwMDAxXHUwMDE5VcOUw4LDpcONO3vDg8Kvw73DgcKWZ8KkI8OrMX83fXXCucK7W8ODwq9dwoFcdTAwMTdiwqBcdTAwMGZcXHZxwqvDi8KtXHUwMDAxw7rCm1x1MDAxM8Ovw5/DtWBJYsKdXHUwMDFkXHUwMDAzQWN/w50oXFxiw63CjF10XHUwMDE1woBhSGdcXHQofsOKwotcdTAwMDbDuT19wphSw5PCh8O7wqJcdTAwMTbDvCfCocK0RHAnZ8Ktw7BQQcKBWVx1MDAwM8KmXHUwMDEyJlx1MDAwN8OhwpRkQCdnbMKNUcK/PUBqwqjDmWYow5LDllx1MDAxMGIyN0XDgcK7woHDp8Kmw7HCs8KVwrlkw6t7wpFcdTAwMTU7XmDDn8OSwpjDv8K4XHUwMDEww5XCuWnDlMKUwoJkwqU4wrl0WcOWwojDoFx1MDAxZlx1MDAxMsOPJUk+w7/Ctlx1MDAwNsKsw6xQw45/w7bChsOkXHUwMDEzw7rDr3FJfzbDh8OCwrszwqN/XHUwMDFkXHUwMDE0w6FHYsO/IFx1MDAwZcK9wqzDnMObTV3CjMOswo7DuybDn8OlecOgaCPDlsKQZsKqQ0PDhXt+w6fCmlx1MDAwN1ggw7TDrSHDtETDgMK4w6xcXHZbw4NPw53CgFx1MDAxN8KuXHUwMDFlaVPDlMOFYsKkOcK5w7NSw4fDn8KUw7FcdTAwMWJVwrloUsOTw4NiNjQ2ecOHXFxcXMKnU8K+KVxcdnFfwpc1wqXDmTs9TcOdw7XCkVx1MDAwMcKZacKbw5fDjX1rw69cdTAwMDbDr2lmU8KZJEzCusOxXHUwMDFmwrjDuXTDlMKgwqhLwrvCm8K9VVx1MDAxNcOAwpdmwqZcdTAwMTdcdTAwMTNBX2fDlcKrwpLCgsKWdHtcdTAwMWbCrMKfw6VcdTAwMWLDl1x1MDAwMURQLcKmw63CvTXCkFbCiMOpXHUwMDE1XFxcIsKvXHUwMDA1w7nDqcOUw4U2NkLDhcKEelvClVx1MDAxM8Oww6dOwqnDlHB4w6xcXHbDu8K9wrQ9SsKwZ8K6wojDkcK0w4DCr8K1Wk5cXFxcS8Olw5LClFx1MDAxOFx1MDAxOMKdIWnCsFLCkTMoacKnQMOtUXXCilbCgsOKw5LDjsOiRMOUw6h4w6tTXHUwMDE4bcO4w4k8w5bCsHTDtEJowoVcXFwiw41+wqDDk8KWQMO+VD1AVEDDrGfDsCxBwpIww7LCnVxcYnrCp2ZcdTAwMGXCkTN4UsK/VcOIPMOCUsKIwrBRKMOPd8OUYlx1MDAxYsORwq/DucKUw5pEwq/CrEl0w4jDulx1MDAxZVJTwrzCtMKRVsOmwrl+ZknCold6wqc3woFFw45kwrFcXHTDrMKJN8KZT1x1MDAxM8KYQMKGKMOJwp7DoFx1MDAxYVfCv1ltwphyKGYvaSPDh8K6XFx0XHUwMDAxwprDuS3DrzHCtMOFL8OJPsKhNVxcXFxew4HCk8KmPUpcdTAwMWLCv8O4w6tFw7Q/w58/w4fCv2A1clx1MDAwZljCrDTDusKCwrrDtcOpw5FcXHbDkFPDmWjChsKXX1l2XHUwMDFhRMO0wrvDilJcXGbCvVx1MDAxNFx1MDAwNMKCasOYw7lcXHbDpVIwwp3DhlxcXCJZwoHDrsOGI8KhZnPDn0BcXGLCjizCj05cdTAwMGbDs8Ksw6bCojTCvEvCuU7DqVx1MDAwZsK0w4jCrGfDtMKlwr7CoVTDhMOqZ1x1MDAwZcKUWsOGWcKuwr5zXHUwMDA0XHUwMDBlKMKOw6hcXFxcXHUwMDFhw5nCgMK7wprDlzpcXGJ5fH58Tlx1MDAxOUDCqV4jw5xUw4dUcHRRwr7DnsOLO2Mvw7nDpMKqZjJcdTAwMTHDjcOKNsOwesKMLXfCjcK3wr/CtMOcVMOjdDPCtMKLwqxbdMOPdMOOc8Ozwq9cXFxcwrrDlVfCpk/Dv8OVw7Q5wqrDkcKMw5jCkWvDtDFKwodsTjFpw4smw5bDsMKVw6tnw4/Dh8K0wq4pwr96wrxawpLDlMOywrFcdTAwMGXDrMOFwqnChVx1MDAxZsOgwpRpwpLDuMKUwqvCncO4dMO8wrTDvFx1MDAxYXdcdTAwMGVGL8KZXHUwMDAzLFx1MDAxM8KhbMKTc13CnSpiRDB5wrnCqsO5LD1KTMO7w4HDr8Kaw4nCuMOEw6c0wqNhwqNFw7PDocKCXHUwMDE4XHUwMDBlwoXCpsKgXWbDiTYpwpkwM8Okw6rCvU3DolHCgcKdw4lWcsKfwrBcdTAwMTRKw795wrREdMKuXFx0w6tcdTAwMDbCp07CiU7CoVx1MDAwZVx1MDAxZMOAXFx0MyZNXHUwMDA2KcORO1x1MDAwZSnCqVx1MDAwMcKsw4tcdTAwMTPCvsKBwqnDjMOAw4rDgsOVbsOOPlDCojZcdTAwMTlKY09Jw6zCrWMma8OUd8Oqw4s6XHUwMDBmVybCscKawqlaIcKYwrwsw6PCrcOOesOOJHbDk8KvwqXDhWJcdTAwMTEpwqfCtWJxwpjDhMOIRMOhP8O8wr7DmFRZwoHDvMKqw7Akwr1cXGbCnMOPO8Oqw63Dv8O6wq7DocKqKMOBVHd+wqArwp3DrnLCs8KSQcOzL2s+wqPChMOuKSrDtyDCkMKiTcK7w57Cgkxuwr3Dr2ZGK2RtXHUwMDFhwoAzJE4seGkuXHUwMDEzw5FTXHUwMDA3fVxcXFxcXGZOb8KiVVx1MDAxMFxcdMKPw6JNwrZtXHUwMDEwwpRiYMKrwpVcdTAwMGVUw6NMw7hcdTAwMTNSP8K7NMO7bk3Djy/CqsKzMcK6w6XCjFx1MDAwZsKGWsO0wpDCqnPDkMOzwqFcXGZpw6fCnFx1MDAxYsOyXFx2XHUwMDA3N8OVwoA9QEBcdTAwMGZcdTAwMGbCkMKRT0/DsMK3NkJcdTAwMTJcXGZcdTAwMTZcdTAwMTLCisKUwozDisO4w4HDkCQow6bCqcKfXHUwMDE1XFxmw4NtwoXDocKWwoZow5VWZVfCpMOuXHUwMDFhw6pLw4jCuFx1MDAxMMOkwoQsY8KDQ8KTwpQhwrzCn8KlIF9cdTAwMTdcdTAwMDTDnsKhXHUwMDAxw4NtXHUwMDExeEg0woomw6bCrTXDsG5Bw7jChmjCmVx1MDAwN8OmwqTDtCHDmsOnPUrDjj7Dh8OGLMKXw6PDj8KjJsOQwrbCsMONMcK4w7h4XHUwMDFiXHUwMDFiwq3DoMOIw4x3XHUwMDA1wpDDucOvVcK4PUDDkcOvXHUwMDE5clx1MDAwNcK8wrzCvHzDt1x1MDAxZsKwf3/Dk3vCg01cXFxcwrjDuHjDh1x1MDAwMsKgwpVcdTAwMThcdTAwMTbDkMK/w4/Dk8OAPMOZwq7DnVxcXCJcdTAwMDVew4rDoMOew5JSwp9ywoxqwpTCm8KLwot0esKMw7fDtl9xOMOXw4bCh8O9w6BcdTAwMTchw5pcdTAwMTAjT0PDkC3Dsj1Kw4LDhMO+wrchw511wrk9QMOPXHUwMDAxTj1Aw5BHdGjDpsONUGNaSsO6w7nDucKmw6TDucOAwr4qdcKSw4/ClT1KXHUwMDA1XHUwMDA2XHUwMDA2w5kkPUDDucKwXHUwMDAzQ0N7U8OzOcO0w5E9QD/DkMKAecOTw5d1XFx0W8Ozw6/Cpn0lXHUwMDA2I3HDgcOBw47DiF5Bw6nDqVfClVx1MDAxMlx1MDAxYsOEw5jDn8KfU1x1MDAwM8OVNMONUEB3wq5cdTAwMTjDicOPw4/CicKqbybDkMK+wo7DgsKUwovDoMKfPUDDmMK+XHUwMDBlMlPDk1x1MDAwZcK2XFxmTMO1w53DpMO6XFxcIiHCqDEhOsKRZcKewoLCtTkowoYhPlx1MDAwNThcXHR5OVxcdjgow6ZjPEvDucOHXHUwMDEzZkDDk8O2R8KmXFxiQcKNVnXCtsKyXHUwMDExwqXCvV89SjbCrlMyOMKtw53DkMKZw5/DtlTDuMKOwqLDiMOMPMO1R1x1MDAwNjhcdTAwMDE3KGo4w4A3YW1cdTAwMTdcdTAwMWHDt8OAwq5kw6JJwq/CrUnCn2s4wq3CkcK9dcO9J8KGJlxcXFx4wqs7wrtpXHUwMDA2wqd6I2nCkTsvwrgywpNcdTAwMWHDhMK1wpcwwoN0Q2jCpsOCYkw3Z2FIw6Jrw47Dk0LDuMK4esOPfMOWwqHDusKXwopVw57Cq8OTPUDDkDMsw7wswoXCrMK6YMKeXHUwMDE5wqpcdTAwMDTCqsOywolxeGk/fMOww6lJecKAMVx1MDAxNMOywqpbXHUwMDFlw5bCiFLCqsKawq7CvScvXFx0XHUwMDEzXHUwMDE4SVx1MDAxOVgxw6NcdTAwMDLChcKFw4LDg0JDRFx1MDAxMlx1MDAxNVx1MDAxM1x1MDAxNMKSwpXCq8KXw5LDkMOUw4zDlsOOMsOHRS/Co8OMelx1MDAxYcOiXHUwMDBlWSA8wqUhw7rCvX/DucKAw6lUKFpcdTAwMWYlwr/DiMKrw7xfwqzDg0TDs8KkU3BtdyfClmA3XHUwMDE0JFx1MDAxZlx1MDAxZMOxIcKhYVjCh8OmwprCoFx1MDAwMVx1MDAxMsOrSFx1MDAxOMKYJ8Ofc1xcXFxcdTAwMWPCvjnCn8KjQ8KfXHUwMDExXHUwMDFlw4BcdTAwMWNcdTAwMTbDu07Dh0dkPsOfNcOSw4LDlFx1MDAxZcOLXFxiXlx1MDAxYcOTwoHDvsOhcVE5bFx1MDAxM2XDi8Kew7PDvn/CmcO0w4NcXFxcXHUwMDA3W8KwZDNcdTAwMDHDmcOYdMKbw4/CmFx1MDAxOcOSRj1NasKfw4bChsKBQzkoIMKOwoV/wqPDmsKZw5NcXGJcdTAwMThcdTAwMTnCmcKZR8KEYMOnYmXCm3bDmiEqwoV9Zzc/T8OrwqnDncKnw41cdTAwMTdcdTAwMDRcdTAwMGZcdTAwMWRXwrHDocO3dUVkw7rDtGp9w4NZUW3CtFx1MDAxOFZcXFwicGnDo8KiwqJcdTAwMTXCtMKDwo/CvT19w7HCuDbCjmbChiRcdTAwMDPCgsOCQlx1MDAxMsKUw5PDlVRVXHUwMDFjP1x1MDAwZcOiwrF5XHUwMDE2w5PDiX/Cvj1KXHUwMDE5w4rDucORYEHCtzxkwoNqLD1KcsO1b0ZVw7TCh1x1MDAxZsO/fyg5wrnDuMOPZcKUKVxcdF3DoWFcdTAwMGXCsTnCoFrDv8KvRcKjwpp4woTCtCTCpmbCqcOaw4tcdTAwMTQpXFxiw70nXHUwMDFjbsKXw47DlcObwrA8w6bCgMKmw5BcdTAwMTUnXHUwMDE3w43DlVV9w60nMFx1MDAwM8OFXHUwMDEzwpXDk1NcdTAwMWLDk8OpwodcdTAwMTnDmcKXVDZcdTAwMTfCmcOKw7TDgUFcXHTDvVx1MDAwMVx1MDAwNVx1MDAxZiNLwojCh17DsMO9dHHCr1V/wolcdTAwMTnDicOJScOJwoZcXGLDqcOMVsKbw4LDpcOXwrvDgDR7XHUwMDFlwok5YXZcdTAwMWPDoWF+woFcdTAwMGXCu0xrw7PChy7ClMKJXHUwMDAywqfDv3ttXHUwMDE3wr7Dk1FXwpVcdTAwMTB2XHUwMDFjw557UcOVwqvDqlQ9TcK/fsOlZ1x1MDAxZsOofMK1JMKoTsKCaifCmMOZw57DgcORwqhpXHUwMDA3aHR5w4AkXHUwMDFkXFx2wobCr8OFw6Rew78nXHUwMDEzXHUwMDEwXHUwMDA0w7tAVMOcfiFcdTAwMTXDtVx1MDAwNVTDsTjDvMK9w43CpGhcdTAwMDdnw6ROXcOywoDCh8KwXHUwMDE0JyBcdTAwMWUmw4DDtMKSeT19T8KTXHUwMDE0XHUwMDE5w7nDocOhOFnDuDRcdTAwMTPDkcOtwrHDlsKfwqFoYzHCgcOmw7Z+XHUwMDBmMsOgw6jDqcOowpvCmnsgw5oowqTCtC55w6fDqWlnZMOdw5NcXFxcPUBcdTAwMDVswofCq1x1MDAxZcKDwqTDpcOow6jClmXDmlLCpcOiw53Cq1xcXFw7XFxcXMOWXHUwMDFjK8Ojw5XDjMKEwofDkjl/w4TDvsK5w43Dq8Kmw5RcdTAwMTXCoMK/w6dGw78nw5Zbw7RqwrAkXHUwMDFkIMO+XnB9wrBcdTAwMTQow7rDpFjDs3M3XHUwMDE0w7HDuMKlwrHDkMKxXHUwMDAzMzLClFxcdMKIwobDhUvDvk5GXHUwMDE1wqTCpcKXwqXCj8OOwrU4w4InwqdcdTAwMDfDiVx1MDAxOEfChcK8Q8KSw414XHUwMDFjw71cdTAwMWRcdTAwMTdcdTAwMDMvw7LDh8Kxw5s8XHUwMDEzRFx1MDAxZSbCosKnw4fDplx1MDAwN3N5asKoICgoXFxcIj1Kw77DsMO0XHUwMDFiwrbCvzDDgcOlw6lcdTAwMDfCicOIwodcdTAwMDfDpcKaXHUwMDFjcsKBwo0/Y3w1w5ZFw65cdTAwMGZcdTAwMTjDnEVcdTAwMWbDmHTCsSTCm07CrnnCn1xcdMOTw5zCvcOPwqRcXGJeb1x1MDAxNHR9w6fDh0HDlGZ+w47DklxcYlx1MDAxOSFgd8OaXHUwMDEwwq3DgVx1MDAxZcOxw51cdTAwMTBcdTAwMTRKLcOycFx1MDAxOcO5XHUwMDAxw4FcdTAwMDHDkMKlXHUwMDEywrp2JsKowqnCpSnCtlt4RMKuTcKpw6lnZMOfw6BKw7p0wrvDlcKhwqjDqcKVLVx1MDAwN8KhPUBcdTAwMTDDpFxcXFzCqcOlZUlgWcO3XHUwMDFhw6F+T1nCscK0XHUwMDE1XHUwMDA1XHUwMDFkwrXCusKhwqFNT8KDwpvCtyBcdTAwMWRcdTAwMDfCl8OswqExwpdow5PDscKKwr9Cw7JcdTAwMDdeXHUwMDE0wqxBXHUwMDFmwqTDhGhywqDDokzDv8O/aMO3K1x1MDAwZSDDkFPCtFx1MDAwZVx1MDAxOMO1XHUwMDBmXHUwMDEzSMO0fErDmXHChVHCglJqZ8O7XHUwMDFmw5DCj8OEw5k4w7PDsMOJw7lhYU5jw5Q6WCYjIFx1MDAwZVx1MDAwMlx1MDAxZcOLw5rCgD19w7HDisKBw4FEw7xnwp/DoyZcdTAwMWUowqRcXHTDqMOpZMOMw4nCsMOiw5wua8OJwoPDhV3DrsK8wo03XHUwMDEySVx1MDAxYcKcw7nDtlx1MDAxYlx1MDAxODAswptfXHUwMDA1XHUwMDA1XHUwMDFkI8O7w5PCsMKsXFx2IFx1MDAxNMOGPCVowp1Bw5Jyw7NcdTAwMWPCvl83ViTDoyPCsHDDkT/Dv8Ksw6JnLsKRXHUwMDEzw6ktJm1xwrl5ZFF6XHUwMDAxX8Obwp5cdTAwMTZcdTAwMTVcdTAwMTlhTMKUbMKEw4XDnMOAw5NnwrbDuXdyw7XDtMOzVSZnwpLDssOSw5vCm1Mpw4YgXlbCmU5XJ8K5w6rDtcOXXFxmXHUwMDE2XHUwMDE0wrd4w4jDqMO8XHUwMDA0I8OXwrFiw7fDo2nDuFx1MDAwNTnCqcOuRXjDuHNGwrEpQzNKwphywpzDiMOiwrbDs2dUwrxcdTAwMTXDrsKLcFx1MDAxOE/DmMKRwpzDiWpcdTAwMWM2w77Dqlx1MDAwNifDusONPU3DiMKvwohGIUZcdTAwMWVcdTAwMThKN1xcdFx1MDAxNcOIwqwqw4l1bTbCsCHCt8OIQMOnacKbbXDCpitvw5fCi1LDiTM2wp98wrDDi1Rpw6zCm8OHXHUwMDAyw4XCqMKcYn5WwoHCr8KGXHUwMDE4wpJ0eXHCtMOUUlXDtMK0w5zDvT1KwrtkwpXDp8OBSkjCsDtOw4nDqcOuXHUwMDA1eSfDj8Kkw49OXFx0Wi7DusKBwpMuwodyfcK0XHUwMDE0wqvCsFx1MDAxYsKqP8KiXHUwMDA1SzJ7XHUwMDAxwqvDjMO4alJ1aVHCtMKkLT41w5dcdTAwMWZgw4o4w7zClDnCqlx1MDAxNWrDgGpcXGZcdTAwMWIvXFx0XVFTw6tHwrXCqcKtQynCqSQpw70pWTwrUitaK1YrUCtVK1Arw51EwrowOsOCdFrDpm/Dq8KqO29DKivCoFI9fVxcXFzDgz/CssK2byvCqFJFSmVKw6o6MzHDjSppLl3CvlXDukpKwqFKecOKw6tqLsOhw65aXHUwMDFhL0zDncKMwrEqLyvCryo3LTQvRDM+MD44XjBSNMKSRno2woNqSVI4UsKrYlxcYsKqUCzDjyzDjy3CjyrCjyt3MMO0L8Ksw7t1NFx1MDAxNDvDlDLDki7DksK+w4JNakzDilTDilx1MDAxM2pdw7JcdTAwMWFGekfDusKWw4rDo2pcdTAwMWTCq0AsVzDChDTDnkbCkk96Z8O6RMOKw59qXHUwMDE1wqtgLMKXMFx1MDAwNDTDvnLDll/DilDDilx1MDAwN2rCpcKrIC1HLmQ2wp4+XHUwMDEyYmF+MMOVTSzDnyrDhzBkdcKwwp3Cqlgswocww6Q0w740wp5HXHUwMDEyUMO6wpfDimVqIcKqSCpnLMKkLFx1MDAxZT5cdTAwMTJjw7p1w4pcdTAwMDFqwpnCq1xcYi3Cpy4kNlx1MDAxZS9cdTAwMTJFw7o5SkJlw4/DpMKqKCpcdTAwMWbCvCt+w5hHKiMtay1waz19dVx1MDAxYsKqw6o6wqrCs29KwqlKX0o3SldKR0pnSi1KTUo9fUpdSnwrwoQrXHUwMDAzKlx1MDAwMytjKmMsw6tUbMO+KkrCgcOKa2rDmsKqQlx1MDAwZjMuXHUwMDE1w57DqsO6S8OyScOyQcOyScKSMno6ejLDulrDinrDisK7asKLalxcdmrCjcKqw4zCqsOwKzvDhcKoZnpGw7PDkW5RwrNcXGI7w4dMwqRswo54XHUwMDBlcMKieFxcXCJuw7RuXFxiw4Uvw55DXHUwMDEyU8OzYcOeZD19wqvDhMKqw6TCqmwqLsKVwqrCqCrCr2t1w59BcjVqezhcdTAwMWVAwpJGw57CgMKBwqvCsCpywoTCqsKmw4vCr2U1PjTCqsOjMcK+OFfCglnDunwqw7kqwpJcdTAwMWbDmC3Dq8KuwoPDtDLChMOmwrVqTypQcVx1MDAxMsKlw6YuwoQ5w4p0ejHDiCvDmmgsR8KvKHJHKsKWZlx1MDAxZWswK8Oyw77CnmvCmGrDocOLworDtyTDin0qw6LCv8Kww4rCvSrDpEPDsMOKw50qw6ZUwpLDosKQKlxcXCJcdTAwMTBsPU3DnzwqXHUwMDAyMlx1MDAwN8O1wpAqXFx2wpfClcKiQMKqw5IwNkPCjjnCkyxCXHUwMDE1SsOUXHUwMDFlUipcdTAwMWPCjcKpwqJRXsKOMyrDtFx1MDAxZljCukEqw5BNKsOdw643XHUwMDFjMj1KXizCmkDDqjQxXHUwMDAxK8OKLcKqw4N1w4vDi1x1MDAxNy/CusOQLXJcdTAwMTkja8KDLcOKw7YqfsKJKsKUdVpcdTAwMWHCjFJcdTAwMWEuw6pkOMOqJMKgLlx1MDAxYcKUPlx1MDAxYTYkVcKlK8OawotKwrJJwrvDqsO9w5vDqlx1MDAwNcKSPUpbwqrDoDNqZTtqwpUww4rCp8OEMsOccjDDg8Kqa1xcZsODMFxcXFzDhC7DnCw9SkguPUpYLj1KXHUwMDEwwqw6w7EqwprCryrChmUqw5hIKsKBM8KqVTXDqsOPK8OiwopsfMOcKsKGTyrDmEgqXHUwMDAxOMKqVS49SsK4Kz1KXHUwMDEwLMKaQcKsLEYuPUpoLD1KXHUwMDFjwoDDqmXCgMOrw6XCgMOtZUU9Slx1MDAwN1x1MDAxNUo5Klx1MDAwNMKzKlx1MDAwNFAqwpdBwqpgwo5RXHUwMDBlwp9BXHUwMDBlwqM5XHUwMDBlRyrDpUHCvnFcdTAwMTUywr5cdTAwMTNCwr5cdTAwMTcuwr47w6rCpD/DqmRcdTAwMGU2wr4nRlx1MDAxYSrCqsKkQMKqRMKkN8Kiw70wZizCuiAscsOBXFxiL1xcYitqw5nCrVxcZj/Cnip5K8OGQSvDhk/CmcKqXHUwMDAxKsO2w4Eqw7ZcdTAwMWbDh1xcZsOkwrnDvmcuw51PLjXDisKtw6jDisKlw5/DisKhw7p3w4okwrLCuMKraMOnMGdcdTAwMTQsXHUwMDA3O8Krw4jCqsOndsOzwq1IXHUwMDEywqtcdTAwMDZbw7LDgzDDg8OoMEPDgMKqw6bDsjBLV8OtXFx2wqM9SsOjSFx1MDAxYcKBwr4zw6nCtVxcdmRcdTAwMWHDkTVcXFwiw7rDoStcdTAwMTjCscKcw7NtKFx1MDAxZlx1MDAwNFxcdsKnent+a09cdTAwMWHChMOHw5B0KsOeMsKqXHUwMDEyRXd9w58jwop1Vyo9TcKdUSbDqHZ9w5lcXHRrMTUkw6nDjCh8fsO/wpJTdMOoQlA4w5bCv8OMXHUwMDFhwqNaw4/DqHR7w5nCt8OOw5PCvMKLw7w+w4hUd8OfXHUwMDE2wrrDkMKUSXV9wqREXFxcXMK+Um7CsMKUw5PCvMOLwohJw4HDi8OkwqhracKkwrpWb0HDtHxcdTAwMWNaw6Vqw5lxw4BswqjCnH7Dv1ZjXHUwMDE0XHUwMDFmV2PDlMOudsOIbGNaw7Mswqp/w5XDk2pcdTAwMTN3fMOKJMKEPlLCiW1IXHUwMDFmw6TDgnHCn1x1MDAwN1xcdntMeWh/w5/CsHnDq8KGP3RZdWpcXHbDpSzCtDh8w47CiEnCgMOOdEbCvlLDpsKIwrPClMO7woHDkMKUw4FTfcKkw7rDgz19V33Cq1xcdMOUw75cdTAwMTVcdTAwMWbDlH7DgcKtRMO/wqFuwrfDjG3DvlMjwrFcdTAwMTTCvlxcYj43NDNew5PDlMOXw4TDvlx1MDAxNWpXw5RcdTAwMGXDl0DCr1x1MDAxMMKVfcOoSGR+XHUwMDE3NUd0wpkzwqJnLFx1MDAxZsKKw7zDpEhcdTAwMWYkwrpow7/Cv8KRasKzMER8f8OpN1Mjwr1wwr5cXGLClsKNNMK5XcOLwpJcdTAwMDJOXHUwMDEzX8O2wo5ZwqPCinBcXHZNXHUwMDEwfjUqw5vDoMOswrzDvHXDn8OMblxcdj1AfsK1w6k3XHUwMDFmXHUwMDA0XHUwMDA3w4BcdTAwMTTCnMOcw40kRlx1MDAxNlxcdsKoMXRcXGLDo0nDj1x1MDAxMVxcdnLDi8KqKH5/wq49fVx1MDAxZmTDt8ODVMOTRGrDizBBw7RBw6XDrCUxfMKkw7TCmH5cXHTCisKhw7RhXHUwMDA1wq3CpMOnw7PCvVx1MDAxNMKkXFxmb8KzdsOmw5PDlE5LT8Opwr3Di1x1MDAxZcOkOsKvwrEkfFx1MDAxZcKkaVx1MDAxNFx1MDAxZknCqcOUTsKQMsKvwptKw7/CjEU2XHUwMDBmOcOLXHUwMDFlwqLDrVJ7XHUwMDBmwprDlMOPUcK+wqTCh2jCvFx1MDAxNMK8OMONJFx1MDAxMMK3w5DCksK9MnQow6pCdMKZbj7Cr2jCuMOPw5RAcH3DmcOnwozDiyY9TVPDnlDCuFx1MDAxY8K3diooUXvCpMKhwr3Dk8Oowp9Twr5cdTAwMTlcdTAwMGVeXHUwMDE0w59cXHROw5TDtUrCvTzCn8KRwpvCn8KfTVx1MDAxMlM5XHUwMDE0bTo5XHUwMDBmNVx1MDAxZkQ5XHUwMDE0w5Zww5LCtcKEw4rCmMKrw5N1wr5HPUrDhzHDgsOXLMO2f2vDrcOwwq1ww7HCmErDglxcdMKPXsO/w7x0fcK3w7haw5zDqDg2wp49fcO6w4FcdTAwMDfDvD5ZwobCsMKUXHUwMDBlwq1cdTAwMTPCqcKBw4DDlMKUw4DDjVx1MDAxNnjDsn3DpsKgw4LCmixcdTAwMDfComRzalx1MDAxYlx1MDAxOFV8wqAjw7R+wr/DlVRcdTAwMGbDlcOZeF9cdTAwMDTClXzDpn7Cl8OUXHUwMDBmw6RYXHUwMDBmw4XCj2pcdTAwMWLDpsK3w5NwSV3DlMOPXHUwMDA2wrzDjMKpXHUwMDA0esKgZUdSXFxicFHDlFx1MDAxNMK7VX9fw6vCrVxcZlx1MDAwMzNTZcOCJ3HCmTfDjMKEXFxmbcOTw7DDhsKacsKdRlx1MDAxZW09TSvDscOTPlnCllxcXFzDv1x1MDAxMsKBbiPDmD97f8K9wpB8wqBcdTAwMDVAfMOmXHUwMDAywqTCtMOIw5/Dg8OMXHUwMDA3IHrDplx1MDAwZT1Nwr7Dh1x1MDAxOMKjw5RUXHUwMDFjUFx1MDAwZsKVw7trX3glclx1MDAxYnQoelfCpmhcdTAwMTdcdTAwMTXDl3FcdTAwMWTDvlx1MDAxN1x1MDAxMsOwL8OIwp7DtcKzw4tewodJdVx1MDAwNWN5w5DCo3/DvVx1MDAxMsOUb8O1XHUwMDEyw5RcdTAwMWVHXnnDumxcdTAwMDXCv1x1MDAwN8OLXHUwMDEzfcOJXHUwMDEyw4DDkcKcfMK3R1B8w6Zdw4h8w6g1TcOOwoRswp3DjsKiwqfCncOORMOhwpnDgVx1MDAxY8K3w6ZSf08pwoDDtFx1MDAxODZ5w4TDocOya8OEWERLd8OBdsK7XHUwMDEwX1bDgcOgJcO6VsKHwr8oPCBte8OAwpNcdTAwMGXCpcOyXHUwMDFhMFHDs8OeXHUwMDE2w4lZPU3ChVx1MDAwNFbDrcKFXHUwMDFia8OQe8O/csOgXHUwMDBmJzLCg1x1MDAwNMKjw4TDllx1MDAwN8K1bcOcZsK/wrnDnH/CsVdcdTAwMGbDlMKIwrbDgT1Nw5fCg0vCkSFcdTAwMTDDgEbCp3/Ch8Oowo9cdTAwMWXCkiPDsMO0w69cdTAwMWPDpjNcdTAwMTdcdTAwMWPDqMKJXHUwMDFmP8KELDw+wqI9TUU/RCfDqFNcXFwiIFxcXFzDpsOUT8KdwqLCoMOUOcKjw6bCjHFowqfDlcK8eSHClVx1MDAxMVx1MDAxZMKQZDRcdTAwMTZkwpUuf8ODw7kuw6jDnGjCtMK3w5E9QFRcdTAwMWPDhMKSw4/DgFU9fcK/wqZcdTAwMTfDmVJcdTAwMWLDmDd+wphmw6PCgEPDplx1MDAxZVRcdTAwMWXDq1xcXFw/w6U1w4l+wqLDi3PDlH/DrVx1MDAxOcOVwoDDn8Kww5VcdTAwMWLDiMOew5RcdTAwMDN/wrl6w5FZw57DlMOhXHUwMDE2OVx1MDAwMcKSRsKfwonCrcOhV3PDvSFcdTAwMWXCkcO3w4BHP8KEw6Y2f1x1MDAxN3AowpDCl1xcdE9cXGJkf8KUwqHCnlx1MDAxNlx1MDAxMFx1MDAwZVx1MDAxNVx1MDAxY8K+w59cdTAwMWVcdTAwMTJcdTAwMWZxXHUwMDFlXHUwMDEywrvCmyRmwp3DiMKrw4dcdTAwMGZLwq3DlMOiPm1cXHTDscKkcMK3XHUwMDA1XHUwMDA1wrbCosOXw53CtsKFw7Auw4VcXFwiwrDDqlx1MDAxNFx1MDAxZTHDmMOEYMOYwoXClD1Aw4zDgcKKeFx1MDAwNWXChVx1MDAwMmfCvsOcXHUwMDBlN8OowpHCgz/DoFxcdMKUW8KTw5lrcX/DisO4fsKtwqRcXFxcMDZyw4/Co8KKMWxcdTAwMDdcdTAwMTYzMHDDvFXDhMKEw6TCicK0XFxcXMKTwqtcdTAwMDPDtHDDnMO+wrhlwpzDvk1TXHUwMDFhRVx1MDAxOEF6QSlUfcOYwqdcdTAwMTTDvsO1woBHw7TCk8OoO1/CisKsT1x1MDAxZlHDqEnDv8OuOMOMw4DDmSHDi8Oww6PCsXzDvMKlwo3Dkmsow4M+w5xAe8Oow7XDgHrDrcKYXHUwMDE4w47DtMO3WHpgQcKJe8KZw5/Co1x1MDAxZcO3QlHCpMOww7HCm1x1MDAxZXJcdTAwMTVkZMKWwoxdwofDmSbCtTjDh1x1MDAxN1DCn2LDjnbDlMOOI8Ksw77DsGJtXHUwMDEzXHUwMDA1w6XCtMOOPU3DhkhyUcKOLsOzw6YpwqRsw7BSPUDChWDDsinDhlbCmcKCwrbChsOIwovCucOGf8KUw40mXHUwMDBlw5FzNMOjw6snwqLCrT1Nw48jScOpw6dcdTAwMGZcXHTDo1x1MDAwN0vCgiNcdTAwMGXCt8OMKcKBU1x1MDAwZsKsw4l4VMOMwrFjw5R/w5XDucOTw7fCoMKdw7vCklxcYsKhal3Dv8KWw47DoMKHw6fCvsOYwrDCmcOFXFxiwoNcdTAwMTnDjTBcdTAwMWR5w5xwNVx1MDAwZsOJw4NmQsKNwpNoIcKhwrdcdTAwMGbDmUssw4XDjcKVIFx1MDAwM2d5w5VcdTAwMTLDkcOPw4k9TcOePUDDm8O4wo/Dp1x1MDAwN1x1MDAwZms4N1x1MDAxOMOIPU3Dl1x1MDAwNMOmwpXCvcOAI8Kuw7LDuTNcdTAwMDLCqcKbwolcdTAwMWHDrsKWw6/Dulx1MDAwN8ORwoHCr1x1MDAxN1x1MDAwNzpBwoMkY2DDsMKbXHUwMDBmwrzCosOHfzRTIcKoR8O1w4LCqMOkUyHDilxcYlx1MDAxZEzClmjDqMOsMsKWwrrChsOaLUBsRVx1MDAwNcKVd309fT/Dj8OSw6Fvw7zDvsO0N8Ocw75Kw6rDncKNwrg8XHUwMDFmXHUwMDFlwq8wwo/CoFx1MDAwNMK6JMKiXHUwMDAyw4BUwoJcdTAwMGVrwrc1OMOPXHUwMDE2w6R9U8OVXFx0wp/Cvlx1MDAxYSYrVMO2JEfDn8KBw41JJ1x1MDAxMnBDZz1NXHUwMDE1wo0kXFxmXHUwMDEyW3xxR8OIdcKTwpPDuMK7OH/CssK6wpPDs2/DnMOoJ8OtXHUwMDBmw5hYwolMw6nCnjjCuVx1MDAxMcKDwp7Crkk8w593eyB8wrFcdTAwMWPCosK3c8KULcKWbF/DmVx1MDAxOcKFw5bDvcKWR8KWw5ojwo7Cq3M9TXzChcO1wqXDlcOdXHUwMDE2wqhGR1x1MDAxN8K+wp9cXHbDv8OKXHUwMDFmwoVmwq8zw6jDm23DhD1Aw7DCuWJcXFwiwpNcdTAwMDbCgsOnwqPDm3NcdTAwMTPCsD/CvcKJeMOpwoc9QDEwY8OnwrfDkFx1MDAxMMKRcn3CiURcdTAwMGVSwo7Di3LDnzLDn8OSI8KxVsOSWWfDiH7CicKCNm/CocO5w5B+NMOYfcOjXHUwMDAywq9ww5XCuMO6VznDncOOfsKEPU3DjsKdXHUwMDExX8OyXHUwMDFlwr80XHUwMDBmXHUwMDEybVxcdjRcdTAwMWTCgSFcdTAwMWHDqU7Ctn9wwoVcdTAwMTHDksOhwoLDh8O/w4NpwpvDilx1MDAxYsOBVHdcdTAwMTXDqGnChcOHXHUwMDEyw7/CiMKtfzzDt23CnMKVeMK4bcOdw5DCj8OfwrbCp8KId8OtwpjCgTXDt8Kiwr7ChGk3w7Qhwr0/XHUwMDBmZVxcXFzCssKEXHUwMDEywolzw5MnwqRuw7vCq8KjXsOnUsKEdMK3aEzDp8Kaw7ozwoNcXHQjwoXCi8K/PUrClcK0wpQlXHUwMDE0w79Bw5TDlsO8w5FcdTAwMWY1w5dcdTAwMTJcXHZcdTAwMWMtQWBuL8OTw5dcdTAwMDNDXHUwMDE5w6XCj8KLwr9vw4Jgwp9AXHUwMDA0PMOHw41Dw77DtMOJwqHDk8K2w6TCn8Oew7zDg8OpfFBcdTAwMWVSwoPDncKlcGZcdTAwMDF2wpHCv1x1MDAwNUVgXHUwMDEzwph3f8Oaw5tcdTAwMTVXIVhnXFxcImTDsMOSw7LDksKYIWTDscK1d1x1MDAxZHTDk8OkwoHCpMOeXHUwMDExw5wzfGxcdTAwMTfDpVxcXFwxwr3CtMKiecKXw7nDk8ODczleVzLDiFx1MDAxMHtIPz/CucKNwqB1f1x1MDAwN8Ofwrslf2drXHUwMDEzXHUwMDE3XFx0UC3Du1x1MDAxNiHCmH/CscKJw5BcdTAwMTNyw5nCmMKTe1x1MDAxNn0gw4Zew63Chlx1MDAxOcO9w6zCi3/Drzg3w5h5wqM7dcOrUMKdwrHDoMOKOcKWV0PDmsOTfMOLw41dLmRcXFxcV1x1MDAxOcOufWhVw4tdLsKQNFx1MDAwMcOpTm7Dl0RRIEHDrcKgwpHCrmTDq8KATyd9XFxmekwhwrvDqMOTU1x1MDAwMsOYw5TCqsKRScOKdMOawr3DssKffcOawo3Cp8OKXHUwMDFkw4EtwqDDjldcdTAwMDLCu1x1MDAxYlx1MDAxYcKlUMOewoHCv8O6wqvCtjHDhcOewr3CnkxPwphFU8KYw4jCq1Ziw4pcdTAwMGVLwodoYsOTwr7Ci8KuasK9w7zDjzbCi1x1MDAxZj/ChcKaw4/CpX1Nw6rDlVx1MDAxOMKlXHUwMDFhL0/DomtxwrlEYC7CozbDml9hw7x+UcKoVFx1MDAxOFllY2TCjG7CusOZw4HDlcONwrfDk8Oow5DCjsKwwo/Ci8KgXHUwMDE0XFxcIsOye8OtLMKnMTnCnMOcX8O7e0tIWcOUw4xSUVfCmMKGXFxcIsKywoppwplhUUV9Z19vw7LCgMK3w5LConTClGzDtkJcdTAwMWLCg2U1TUd/aMOnw4rCmMKEwoPCmMOww67DosObw43CsTEkwqJsw7TCkCRUXHUwMDFlwrTCr8Odw5R1NVDDkVHDsHDCuERcdTAwMTRZwp5JPUrCisOTc8KZw5LCiVxcXFzCmcKww5JOWV1PaGRMXjJcXGJcdTAwMDFcXHTDglxcYsOjw6PCi8OvJsOkXHUwMDEzXHUwMDBmwq9jwr3CvFFuwq/Cu3ZlwpTCiMK6JsOHwpVjwpvCosKJw73DoMK3N1XDgX7Dj2tcdTAwMTUhwrQ8w5bCv8KrU3RcdTAwMDZxwr8lwpLDq3FBZCDCjjM+XHUwMDFiXFx0TsOtw6NIw43CuUXCpVPDjmlcdTAwMWXDhCBbwpTCmsKHw7zDqMOrw7wgw5xcXGLDuDlnw6c5Wm9cXGLCsEVFw6bDmcKpZ1x1MDAxNSfDoVx1MDAxMMK1wqEnOH/Di8KWwr3Dp8OaJH7Dilomf8OcesOXwpjDhMOawqBcdTAwMTfCjFxcdlx1MDAwZsKnw4XCr1x1MDAwMVx1MDAwM01sWcKmb0LDmyXDk3rCnT1AWcOLw5zCv2bCnVx1MDAxOcOlZD19YcOqwq5zw6U9TcOqw7bCpFx1MDAxOMOrYsK5OMKOw4DDgm5aYlLCu8ODwqFYwrFcdTAwMDPDncKGw67CtsK4w5PCj1xcZn9cdTAwMTBdVcKIWMKNdEheWmPDicOgWsKhN8KgXcKpXFxmOV3ClMOxWz19wpLCncKrY8Omw4vCt1PDoMOpw7FWYyjCvns2wqnDsWYoXFxcIsK/wrvDlSXDrcOaw5R8w7JOwoQ4woPDmFx1MDAwZsONe8K5wr/Cu8Ktw6AwXHUwMDFjR8OMwq3DllBDw4rDplx1MDAxM1BcdTAwMTJcdTAwMDTCpjVcdTAwMWXClMOYN8O0WcKdalJcdTAwMDQzXHUwMDEzwoPDpcOMXHUwMDAxwrlcdTAwMDfDusO0XHUwMDEzwojDsn/CrWvCkVx1MDAxMVxcXCLDjMOMw7krclx1MDAwZT/CtsKWw5zCsMOLwpVfTcO6w7XDhFpcdTAwMWVPXSzDt1x1MDAxZMKybFx1MDAxM8KZw7HDi0vDjMKCw75cdTAwMDdfK1x1MDAwZsK3dWrDpVx1MDAwMU7Di8OAwp09fXtcdTAwMTXDl37DjsKgS0dcdTAwMDfCgsOBwqvDnD1Nw5zDulLDg8OzXHUwMDEyJSZGXHUwMDFldMKUNMKUSMOJwrF2PUBcdTAwMTFNwqbDnypvw6dSbsKlwohAw4tcdTAwMGZhwrTDu1x1MDAxZEdPUsKZw7R+wo7CjX3CtMKIwolUb8KVUMK+w4trw7nDtcO6XHUwMDE0wptcdTAwMGbDkiN+Y8OUW8OTasK5wp1Uw7rCuMOtP8OSXHUwMDFmwqUvw5zDoD19w4vDhFtMw654P8OLwo9Vb1x1MDAxMsO0aDvDvGZZbMKwwqFuwpJcdTAwMDTCnTvCpFx1MDAxZWvCrjjCpz19w4vCg8Opb1x1MDAxMsOsSTvClFx1MDAxOT9LI2g7XHUwMDA0Nlx1MDAxZTDDkkHCssKqw5UtXsObwqDDkMOswopcXFxcw6pQdcOvLVZKZj5cdTAwMWUrwoDCocKtOcKeKsOYw6bDjS7CnFx1MDAxNUwqbMKNwovDvi3CqMKGXHUwMDFlXHUwMDEywq3CkVx1MDAxMSt3JFVswrXCpUpcdTAwMDfCmMKiw7F5wqLDscKBO8KcKC5cXHTCmT1KIV1iKTrDmFxcdDzDi8K2VUxeKV7Dplx1MDAxOcOCMl9cdTAwMTlAw4tcdTAwMWTDhW7DsjJcdTAwMWPCpsKcwrgyXHUwMDE3O8Kzw7rCscKGO1R2PMOLwos7TMK+R0pswrnCh2/CksK/w6Mywpd+P8OLXHUwMDE4XFxiNMOeXHUwMDEwwocvw4RcdTAwMDXCiMKrWMOhfsOKw7LDhz/DkinDnDQ+WMOUalx1MDAxMXxVesO3w7I0w57DrsOXLMKnYMOWalXDjlTDuiZcdTAwMDFcdTAwMGZcdTAwMTJcdTAwMTBcdTAwMGbCnMK+w5zDpUYvWFRxIyNcdTAwMGZcdTAwMTLDtcOCwpzCnsOsw5dGXHUwMDA3PUBYcVxcYmnDtcO6XHUwMDAxwoXCj1x1MDAxMlx1MDAxMcOoXFxcXD7DnMOKNsOnw7lWbTnCrMO1wrrCq8KPQ8KUJsKFwrTClFx1MDAxOcOAw4wtwqV1wrtcdTAwMWTDlnzDvsK9esK0wp5mdcO7XsK/fE7CpmM/L0nDhcK0YMO2w4XCtGw9fVxcdsKiw7p+w55uwqhUwpzDqMKBwqzCtsOgw4HDilx1MDAxMsOTT1x1MDAxMsKXcjPDpMOKwoXCrMOkwog/w43DvC3Dr8KSbn9bw7Q1V3BcdTAwMTnCnsK1w7vDqFx1MDAxMW9cdTAwMTLClH07XHUwMDFjVFRswofDkjJcdTAwMWI/wrR6wqDClUvDnMKEwoDCssOGwow1w7tGw51sXHUwMDBlJ8OUKiPClllqw7XDnTTCusOJwp0rXHUwMDFjJ8OEwrnDgFx1MDAxNsO5ccKtXHUwMDFkXHUwMDFkwrslw6rCpn4lVzlcdTAwMWZcdTAwMDXDgcKxw5bCnVx1MDAxY3rDi8KNSMO8wqlhL8KTwpjDg8Kswrw9fcOQSsOoXFx2Pk5cdTAwMDXDiMK1w4xcdTAwMTDDrcKKwoXCmlhcdTAwMTRcdTAwMTXDtWvCjThcdTAwMTFKw5NcdTAwMTZGTsKRw4PCrTxcdTAwMTl3cMKEXHUwMDFkUE19w6nDs8OSJHFgbFx1MDAwNcOce8Kiwp5gZFPDsnBfUcOcw7pcdTAwMTDDtlbCjsKOw4LCr2jCicO0bjBPw4PCksOnwp9Qw5TDpsODwqvCuMK1XFxcXMO6UsKxNlx1MDAwZcO9aDPDt8OTw4bCrsKGXHUwMDE2UcOLa2HDvcO7XFxmw7zCnj7ClMK7wrjCvFnDj8OLw6VjwpPCksOFwqBEw6TCp2Y/w6/DscORw4zCisODfl7CqcKVNMKcR8OEwqxcdTAwMDZodm7DtVx1MDAxMXhueydRw4zDjMKVw7NcdTAwMTJxwoBcXFxcw6TDj8OCwrbDvsKhTsOLw6fDq3PDiinCs3LCn8KETMOkwpjCvsKyw6hHc2pvXFx2M1Igwo1mXHUwMDA0fj19wrlww4LDrsONw4LDrcKbXHUwMDEyXHUwMDFjwrJiw75cdTAwMWHCnCzDpMKHZCtcdTAwMGbDkndqXHUwMDAzwoXDsMONRcKIPU3Du8OUwpXDm1x1MDAxMsKGbFZEIWcwwq/Dv8Ouw4rCh2RbwpLDtMOgwpLDnsOwTURcdTAwMWbDqVo4XHUwMDAzbsK3bcOfWcOxw4zCu8Kjwo3Cu8KyRMK1wp5cdTAwMTBwS8KHw6dSXsKXfU7CtMKewrRuwrXCucK4a8KIKMKNw7rDmlU7XHUwMDEywqZuLlx1MDAwNFx1MDAxZlpGw7vDs1xcdjLDqUXCt1xcYlx1MDAxMMK2cMOMw4nCi8KSwoTCk0IkXHUwMDA0YTTDn3hJwq9cdTAwMWVcdTAwMGZxw4tFwp9Ne8OhwopOwoRawqEuwoTDjGYsXHUwMDFiXHUwMDEwwrHDjMK5w7TDi8OywqFcXGLCmk7DlV5GN8OIZzZnf0LCsMOkwpA2b8O9w4/CsEx7bzIkw74/wrbChFx1MDAxZMKtwrtcdTAwMGZcdTAwMTFKXHUwMDFlW1cyXHUwMDAzZzVuIcONLTvCn8KdMsOUSWQuXHUwMDE3wpYzalhIK8OywpPDgWlcdTAwMDTCilxcdsK5XHUwMDEww5hcdTAwMWFtw4k/J8O6wq90wonDjilcdTAwMDcxw6d2XHUwMDFia8OgITrCpGM+S8KtPX02w6TDvMK5a8OpwoA1w7tEb0vCjHXDp3tcdTAwMTbDpcOrw5LCilx1MDAxNsKKw65pXHUwMDExwq/CtsKGw6d6w73ChHnCnsKGPUrCs8KswrRmelx1MDAwMl3CocKewqnDomXCpMKow7I3wo/DgsOkw4smw6Rrw5Ihw7VqTklnOlfCmMKbb1x1MDAxNcKWwofCu1x1MDAxZMKmQVx1MDAwZSHCjSrDpEVnKsKnw6vDuMKSw4jDj11cdTAwMDRnw70zwrcjw7pJf8K3XHUwMDE2wrnChiBjw4zCnndxwo59XHUwMDAyOcKPXHUwMDA2wptqXHUwMDE4SDjCkiA0wqXCviRcdTAwMDU4wofCs8OcbcOxOFx1MDAwM0xBV8KFXHUwMDBlw4TCkcKtwprDhV/ClMKhw55wT8Odw5bDuj1AwoHDgFLDq8O5PF/DmMObalx1MDAwZsOpw7fDu8K9w7tcdTAwMTDDksKfw5FDNMK/XW1bwpvDkFx1MDAxMiHCiz19wo7Dj8KUwqzDiMOPRE3CkcKWwq5+w5/Ct3p/w5BLw5Rowo/Cqlx1MDAxZcKfN8K6wqnDgGjDjHhcdTAwMTPDi1rCl2dcdTAwMGVgc0FcdTAwMTfClz1Aa1fDlGRSX3NFwpdmw5LCrzRcdTAwMGbDn8O6w73Dm8OEXHUwMDEyb8ONMDzCn8OVw40nbcO/e1x1MDAwZlRfXHUwMDFlJMOXVMKkPU3Di8K0w5TClX/Dulx1MDAxYlx1MDAwNcO0wpLDiMKvXFxcXCTDhcONwq5cXFwiw5ZMXHUwMDA0w7nCgW5cdTAwMDfCuyxcdTAwMWXCji1JT8KnXFxmw4tEeUg0w5PCgGplw5nDs8ONXHUwMDA3w6RcdTAwMWNSTHs4w79cdTAwMTnCum/DvcOpw7VKP8OLNjzDuMK6cFTCgcOPesK3w5A+woRJbcONwq43PUpRw6JcXGLDscKWRynDgXvCqFx1MDAwNcOtw4bDtCXDrcOGXHUwMDE1XHUwMDE3wow2wpTCqV1XVMOpw4LCjcO1wqlawpxQXFx0w4PCl8OFw6lcXFxcNzjCicOCOcKlaF01McKnwoxARifDqsOmXHUwMDFiwqjDucOWw6zCmcODcFxcdGHCtj1AXHUwMDEzwoHDtj19KcOBwrbDrMODXHUwMDExw7ZsKcKRdlx1MDAwM8OTOFx1MDAxMMKsw7k9fcOQw4LCp8Ouw7ZDJsK6wrtlwpzDicKjXHUwMDBmwqTCuVx1MDAxM8OpJThcdTAwMWTDrsOYw4dcdTAwMTNcdTAwMDTCosK1U2HDpMOzwo5Zw6XDuMKGe8KYwo3DgFx1MDAwMcKGwo3CmFx1MDAxZcKIwovDtFx1MDAxZFldVVxcdMKHwo7CllxcZllaw6DDocO5W8KVbcO4XFxcXMOdw4R5XUnDhnlbXHUwMDExYMOIwo5cdTAwMWXDnltcdTAwMWTDlMOgw4PCm1x1MDAxNmTDuMKmc2nDsMOiXHUwMDA2acOswqYzY8O2Ykdnw7LCpsOcY8OqYldcdTAwMDXDscKmwr9cXGLDtcKiXHUwMDEwXHUwMDE4wpDCjkhhW8K7bcKhXFxcXHjCscOgXTXDtkTDg8OTwp3DoFxcXFzDicKpwpjCkGjDscKZwozDtFjCl8KKw4DDpcOYwpHCpsKAw5nCj8OQw7ReWivDg8OVw4NcdTAwMWZhwoFbNcOnwoBcXFxcXHUwMDA0XHUwMDE1w4Fdw7hcdTAwMWPDtcOCw5HDg3VCw6VFwrVCwqslbMOQw6DCqGjDvcO6YcOBM3XDhMOtwpZiYcK1woPCksKBw7HDgsO4w5PCj3DCp8OEw6vDgsK5w5TCkMOAXHUwMDE5w4fDsFx1MDAxNnvDmcKMSMOpw5TCikTDocOAXFxcXMORfcK1Q1HDhSxcdTAwMTDDvcO1woZwwpB9YMK9w4HCusOrwqJFw5FbwrMhwr3Dg2F1PX3Dgj1Aez19QsKnazbCnVx1MDAwZnY+XHUwMDFkw5RmwqzDs8KaNcKNw7DCqTTCj1x1MDAxYVx1MDAxMMOLw7bDjFx1MDAwMkpcdTAwMTDDqMKkKsOdJsKsOcKdw5fChsOyfsOkwqJbw6XCiMOjWz1NwoHDo1xcXFzCnW3Dh0Npw7TCu1NcXHTCkcOxXFxcIk/ChV01w59Ww4JcdTAwMTbCnVDDtsKtbG1cdTAwMTDDqMOfSMK9w7/DmMOvw5bDgsOLw7jDrjZ+wovCuGc9fVrCsUFSWjvCtlbDnVx1MDAwZWfDt8KeZCE0XHUwMDBmwpAnPlx1MDAxMGglVsKeXHUwMDFmwqRVRsOjXHUwMDFhw4PDmlx1MDAxZlx1MDAxZi1cXHZrXFx2wpfDi1x1MDAxZVxcZsKVw6zCvcOZw7k1w6k4wpg7w5jDiMKpdsKiJFx1MDAwM8KowotcdTAwMTDDilDCi8KnXHUwMDE3QFxcdsOCwqXClcKvwpVcdTAwMTfCgTRVdEEzwqnCiMOIVz5Cw7g6PUBcXGJTPX0wQHhAwrhcdTAwMDF2PsOgXHUwMDE5wrc6SEc7Tn7Cp1x1MDAxOVPCpsKDw715XHUwMDEywo3CmExcdTAwMTZcdTAwMDHDllBcdTAwMDZBT01mXFxcIibDjcKhw6bDuHdcdTAwMTnDrMOLccOmL1x1MDAwZsKVw6bCh8KgeVx1MDAxZFx1MDAxOMKYQ1x1MDAxMydcdTAwMDF8XFx0XHUwMDA1wohcdTAwMGZcXGY9SsK/woUxOVx1MDAxOMKJXFxiwqhcdTAwMWVwwopcdTAwMThcdTAwMWJHwrnDiUlcXHRcXFxcw7FcdTAwMTBuwr9cdTAwMDdcXFwiPX15PX1cdTAwMTV4w5bCnVxcYsKeXFxmbVnCpcKMKcOPwqVRZMOAwqdpW8KKw5nCplx1MDAxZMKMwpfDl1x1MDAxMGPDj1x1MDAxMMO3REd4w7fDsCvDrFx1MDAxMMO3woXCsWDDmVxcdsK5wpcow4Vjw5vDg8OnYMOPI8OHeMKPw53Dq8Kvw4RcdTAwMTDCuW/CncOFwo3Cl8OAXlHDn8OZwpRcdTAwMTjDl8KIXFx0wpZcdTAwMTfDpMOXI8KIw7HDmMKQw5/CozHDhVnCo8OHwpIoJVx1MDAxNH5cdTAwMWQgb0HDhVkyXHUwMDA1w4RNXFxiw55hOcKHXHUwMDFlw5LCo8O9PUpBw7c9TcKJw6bClcOIXFxcXFx1MDAxMXVcdTAwMWRNXHUwMDAxXFx0w7fDlVx1MDAxOCnCl0jCp3zCtFx1MDAxN3vDgcKNwq1QXHUwMDFjwoLDgcOtwrRcdTAwMTZbL38gw7tiN8Kgw6/CoMKXIMKHw6FIXHUwMDA1YMO+wrI3woTCj8O0wrjCosKVw6towp/DocKLw5NEwqXCoMO1d3Egw5BcdTAwMTMqwqDCpD1AaiA9SnvCocKgw4xcdTAwMTbCisKgXHUwMDFiUsKwXHUwMDFmw5Qhwo/DjcKJMMOaw4cnwq1cdTAwMDPDmMOMwovClijDsztcdTAwMTbCosKvw7tcdTAwMTYowrvCjVx1MDAwMsOmwo/CjVx1MDAwM8O/OcKNwoLCpVx1MDAxZGI9QEpfwrvDt1x1MDAwNFvCu18jw4bDsCDCncOzwo7DgVx1MDAwZXnCkE04d8KLUSdUworCmcOkw4HDmsKdwrXDtFx1MDAwMsKPwrFuwpbDq8O+VMKgwrJcXGLCniBcdTAwMTJcXHbClMOgwpd2N2VcdTAwMWTChVclwp5rR8KlXFx0wptgw4XCncKTOMOlU8KPSMOFWcOfwqrCp8OcwpBLJcOswo1bwoXCn8KdM8KlUsKVQ8KFT8OpwqzCp8OgwphPwqXDscOdw4jCt8Olw5vDhFfDg8O+w6rChHLDl8KNUcOWwobDucKEZcKZwo7DtcO5wpfCjD1Nwo3DocOaXHUwMDAxw6jClsKPw7nDv17DnGswZVx1MDAwMnvDpcKhw5xHwqjDpVx1MDAwMknDocKhw51cdTAwMWTDvSDDnHdcdTAwMDclXHUwMDAyw7pjMVx1MDAwMsKWw41tw5ZcdTAwMTTDmMOtw5Zdwp3CvsKXw6fCpMK2wqdBwqXCrMOHIMOow4PCh3zCrMKDPX0jQD1AwozDs1PCoMOXXHUwMDEzQ8KgXFx2w7jDnVx1MDAxNsKZIVx1MDAxZFx1MDAxNsO3fUHCglx1MDAxZMO6dVx1MDAxNsOdIMO1w5ZwJn8gPUrDhcKVXHUwMDE2XHUwMDAzw4ZgPUBcdTAwMTkhwp89QHvCnsK9w4dYwqXDhVx1MDAxZsOJXHUwMDA3w7jCkMOTXFxiwo8lw4BcdTAwMDbCjcOlwp5Jw5o9TcKAacKOwrd2SMOdwqtcdTAwMTXDicOaYcO3w4nDnFdFw4nDm8OUw4BZwoLCoD1NdSDCtCPClT1Awo0nRcOAXFxcXMKjw7HChMOYwqjDucKYw7onw7J4wodcdTAwMWPCs1x1MDAwN8OLw7zDs8Okw7gkw6zDlMO1wqbCjS3DtcOpw53Dl2nCqMOaXHUwMDA1w53CqMObIcKIJsKQw7HDsMKew53DoFx1MDAwMSnDmmvCq8OnXHUwMDE2w6vCjcKpwoNcdTAwMWHCu1xcZj1Nwpc+wqh7cT1NwqfCqHxcdTAwMDJcdTAwMTTCuT5Iw6bCiUQpw4ZOwq3DrcO3wo/Cm1xcXCJnwoMmwo3DqEYgMsK+w7FwZ1x1MDAxY8Kiw63CiC/CpmjCr8KxXHUwMDExQlx1MDAxYcKbwpFVScKpw4VYw6rCtVx1MDAwNz9cdTAwMWJcdTAwMWbCocK0wqJcdTAwMTFET8KWY3RDwqVyw5M9SmElf8Oaw7Vuf8OWw5XDl8Kww4HDiX3DrcKlNMO/wpvCvMOfMFxcYsKfwoUtWcOWPUDDrnTDmMKEXHUwMDAyXHUwMDBlw5NAw6haeUVVwqJcdTAwMTU9SnHCmcKewppcdTAwMWF8wodGXHUwMDE2w5XCsUnCqMO6w61cXFxcVVx1MDAxZVx1MDAxYnNpLcOWXHUwMDFjw7sqwqFYXcOuc2hwYlx1MDAxN8OXOyjDpcO6QsKFwqPDgz1KwrF5d8Oab8OHU1x1MDAxOMKgXFxcXMOtwptcdTAwMTfCkMKiwp7Dg2PDqMKPwpDCq8OJw4nDncOqw4w2dcOmf8OvNMOxXHUwMDE4w6HDrMKVTMOXwpvChMOBX8OwXHUwMDFmYMKiw4fDukA1w4hcdTAwMDJcXGZowrtHWGHDn8Oxw715XHUwMDA0wo3Dn8KiMcKWw71cdTAwMTHCqsO5w5ZcdTAwMTPCsVxcdDbCoMOuwrVcdTAwMThjXFxmw73CryfCm8KzwrA9fWjDmlx1MDAwNTNcdTAwMTE3wp3DsMKxwoljwo17w78qwqZcdTAwMDPDqi/DmWZcdTAwMTLCrFxcdMK3wprDr8O3w5nCh8ObwqRcdTAwMGZqJnDCkTpww6UxwotcdTAwMTdqYcOGJ8O6NznDg1xcZsK4woHDtcKlPUpcdTAwMDbDv0hcXFwiw5bDnVHCiMKgw7A9fcOpwrRcdTAwMWPDrCVcXGLCo1xcdsOIw5zDq1xcXCLCvsOcYcOAwohcdTAwMTHCt8KFw4bCr8OiJcOOOmHCt8KMXHUwMDFhwq1RNsOIw4jCt1x1MDAxYVx1MDAxMEjCrsKnwpAjPUrCmkfCiVx1MDAwNsObw7tBw6nCmlx1MDAxY8OtXHUwMDFiw7EnwprCosOKacKQXHUwMDA1JsKbbcKeKigjZirDicO0RsKswo/CqTbDq1HDtCxcdTAwMWJFXHUwMDEzSsKGYVUyw5l7N8OwwoDDtcKsw5vDk2syw4jDoWAuecOgQsK0woXDoDbDr1/CoMOtXHUwMDFhwrNHw63CmsK8PU3CmmbCn1x1MDAwMcKaVlx1MDAwZj7CtMOlwqHCr1xcZsOuKE3DmsKRw70ywoZcXHZaPMOlYMK4w67CjcOWcVxcdsKBRXBcXHZBw7DCi8Kiw77DlFrClsOVX0TCkcO3ScK3wrfCo1xcdsKiXHUwMDFhw57CmsKmw6RlRknDiDzCq8OfXFx0bz1KUVx1MDAxYsKNw5okw4dbwqLDuVx1MDAxYXLCpsOiTzxcdTAwMDXDom/Ci8KUwqU+IF1EwrVpw7ZJwrUpw7w9TcKawptcXGJiZlx1MDAxOMOvYsOmS0xEwrHDh8Kzw7BTw5hbXFxcIlx1MDAwMyRCwqbChE9AXHUwMDFkw7XCjVx1MDAxYlxcdsOhw5tcXFwiw6zDglx1MDAxYsOCwpNDwrnCnyV3w6p7w7VQPUrDmMOoM8OiWVc4w5HCh8K5w63DmMOIXHUwMDFiYsKbwodmKFDDgcKqwonCkFDCisOZRTPDosO9VztVw75RXFxmw7TDqcKzwqLChmw8wojCnmQzIcOddMOwwoBfw7PDolxcZn9cXFxcwqA5w4bCsnHClsOIwrLDuXTDkT1KfzNTXFxcIlTDhcKsUULDjlxcZsO6w4x+w6ZcdTAwMTRwVDjCmnbDrcOtwpTDvVx1MDAxYcOYwrheZlx1MDAwM11Hw7nCiMOCwrjCj1xcYsOQPU3CpcKSPFx1MDAxMFfDhcKuw4HDpsOJwq51wqdcXFxcXHUwMDFhwrNPQ8KiXHUwMDA2w4U2ZsKcwppQwohhYT19OcKlwrzCs3FkwpFcXHbDkMO0VmbDm1c1QcOCwo49TVHCg1x1MDAwM8KiJ1x1MDAxYsKWwqbChsKLXFxcXFx1MDAxOGnCkFxcXFwow6fCmFxcXFxgXFxcIlpDWcKfw7XDq8OTwr9jwqLDq8OvRsOWw4zDiMK1wonCt8O1w69EXHUwMDE1wp1cdTAwMWJcdTAwMWNcdTAwMDHDo2JcdTAwMDHCmzTCiGHCjzTDoGhmL8O9wqnDkMKKQVA5ScOTw7bDrXV4XHUwMDBmXFx2XcO8I2JOSknDhcKBXHUwMDExPU17w5FcdTAwMWRcdTAwMWI3w6QqwpltL1xcXCJwwoMrSMKfw54qw4UnUsOqbcOGNcKbXHUwMDFkw45sZsKdfUtcXGJcdTAwMWPDkjrClcKVQVxcdsKlw4tvXFxcIsKdwp87wrhkwojCrsO/w6g+wotNXHUwMDE1woxmX8OkQlx1MDAwNcO5VcOwOFfDr8OiJsKFW2DDnVTDq1x1MDAwNMK7T2LDoMOQLsKpZ8KCwqxcdTAwMTnDqVLDq1x1MDAxNER9XHUwMDFiVMOJw5NiWcKVVMKIw53CnFQ9QGhlP2kjZj8pPUBVw68zKMOPwoJpw50+w4VZU8OvfcK5w4HCjMO9wpHDj8KCccOLNsOxZMOAXFx2w7jDmlxcXFzCpsOdw4o2w7XDmFbDrV/DscO1XHUwMDFhw4Jxwo9iXHUwMDE5wplDwqjCjMKGwrjCgVtcdTAwMGbCoj1NXFxcIsKcXHUwMDA2wofChMK4XHUwMDAxw5hWw7HCtTjCvz1Nw4Vhw7TCm1xcZsORwpzCtsKiP2JcdTAwMDfDjCxpXHUwMDFmw5jDqsKFw7F+PUrCjcKDP1x1MDAwMsKKcC/DqMKCwonCq8O5XHUwMDE2w5fDqnRcdTAwMTFVXHUwMDFhwrAxP8Kiw7BcdTAwMTE0wqZ6dMKuwofDnm7DosOxwoTCrl9mbsOiWsKCwq7Cl8OwwrTDmsKPw5QywpFBwrLDmlx1MDAxNsKeO8KoXcKJwq5cdTAwMWbCgMK1XHUwMDFhw7zDl0xGw6F5wq5cdTAwMWR5wrJcdTAwMWHDh8OdTGY9TcOEMsKBw5/CtVx1MDAxYcKvcUxmKMKvMjVcXHTCs1x1MDAxYcOOw7lMJibDhTJhKDxcXHY9TVx1MDAwN1x1MDAxYcKGw5kyw4kjNcOxwqdMXHUwMDA2N8Knwol5XHUwMDEyJWDCoGvDiT8kw6bDsMO6XFx0w5/CokpsPU1YwrV6w7U7O8K0XHUwMDAzUmzDoMOdb8OyUHHCrsOMccK1OkhKbMKNwr9vw7JcdTAwMTQ3XHUwMDFlXHUwMDA1wpsvwrTCh8KGwqtYTsKBw4rCnlx1MDAwMTRcdTAwMGVcdTAwMDXCgcK4cMKIUnHDtVx1MDAxMMK/TcO3w7tcdTAwMGZcdTAwMTLDnGRcdTAwMWV/XHUwMDA1w7TDulx1MDAxNVx1MDAwM8KPUl7DijbCp1x1MDAxOFRvwoHCocOAw4zDocObw4/DssOJwonCtEhHw4LCtDjDr3hvXHUwMDAxXHUwMDEzw5PDkinDkDzCnsO3w6kuXHUwMDE3XHUwMDE1UnA5w5FAw41cXHZcdTAwMTTDr3LCkMKVO8K8XHUwMDFiVsKsXjXDu8K1wrJswp5cdTAwMTjCmyskY8ObKj/DpsO1cSvDgyPCklxcZiVmwp5pXznCl8KmZC/Dh0RlL8KjwojDt29mwr7CtTBcdTAwMTjDtGvDsVx1MDAxZsKdw7rDpFx1MDAxNMOzXHUwMDEyw68lwpZewpV+YMKEw6ZZNcO7XHUwMDE0woNcdTAwMTLCoMKgUHzDpcOCwqs4w4XCkMOKwrUvwr16MlxcXCJgZsKfw717J8OuXl7Co3lUZCBlL8K/W1NcdTAwMTJyw79uXiN+XFxcXFx1MDAwNG5Pw43Cklx1MDAxOU7DnsOaSjs3XFx0w4PCqlx1MDAxMMKfw67DjcKbXHUwMDE0XHUwMDFiwpLDgcKZRsKEw4JnK3PDmUbCuT7ChMKMw7vDpMKBW8OSwr9Bwq3CgFx1MDAwMnHDjWnDqz1NesKZXHUwMDFjwoLDnsOgTDTDp8KGRMKzXHUwMDA0w6DCuWtzw7c7wpInw7/Cml5cdTAwMTHDq8KSwo5cdTAwMWRkNj/CnsK4bE/DqXDDjMKrZ03DusK4w6nDi1x1MDAxMsOzXFx0XFx2XHUwMDEywoDDuVpeXHUwMDExIXrDrilEwqxww6k3cD19STHDi8OKXHUwMDE1wqtcdTAwMTJ5w7U6fsOnUSrDp8KGXHUwMDE3wrl2wpUnwrpcdTAwMDHCjsKJXsKawrY5w7xcdTAwMWFuXHUwMDEyw5howq3CkMKgwqVNXHUwMDE1w6XCrcO7wqsnwojDssKXw5hRXHUwMDA0w4dcdTAwMTbCq8O2w6dcdTAwMDbDu8KMT2FOJcKOSlRcdTAwMDVcdTAwMGbCtMOkdMKHw7rDnsOKK3J5w7dDw4fDpFx1MDAwNUnCs0RGe8KOwoxpPsKWXHUwMDEzwqrDjMKJXHUwMDAyw4svRcKWw7slM2BSwoHDuUTCg1x1MDAwN8OabsOmZDXCjsOrw4LDjcKsWcOQcsKQw40zw6RbXHUwMDA0QsOnw4rCtsK6w5rDsypnwrfDvHFhU2fDjsOhdzFHMsO/cFx1MDAwNcOpwpLDjFxcYsOvRMKSXFx0asKfwp5cdTAwMGbDkFREwr/DlcKsJsK+wr7Du8OQw5fCtMOSw7ZxwqrDmFxcYlxcdsOLf8KDNFx1MDAxMldXwrnDhMOBw7LCrMKZdDBzScK8bD8rXlxcXFxcdTAwMDZcdTAwMDLDscKOSVx1MDAxNcKLw6TDmcKfW8OBZMKoXFxcXFlowqnCjcOswqRkQ8Knw6N5dsK6w7zCpcOQbVx1MDAxNzdcdTAwMWR7PU1PfcOOXHUwMDFiwrbDk3/Cp8OswoI0SFxcXFzCjcOPXHUwMDE5WyDCh8Ohw4N3ScKYWsKBScOfXFxcXMOlw5nChsKLcEnDp8OyPUrCt1x1MDAxMcOCw6nDnXldw6R9eFxcXFxcdTAwMDTCu8O3Nlx1MDAwZsKbwrZcdTAwMTPDumPDtl4pXHUwMDAyw7nDlsOpw6jCscKDw6TDjcKzXHUwMDAzWsKnZcO9ZMKYVcKNw73CqT19w53CucKEw7nCvsKGwonDrcO2woLDocK0wqPCvMOfw4bDg1x1MDAxOcOjwq7Cg1HDp8K6w7vDqVxcXFzDgcK7wodmwrXDs0LChcO1bkTCgF3CgUnCgVxcXFzCsXpTw43CtFx1MDAxZMODPU3CrcOdw4PCtTF9w4N6w7EuwpBcdTAwMDbCsMKSw5B5XcKsM8OFO8O0TsKnNcKOLD1NwqZCw4/CtcOIw7ZPwpHCgcKQw6vDnMKow7bCvsKYVcKQwoTDljPCnT1Nwq5YfcKSw4rDuMKywrQvNsKndcKwW8K0XHUwMDE3O3h7JFbDnmVcdTAwMWJ+w4LCvMKgdWJsJ8Omelxcdlx1MDAwMntcXHbCu8Oiw4fDrMKUXHUwMDEzw5/DrG/DhUE0XHUwMDBmLcOVwq9cdTAwMTTDgcOcwq59wo/DrcKvNUM5XFx2w5AsTcKLw7nCoFNcXHbDj1x1MDAxMMKAXHUwMDE5csK1f1xcYjPDtEtcXGLCkcOhSElWw4ZEwqPCtkFcXFwiXHUwMDBmw6Ikw43Djj19w43CkMKXZ1xcdsKVI1x1MDAxMsOuXHUwMDFkXHUwMDFiw6bCkDXChcO1XHUwMDEwwo/Dh3ZcdTAwMWRcdTAwMDFtPU3DhFxcdHfDt8KZPUDCmcOSwpcgXHUwMDE1wofDvMKmS8KkbcKdw7fDi1x1MDAwN8O3e8OUw7fDt1x1MDAwNMKTw4HDhFx1MDAxNcOFXHUwMDE5XsOJwoDCp1x1MDAwM8OGw4hcdTAwMWHDn8KjXFxmXHUwMDE4w6hcdTAwMTDDi1x1MDAwZsKcwpbDhMODPFx1MDAwNcKnwoTCrSfDgsOWw7kgw4Fbwo3CocOYw6HCi8Otwq8nwoPDv2UtXHUwMDAzRVx1MDAwM8KtXHUwMDAzRENpwoDCmW9awoXCjGHCvMKHwpzCjjZFY07DgFx1MDAwN8O/w4TDsj1Ab8OPw51cdTAwMTc5UcOdwr/Cm8KvwpZcdTAwMWLCvVxcXFxgwozCgT/ChVx1MDAxZsOow4RcdTAwMWbDmsODw7N4c8OCw7fChMOYw4TDsTjDo8OowrrDp1TDocK+XHUwMDA3XHUwMDE5w5/CrCfCvsKDw7lcdTAwMTDDmcKTworCr8KBPUDDnWjCh8OFXHUwMDAyZsO1wpfClsKVXHUwMDEyOGDDjsKKQcKlwqnDv8KIw6DDgmfDqkTCnkbCkMK5XHUwMDFmR8KNwrFDw5tcdTAwMTbCo8K5QD1AwpRcdTAwMWVDYFAnZsOFesKbwrPCn8KIwqLCv2fDm8OowrfDjyBcdTAwMDbCjsOpRsKZwpHClcO5XFxiwo1LworCt8OXw6Q4w6BcXGbDt8KRwpY9TcO3w4HClsKhXHUwMDA1RcOgI1x1MDAxY8KlIFx1MDAwN1x1MDAxM3nCllx1MDAxYsO7WcKWJsO4XHUwMDE5XHUwMDE2w5TDv8OpwoLDrcKDXHUwMDA3XHUwMDE2wr0mwohgw5Vpwq/Dj1x1MDAwMcO9XHUwMDAye8KHRMOpw5TCvMOrJ2TCj8KbwqHDlmZIwqhrK0XDpVx1MDAxYcKbXHUwMDEwVCs2wrlSXFx2w7Y+wo/DlsKdcy9lIH3DrWVcdTAwMTHDkj1NL1x1MDAxOV9cdTAwMWFcdTAwMTfCilfChsOic0VcdTAwMTEow7/Dq1FNXHUwMDFmwprCjMK9aDjCvVxcXFzDrsOdw7BCwotcXGLCgMKNwqYjw5Ezw6g8worCsMKjNcO3wptcdTAwMDMtNcKWwpPCk8KvwqVRwoPCjcOTZ2BcdTAwMDIjw4VXw5hIwpLCucOlXHUwMDFkRlx1MDAxYSbDpydaJFx1MDAxMsKyXHUwMDBmwpfDhlx1MDAxYVx1MDAxZDPDuMOiwpfDsyrCplx1MDAxM8KsNcOoPUBcdTAwMTfCtFx1MDAxOVx1MDAwNTnDrMKZw7DDpFxcdsKJw79cdTAwMTjCgsKUw6Exw4DDqT1NwrPDj8Klw6dcdTAwMWFBfcKZXHUwMDA2XHUwMDE0UcOuw5U8Q2bDnDxcXHbDoVx1MDAxZmhiXHUwMDE3w4pZaMKhw685w73DuSbDm8O4wrkqVldBwrLDucKSMFxcdnLDncKKwqbDsksuacKfR8K0wpnCozjDrcKdwq/DrVs5wq9cXGYqwpAuQDhIwrNlMcK3w6zDuyfDrcKawrNcdTAwMGbCkmZ+YUbCiVxcZm89SsKJw6lNXHUwMDFhw5/DgcKNwprCksKFTsO4YzzCr1x1MDAwN0XDsFxcZsO/fz1NXHUwMDFhw6TDrsKSw7ZcXFwiw7A9SizDjcKCXHUwMDE2JVVAwpnDomBIWVx1MDAwM2IrwpVAw7DCi1x1MDAxZMOqwqLCpnZNK1xcdMKlw4bCqm/ChT19wpvCjcKAPMK4QirDoMOzXHUwMDAxwo7ClsOnwqFMOMOzdMOrWcOXfVx1MDAxYlx1MDAxOXHDk8Oiwpx7RFg3csOxwpnDqMOPPU3DvVx1MDAxNVDCi8OvwotDXFxcIlx1MDAwZVx1MDAwMTYmwqLCo1B4IMO0w6zDjVx1MDAxOMKRXFx2wp9vXHUwMDAzYsKGwqdcXFxceFx1MDAwM2hDwpbCvkZcdTAwMDbCok0xXFx0eMO2w69bw4fDo1x1MDAwMsOVwp40w7jCv8O4w63Dp11cdTAwMWRcdTAwMWHCjWtowoDDhcK9wrnDgVx1MDAxYjTCmnDCnyvDiFxcdH3CqsOTU8KKVcOmUsOuXHUwMDExTMK0w5pcdTAwMTjDk0zDpsOZwolbwojDpsOOQklcdTAwMTlUw7DDoMObT1xcXCJcXGJcdTAwMWI8wqZ/wqFUw4DDtMOFwrR1WHfDr3hQw49cdTAwMDJcXFxcw6E+wrlnwoPCtFlUw4BcXHbDrMOyXFxcXEbDocOQNnnCpcKEwrBlw7bDtcKbe2xjOMKEfcK4ccOgw4E9TcKjwrQ/woLDsMORLFx1MDAxOcOzw5PDqsK1RFTCmj1Nw680Jj1NdS9Yw7o7wotlWTvCgMK3QMKLwrFMO1jCiFLDrMOpw6HCs1x1MDAxYSDCkDvDiFxcdFTDrMOFScK1XHUwMDFhccKSwrl9w6jCtcOaXHUwMDA0SWLCsGBcXFwiR8Oew6lZw6vDmcOnXHUwMDBmwr8yY8KIPsOLw5zCn0zDnl59wq50Rm/DklxcdFx1MDAxZDTDnsKhwpgvPGLCgErDvnzCuHA5V3HDq0HDtMK6XHUwMDE3PUpcXFxcXHUwMDFlwpVtU8KUXHUwMDE4w4XCtFTDrcOqwqnDpcOMLkNcXHRUcGZcdTAwMDPCjMOOXFx2esKuLC01w7vDuMOyLF5MYEnCo27Cq8KpX8KSNMO8wprDtm/CsDRjw5JcXHbCmGBcdTAwMDRcdTAwMDbCusKvwqbDjF17wq9KLcKPXHUwMDE2dXHCpE3DvcO6w5zDkVNcdTAwMTLClSRuw67DpnNsw53CjT19w7vDpcKdXHUwMDFiUsO1UDjCg8KBwrZxw6DDgcKNw7o2XHUwMDBmwpI+SGZAwpdWwrhuw51cdTAwMDFwSsO9XHUwMDEww7vDklx1MDAxYSRSw55cdTAwMWJcXHYyw74mwqJiwqTCmsKRUsO8w6I6wrbDtMKgMcOMKFx1MDAxZCzCusKZw5xJw6Rgw6oxwqdcXFwiU8KuwqDCk1pcdTAwMWN1XHUwMDFkbnfDhFx1MDAxOHJcdTAwMWZcdTAwMTJqXHUwMDFhXHUwMDFmw6VKw6XCoXhyw5XDsjt3XHUwMDE2w5txwq3DkFx1MDAwNMOMXHUwMDFmw4fCgFx1MDAxMsKGw4YvZMKjXFxiPlx1MDAxN8OeX3DCt8O9NsO6w5dcdTAwMDXDpMKSw5LDo2DDnHnDvWrCtcOhw5TDjHdHdMOSfm3CqmbCpz56wpnCtFbCpMKHVcKvRi0lw4LDglx1MDAwNljCkCPDrMKZwrZcdTAwMGY9QMK5w7bCusKnw5lDXHUwMDE5J3nDg1xcdlx1MDAwNUnCqilcdTAwMTRgwp3Dm8Oewr/Ci01ZXFxcXHnClnldY8KJeVrCsSFJwowowo5cdTAwMTjCi8OUwrbDoV3CtVjClsKOXHUwMDFjXFxcXD1AWsODXHUwMDFjw7XDg8Odw5VBWlx1MDAxMUfCkFtxOXbCkcO4ecOIw7TDgsKPwo5bwpTDm1x1MDAxYsK2w4fCqWLDvcKVRMOyw4IoXHUwMDFlworDlnllWsOFwpBEXcK4a8KUdn7DiV7CvcOHXHUwMDFle8Kiw5QjwrBcdTAwMWHDqFx1MDAxYztcXHY9TcOSX8OsaVXDkTN5XHUwMDE2RlPDhsKSw5JZwobDs8OpXHUwMDEywpfDqcKfw5rCoXXCmyVbw7HCqlx1MDAwNj19e8Khw4jDiULCiMKPw73Dpm7Cj8Kmw509QMO6w6RcdTAwMTDCksOjd8O3woPDsVx1MDAwM8KQXHUwMDFkw57CpcO3TS5cXHTDhcOJwrHDs8OdeFVeXHUwMDAzwonCocO2XHUwMDAyw7fDlHhcdTAwMTZAwonCmWDCo3wyRWRVwrzDp8OkWMKzR8O/wr7DrThcdTAwMDPCh8O4VMKvw7nCikVYw7bCkMK/ZkDDm1x1MDAxNFx1MDAxNcKBw5pTw7zClcKDZsKLXcKlwqFcXHQ4YMOnwplZXHUwMDE1OsKawq7Dp8KFw7PDnCAxw7nDmjlkWMObw4XDj8OZw51twrZcdTAwMTjDmi/CuMK5XHUwMDAyWcOYw7lcdTAwMDNsXHUwMDExw6FcdTAwMTZzXHUwMDFkw7lcdTAwMTbChig5w6Aowp9hwqVdw4DDrEhow7xcXFwiwqvCu0bDmCnDi8Kqw43DuTVcdTAwMWHDmW/DtGLCjMOWREjDj8ONwrPDmcOgwpQ9TcOHf8Kkw6LDl8OJSz1Aw6nCmMK2w53DnMO3XHUwMDFhOEN1wqbCosObX8O4YcOaw61cdTAwMTFcdTAwMTVHXHUwMDFhwozDtyhcXFwiXFxcIjbCkcKWJ1x1MDAwMy9JSF8ywrlcdTAwMDNcdTAwMTjCuMOJKVx1MDAxYsOubcKxwqI9TVx1MDAxNkQww6XCjUlmJV1cdTAwMWU9TcKewrA9SizDoUrCpsKpwqIyw7jCskjCsH89TWxcdTAwMWIoXHUwMDEywrvDgjM3w63DlVx1MDAwNsOsXHUwMDFiwqhcdTAwMTdbwqLDtMOxcsKmIFx1MDAwMsKCw6bDnkxEw6HCo8OuXFxmw67DoT1Nw5vDscKsYlx1MDAxNj1Nw4LCqn15UFxcZsO/S8OzXFxcIlx1MDAwNMKvwrNcXFwiw6daP2lcXHTDgMKww6FcdTAwMWNQwovDhVxcXCI2RsObXT19w4XCpsO0w6x9w5dQPU3Dm8ONwp1cdTAwMWHCuCbChsOGZMKRNEDDl8O2w63DmVx1MDAxNVx1MDAxZFx1MDAxYsO8w68vw6LDjMOcOll1VsKsZMOaQmXDs8K/PUrCsFx1MDAxZE/CgsORwoxUwojCjMKBwrTCv1jCq8OXScKBwrDCmcOpV8Otw6RcdTAwMTNcdTAwMGbDgsKjfsK4wqcsVcOaXFx2w5A0wqZcdTAwMGbCkS84wo9uwqJcdTAwMWZ+O2jDnm3CrsKBwohBwospOUzCpipaw6YvXHUwMDFhw6Uuw7DDksKAw5nCrMKbVXU7XHUwMDFjw4LCgMKrwqQhwr9Nwp7DojZcdTAwMDPDuVlvXFx0w6bDkMOMwoXDscK0wrvDhHQ7JFx1MDAxM8KIwqrCmDnDtG00w6bChlx1MDAxZcKPwplgXHUwMDE0wpzDuG41wpTDvMK7w70oPj7CqGIzf1nCsMKbwqw9Slx1MDAxYsKSciViTsO3bkzCscO0w7vCklxcZsOEO8KSw6zDnMOLXHUwMDEydHBKw4TCjlx1MDAxNsKxw6TCoDPCu8K5w5tRfMO0RMKywobCgGXDi1x1MDAwNMOHIFx1MDAxMsKnwq0/bCPDkFLDtcO7Kk/Chj1AbHRNf3tcdTAwMDR7aMO0OsOyw4wowp0oXFxcXMK5wpjCp8KPw6jCpsKnw6/CslxcYlx1MDAwNsKRw6BGw6jDsMO2dmbDr8K2wqLCqcK6w5vCucKSwo7DrD1Aw5jCkMKkw5nDt8KRw5zCiHjCjcOYwofDtsKKPFx1MDAwMcKwW8O4w41cdTAwMDbDg8OFR8Kww7bDgVt8dsKMwoTDlcOawrbChE/DniY9fVZeXHUwMDAywp5cdTAwMDYlwoV7XHUwMDBlXHUwMDFiwo5cXHbDgT19w7F5UF/DkcK4XFx0XHUwMDA0w5ZcdTAwMDMmw5rCgyTCuSzDhVHDnMKKMcOoQMOcw4VGw7HDnD1ATcOQw5pcdTAwMTRcdTAwMTBfwpbDh1x1MDAxNsKMwqDCilx1MDAxNcKEIMKgXHUwMDAzeD1Af1x1MDAxYlLDlcKJwqTDgMK3Y8Kpw4fDpyRcdTAwMTM7ZVx1MDAxNFx1MDAxZMKFICbDo0lcdTAwMTbCrMONWiHDmW44woXDhFNcXGbDo8Klw77CmsK0w584aMKAwo/CssKBw57DgsKLw5fDgT1AwqJcdTAwMTLCpTFGwqPDvUPDscOWSMKuw5E5XHUwMDFiw6zDp8KBQ1x1MDAwNl3DuknDiVIzw6xcdTAwMGZcdTAwMWbDrcKaXHUwMDFmw7TCu1x1MDAwMk5ZRsOZw6HCs8Osc8Kxw4xcdTAwMWJjPU0zXHUwMDAyY2grw5V2d8OwwqFdfMObJsOKc1x1MDAwMlx1MDAwZcKgUMKYRmBDw6XDmcOyw6/Cs8OxXHUwMDFjXHUwMDFhw6/Dpy/CgsOlw4wyKV5Yw6vCkHXDkGxJw5g+wrlcdTAwMTVYw61cdTAwMDdcdTAwMTnDtMObXHUwMDFjXHUwMDE4NMOGSVLDrFTCpW9cXFwiXHUwMDA0UTsow7nDlFx1MDAwNClAXHUwMDAxw4AmXHUwMDAzwpvDicO7XHUwMDFhU8OPYHtBw5LDscK+XHUwMDE5w5vCt8OewoovV8Oowooxw5HDs8KRPX3CpmRTaMKXalx1MDAwNSZcdTAwMTHDtCnDp8ONPsOYwr05w4lcdTAwMTDDvS3CksKwOMOQccO7KcOYJlxcdGVkwosgWyNaXHUwMDFhwrPDjD1NXHUwMDEyPmTCvSjCoVx1MDAwZilcXGJbKsOYwr15RsKmw5DDusOvwp4vZ8OHwpYkw6bCs0BGwrvDm8K/KSlcdTAwMWPDucKAb8Oxw7rDrlx1MDAwNsO8XHUwMDA0w7DDuFxcYsOLw4nCjcKpUcORK1jDmC0xw6PDo8OlwqXCpDcgQFxcXFwyIyQjMTYzNjTDnMO/XsOdwp1IXHUwMDBlU1x1MDAxZVx1MDAxYkU8PlxcXFzCllxcXCLCsnvDjcOxbsK3wrXCs8OHOsOJYltfZ01dZcKRdGt7c8KTwoNvw4/Dl8K4wrfDlcOhwqnDssOyXHUwMDFhw5LDgjMzw7NTXHUwMDEzQ8K9XHUwMDFkNHXDtFTDlMOQXHUwMDAxw7jDiMOhwprDs8Ocwr9cdTAwMWbClWHCmMKTXHUwMDA2w6PClVx1MDAxOcKoNcOtK8OoTcOwT8KPdlPDmMOSw4hjwqFcXHbDvMK/wpVhXHUwMDE5XHUwMDAywp09SsKSXHUwMDFkw7NcdTAwMWTCgcKZXFxiwqdcXFwiXHUwMDFlXHUwMDBmw4XDuWkowpLDg8Kjwrd2w7JTw5nChcOcwpDDtcOYbcO3w5FZw6BcXGLCpSgoXHUwMDA1SV81PmPDk8KeIMK0w7fCpcK5w4nDpz1AKFxcXCLDv8OxwphnPX0hwotbXHUwMDEzL8K/w51Aw5fChMOpwpdcdTAwMDHCq8ONXHUwMDE2wq/DoGXCucKJw6hcdTAwMTkmw7vDkcKUXHUwMDEzZVjDpcKcw6tcdTAwMDTDkMONwpHChFx1MDAxOWfCpSHDn8KFwophXsOfwpwjeMKmJ1x1MDAxM8OBaMOIw63Dslx1MDAxNsKDRcK5w59oKcOTwpI9fcK+fsOkworDvcOLwp1cdTAwMTdZw6hcdTAwMWVcdTAwMWMkwq9cdTAwMGbDuFx1MDAwNcKgw5wnwqfDiSbCqsKSw7tkJlx1MDAxYcOBw4bClcKGw7cgw7VcdTAwMTlcdTAwMGXDh8OMdFx1MDAxNcK5XHUwMDA2JFJhWsOLwpjCgcKFw5HDllx1MDAxMcOOXHUwMDBmUcKJw7U4w4hcdTAwMDbCmlx1MDAxM8OFw5bCpVx1MDAxNFxcZj1NR8OcXFxiw6NcdTAwMTXDmSfDgFx1MDAxYsOHw6TDpW3DsMKJwp4yXHUwMDEwwrVyTF5PwqlcdTAwMTU9Slx1MDAxOVx1MDAxMsO7w40lIMKXw5U7woQnZVx1MDAwMzPCqcOXw5fDl1x1MDAxMcO4R8KIPUrCkXVcdTAwMTjCulx1MDAwNsKfw57Dj8OPXHUwMDBmXHUwMDFhXFx2w4fDncKmw5bDs0fCvMOlwoTDmcKGw6PDvMO8wpzCisOow4lXw6NtwpxBI03CoSRcdTAwMDTCumVOwqHCh8OjwqJcdTAwMWJcXGbCsz19wqVcdTAwMTAkXHUwMDAzdFx1MDAxOD1KKHjDh2TCn1x1MDAwZXLDvcKWwolFwpzCsVx1MDAwZcOYwrVcdTAwMTHDuMOHZcKowqYhRmnChcO0wqFtTVdiwpRBecOrPMOSXlx1MDAwM0PDjcK8XHUwMDE0w4rCplx1MDAxMsKfw545Lz19wrpcdTAwMTPCoiROw5dqw48rPsKWXHUwMDEzw4PDmndcdTAwMDZ2XHUwMDE0Nz82fcK6wqzCi8KTVy9kwrfDqCrDlcK0XHUwMDBlesKXwr5dw6cqwozCsEHCqsOYwrjDjCHDusONw5Jnwr5Uw4dtw6HDu8OkWklcdTAwMTBYXHUwMDBma8OZw4pnw5I/w77CmcKUVsKnwq5INXXCrlx1MDAxM8KsKFxcYsOPwo/CiijDtEPCgsO8w5XDhMOgw47DlMOTQX4qw6fCszgqwpbDs8O6w7NcdTAwMWVDwoTCu8O0w47DmHonXHUwMDEyY8KeacKUOFx1MDAxZsKrRHhcdTAwMTnDjsKxfWXCi1vDsnYkNMOXc1x1MDAwZn3DocOSwqtcdTAwMWU8wqRKw5/CriR4b8O6MVx1MDAxMjJcdTAwMTQqw49zXHUwMDExw73DocKSbcOUwrbCpHLCo8O9w5XCk8KZwpRfw79tw6/DvFFcdTAwMTLCglx1MDAxNC7CjzJ9ZklsYmssw65ew4LDu39aWcOgNMOMPX3Cplx1MDAxM1x1MDAxZlpXwp5nw65DTsO6V145XFxmXVhswrZqR8KKw6U4wow/bFx1MDAxMnBkLsKMUMKiwp5kwqfCu8KAwq3DgyVcdTAwMDErwrs1XHUwMDEzK1rCqSk1w7YnXFx0dcKxay7Cr0TDh3XCicORXHUwMDFmSsKgPU1Iw7Y9TcKJc8KlbD5wQW4sRsOPw7FrZsKvSMKHbFxcdMONwo9LLFx1MDAwZVZuS8O2w4rDl0rDgD1NT8OuPX3ClsOQwrFqfsKwVmfCu2h1VWtmw7J/wrJzw4I1fcOQXHUwMDExbMKWblJWwoVANFtEdMKeQMKnwr89QMKsXHUwMDEywrpcdTAwMDU6w4vDmsK+SC7Cm0hpSj1APUpKZzDDjDHDnlx1MDAxMiwkYMKXLsObTMK5SsKIwos3V8Kuw5LCucKIwrJmwpLDkMOxbSbCsDtWwqggMiB8dMOOeMOrwrjCu8O9wop/XHUwMDFlwpPDvl1cdTAwMDLCuMKWLVZcXFxcw6crbMO8PFx1MDAxM31ew4nDhG7Ch8OMXHUwMDE2XHUwMDEzwoPDnmdfwrXCpHE3w4/DocO9bcOTXHUwMDE3esKhd8OMWcO7w5pcdTAwMTJFwp/CrcKcw4tBw7tYw75MXHUwMDE0VV/DhFxcYnHCucOQIHtcdTAwMTR6MVx1MDAwN8OKXHUwMDFmw5PDk8O+wqfDtMK1wohvwqV7w5XCisK3wr7CkiRCR3dHw41cdTAwMWVcdTAwMTPDk1x1MDAxZcKnwoTCuHTDi8O4ez1Awp43wpd3w79qYsKaSsOnwq84w47DoHrCnHrDtcOHw43Cv8OTwpZcdTAwMTREw7/DicOIcSHDkVx1MDAxMHvDicOSO1x1MDAxZVjCpC7Dn8K1fMOQw51cdTAwMTPClcOeYH9yw5/DrSzCnsO1wpJhwpRDXHUwMDFmwr3CtMOOOcO7wrvDvkt0w4VYw45cdTAwMDXCk8KNw5QsVMKRwrDCmMOKQ8OUK8KMXHUwMDBmUMO6VmfCq8KMU8KNw5I/ScO9w7w6wpfCnURMaMOQw71AOmFcdTAwMWRGwoxhYMO8KDorTXdRw7vDkcKTK8OuXFxiwobCsFxcXCLCuVx1MDAwM8OeLW7Du8OmwrFywrhHXHUwMDFlWsKywrE7w7pDXHUwMDFlwo/ChC1MwpvCmGxew7LCjFx1MDAwND/CjMKUw6hrwobDscKoZEbDjMKNXlx1MDAxMmYkUMKXKlx1MDAxZiAtwrI3w5PDkTFtwq7Dt0nCslx1MDAxY2J4w7Fqw5bCtivCh3Rpw4pcdTAwMGZLw6RcdTAwMTFmbsOCw77DvGA6w5FcdTAwMWREwoxvw6DDvGs6wptNecORw6wswp5UOlx1MDAxNcO9NFx1MDAxYlBcdTAwMWTCk1HCslx1MDAwNCM2wrtNw6VcdTAwMTPCuzrCqcONbHnDkMKFwpNHwrImw6Mtw7tRw7XCk8KhwrJcXHYjL8KbTsKxXHUwMDEzUsKyw7DDu8OLwrVcdTAwMTJlw54zw64rZ8KrwoLCvsOfXsKswrLDiGjCslTDq8KeRsOuXHUwMDEww4LDukwkM8ODa3BcdTAwMTDDjX9Qw6teQcKGOsKjwowgwoU7XFxmXHUwMDExw6DDiVLDo1Rsw5nDmcODYGXClztLw5kzwrvDt8OlXHUwMDFkbnI9TVx1MDAxNcK2XHUwMDEww5hrTMKOw6nCpcKHw50kw7E0XHUwMDBlZFx1MDAxYsKiwp1cdTAwMTnCtDROw43Du1xcYsKmw6zDnSxcdTAwMGZHXHUwMDE4wpZIw73ChMK4w6DCl8K9wo9Zw63DvsOIPU3DicO/woPDlcKlwo9SPUBcdTAwMDPCvnc3V21pw7xHXHUwMDAzP8Kxw6ouw5QhwozCg8O3fMKeXHUwMDE0wpY6JVbCn1TDpCRUwqxcdTAwMGZcdTAwMTdTa8O9KFDDmlxcYknCtXvDklxcZsKOw6BcdTAwMDTDjkLDl8KAU8KNXFx0L0DDi3nDvcOVXHUwMDAzw4zDjmzDrsKew7nCjFx1MDAwNzTDqlx1MDAwN2HCk0tcdTAwMTXChsOAwrnCsFxcdMKEw7hcdTAwMTBAXHUwMDExw4vDk1x1MDAxODfDllx1MDAxZcOOU1x1MDAxMlx1MDAxYVxcZndcdTAwMTYhe8OjXHUwMDEyw67DhVx1MDAxN1x1MDAxNnLDsUZcdTAwMGVcdTAwMTXDoMOBX1x1MDAxNcO1cMKeXHUwMDAzwovDoFx1MDAxYcKGQMKsMMKtw4daZz19wpPCp2jDt8OoSMK+wqtIRcKGwozCt0nDkcONwrXDksK3f1l1bcK1w4xcdTAwMDVcdTAwMDPChVTDk1x1MDAxMsKFw7BtYMKpXHUwMDBmbsOeZ1x1MDAxOUN1XHUwMDE1T8ONXHUwMDA2XHUwMDA2YVx1MDAxNlx1MDAwNsKjwrNywqhcXGZRPUDDoGVIXHUwMDAzwrZcXFwiw7jDqMK0wrNtNSTCn8OdwqEgwrlRJsOtVHzDm8OyPUrCrz7CiEFCwrfCtHjDs1xcZsKww5TDm1x1MDAxMlx1MDAxMVQvwpbDnmk8P8KPM1x1MDAxYcKqMTtcdTAwMTLDqMORXFxcXChcdTAwMDZfRFx1MDAxOMKBw63Dg1TCi1x1MDAxMjw9QMOqw7cwTcK7wpjCs2AowpdGwrTDmGRcdTAwMTJcXHbCq8Kkw63DusOPZTDColBpLsKnU13DsCbCmcKrw7LDvMOqNsKJw6k7wqosIcKDPUrCicK3PUpcdTAwMThcdTAwMWTDncOwwrXCtcKnw7pcdTAwMWR1w6DDosODwovCusO/wprCmkNcdTAwMWU2cMO5w7lkwoxcdTAwMWTCp8OIwrIgwprDsDVcXGZcdTAwMDbDu8OuN1hcXFwiw4XDtkouwq5cXHZCw6tjNlx1MDAwMTpcdTAwMDbCrVxcdsKILsO5worCokBrRELDvGzCulDCsMOeO8OmLcOtw6U6w6Y9fcOtw6U7XHUwMDBlK23CiDpcdTAwMGUzbVxcYjpcdTAwMGU7bcKIO1x1MDAwZUNtXFxiO8K+K23CgzrCvjPDjHLDvsOqw5dlRG3CgzvCvkNtXHUwMDAzO1x1MDAxYSotWTpcdTAwMWEuLcKZOlx1MDAxYTItw5k6XHUwMDFhwrbCrsKySz1KSzDCiFxcXFzDqn02w6bCj8Kqw7FCwqLDtyrDuVtcdTAwMWHDiCtDworCui8tXFxcXMOrSkUwwo7CrmvCgDbDsjbCrVx1MDAxNkLCukswwoNcXFxcSn02w5zCj2rDsELCjsO3wqrDtlvDssOIK0fDqsOKNTZcdTAwMTIuMFx1MDAwN8KKanHDisOlw5zCsyvDh8Orw4plNlx1MDAxMjowwofCjGrDkVpcdTAwMTJALWTCsGtcdTAwMDFCw7pjNsOkw7HCqjjCjMO6bzDCnjzCrcKYXFxcXMOKw41Cwp7CvyvDh8Ovw4rDpTZcdTAwMTJaMMKHwpBqw5FbXHUwMDEyYC1kwrhrXHUwMDAxQ8O6wqM2w6TDuSowWsKKwqsrdsKKw6owLULDq8KqP0vCijAtwqDCrsKqSzbCgjwsw5Bawop1MkLDrcKqX0vCijgtIMKuwqprNsKCPixQW8KKw71FWsK0K8OVXFxiwqrCg3Zjw7nCr1x1MDAwM8K2wr9cdTAwMGUhM1x1MDAxY8OFworDgcKGUVx1MDAwMk8hPX1cdTAwMTbCvFx1MDAxMTPCoHPCpC7DpU7Cp8KswodcdTAwMWNowqzCh1x1MDAxY8KowqzCh8K8ScKswofCvGnCrMKHwrzCicKswofCvMKpwqzCh3xIwqzCh3xowqzCh3zCiMKswod8wqjCrMKHw6w5wqzCh8OsScKswofDrFnCrMKHw6xpwqzCh8OsecKswofDrMKJwqzCh8OswpnCrMKHw6zCqcKswodMOcKswodMScKswodMWcKswodMacKswodMecKswodMwonCrMKHTMKZwqzCh0zCqcKswofDjDkuw6VuaTLCoMKzw6g6XHUwMDE2PCdLXHUwMDAyTyRuw5p1XHUwMDFlwrXCisOBXHUwMDEyRcOrWMO7acKswofDjMK5LsOlbmkzwqBjwqcvXHUwMDE2PCdPXHUwMDAyTyR2w5p1XHUwMDFlw4XCisOBXHUwMDEyZcOrWMO7wqnCrMKHwqwxwqzCh8KsOcKswofCrEHCrMKHwqxJwqzCh8KsUcKswofCrFnCrMKHwqxhwqzChzjCqcKqwofCrHHCrMKHwqx5wqzCh8KswoHCrMKHbFx1MDAwZcOCw4ZNXHUwMDAxw7JnXHUwMDBlwohcdTAwMWM2wqPDgMOOa8O8TMKTwrzDnsOzZcOyw6XDsmXDs8Olc0hywohyw4hyXFxickhzwohzw4hzXFxic0NywoNyw4NyXHUwMDAzckNzwoNzw4NzXHUwMDAzMzkyWTJ5MsKZMsK5MsOZMsO5Mlx1MDAxOTI5M1kzeTPCmTPCuTPDmTPDuTNcdTAwMTnCszbCslbCsnbCssKWwrLCtsKyw5bCssO2wrJcdTAwMTbCsjbCs1bCs3bCs8KWwrPCtsKzw5bCs8O2wrNcdTAwMTbCszg6wodKZGvCnsKtXHUwMDEyMsO7P8OMXW7CocKyODvCh0xkb8KewrVcdTAwMTJCw7tfw4zCnW4hwrI4PMKHTmRzwp7CvVx1MDAxMlLDu3/DjMOdbsKhwrM4PX3Ch1Bkd8Kew4VcdTAwMTJiw7vCn8OMXHUwMDFkbiEzMDJAMlAyYDJwMsKAMsKQMsKgMsKwMsOAMsOQMsOgMsOwMj1AMlx1MDAxMDIgMjAzQDNQM2AzcDPCgDPCkDPCoMKLw7vDocO3wrxcXHRGw6Azw7BPIcKdXHUwMDAyUcKfwqpOZ8OYwphKwp/Crlx1MDAwZcKnwoZcdTAwMDdrXHUwMDE0OnPCqMKuwrwmwpvCnzfDk8KdTiNcdTAwMTFcdTAwMTRMfFFzw7TDscO/f8OOw7jCvMK+w4nDlcO1csOHUFxcdjnCgVx1MDAwMcK7ZHnDrGnDmFhOwp/DjMKuw6nChsKHc1x1MDAxNHYzKcOjw6TCvsO+w5M8I8Kawp9Xw5PCnU9cdTAwMWM9TVx1MDAxNMKMfFF1XHUwMDBlw7XDv8O/w47DuMOAw7LDicOVw7Vzw4dYw7s5w5jDmFHCn8OobsKpw6LDoMKqw54zPCdcXGZcdTAwMDQ0w7zCkHJcdTAwMWXCucKVdXLDhUzDu3nDmMOXS8KXwrhuwqnDo8OgwrLDnnM8J1x1MDAxMFx1MDAwNFTDvMKQc1x1MDAxZcOJwpXDtXLDhVDDqzFcdTAwMDE9QMK7YHnCrEnDmFdOwpfDjC7CicKGwoVzXHUwMDA0djMow6LDoMK+w57DkzzCpsKcwpdXwpPCnU9cXFwiXHUwMDBmXHUwMDA0wozDvFB1XHUwMDFhw7fDn8O/w47Dt8OAPUrDicKVw7Vzw4VYw5NJw6LDoMOIw54jwrwkwq3DnS/CsndKw5PCiWLChcKrXHUwMDAyNsK8JMKxw51PwrJ3S8OTw4liwoXCrVx1MDAwMkbCvCTCtcOdb8Kyd0zDk1xcdGLChcKvXHUwMDAyVsK8JMK5w53Cj8Kyd03Dk0ljwoXCsVx1MDAwMmbCvCTCvcOdwq/CsndOw5PCiWPChcKzXHUwMDAydsK8JMOBw53Dj8Kyd0/Dk8OJY8KFwrVcdTAwMDLChsK8JMOFw53Dr8Kyd1DDk1xcdGPChcK3XHUwMDAywpbCvCTDicOdXHUwMDBmwrJ3UcKTSWLChcK5XHUwMDAywqbCvCDCrcOdL8Kzd1LCk8KJYsKFwrtcdTAwMDLCtsK8IMKxw51PwrN3U8KTw4liwoXCvVx1MDAwMsOGwrwgwrXDnW/Cs3dUwpNcXHRiwoXCv1x1MDAwMsOWwrwgwrnDncKPwrN3VcKTSWPChcOBXHUwMDAyw6bCvCDCvcOdwq/Cs3dWwpPCiWPChcODXHUwMDAyw7bDvsKvwprCsibCqlx1MDAxYkDCm8KldsOYPX02wr0lc8Kld8OIUUJQXHUwMDEzOzbCvVx1MDAxZTPCsMOzJTLCsMOzJTPCsHPCqDLCsHMowrLCp2pcdTAwMWN1WnZcdTAwMWN5WnbDtG1adsO0cVp2w7R1WnbDtHladlxcXCJrWnZcXFwibVp2XFxcIm9adlxcXCJxWnZcXFwic1p2XFxcInVadlxcXCJ3WnZcXFwieVp2XHUwMDBla1p2XHUwMDBlbVp2XHUwMDBlb1p2XHUwMDBlcVp2XHUwMDBlc1p2XHUwMDBldVp2XHUwMDBld1p2XHUwMDBleVp2XHUwMDFlwqvCisOCXHUwMDEyMcOrWsO7QcKswovDjGkuw61uw4kywrDCs8KoOzY9fcKnTUJQJHFcdTAwMTZpw4zCuS7DrW5pM8KwwrPDqDw2PX0nT0JQJHZadlx1MDAxZcOFworDglx1MDAxMmXDq1rDu8KpwqzCi8KsMcKswovCrDnCrMKLwqxBwqzCi8KsScKswovCrFHCrMKLwqxZwqzCi8KsYcKswovCrGnCrMKLwqxxwqzCi8KsecKswovCrMKBwqzCi8KswonCuE4gXsKhwrdcdTAwMDZNw5vDocOjwpFzRDzCpcOGdcOFw6ZtwozDmcKdXHUwMDE5UMKjwrpcdTAwMDJcdTAwMWTChlxcYnJITyBow4HCoXwwc8KpwqpVRVPDjcOOw6nDqsK/w4dcdTAwMWFqw7zDiT1KwqJtwqJOXHUwMDEzwpnCmsOmTWbCvlx1MDAxZXFiXFxiPEh1JFVGXHUwMDE5wrM2TidDeGBucMK8KDhRZUxtc8KpwrLCvVfCu8Obw47DqcOuw7PDiFx1MDAxMsKqw45pw69cdTAwMTMww7s7c8KpwrXDvUfDjG3CvChCw5HChW7DsU4nX3ghwrI4dCTCncOGwpg8R8K/XHUwMDFlIWJcdTAwMDdPZFZcdTAwMTM5wpzDpHfCnsKGw7zCiVx1MDAwZcKew4nCimrDvMOJXHUwMDBlw5prWkxcdTAwMTPCmcKcXHUwMDAyS0LCvFx1MDAxZXFjwpY7wrZzJMOVRiAyME8nwoPDi8OOwqnDtcKLwr/CikDCgHLCrcOqwrovPUrDrXzCr2/Ds8Kcw6rCncO/MGtMw43DqsOBw58xw6bCg1xcXFzDvmpcdTAwMWFdVyt5wr1QPyrCiMONdz1KYcOcw45Mw6o9TcKeKsKmeDTCvjFcXFwiw6HCgMKqwrF1w4E0MMKZw79gXHUwMDFhwoFcdTAwMDN8wo3Dq8O9wp8uwqbCh8K0OsKPwr8zSMOOVTrCn19GwqZ0ZcOrw5XDvsK5wrQvwqnDvjNcdTAwMWFyw7vDmsKccizCosKrwoTCii88wolcdTAwMWE1w5cxw7nCukPDljB8LyjDisOROsOlXzImZ3XDqz1Nw40vVcKxPsKqw4lcdTAwMTFgw5ZqXFxcXDBmaTHDqyHDrcKtf3DDvMOrccKeO8KAwrAyK8OZe01cXFwiwrdcdTAwMTbCilx1MDAwZsK6ZFx1MDAxYUDDp8KvP03Crj1KN8KELShKTcKCwo/DjkbDpmrCucKKw5/CvFx1MDAxYj1KQcKUMMO5wro+XHUwMDBmLEjDh289SsO9e8KxJ8ORw5DCqlFcdTAwMTEwLm7CtzBcXHTDuGhcdTAwMWFcdTAwMTjDsnvCmD1KwqHCgzDDiEHCl1Q6w6ZSwoXDqsK5wox3b8KsMVx1MDAxMDpcXFwiwopcXFwiw5p6KU5cdTAwMWHDv8KGwqxcdTAwMGZcXFwiwrHCrCHCkGVcXFwiwplcdTAwMTbCi2MowoM9SsOfwqMxW8KQNsKiwo9Ew6pZwo02w7vCjz89SsK3wqN2XHUwMDFmw5FQwqrCqcKwLznCt17DlsK8wrwuwojCu8O9w5pcdTAwMDTCtGlcXFwic2DCrMORw64swoBow4M4KMK7XHUwMDExOsORXHUwMDEwOCjCuVx1MDAwZj1KK8O7wqt/fMK0w6pcdTAwMTnCmzHCgMKFwrMsecOywotcdTAwMWHCrzLCim/CvzZcdTAwMWHDg8KGwrDCv8KDwrDCq0HCjzFcXFwie0bCisK/wr5cdTAwMDM9SmfCoznDlcOiSlx1MDAxYcK4w5YvKcKyM8OWw5JMLMOZw7I9fcKCw4NPOCZOQmZPw5o+K39hwp1QwoPCvC3Dolx1MDAxNDYjelx1MDAwZsKswqnDolx1MDAxYcOJOWHCksKrwoZmVsOVbMOswqnDkFx1MDAwN8OOL8KffMOkwpp5WsKSwq4swpLCqzFcdTAwMTJrRFx1MDAwNsKZNcOEW0DCnm0wTmM6wo7DgzbDnMOfLlx1MDAxM3DCqsKmX2vDkCtKw7/CpnJ5OcKORCx8XHUwMDBmwqtOZ2vDgFx1MDAxM0rChWXCulx1MDAxOGLCusOZVnLCjTrDssKNTMOyw7E0Tl4wwo7Dji/CnEMswrxTKsOTXHUwMDEywq3ChsKwwqzCjlxcXCJKN1nCusOxTsK6wrlnclJEwo5OMUbCny3DiMOQKsK5w5fCq8O1wrvDqsKRwpc9SsKXSsKaw6E6dMKOKsOmRzBcdTAwMDY/KnExLXldwqrDsTjDqlx1MDAwZkI9SsOdZsKaw69HXFxcIsK8NMKmw5wreG8rw5lKXFxmQcOiRjHCplA7wrFdwpFUwqLCvU/DlMKOa8K1w7PDpMKsKTPCuMKEwqdFw6J9M1vCscKuZSU9SsOxwoZcdTAwMWHDlVx1MDAxNGzDs8OHXFx2w6RUXHUwMDFhw6xAw6LDiypGWi9IwqLDqj19dFx1MDAwNsOANS1KT19Sw5dHwr7DgTHCj17CrXzCpGzDlMO0enDClVLDj0bCvsO2QsO0XHUwMDEwMMKPw7/CsMO8IMKxXHUwMDFjdG1cdTAwMTg2SsKpw5jCusKJN8Oyw5stXHUwMDBlwoMqI8OewqrDhjgweMKdXFxcXFx1MDAxZUDDmT1Nw43Dsm9hwpxjw6bDv3g1wpwgam5OXHUwMDBlelx1MDAxY8Khw7fCscOMWCpHK1x1MDAwNDjDnivCkj/DuizDimNqw5XCq8OAK1csw4RRI8OnLsKSPUApXHUwMDA2bcKow5nCusKGw7kjwqnCvMKZXHUwMDA1R8KEXHUwMDFhf1TCglx1MDAwZcKFXHUwMDBmwoFcdTAwMTPChVx1MDAxM33DsyojfsOwwrjCskdDZUzCpMKOw6jCh8OIXHUwMDE3Plx1MDAwNcKUJ8KUJ8KvwpRcdTAwMTU/IVx1MDAxYSE0wp4hZcO5wpzDlcKfw5VIfj1NW8Otw6dcdTAwMDTDp8KEYk9awqhcdTAwMTJcdTAwMDLCi8KNw43CsMK4XHUwMDFkwrVcdTAwMWJ5SMOGXHUwMDEzfMKWZcO/VMOrwovCrnVcXFwiwrLCssOaw5vDrUzCsXAvb8KxwrZJZMKowpLDgFx1MDAxNz7DtSxcdTAwMWQsXHUwMDFkI8KUNcO/QcKTwpZ6XHUwMDA2w7ZcXHRRXFx0VsOxVFx1MDAxNlx1MDAwZlx1MDAxM1x1MDAxNsKdw7VtU8KowrNtwrzCsMK4NcK0M8KzQ1tYwpx+w5ZcXHTCosOJwr7Dq8OTXFxiwpNcXGIvLXUlw7fDnMOCwovCvMKKR1x1MDAxNFLCtkhcdTAwMTnDh8KYw4nCi8OBXHUwMDE3w4LCmcOHwpXDh8KNwofDkMKJwpdafcKNwrjCkMOnXHUwMDFjwoTDvzBcdTAwMWZcdTAwMTd0wqUjw7E/eMO0XHUwMDE3XHUwMDEww5dcdTAwMGbClVx1MDAxN0XDhkc+Y8KWdm7CosK2XFx0XHUwMDAywrrDkj1KXHUwMDAywovCs8OrXHUwMDEzwohDwpjCoy3DkcOiXHUwMDExwqJ+w6PCgFx1MDAwNVhdw4XCjcK+wpI7wpTCmcKJPFx1MDAxOcOBXHUwMDEzWlx1MDAwM8Ogw4rCicOTwpPDm8KPwrvDg8Oyw5bDsMKmw6A9QMKMw4c/w4Q3wqTDlVx1MDAxZcOhwpJfw5NIe2TDrMKJw5BewoVvwqVJw4RcXFxcwp7Cnm7Colx1MDAxNlx1MDAxMn5QaGJcXGLCqcKMcnDCmsOYwqVcXHbDqlx1MDAxY8Krwq8tNVx1MDAwNsKVMcO+XHUwMDAzw5ZbwofCksK+wopANMK1wr3Dj2p1cEBnw51cdTAwMTDChF7DlFAtw6tcdTAwMWNcdTAwMDLCssO0wqvCs8KFwpfDrUPDnGpcdTAwMDZcdTAwMWYlw57CisOGwqzCvMOUwrDDgMK4w5jDqMKrw4vCu8ObwrPDk8OTw4PDo8OjL3bDjsObTMOVY8Kzw4HCg8Ktwr/Cn8KcNFx1MDAxY0w8fFx1MDAxZMOiwq09SsKzM8Ozw77DssO+w77CmsKUXHUwMDFlKkHCuWJcXHRcXHbCqMKNbD1NwqzCpm1wwrLCqXHCtiBcdTAwMWZJUChcdTAwMTfCpT1KK1fCglxcZsKdXHUwMDAyw5JvUMKlXHUwMDFhXlxcYmfClcKpw4/CscKvXFxcXERDQ8KRwp8gwq89QFx1MDAxMsO1wrg0XFxcXGhcdTAwMWN7w6vChMOPXHUwMDFkw4zCo8KlJVbDkcKuw7XDrUbCvFx1MDAxNT8xXHUwMDA3w5bDo2TCqsOpwpjDiMKhwp1cdTAwMWRywrnDhjHClMOtw7nDicKVNWBcdTAwMTjCgmbDjsObwqHDnlx1MDAxOcO4UMOXYsKtZ8Ohwox4V8KFSMKDWmXCnFx1MDAxZS9hw6dzTMKxw6VcdTAwMDPChcK+XHUwMDE0wr3Dvn7DjX1fwqfCtnRgwrjCqcKCaMOfwp7Cl8O4w7/CvjMjR8KxVsKAblx1MDAxN8Kiw6DCpFxcYlx1MDAwNlx1MDAxZjVnQcOuWVx1MDAxZmjCk13CpSDDjcKBXHUwMDFkcSlcdTAwMDNmXHUwMDE3XHUwMDBmw5VcdTAwMGXDhMObWzhcdTAwMTZcdTAwMTHDqsKhw7FcdTAwMDZcXGZFOcKBwr/DkVx1MDAxN8OZwqDCnsKUwpzCnyjDvlxcXCJ4w6XCk8O9wqJrXHUwMDEww6QvwoNYw6HClsKcw6jDnyfCt1x1MDAwNlx1MDAxZFLCjsKCXHUwMDE4w6dcXHYwwphcdTAwMTEpw7InZMKXwpjCpD1KXHUwMDA0fMKLw6tPXHUwMDA1dMOZw5nClVx1MDAwMSYjQ8KiJsOyw4lZwoV0JMOoKcKOw4gkw6lcdTAwMTnCpcOjXHUwMDE0XHUwMDE0wrNhwrjCl1x1MDAwZknCtMKcwpQww4jDtjTCnD1ARVBNXHUwMDA2P8KjPUDCncKxXHUwMDA2XkVtLcKpwrXDnWzDlCk+w71AJT1AX1x1MDAxZMO+wrVVccKUw5lcXHTDjMKSw4rCpybDlMKzw7AlwoNcdTAwMWXDkMOJw63CjsO1XHUwMDA1Pj5YwofDp8OSUsOpwo3Co1x1MDAxYsOIbcK7wo9cdTAwMTM1w57CnEnDucOnf1x1MDAxYT1Kw7tcXGbCtsO2wr3DjVFJwqbDj8OAUlx1MDAxZsORVy8xw5jDh8OKOl1LJMKkw6N7fnQmw61cdTAwMWFOXHUwMDExJMO6woXCuMO7S3Qsw6fCqsKNXHUwMDA0wqHCp8OAw4lcdTAwMDXDpsO9XHUwMDFla1x1MDAxY8Ogw5jCiMOFw7dNZMKIw5dJw6DCkWdcdTAwMTjCk8K0acKYX1x1MDAwNVxcZsO6w4zCj8O5IGNjXsO3woRcXHbDgGPDucKBw7/CkyR5w495w59cXHTDsGHDmDZcdTAwMWFzwoXDnVDDr8KLwqvCp1x1MDAxM8OlT8OZwrc4wp7CtsOMNMKIw77Cg8Olw6fCjzApJGJiwo3DucOhY8Kvw6PDqcOwwrbCnFx1MDAxM8KoQCRcdTAwMTfCmcKGXHUwMDExwrPCncKZaMOAw4lEwprDg8KTw5fCk1x1MDAxOcOlZsOnXHUwMDEww7JcdTAwMTfCq1x1MDAxZk9cdTAwMDFpYMKlZ8K2woghXHUwMDExXHUwMDE4w5E4w69cdTAwMWXCm8OnwoHDnVRJw7bCtcKhaWFcXFxcXHUwMDAzwo/Dg8Osw75Dw51ZwoDDrmDDt8O0wqXDqcKRwoJ7w47CvMO2w7LDkcOUwpHCscKjw6LDvy7DuMKhMlx1MDAxY8OFf3TDrzR9woTDsMOoXHUwMDFhw4NgUMKmw6bCqcKCw63Cik1VZVx1MDAxNcKxwpDDh8O+XHUwMDA0wqhrcD19wpYnbFx1MDAxZlx1MDAwNsKowrbDpFx1MDAxNcO8w5nDmkjDv8KRbjnDoMKYXHUwMDAxwrzCiMKiI8OAwqZcdTAwMWHDsVx1MDAwZibDqMO4clx1MDAwZlx1MDAxOMKfwpTDlMOLw7fCl8OEdVx1MDAxNEFcdTAwMTXCg8O+wrZgfMK4wp4kwpzCnlx1MDAwMsORSVx1MDAxYsKDd8OpXHUwMDE5XHUwMDBlwo4gXHUwMDA2WsKfwqJge1xcXCJcdTAwMTjDvzPCrcOwISzDo8Oew7nCscK4XHUwMDA1XHUwMDA2w4vDocOmw6TCo8OhwpxcdTAwMWQ9TcOzwpXCvFx1MDAxOXnDpMKUwptcdTAwMTB7XHUwMDA1w53CvVxcXFxpXHUwMDAxwolcdTAwMDcpaCjCjMOvwobDkCNcXGbCrMOow43DlMKxeEZcdTAwMDLDpMONwqbDucKwacKIw6XDnsKIJ1x1MDAwM8KoXHUwMDBmXHUwMDBlwrvDl8OPwrl0YMOIwrXCocOVw7lXKcOfwqDChcO2wqtvUMKrL8O1XHUwMDFlw5/Ch8KQYDPDqMO3w7PCoVx1MDAwNn3Cn1x1MDAwNGPCocOww7Qvw53DsCHDiWXCllx1MDAwNsOZRzQ7aMKxWMK4RFx1MDAxY8KUXFxiwrLDmcKpcDjCn8Kiw45Cw54kXHUwMDBlf8Kpw51cdTAwMWPCk8OPw7VcXGYnb00tw5NTw6nCjcKENMKlL1/Ck23Dn8KtXFxcXEFlw7VOwoJkw4jDh1xcXCLCoMKCw6dcdTAwMDTCrsOywpLDl1x1MDAwNEZnwodcdTAwMTHDlsOlwrDCrcKuwpXDj8OQw4N4wrrCtcK7XTzCplrCosOSPMOgwo/DmyXDlT1Nw43Ch8O7RF/CkMKQwo/DhVx1MDAwMVx1MDAwNsOgXHUwMDBmw4DCiMKBTXfDicOpXHUwMDAxwpzCtlxcXCLCo8O1w5jDrsOkXHUwMDFiXHUwMDE2w5/Dq8KTV2RwOMKBPUB7XHUwMDE5WMKWSMO/w77DmEjDhMKjPU3CnMKww73CvcOcw6x5OcKEWMOZwqnCiFx1MDAwMkgpwqTCocORw69lXHUwMDA3wrnDuWhDX8KZXHUwMDE4XHUwMDA2w6hYI8KlwojCt3dcdTAwMDHDgyTCgcOnw6ZcXGJNwp/ClnHDs1x1MDAwNsO+wp3CiMK/wpc5KH5cXHTDiMKnwox/XFxmw5xcdTAwMWPCsD1NwqXDgsOvwrR3wqfDtSHDlFx1MDAxOFx1MDAwM1fDkcK+w6U9TcKzwq3DtcOAXsOhwplFw5x8OMOGw6LCicKEwppuwqTDplx1MDAwNcOrLWjDqcOywpzCkMO+w61Aw6dFVDfCiVx1MDAwMVx1MDAwN8K2wqVpw4/Du8O2wpxya8KxwpojQFx1MDAwNijCnMKUb8OVJcKSKT1KwoNcdTAwMWTDkMKvwrdHKVx1MDAxMsOCwqfCv1xcdsOwXFx0wqk8XcKFwpdgQELCp1x1MDAxOcKTw4LCllXDlsKXPUDDkjl9wpfCtzhowo9Sw6XCm8O5w7Ndw7E8wrlHVULCvXzDhMKDwqXDusOcIHEkw7UwRVxcdMOlwqTDlT1AXHUwMDEye8OrTSxcXHTCpVfDlCckXHUwMDEwd8OBXHUwMDFhw7NqOXXDj1x1MDAwMcOTw5fDjMOrwoVcdTAwMDTDhcOWXHUwMDA3YMOEwqApZCDDv8KYwoXCglx1MDAwZsK5XHUwMDFlPUrDu1x1MDAxZMKfwpRRwrDDoWFGw5jDllViRUXDhsOTwr3CiVx1MDAxYcKoJcOgLcKJwrV1XFx0XHUwMDE1XHUwMDFiw6FcdTAwMDR9wqFJb8OewqjDkMOBw6A1wpnChjzCuH5AwoLDmEPDvlx1MDAxZcO/I8KXXHUwMDEwJcKRwojDmMO+wqzCgcKJXHUwMDFmJsKAw7nCk1lcdTAwMWEzwpdcdTAwMDfDpMKCXHUwMDA3XHUwMDFjIMOyw4VsI8O+ecOxwrhHwqFcdTAwMDTDgsOAw4A9fcOWwqnCisKZXHUwMDAywq/ClcOXN8KnXHUwMDE0w7TDn8K4V8KLw4PCm3A1NFx1MDAxMDjDuTZcdTAwMWXCh8O6PsOhXHUwMDAyKVx1MDAxNcKrw5HClcKHw4XChsKJwrBQw7TCosO4U8KXwqnCocKdw6tQYVx1MDAxZsOkbMKNUVx1MDAwZsO1w5FoXHUwMDEzXHUwMDEyw5NcdTAwMTdcdTAwMTfDs8Oiw4RcdTAwMWRcdTAwMWNcdTAwMTLCi8KPJcKjQ8OXw5jDm3FAXHUwMDA2XHUwMDE3w4lGPUDDvD19IXVRwpbDpMOFXHUwMDFjXHUwMDFle1x1MDAxM1nDqcO2XHUwMDAzPUDCjVx1MDAxYsOdXHUwMDA3f8O9wojDsSjChsKBwprDtSvDlcOkw6VTdDFcXGZIwoZZMlx1MDAwZXNcdTAwMDNhwr9owqjCqcOKwpvDvcO8w7zCsFxcZsKyw65cXHZlLsKfdsO7w48vSVBvw6l2Yn5cXHTDncKpXFxmQ8OHw4DDjcOcw7REw5F1woVWd8K4XHUwMDA3J8KjXHUwMDBmw4/ClcOfw5TDj8Knw47CscKIw70lQcKhOcKiw6RcdTAwMDHDsDfCpUlCw6LCnMOLcVx1MDAwN8OYw7rDmC/CjzfChXTCvyd8PX1Jw4DDnkbDslx1MDAwN3ZfwpdWwrY1w6bDqMOnS3jDpMOXwo3Dq2pvw53DpMKBeVQ8w4FyPU3DvGrCscKTZ8Kpwqgjw6nDnsOdXn7CuCMncsORwphcdTAwMDTDsMOlXHUwMDE2wq7DrsOAw7bDo2zCpT1Nw5pIXHUwMDAxVVVcdTAwMTjDuMODQMOKw6HCnsO+XHUwMDFjw6o0XHUwMDFkwovDn8OTw4ctw6TDoMOHKVx1MDAxMsObwoHCtXPCt3jCp8Ogw68pPUrDjyRdNFx1MDAwNMO7wrlcdTAwMTjDicK/wp9cdTAwMDXDkMKhw7DCk8KUw7zDm8K4esKGXHUwMDA0w59gw718Jz1Nw4jDgSxeXHUwMDA1KcO7w4zDksKTwpHCpsOUSWPDo8K2X8KeXHUwMDE1WnlcdTAwMTbDpFx1MDAxZMKhwo3CscOWwo3CucOKXHUwMDEywrV6wqdcdTAwMWRnwpTDk8OYwpbDtcOGdVx1MDAxNzfDk3FcXFwiwps/wr3CnMO2IMK4XFx0XHUwMDAzw5s3UFx1MDAxOSUhwpjDlsKywqDCjGljwpdywp7CnMO1XHUwMDAzw4VcdTAwMWRyVMKVXHUwMDE5w4Ngw4fCgMOrXHUwMDE1w7XDtFx1MDAxNMKtwp7DrcOkwqzDuFZcdTAwMTLCgiTDi1PDvz1AY8Odw4wlw6NcdTAwMTXDvMODXHUwMDEyXHUwMDE1w4ZcdTAwMTJLwp0mw53CgMKwcD1Nw4tcdTAwMTTCpcOZWMOlw6PDt8OOw5PDisKMwolcdTAwMTjCq8O+XFxcIjdcdTAwMTlcdTAwMTHDksKBXHUwMDAyWWdTPX07J1x1MDAxNVx1MDAxOHzCqVXDq8OPwpd7wqEuwqXCkVx1MDAxZcOjw6PCo8KCJsKcwqRcdTAwMDHDo1x1MDAxN8O2wrTCqFx1MDAxM8K5wrBwXHUwMDE0w5LDgcO5wpRBXHUwMDE2SMKBXHUwMDAxXHUwMDFiwpJwwprDgcO0w5ctw4F4VT5cdTAwMDZ+wqXCilx1MDAxOcK7TilcXGLClsKZI8O8eV9cdTAwMTVNwqhvdjtCwoRcdTAwMTnDpE4lw6dcdTAwMTBcdTAwMDHDnsK6wpLDoSQkw6RcdTAwMWXDhsOhwo3DoMOPOcKgwpRcXHTDjFxcXCJ3MWlgN8K4XHUwMDAyXHUwMDAzfUHChMKbXFxiw5Mow5DDq8ORwpNcdTAwMWXCr8OnXHUwMDEzwqPDhGNjXHUwMDE1w53Cv1x1MDAxYsOcwqfDl8KFLDxAwq7DpF/CsW/DpsKCw4TCo8KdwoZyw73Dj1x1MDAwM8OVw6jDhMKfL8OkwqRiwqLCsShcXFxcXHUwMDE2w4JcdTAwMWRcdTAwMTPDhFx1MDAxNXdcdTAwMDM9fcOJw783w53DqXh1wqlcXGJcXHRpwpFqw5nCi8Onw6lcdTAwMDPDjcKTNcKNYMKwwpjDk3fCtsOywrk6wozDo8ODZ8KFwpjDl8KVW3VZw41mwrhcdTAwMTnCuMOlwqNbw5lcXHbCvCvDmW3DoFxcdMKXXcOtw6nCnD/DqVx1MDAxMFx1MDAwNsOxw4lQZsO/XHUwMDFkXFxcIlDDpsKVwpAgw5MgfMOidT1Kw7fDlMKKOcOtbXXDpMKOwr3CrcOgwqbDvMOYeSfCn8KQwqnCnnjDs1x1MDAwZSRcdTAwMWVHUcO4dsOlQVnChVnDulnCt1x1MDAxYWjCoVZcdTAwMWXCvT1Aw7VXw5VZwoTCjMKCXHUwMDBmN8OANlx1MDAwMsKjw4HCgEjDocKBw6RcdTAwMThxw6TCvlxcdsOobiPCpD1Nwo3CnFx1MDAxNFx1MDAxOcKZw7RWNzzDssKkTsOJf8OwQcK2flx1MDAwNsKuI3TCpUFcdTAwMTh+w57CllxcdMO0XHUwMDA1Yn/DjsKKacKJw4VcXHTCjsKbd8K6wp3Ci8OAw7vDmVx1MDAwZcO7wrA/NTFFwqEzw4nDhcKOeMKnw40pw6hcdTAwMDdcdTAwMDNKw7vCjMOGXFxiw7Ujf8Okw6tlccKUw558w7XDvy3CqSZ/wpdDwpHDl0DCi1x1MDAxNsOSwqPCnVxcdDnDl1x1MDAxMsOKw79kwrlcXGIxwpLCoVbDuiw1XHUwMDE4w5RcdTAwMDHDkcK1w4Vmw7xRw4DCoyDDgkHCo8OBw7hcdTAwMDVXJsKEwqQ4P1x1MDAwNlvCkFx1MDAxOMKowplFPmHCgMKLworCpX3CrMKFQsKnw74ndj1KaEEpwqHCvcKGWcODcjkyXHUwMDA3KcOqwqPDq1x1MDAwMsOfPUBkXFx0wq3ClkRcdTAwMTIowoDCpHdpV1x1MDAxMcOmXHUwMDE1Xz19LsKEw4N4XHUwMDA1aVx1MDAwNsKGPUDCjsKzw69gXHUwMDE5wpLChcORL8O9XHUwMDE2w6B2wqZcdTAwMTnCisKgw7vDvyjDqmY5UcKBXHUwMDFkwrgow7FcdTAwMTjDvlx1MDAxZj19w4DCsGPDiF7CnVI2w4Qlw5dcdTAwMTLChFx1MDAxYsOUwqzCusKFwqgjOUHCsVx1MDAwZcOww4rCr2NhWCfDiFxcXFxQw69eXHUwMDE5IcK6ecOvw4zDocKYT2k3PU10wp0hw754wqdcdTAwMWLClcK4UlNQw4xcXGZcdTAwMDdYwovCg8OAw77DtVx1MDAxY2fCmVx1MDAwMcKRw6I5U8ODw65cdTAwMTh7d1x1MDAxZF7DpsK6w6hdXHUwMDEwwp7DkMOtWcKtw5Y3fH1QwoVcdTAwMTdcdTAwMDTDiGfCncKYXHUwMDFjbj/DnT19w7Nfw6HCmMORw7rDr3TDk3XCusKGw4zDsFxcZsOxc8OVfDhRQsKHw4RGwpnDpMOBM1x1MDAwN8KUXHUwMDFlwpTCoilhXHUwMDFkcV4wbsK3XHUwMDFlw4DCuEfCpMKmwqFcdTAwMWZaw4FcdTAwMTLCuUsxwqk4ND1Aw6cnw7HCqcKXwrPCr8OJIMOGw4toNXdBI8O0w47DmDbDgsKoXHUwMDAzwqEyw4nDmzfDhMOlw5Jdwpp+w7PCq3vCocKYwpHCsHdawr83w6lhXHUwMDExw7tcdTAwMTJcXHbDgVx1MDAwNcONWMORVHEkV3TCt2LDtT1KW8KTcMOjPX1oXHUwMDE5wpfCtnUzYmMoXHUwMDEzRVx1MDAwN1x1MDAwMiZcdTAwMDdEPU3DqHPCiUhlXHUwMDFmXHUwMDExwrBcdTAwMTJcXGJcdTAwMTLDk1vCvyjCu0lcdTAwMGVpw7klYnkpXHUwMDFmwpFcXGJLXHUwMDFlwpNcdTAwMWbDgcKrXHUwMDE5N8OwwqnCosOhwpJcdTAwMDXCtmHChFxcXFw9TVxcdEjDm8KDJjbDt0ggJnrCryPDvSthw6RlYFcnXHUwMDFjw7zDrMO9XHUwMDE4w68gVWjDmUY9TcKBw6ZcdTAwMTjDhidcdTAwMWF1wrvCt3ZcdTAwMTFcXHRFwoPCiXVUOMKoJT1Kw7Mow7bCgsOEXHUwMDFjXHUwMDE1woPDpsO0wrnCs8KBXHUwMDE4wqbDqVx1MDAxYcKDw5nCmcOOwqnDtVxcdMKdwrHDoFx1MDAxZlxcXCJcdTAwMTRcdTAwMTFcdTAwMWVcXGJEwokkZSbDtcOww5glXFxcXMOBKMK2XFx0w5BcXGJHwqnDvSnDuMKVe8KnwqUgw5bDmcOhXFxiwoRcdTAwMDVcXHRYdVrClSXCncOfXHUwMDE1JD7CuS9hwqlWM8OoWyDCmsO3w6dRMD19XHUwMDE4cMKowpzDqcKpXHUwMDA3XHUwMDE5XHUwMDFkwq0qXHUwMDAzQcK5eWHCpGlDRGVcdTAwMTDDu8O/w7jDozl/N1jCiMKEwqjCglx1MDAxN8Ocw5vCiVx1MDAxYsOvwr/DiT1Awod6wpZcdTAwMDbCm8Kfw6DCllxcYj/Dk3gnwpVdwox5w59cdTAwMDTCtD7DuVx1MDAxNsOowqNcdTAwMTXDlsOfwp9cdTAwMWQjXHUwMDFmw51Qw4hFwqJfJVx1MDAxZSjCrm3DkcOmw4BmY1x1MDAwM1x1MDAxNktcXHRcXGbCvcKCw6hcdTAwMTQmw5/Dt1x1MDAxZk0wwonCg8KjwpvDo1x1MDAxMMK0XHUwMDAyYMK9XznDtMO4w5lIwofDocOVXFx2w6B/XFx2XHUwMDA0wozDo011JMOgw7FZV8K2PU1XKVx1MDAxY1x1MDAxNyTDnFx1MDAwZS0hQWlcdTAwMDHCv8KEXlx1MDAxM8KNw7DCrMK5w6glQWTCmSl/wqXCgsO4w5PCsCNAwoLCp17DmMKLcGlcdTAwMDfDj8K/ZTjCrsKAw4MlwoR4XFx0JsObwpHDhMOsX8OBw6QjwrNcdTAwMTnCkMO0V8OJaMOVwpTCmsO2wpbDt8Oce1x1MDAxZEDDocO3w4bDmcKZXHUwMDFmwp5cdTAwMTjDhGTDuWNcdTAwMTXDqMOQw5fDocODw5rCkVx1MDAwN8OYRyFgXHUwMDAyw7PDvUV5XFxcIlx1MDAxYcOhNijCmsKNXHUwMDE1aMOnPU3DhTFHdlx1MDAwNMOewozCg8O9wpg9fcOZwqzCh8O1woQ3wqHDlE/Dh8KTw5TDoMKWXHUwMDA3UGd9w5HCm8KAwqPDrzjDj1x1MDAxNcKFw6DDocKjZ2U7w5/DtsOVI8KbfGJIXHUwMDAxZMOFw6dcXFxcw51cdTAwMWNcXFwiWsO1w5vDsXjCh0nCmsKOciNcdTAwMDXDjcKZUFx1MDAwMlx1MDAxNsOFJsOfwpkpVSPCj8KlPX3CoMK2XHUwMDAyXHUwMDFkJ8OtwrrCrcKjaMKVOMKeSSbCqMOSwobDmUnCg8Oswr5kw6ZUXHUwMDE1XFx2Z8KFJz19XHUwMDAzJcK0XFxmwo/CsSlSXHUwMDA1XHUwMDAxw6jCjFx1MDAwN8OtXHUwMDBlw7lRXSh4XVx1MDAwZcOZwqJcdTAwMDHDv1Z/wpXCn8KdeVx1MDAxMcK6wo4lX1V/wpjDg8O2YlxcXFzCjMO0w6IgSMKDw7nCrsK+w57DgUVHX8KpwpNIWMKbw4JUw5VmXHUwMDE2XHUwMDE0XHUwMDA0w45cdTAwMGbChTzDiMO4woAlXVF0Plx1MDAxY8OxJ8Osw7fCj1x1MDAxOUU5KH9gwqDChMKmTcKRw7fCtcKnXHUwMDExXHUwMDBmXHUwMDE1w5zCocKgM8OQQk7Dj1x1MDAxNlTDosOYwqBcdTAwMTfDvsOaXFxcXFx1MDAxZlnCq8KZXFx0L2jDlsKgw53DtyhAw6MgwqXDrcOWXHUwMDE5wqbDrcKPKDXCnMKxZMOEw7VcdTAwMDPDmWTCvFx1MDAxYlx1MDAxZMO5wo3Ck8K3XFx2K1x1MDAwM8OXXHUwMDEwaVx1MDAxZsKgWcO3w7bDuSXDpVx1MDAxMlx1MDAxMVx1MDAwZTrCryQnYMOxaFx1MDAwNsKGworChMOPXFxcXGTDjVx1MDAwMVx1MDAxMlx1MDAwZsOBL1fDnSfCicOZIcOoYcOVZsO0cEvDi8ONwqPCjFx1MDAxZGY/XHUwMDFmccOIdW9cdTAwMWVcdTAwMDLCmWRZaMOReVx1MDAxZsOSwqTDil49QMO3YcOowqRmwqjDoFxcZsOHw78mwqpcdTAwMTRcdTAwMGbDqVfCh8K/w4AoSMOdaj1NJF3CqMKvw7zDhk3DpsOWw6tcdTAwMTDDs8KlcWfCpsO/XHUwMDFlZMKawqDCmFx1MDAwNyFIX1DCpVxcdsO/YsKvWFx1MDAwNWHCtcOAwqbDmVvCp8Oowo7DqsObwqPDq8O7K8K0O0lJUcO2w4bDiMOTJ8KQPUrDucO8wqtpw4VcdTAwMGbDl8KnwpdQwp9lV1/ChMOfbE9RXHUwMDFhXHUwMDA1w4HDmcO7K0PClcKVXHUwMDE2XHUwMDE5w6fCo8Ofw7DCqcKwwoHCucO/w7FRw63CmsOPw57Cv8O8w5nDjm/DtcKBXFx2w5jCnlx1MDAwN8K3TcOoP8KydsKnw492w4Bpw4LCpsKkfcKlIcKKwrdcXHbDtcKJw4EpXHUwMDE3w5LDp8K+ZmHCkCdUwr9KwpdUw5vDqMKiw4k9QMOJwoBcdTAwMDXCjMOFwodNfnlcdTAwMTNcdTAwMDdUYVh0XFx2woHDhlx1MDAxNnNcdTAwMDfDmm1cdTAwMTRPwpXDosKMwpBcXGY+JWjDk8OdwqVAZ8OAKVx1MDAxZFx1MDAxM8O0w4jCrlx1MDAxM8OUwrnCmcKow7lzOcKDw6N9XHUwMDE0w5rDq8OIwq3CuMKvw4M5PUDDvMK0w4PDnMODwpd0c1xcXFzCrcK4wp/Dj8Opw6dfw7bDolhcdTAwMTPCpFxcYkIvw5FZS1xcXCI9Slx1MDAxNMOPXHUwMDAxXHUwMDBmXFx0KXLCg33CjcKRTsKmw5/CjyU9QFx1MDAwM33DucKSXHUwMDFmXHUwMDEyXHUwMDExw7fCicKieGHCgT1NKFx1MDAxOCE/wpxXPU3ColPCr8ORwr3CuVx1MDAxM8KWwoDCtsKFwrE8w5DCicOFw5Unw6Zuw5E+w5PDqVx1MDAxN8OcXHUwMDAyw4bDocOOXHUwMDE5wpzDtVx1MDAxZMOfwo9bXHUwMDFkJsKDw7/DmcKLw6bCg8KVXHUwMDExw5DCpMOmI1x1MDAwMsOgwovDsMKqPU3Dm1x1MDAxY8K4wrRcdTAwMTFQwqdzw7ZhwoTCoiV9eFx1MDAxMsKrw4PDpFx1MDAwNcOOw781XHUwMDFjw509QHPCk1xcYiHDhMKmwotcdTAwMTnDg8K5w6FcdTAwMGVQflTDjsKnXFxcIsK/IMOOwprDv8KrOcOPVMOtwo3DiFBYQj7DmMO/Y1x1MDAxN8KMwpvDqcOhXHUwMDE4XHUwMDA3w7g9fcOEw4DCqcKaYFx1MDAxM8OCfWXCjVx1MDAxOMOSwoHDucKJSDZVw4PDg8K4WCFcdTAwMWLCkMKwV8OkJ8Kmw6FcdTAwMTTDr8Kya1x1MDAwZsKEwojDnybCrMOjcMOTwrdNTTfCuCnDqHzDgsOkw5bCrMOAYcKlwrsjworDkijDkVx1MDAxZMOnwr/DvTdAw6XCplnDn1x1MDAwNsOgwpxcdTAwMTXCusKVwokmw6hww5bCmMKCJ1x1MDAxNCfCicKxw5xEwp3DicKTXFxcXMO2WVx1MDAwN1x1MDAxZcKRVcOhRXlcdTAwMTVcdTAwMTnDhmFLw6JcdTAwMTNxe8OJJcK0RzUpwonCh8OHwo92wobCi8ONwq7CtcOlbcOhelx1MDAwNlx1MDAwN8KHQEBVXHUwMDE4w496XHUwMDA2wofCtcOlXHUwMDA1XFxmw6/Di8Oiw6XDnsKCwpvCkcO7QMKxTMK1ZT7DkVx1MDAwMi/CmFx1MDAxOMOBw4VcdTAwMTlOeVxcXFzCkcO4XHUwMDBlJsKmwqnDp8ODM2dDw4tPNSxSbFxcdMOKJ1x1MDAxZMOgw4V1RFDClMOMfMKhw6E7XHUwMDExS8K1w6fDlsKbwoDDtU5rPUrCjjjDoWYoPUrDo8KpwqDDpDvDuMOEw5fCpMOUw65aXHUwMDFjV1x1MDAxYkoqRMOKdT7Dl8O1woPCpFFGw7TDg8OcwqBmwrTCqcOZw5dcdTAwMTNzw7jDocKzU0A9SsKRwrwvwqfCsVx1MDAxMMOTQ8KOwojDrsO5wrjDvUnCgVx1MDAxOG3DosOTXHUwMDFiwrLDimgowp9rw67CkcOdT8KUZcO8w5ZcdTAwMGbCqlxcXCJFw5DCvT19w7LDmkHCu8KMeFx1MDAwNVx1MDAxMMOLw5fCjjnCtFA8TMKMQMKhw5ghw4VKZcOaXFx2w7XCv1MmwojCkMOdw5/DuFxcdiZcdTAwMWPCnSvCkcONUlx1MDAwNmXDgkwlaDEqwotcXHbCpsK2wrUxw7sqw5zCn8K/w5jCg8KNXHUwMDE5W1x1MDAxOMOWwrXCtWlUwoPDvsOtXHUwMDA1fFx1MDAxNsKiw7JqKHjDoz19wqnCvkXDoCgkXHUwMDAxwrzDqGJcdTAwMGbCi8OhRWDDqcOtXHUwMDBlwp0swobDqnPCqMKuQVx1MDAwMcOSSsKww6TCocOYXFx2dU9cdTAwMWPDhUI1NsKDw4wzw4zDrsO+fMOqfMKaXHUwMDFhL2NcdTAwMTBcdTAwMTDDl3/DpMOswptnaMO9w7BHTMO8SDLClsOiwrN2ZsKeaMK/elx1MDAxZMOCO0RswozCrsOmwqt3w4lNwrnCnsK4w7XCtlx1MDAwNMK0wrgjZWLDusKUP1x1MDAxY8OgwqUyUcOdw6LCiVVYwrDDoCrCoMOJwpNpwoPChsOCPU1HN8KxMVTCtHp5w6JnWULCpcKqbFx1MDAwZsKFSF3Ci8KOw77DrmQme3nDr8KBw5NDcXzDtMKjwqtEQl1idMKddcOjST1NKDMmwo/DuFx1MDAxZMO2azN+wqPChcKDPUDDpsK0PUrDpMOJwrbCi2HCj8Kyw7tcXGbDvnDCq8KSN8OtU8K9w6pcdTAwMTTDtsKew7B6OT1NwrzCn8KBUMKgYz1Nw73CoEDCscOALMOWw5AqwoDDtT1AXFx2w4DDmFTChlx1MDAxOMK8woZHXHUwMDFjwpLCs1x1MDAwNsOULcOPZ2szwpfDuFDClDdcdTAwMTlMwo4nwpjCpDFcdTAwMWbCssO4a3PCn8O4wobCg0zChMKaY8OeXFxmw5rDjn7CgsOcIHVHf8Olw4poRi7Cm8O0wp56woPCnMKeXFxcXMKTw6LCjMKjwqNjKnLDlcOcw61cdTAwMGZaw5J2J8KHwrjDiFxcdms1w4hcdTAwMTTDrcK2M1XDkFxcXCLCssOqw7ZuT8KhPUB8XFxcIsOGwq9cdTAwMTBcdTAwMDRMwpXDocO2XHUwMDAyw48swoXCgcOFRMOww6XDun/ClcKse8ODSMKCasKpO8OAKMOZXHUwMDAyw61MXHUwMDA3Z1x1MDAxMlxcdjJcdTAwMTLCtHnDhCDDuHktXHUwMDFmwplcXHTCrFx1MDAwN8KnwrZ8KcKrwpDCmShgXHUwMDAzwoZOw6xcdTAwMTBcdTAwMTHCjVx1MDAwZcOUW8KTXFxcXGFbNMKGw7vDqcOaXzJowpAjNDHCjWl8w7fDtcOFwoHDhi3Cn8KSw4jDoF/Cl1fCv2p3woU2NMK5XHUwMDAxMsO8wrzCiMOwXHUwMDFjQnE6XHUwMDA3woPDrVTDv0bDgcOawqTDvcKFwpJRwrXDp8KWXHUwMDEzw78wwpV7XHUwMDExLcOkwpnDgsONwrc9TcOueMOZL8Oowp/Di8Ofw4jCicKGwo5cdTAwMWIjwpjDssKzw5NcdTAwMDLCgVx1MDAxOGfDpMKWXFx0ZcOew45rYVx1MDAwNVx1MDAxZcKCwpLCiVx1MDAxNnFcdTAwMDXCrMKKwozCuTLDrcOHw7U9fcOlwpQ9TTnCiMOYUVx1MDAwZVx1MDAxOMOswpfCsnNCRnBcdTAwMTPCvMOvw63Dm2N2w7/Dq8Odw4zDi8KwVlx1MDAxZlx1MDAxNcKgw5BewpzCiMOHw49WXHUwMDE4woHDl1rDqDTCplx1MDAxMMK4MsOjPU1AVVbCjz1Aw5Msa8K7w6BcXHTDoWzCksOSPsOpaMKAXcKQYcO/THXDscK0YsOyOcOAOVx1MDAxNDzDvVx1MDAwZsOUwqhcdTAwMGUsXHUwMDAxwoHCoUbCoFx1MDAxOFpyw4A0QXw/w6NgwozDv3YywoNcdTAwMTDCsX/CoCfDusONUsKTw7BcdTAwMTHCsz1AY8KTaMO6VsKQwr0qI1x1MDAxMH1Vwpo9TUsnw6/DtmDDpinCqlxcXFzCnsK6P3zDnWc9fUnCrMOqdMOcwqvCljtPeT1AwrDDrsK2wqUjwobCi8OQw4bCkGvCqsKyXyvDpUZ+wrTCv8K+PMKmXHUwMDEyXHUwMDFhwqg9fXRFw5fCmlx1MDAxZirDrcKeIcOHNsKvVFDDu8OIw585wotqwqpWTMK5woVdVcKUw5g0XHUwMDExwpLCm112wpR2PsK3w5zDtcK3Oj19XFxcXMOEwo5fQjRcdTAwMDFnw5NJwoXDpjbDssKyK0gsIMOjwrQsw67DkydawpJCXFxcIj1AO1x1MDAxZcO7RsK2w7/Dr8KZSsK8XHUwMDEzw5h/w5zCvXDCi1x1MDAwZnbCscO6PMKNwplcdTAwMDNcdTAwMDTDgFU9QCDDvXdcdTAwMDJQY1XDncKAw6LDscObw5QjWVx1MDAwZsOjM0DCqzw9QCVcdTAwMDV0fsOodFx1MDAwNGHDkTZEwp/DscKSw7s7UMOgwqtcdTAwMDdBwqdTbsOIL8ODXHUwMDE0wqA7SMOPwpVRw5h6ITnDsMKsKcOyR8OoXHUwMDE2w4zDhTfDhVx1MDAwM8KCMMOGXHUwMDFmJFx1MDAxNVxcXCJBZD1NXHUwMDA0w65PXHUwMDE2wpdcdTAwMTnCkFx1MDAwZmTCs8Krw6dcdTAwMTlcdTAwMTPDrGI/XFx2wq/CusOldsKia8OJcFJcXFxcQFXDg8ORw7DDrVFcdTAwMTJPPUDCpMK2w5DCj8KQwoTDn1x1MDAwM1x1MDAxMMO5XHUwMDBmXFx2wqjDtTjDgsOYw6h7R0fChCR9w7vDiWI+asKVT8Ofw61uKMKFwoNcXFwiw7jCqsOIw41Iwq7DpDFIw59cdTAwMDVcdTAwMTbDu1x1MDAxM2lRw4bDt8Kpflx1MDAxM8KzTsOTemjDsMKIw4nDgXA8XFxcInLCq1x1MDAxNFxcXCLDpl04wqvCgsKNLlx1MDAxNVx1MDAxZjrCk3dAK8KaJMKMWSDCjyHCmDXCgGrDsUhcdTAwMTTDnkXDmcO9MUhCXHUwMDFlXHUwMDE5ecKzfsKiTSpIVsKVZsOjw6DCkyY7XHUwMDE4XHUwMDAywpbDkcOJV1NcdTAwMTFrwodgwow1w7dcdTAwMTDDgGdcdTAwMTZ4XHUwMDAyUVxcXFxoJkFcdTAwMGUkwpVpw57DvsKxw5RRT8KVwq11wo/DvcO8XFxcIkrDinBcdTAwMGZrw5XDlMOrc8OGwqrDuMKPwqvDtsOjUVx1MDAxMsKMw7dcdTAwMDPCmmFcdTAwMDfCgFx1MDAwN8OLw6vCmCRcdTAwMWbCn0jCtm3Chk/CrTXDvHl/wpcpcHnCm2p8SMOGbcKkXHUwMDBlw6XDh1x1MDAwMsOpZmPDqzXDljXCu1xcZsOAwqNLPUDCiULDqFxcZlx1MDAxNMOVwpA1dDPDnsOXw63CrVx1MDAxNErCjsOtw69cdTAwMWbDhsKfP0M2wq5cdTAwMTXDmsKfcFHCtlx1MDAwZsKlYcKUXFx2M8OBwojCg8Ohwp0jw7XCq8K1ey1Swo3CkTF4wofCtcORw7E8wppVU3R2J8OOXHUwMDA0XHUwMDE0w6VcdTAwMTBEXFxiXHUwMDExw4LCmC9cdTAwMWbCmFxcYj1Kw5xxXHUwMDA1XHUwMDFkwrpaw43Dj0bCgMKkM053REVcXGY/eGbCuMKMe0vDsMKbwrw3w4VwXHUwMDE2O3FKfMKtw4hewpTDkMKeZ8KIXHUwMDEyTsKuw57ClG5Gwo/CkMKFOihcXHZrwrfDgMOQwrfCuzPDjU7CiVx1MDAwMl/ClMK7bVnDq1x1MDAwM8ONSS/Dv1x1MDAxZjJhw7JiwoNcdTAwMWXDiW1lwp/DjMOMw4NcdTAwMDPDqMOCw4zDiVx1MDAxYlFIwp/DjMO5TlxcXFzDizXCp1x1MDAxMDnDvcKxw6jDmMOnc1RCPU3Cl1x1MDAxY8KQwrHDkMOSTnovw4ZcdTAwMGVVwphcXHbDjWXCjGTDkyTCunjCu8O4w7TDrEnDj8O9wrvCjW8hwrNvXFx2w759w7V7XHUwMDEybUnDqcOjwpbDm8OuXHUwMDE1aFx1MDAwNMKONmA9TcOPw4g+wo4ww47DsMKYw67CnlDCrcKVVsOQw7lcdTAwMWTCv1HDpsKpXHUwMDFhw5fDrV/CvVx1MDAwN8KAJjdhw4TDpMOZXHUwMDFiw7xjw4IlbsOfJ8OOSlxcdHHCscOrX8K2XHUwMDFmIFx1MDAxMcK0w6V6XHUwMDE5wr4rw6PDmHRCUMOfwohfa8OPXHUwMDA2VilcdTAwMWXCsXHDlGBdwoQ9TWh1dnkvwqlhN8KYwpHCp1x1MDAwZlbDi8Krw6N3XFxiPU17woXCtD5SaMKdw7FpSXZcdTAwMWTDiVx1MDAxYcKadMOjw7tcXFwiw6ZbQcKuw45TfcKsTW8/wqZFR35cdTAwMGXDg8KJwp/CgkRMw6LDmsKWwrBcdTAwMGbCi0/CqCE8MmcnwqbCscOhwrPDkTQgw5vDu1fDmlx1MDAwMsK6wonCvMO1wr5owoFnYcKPw6wwwoXDq8OLw6sjwqPDvcKkwql7QVx1MDAwM2bCt8Osw7XCpMOyccOwXFx0wonDjsObXHUwMDA3Yy3DrCFdJCU2w6vDhMKIw5bCpMOzcCnCgH3DjcO4wq5qwp59PUDCqXcxwpBcdTAwMDbCgXBcdTAwMDFcdTAwMTlcdTAwMWV/woVBw6E/wrLDocKdwqlBwrbCgcKSw6svw41gbsK4Y8KhXHUwMDBlw7coVcKFw6I1VCbDpcOgScOwwrrDgTLCsMKTT8O0XHUwMDFjdl94esK3wrDDtjk9TVx1MDAwMcO5asObLsKlw7xTw69RXHUwMDE0LkLCucOWZsO+PUBqUMK1XHUwMDAxLHQjKcKaaMK0wqI4wqN1w6PDlkPCuMODw45TKMOaw5nDv8KGwoDDmi4+wqvDrsO6woNeI1NoXHUwMDE0woo1aD1KcFx1MDAwZcKxwrxcdTAwMGbDoMKKSsO5UcOjTMOGw7DCu8O6w7vCucOFW8Oow4NjPFx1MDAxYsOic8KQwoFcdTAwMDNawox6wpxPw45gw6F5PUpMwr9cdTAwMDItXHUwMDFjwpQvPEk9fVxcYlxcZjbDqmRLwqDDmsOLw4rDj8KaXHUwMDExwrPCjcKAWFLDvWDDk8KUXHUwMDEzwpFawqbCnjUuw6PCgcKhM8Kiwq9Xw79cdTAwMDNnwog3RcO4SMKTwpjCilx1MDAxZsOcSMO9w7dBXFx0RMKGw5jChsOiSWHDuD1Aw77CtlnCr8Kpw4FIwqd0McKgw7kvw49uUj19R8KxwoTDqsOCUcK8W8K9XHUwMDEwXHUwMDFhXHUwMDFiw6PDn8OJw6LCiz1AOFx1MDAwNMKvwr/CnsK0Z8OAw5FcdTAwMTReXHUwMDExw4zCvcKef3tNw7TDnlx1MDAxNFxcXFzDm2HDo8OawpVPwoFkwrvDkcKvwoLDgcOwXHUwMDA3wqnDgjbDhD1AXHUwMDFmQntcdTAwMTLCpVx1MDAxZMKmKm4mTGhlJ8Otw6fDgSDCosKCw6TCoFxcYlx1MDAwMcKKw6NcdTAwMDPDgMK3w6fDgT5EwpHDl8KCwpvCl8KLwoBcdTAwMTVcdTAwMTlyXHUwMDFjN8Ozw4FRw7bDqz1KwpI6w4o9QClRccOUJ1x1MDAxOcK4dlx1MDAxY8OoXFxcXDbCsF1JZMK3f1x1MDAxMcKlZ8Ozw6vDocOYMF9cdTAwMDZ/w47CnSzDizIww5Y5XHUwMDFlwp5+XVl9OMKZwppWaVN9eMKAwpHCnV9cXHQoZMKZw7k8woLDiUPCmyXCj8OxwoPDvMKvworDoMOlXHUwMDE3V1x1MDAxYVx1MDAwZkTDucKIw6LDmUxcdTAwMWbCksOQw6FVw4nCisOKcjjDqCQ2wqtcdTAwMTlXXHUwMDA0XsOXw4nCmFx1MDAxMFx1MDAxMsOfXHUwMDFkIMKcOHdcdTAwMDNbXHUwMDA3ScK5UcKPWsOJw5JcdTAwMDZcdTAwMWJUVcKPdWZzwrBCMic2wqrDs0JXw4lWw55zw6bCssOWw6XCr3DDssKHWcOjw6pbwoFjw45Hw5rCmzFcdTAwMWZcdTAwMGVcdTAwMDbCucKOXHUwMDFmwo9lw41ILMKQwqYzw7HDisK2w7xOw4DChVAmw41cdTAwMDYmwqHCtlx1MDAxOMOOPU1bXHUwMDExw5fDrcOzX8KywqZiwrxcdTAwMGVcdTAwMTFmflx1MDAxOFxcZmrDpcKrXHUwMDEwScOxw5DDn0rCocKKOsK9XHUwMDE4XHUwMDE2XHUwMDAyw6V3YMKMwr7CkjlcdTAwMWY3Lnc9QF1lQsONXHUwMDE4w4PDhVx1MDAwNMOzIMOEUVx1MDAxNsKQMirCkFx1MDAxY8OFQMORw4/Ck07Dv0XDmCsuaTFnJsOhJsOiwp7Dv1x1MDAwN8Onw6YtU8O7woHDp1x1MDAxMcOQZT/Cr3bDvcKiwqQpJMOne8KpXHUwMDE2XHUwMDA3cE5cdTAwMDdOw5ZYwrdaw7rDjFjCrMOGw47Csk5cdTAwMWLDlcO6w4JPPUAjwr3ChMOjQlx1MDAxOMK5wqbDmsKsXHUwMDE0wqByIcOhdcKDw77DsmbCry/Cj8KiXHUwMDE5b8KDwoDCuGjCo0/DlsOGLsK1d8KuecKNw7vCiijCnVx1MDAxMGDDmTxrwoTDu2LCplx1MDAwNTLCgVpcdTAwMDXCilhpw6LDrivCqcKLXFxcXF7DncKvw4DCvcO7XHUwMDE1XHUwMDA0NVx1MDAxZMOFTnMzwoTCjsOBwp1kUGLDs2jCjsOqecK7wrVcdTAwMTbCuCVcdTAwMTjCmVvDhsKNXHUwMDFiXFxiKsKEw49cdTAwMTjDhsOzR1xcYlx1MDAxMDzClsO5wo/DrcOxQsOIcMKgXVx1MDAxND81cMKqwqMgR0xcdTAwMTBcdTAwMWHCocKcw7HCjmDCuMKhZ8Kww5rDo2zCn8KibcOgwrl9wo1SwpnCpcK0XHUwMDFlw58pwrzCvm7DlsOjw4g4w4xcXGLDmcOew6h5wrTDpsOOwpHCoMOOQMK6w47DncOjL8KzMVx1MDAxOVxcXFw6wrZYT0bCvGrCmMKpw5RHwrBcdTAwMTk2acOGw77CsMK3wqnCvCfDnlR0JMK4dsO6JT59wrcjw6NAwo3DsMOIY1LCssOsXHUwMDE2wqLCvMOvT1ZcdTAwMDZcXFwiLcO6w5lrfcK9XFx2aG/ChytpwoZcdTAwMTLDp8O4IT1KXHUwMDFmw5LDjMKtSSfDq8OzwqUkwrM5R2LCo3xJw6TClMKDw5o9TUZcdTAwMTPCh1fCtsOuUlx1MDAxM8O/wpjDgMKYT1xcZsONRcO1Mlx1MDAxZHHDhMOHWG3DqsOtXHUwMDEySV1cdTAwMWPCnsKyaEEsw7lcdTAwMGVxw5dcdTAwMDRnwoZcXGbCl8OXwrIxw5PCvsK3XcOFXHUwMDFme3HDmVx1MDAxN1x1MDAxNMKjwpLCp0DCt8OXXHUwMDA0woDCuyzDlcOEfsOww53Dm8O0w7JcXGZWSH9cdTAwMGXCslnDoMKewoY0w7RXcWnCpcKlQMKMwprDoVx1MDAwZcKDKFNHQCfDhFx1MDAxM15KSG/DgsKqe8KTW8OAw7zCuMK/w5s6XHUwMDA1wo7CrMOGw53DtCfDq8KKe8OfcMOTSMKbw7dBXHUwMDFmwrPDrT1Aw6LDvllcdTAwMTZKNlhfXFxcIsOBbMOLOifDoUlcdTAwMTQow6nCh1/Csy53wqvCtMOYw4nDrMOoQXRJwplGQsOwwqFkZFx1MDAwN1x1MDAxNsK0wrTCtVxcdkbDlcO9dVx1MDAxMcKnwo/Di8K8N8K8wpxrw5bCpcKyw4PDtXfCiHbCtTDCksOfwqZcdTAwMWTDscOkw5RIw6bDjFx1MDAxNcOWw7PDnVx1MDAxZVlcdTAwMTk1w5pcdTAwMTkjZMOLXHUwMDExwo93w5TCqlXDjMKUwpfClS5cdTAwMWLCsFx1MDAxMTfCv8KTw4XDusO6w4h4wqXDiShcdTAwMTVcXHZmw4zDj8OmXHUwMDE3UcK2w6TCh8OjP2bDj1x1MDAwMkTDjcKrwpTCrlnDoFvCpXIhQcOXw5NcdTAwMDIww6dwXHUwMDFkwqZIUm1sw7bDpcOFwqpXXHUwMDBmw5BcXGZ2Zlx1MDAxMMOQwp1zwr06IyAkwo7DlCfCscK5w57Cmy7CvHRcdTAwMWTDiVx1MDAwN8OZUsOqXHUwMDEwXHUwMDAzwpjCpy/ChWh4XHUwMDFmW3bDqmrDiFxcdFFcdTAwMWLCpMOLw6NUwoTClVxcXFxKIFBOXHUwMDExMsOPwoPCvV/DrMKew5PCllPCgsK3VcKGbzXDj8KtVmFcdTAwMDTDoMOTcMOUL8OLPCPCgsOBw47CnSHDjMO6dlx1MDAxY8KnMcKGw7Z+aVlcdTAwMTfCo8Ovw4jChj5cdTAwMDdcdTAwMWPClVx1MDAxM8OWw4TDrlx1MDAxNMOCw6vCqMKSwrHDqVrCpTfDqsOwacO8wrTCmV03w7DDmsOMw4xPXHUwMDA3w5VcdTAwMWZcdTAwMDFiwrlcdTAwMDHCnsOvw5x3XHUwMDA1wqfDjEBmwqzCrsOWw5dcdTAwMDTClcO7V1x1MDAwZXnDiHh8wrVuwr3DqFx1MDAwMyTCi8K4w6fDnlx1MDAxZsOxJEc4w55jwq5cdTAwMGbCmMOew6xaPUrCnFx1MDAxZVx1MDAxZS82dcKGw6NcdTAwMTPCrsKzwovDnWfCqcKILcOOw63DsMOrwpDCtTFfPFx1MDAwZsKTw4DCiMKXw47CjsOoNMOwXHUwMDA1XHUwMDFkw7TCql7CvVLDo3E6w45bw4Znw4J3SsOEw79cdTAwMGbDolx1MDAxNsKywoRcdTAwMTPDrcKeXHUwMDEzw49cXHZTwoTCpnPCk8O+NULDmUrClXbDoMOww7HDr8O1R8KUwrrCo8OWfFdcdTAwMGXCoGTCp8OMesKdXmLCsicvKT1NwqrClVx1MDAwMcOJWcObw4ttw4LDgcOxwo9Xw7/DiFvDvl/CknfCpcKkwqtWXHUwMDE4SGbDjcOYYTNcdTAwMTBcdTAwMTc+MFx1MDAxN8K9woQuasKFw4vCnExcdTAwMTnChVx1MDAxYsOfwphfwoFsw55aIFl1w7nDskN6w7QmPjjDjsOow7HDtcK7w6TCkEjDkcKfwqh6XHUwMDE4wq98woDDm1tnw4zDpXbDvX3DvcK8wojCriTCtE/Cgk5uUzhqXHUwMDBlw4/Ctz8sXcKkK8OVeT7CoS5+K8OjXFxmwq/ClUc7SMOKw5fCg8K8LD5cXGbCmMKCw5/Cj3JcdTAwMWJePUpXfMOGXHUwMDE2w4FXwr09SkRzwqhJecKFXHUwMDE1w7DDjFvCuFx1MDAwN1jDoMKPdFxcZlx1MDAwMsOaNyo9TUXCsDvDmsK4wqXDn399w6VcdTAwMWTDusKLTkZpw4jDrsKUw6Q2c8OVwqFcXHbDhiNcXGbDvcKFZWnDuWnCn8OVwr5rw71MPU1cXFxcw7LCg8Ozd1VcXHQxwqfCizPDnMOSVsOYRyHCqMKUXFxcXMO7XHUwMDAxw4h/w5dcdTAwMDXDlMKJw5/Di8O+O8Ojw7fCisKtdsOYXFxmw4vCj8K2RsOXXHUwMDAxw7R9w4RMwonDh1tcdTAwMTjDvcKQw6vDpsK8XHUwMDE4wr3DgD7Ds8OsIzlcdTAwMDZAwqR2w65mw5NcdTAwMDFcdTAwMTcgw63CszBrwpp0wrk1Z3zDiTfCusO9XHUwMDE5PUpfXHUwMDE5M8Khw53DssOFRXR/wo8+wrbCjSAqw6zDpcKSwqHCgVx1MDAwNlx1MDAwZsOjwqbDjMO5LSlFX8OoL8KLwrQzwoDDiTlLU8O7wqfCk8OkVMKQw6fDmmZcXHbClm3CpcOew7nDlT1Ka8KRw6dqw5TDnMKZZFx1MDAwN3zDicOsN3PDo2jDqFx1MDAxYsOmwrfDtsONVmPCvkLDocKNwol5w5g+wrzDsF1cXHRcdTAwMDPCu1xcdjlsUmbDvVnCpsOswrLCssOYRMO+worDo3RcdTAwMTHDgkp8acOcMU/CmG0ww58uwpfDnDo3TEdxwq1cdTAwMTPDg8KYw7hcdTAwMTDDkWPCg2c9TcKWXHUwMDBmXXfCtH0vI1fDnMOcZcOUw4jChVjDucKTw4B7LsKYwqfDvjBcdTAwMDJeXFxiw4rDicKJXHUwMDE0w5LDjyrDhMO8XHUwMDBlRDnDn2vDoj1AwonDqV/CmsK2XHUwMDA3w5JYTXvDicKwXFx2TGPDvMO4WSdcdTAwMWM3XHUwMDE1PUp0elp4wq7DrsKCXHUwMDFiVMKmXFxcIsK7NErDhsKew6fDhWzDicO4wo/CiMOmaVx1MDAwNXDDvlXClWDCo8KYPUBcdTAwMTROT8KXXFxcIlxcYsOEXHUwMDEwwpMjw6jDgTg9TcOAXHUwMDE3XHUwMDEyw4HDgMO1bMKYU0LDuTHCj3zCu1x1MDAxYWpiw6bCicO4bMKkJkJEwrfDlVx1MDAwNiRcdTAwMDUnwqPCp8OYLEfCjcOxw4FcdTAwMDTCqk9ZPih1w4nDr8KYw7XDpcKrMDlmwo3DiCTCs8KIJcOtwpzCtErChMOhwqovw5HDqcKVwq1pwoNqwoPChVxcXFwvwrjClnPDmnbDsWPDr3/DvjxywoHCiMOewoVuw58pTmvDtMO2w6DCosOLw5HCjVxcXFx1w7PClsKvYsOcw5t5wr1cXGbCtsOIblx1MDAwM8KKdMOzZcOVXHUwMDFiwoLDpMOLXHUwMDBlwoB3wqjClcOxw5LCnjg9QD19XHUwMDE5XHUwMDBmd8OYw69aRMKow6lhUcOFw5Vkwp/Cq0x3XFxiwqTCg8KxSz1KXHUwMDE5R3TDiTLDoMOaY8OZe0DCuV/Dv1xcYsKZw4d3KTx6wrnCtcO9w5ddwrs0w6pcdTAwMTDCgVPCsnnDtVx1MDAxYVx1MDAxMVx1MDAxMlx1MDAxN03DhMKMw61GwprCoMODQsOFZ23DqsKbWcO9wptzw4B0Ulx1MDAwZlDDnyFNwoBSw7bCmTEmRV7DosKNwqkpw4IlQSVdw5fDulx1MDAxMsOHw5nCg0PCi2zCt8KVXU49fcKIwrBxwp/CqMO5SMOVR1fDklxcdMOSwqYrXFxiRMO9worDpsObMGjCqHTCmyFdPUDCi23Du2xJw74rw6vDlsK/w61awoZcdTAwMWTDmMK3QG3DmlMywqbClG1fwoPCt1x1MDAwM1fCliRcdTAwMDXDulxcZlxcdsK0PUrDn8OJRTvCoURcXFwiw6zCtcKoXHUwMDFmasORw4PDmsKSXHUwMDBlcjBcdTAwMWQpw6XDuCBcXFxcUVx1MDAxZsOWacOFKC4sZ8OfwohcXHZqwqhcXGLDmCrDv8KQw6vDjMO7w4nDgMOmXFxiwovCom1AwqQqwqZcXHZvw6nCoipDwpbDu1x1MDAxM8K2wow9SjVZJCPDmcO5wpvCoMOaV8O8wpVGT8OUPX1cXFwiw6zCtcKoXHUwMDFiYsO8IcKrwopcdTAwMDVcdTAwMWHCgcKIXHUwMDFlwqnDqMKtwpTDqcOrw4wvw6o6wrpcdTAwMTbDp8KQXHUwMDAzw4A1wqtZw6ZcdTAwMTJBw5k4ZDbCjsKRw57CpFx1MDAwZm/DmcKfw67DqFx1MDAxYynCnVl5w7zDv8Oqw5V4w5PCuTDDqFx1MDAxYcKpXFxiw5bCkE9aXHUwMDEzXHUwMDE0w6PDmSTDg0EnXFx0XHUwMDE5KcOzwq3ClMOdwovDuz1KNsO9fygxXCIpKTt2YXIgJCxtLEgsSSxxLFIsaz17YTp7YjpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5jb3ModCl9LGE6ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguZXhwKHQpfSxjOmZ1bmN0aW9uKHQsZix2KXtwLmNvcHlXaXRoaW4odCxmLGYrdil9LGQ6ZnVuY3Rpb24odCl7cC5sZW5ndGgsZnVuY3Rpb24odCl7dGhyb3dcIk9PTVwifSgpfX19O1dlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKE8ud2FzbSxrKS50aGVuKChmdW5jdGlvbih0KXt2YXIgZix2PXQuaW5zdGFuY2UuZXhwb3J0czskPXYuZyxtPXYuaCxIPXYuaSxJPXYuaixxPXYuayxSPXYubCx2Lm0sZj12LmUuYnVmZmVyLG5ldyBJbnQ4QXJyYXkoZiksbmV3IEludDE2QXJyYXkoZiksbmV3IEludDMyQXJyYXkoZikscD1uZXcgVWludDhBcnJheShmKSxuZXcgVWludDE2QXJyYXkoZiksbmV3IFVpbnQzMkFycmF5KGYpLFE9bmV3IEZsb2F0MzJBcnJheShmKSxuZXcgRmxvYXQ2NEFycmF5KGYpLGZ1bmN0aW9uKHQpe3QuZigpfSh2KSxnKCl9KSk7Y29uc3QgVD1uZXcgUHJvbWlzZSgodD0+e2c9dH0pKSxZPSh0LGYpPT57Y29uc3Qgdj1uZXcgRmxvYXQzMkFycmF5KGYpO2xldCBiPTA7Zm9yKGNvbnN0IE0gb2YgdCl2LnNldChNLGIpLGIrPU0ubGVuZ3RoO3JldHVybiB2fTtjbGFzcyBae2NvbnN0cnVjdG9yKHQsZil7dGhpcy5jaGFubmVsRGF0YT10LHRoaXMuc2FtcGxlc0RlY29kZWQ9Zix0aGlzLnNhbXBsZVJhdGU9NDhlM319Y2xhc3MgTntjb25zdHJ1Y3Rvcih0KXt0aGlzLnJlYWR5PVQsdGhpcy5vbkRlY29kZT10Lm9uRGVjb2RlLHRoaXMub25EZWNvZGVBbGw9dC5vbkRlY29kZUFsbH1wKHQpe2NvbnN0IGY9SShGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQqdCk7cmV0dXJuW2YsbmV3IEZsb2F0MzJBcnJheShRLmJ1ZmZlcixmLHQpXX1kZWNvZGUodCl7aWYoISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpdGhyb3cgRXJyb3IoXCJEYXRhIHRvIGRlY29kZSBtdXN0IGJlIFVpbnQ4QXJyYXlcIik7dGhpcy5PfHwodGhpcy5PPUgoKSk7bGV0IGYsdixiLE0sSixyLGUsYT1bXSxuPVtdLGk9MDt0cnl7Y29uc3Qgbz0xMTUyMDtbdixiXT10aGlzLnAobyksW00sSl09dGhpcy5wKG8vMiksW3IsZV09dGhpcy5wKG8vMik7bGV0IHMsdT02NTUzNixjPTA7Y29uc3QgaD10LmJ5dGVMZW5ndGg7Zm9yKGY9SSh0LkJZVEVTX1BFUl9FTEVNRU5UKnUpO2M8aDspe2lmKHM9TWF0aC5taW4odSxoLWMpLHAuc2V0KHQuc3ViYXJyYXkoYyxjK3MpLGYpLGMrPXMsISQodGhpcy5PLGYscykpdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZW5xdWV1ZSBieXRlcyBmb3IgZGVjb2RpbmcuICBZb3UgbWF5IGFsc28gaGF2ZSBpbnZhbGlkIE9nZyBPcHVzIGZpbGUuXCIpO2xldCBiO2Zvcig7KGI9bSh0aGlzLk8sdixvLE0scikpPjA7KXtjb25zdCB0PUouc2xpY2UoMCxiKSxmPWUuc2xpY2UoMCxiKTt0aGlzLm9uRGVjb2RlJiZ0aGlzLm9uRGVjb2RlKG5ldyBaKFt0LGZdLGIpKSx0aGlzLm9uRGVjb2RlQWxsJiYoYS5wdXNoKHQpLG4ucHVzaChmKSxpKz1iKX1pZihiPDApdGhyb3cgRXJyb3IoYGxpYm9wdXNmaWxlICR7Yn06ICR7e1stMV06XCJBIHJlcXVlc3QgZGlkIG5vdCBzdWNjZWVkLlwiLFstM106XCJUaGVyZSB3YXMgYSBob2xlIGluIHRoZSBwYWdlIHNlcXVlbmNlIG51bWJlcnMgKGUuZy4sIGEgcGFnZSB3YXMgY29ycnVwdCBvciBtaXNzaW5nKS5cIixbLTEyOF06XCJBbiB1bmRlcmx5aW5nIHJlYWQsIHNlZWssIG9yIHRlbGwgb3BlcmF0aW9uIGZhaWxlZCB3aGVuIGl0IHNob3VsZCBoYXZlIHN1Y2NlZWRlZC5cIixbLTEyOV06XCJBIE5VTEwgcG9pbnRlciB3YXMgcGFzc2VkIHdoZXJlIG9uZSB3YXMgdW5leHBlY3RlZCwgb3IgYW4gaW50ZXJuYWwgbWVtb3J5IGFsbG9jYXRpb24gZmFpbGVkLCBvciBhbiBpbnRlcm5hbCBsaWJyYXJ5IGVycm9yIHdhcyBlbmNvdW50ZXJlZC5cIixbLTEzMF06XCJUaGUgc3RyZWFtIHVzZWQgYSBmZWF0dXJlIHRoYXQgaXMgbm90IGltcGxlbWVudGVkLCBzdWNoIGFzIGFuIHVuc3VwcG9ydGVkIGNoYW5uZWwgZmFtaWx5LlwiLFstMTMxXTpcIk9uZSBvciBtb3JlIHBhcmFtZXRlcnMgdG8gYSBmdW5jdGlvbiB3ZXJlIGludmFsaWQuXCIsWy0xMzJdOidBIHB1cnBvcnRlZCBPZ2cgT3B1cyBzdHJlYW0gZGlkIG5vdCBiZWdpbiB3aXRoIGFuIE9nZyBwYWdlLCBhIHB1cnBvcnRlZCBoZWFkZXIgcGFja2V0IGRpZCBub3Qgc3RhcnQgd2l0aCBvbmUgb2YgdGhlIHJlcXVpcmVkIHN0cmluZ3MsIFwiT3B1c0hlYWRcIiBvciBcIk9wdXNUYWdzXCIsIG9yIGEgbGluayBpbiBhIGNoYWluZWQgZmlsZSB3YXMgZW5jb3VudGVyZWQgdGhhdCBkaWQgbm90IGNvbnRhaW4gYW55IGxvZ2ljYWwgT3B1cyBzdHJlYW1zLicsWy0xMzNdOlwiQSByZXF1aXJlZCBoZWFkZXIgcGFja2V0IHdhcyBub3QgcHJvcGVybHkgZm9ybWF0dGVkLCBjb250YWluZWQgaWxsZWdhbCB2YWx1ZXMsIG9yIHdhcyBtaXNzaW5nIGFsdG9nZXRoZXIuXCIsWy0xMzRdOlwiVGhlIElEIGhlYWRlciBjb250YWluZWQgYW4gdW5yZWNvZ25pemVkIHZlcnNpb24gbnVtYmVyLlwiLFstMTM2XTpcIkFuIGF1ZGlvIHBhY2tldCBmYWlsZWQgdG8gZGVjb2RlIHByb3Blcmx5LiBUaGlzIGlzIHVzdWFsbHkgY2F1c2VkIGJ5IGEgbXVsdGlzdHJlYW0gT2dnIHBhY2tldCB3aGVyZSB0aGUgZHVyYXRpb25zIG9mIHRoZSBpbmRpdmlkdWFsIE9wdXMgcGFja2V0cyBjb250YWluZWQgaW4gaXQgYXJlIG5vdCBhbGwgdGhlIHNhbWUuXCIsWy0xMzddOlwiV2UgZmFpbGVkIHRvIGZpbmQgZGF0YSB3ZSBoYWQgc2VlbiBiZWZvcmUsIG9yIHRoZSBiaXRzdHJlYW0gc3RydWN0dXJlIHdhcyBzdWZmaWNpZW50bHkgbWFsZm9ybWVkIHRoYXQgc2Vla2luZyB0byB0aGUgdGFyZ2V0IGRlc3RpbmF0aW9uIHdhcyBpbXBvc3NpYmxlLlwiLFstMTM4XTpcIkFuIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHNlZWtpbmcgd2FzIHJlcXVlc3RlZCBvbiBhbiB1bnNlZWthYmxlIHN0cmVhbS5cIixbLTEzOV06XCJUaGUgZmlyc3Qgb3IgbGFzdCBncmFudWxlIHBvc2l0aW9uIG9mIGEgbGluayBmYWlsZWQgYmFzaWMgdmFsaWRpdHkgY2hlY2tzLlwifVtiXXx8XCJVbmtub3duIEVycm9yXCJ9YCl9dGhpcy5vbkRlY29kZUFsbCYmaSYmdGhpcy5vbkRlY29kZUFsbChuZXcgWihbWShhLGkpLFkobixpKV0saSkpfWNhdGNoKG8pe3Rocm93IG99ZmluYWxseXtSKGYpLFIodiksUihNKSxSKHIpfX1mcmVlKCl7dGhpcy5PJiZxKHRoaXMuTyl9fU8uT2dnT3B1c0RlY29kZXI9TixcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsJiZleHBvcnRzJiYobW9kdWxlLmV4cG9ydHMuT2dnT3B1c0RlY29kZXI9Til9KCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZ2ctb3B1cy1kZWNvZGVyLm1pbi5qcy5tYXAiLCJjb25zdCB7IEV2ZW50VGFyZ2V0LCBkZWZpbmVFdmVudEF0dHJpYnV0ZSB9ID0gcmVxdWlyZSgnZXZlbnQtdGFyZ2V0LXNoaW0nKTtcbmNvbnN0IHsgZGV0ZWN0IH0gPSByZXF1aXJlKCdkZXRlY3QtYnJvd3NlcicpO1xuY29uc3QgYnJvd3NlciA9IGRldGVjdCgpO1xuXG5jb25zdCBBdWRpb0NvbnRleHQgPSBnbG9iYWwuQXVkaW9Db250ZXh0IHx8IGdsb2JhbC53ZWJraXRBdWRpb0NvbnRleHQ7XG5jb25zdCBCVUZGRVJfU0laRSA9IDQwOTY7XG5cbi8qKlxuICogUmVmZXJlbmNlOiBodHRwczovL3czYy5naXRodWIuaW8vbWVkaWFjYXB0dXJlLXJlY29yZC8jbWVkaWFyZWNvcmRlci1hcGlcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKi9cbmNsYXNzIE9wdXNNZWRpYVJlY29yZGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGVuY29kZXIgd2ViIHdvcmtlclxuICAgKiBAbmFtZSB3b3JrZXJGYWN0b3J5XG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7d29ya2VyfSBBbiBpbnN0YW5jZSBvZiAuL2VuY29kZXJXb3JrZXIuanMgd2ViIHdvcmtlci5cbiAgICovXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbSAtIFRoZSBNZWRpYVN0cmVhbSB0byBiZSByZWNvcmRlZC4gVGhpcyB3aWxsXG4gICAqICAgICAgICAgIGJlIHRoZSB2YWx1ZSBvZiB0aGUgc3RyZWFtIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHtNZWRpYVJlY29yZGVyT3B0aW9uc30gW29wdGlvbnNdIC0gQSBkaWN0aW9uYXJ5IG9mIG9wdGlvbnMgdG8gZm9yXG4gICAqICAgICAgICAgIHRoZSBVQSBpbnN0cnVjdGluZyBob3cgdGhlIHJlY29yZGluZyB3aWxsIHRha2UgcGFydC5cbiAgICogICAgICAgICAgb3B0aW9ucy5taW1lVHlwZSwgaWYgcHJlc2VudCwgd2lsbCBiZWNvbWUgdGhlIHZhbHVlIG9mIG1pbWVUeXBlXG4gICAqICAgICAgICAgIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFt3b3JrZXJPcHRpb25zXSBUaGlzIGlzIGEgTk9OLVNUQU5EQVJEIG9wdGlvbnMgdG9cbiAgICogICAgICAgICAgY29uZmlndXJlIGhvdyB0byBpbXBvcnQgdGhlIHdlYiB3b3JrZXIgLndhc20gY29tcGlsZWQgYmluYXJpZXNcbiAgICogICAgICAgICAgdXNlZCBmb3IgZW5jb2RpbmcuXG4gICAqIEBwYXJhbSB7d29ya2VyRmFjdG9yeX0gW3dvcmtlck9wdGlvbnMuZW5jb2RlcldvcmtlckZhY3RvcnldIEEgZmFjdG9yeVxuICAgKiAgICAgICAgICBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhIHdlYiB3b3JrZXIgaW5zdGFuY2Ugb2YgLi9lbmNvZGVyV29ya2VyLmpzXG4gICAqICAgICAgICAgIGFuZCByZXR1cm5zIGl0LiBmdW5jdGlvbigpe3JldHVybiBuZXcgV29ya2VyKCcuL2VuY29kZXJXb3JrZXIudW1kLmpzJyl9XG4gICAqICAgICAgICAgIGlzIHVzZWQgYnkgZGVmYXVsdC4gVGhpcyBpcyBOT04tU1RBTkRBUkQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbd29ya2VyT3B0aW9ucy5PZ2dPcHVzRW5jb2Rlcldhc21QYXRoXVxuICAgKiAgICAgICAgICBQYXRoIG9mIC4vT2dnT3B1c0VuY29kZXIud2FzbSB3aGljaCBpcyB1c2VkIGZvciBPR0cgT3B1cyBlbmNvZGluZ1xuICAgKiAgICAgICAgICBieSB0aGUgZW5jb2RlciB3b3JrZXIuIFRoaXMgaXMgTk9OLVNUQU5EQVJELlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3dvcmtlck9wdGlvbnMuV2ViTU9wdXNFbmNvZGVyV2FzbVBhdGhdXG4gICAqICAgICAgICAgIFBhdGggb2YgLi9XZWJNT3B1c0VuY29kZXIud2FzbSB3aGljaCBpcyB1c2VkIGZvciBXZWJNIE9wdXMgZW5jb2RpbmdcbiAgICogICAgICAgICAgYnkgdGhlIGVuY29kZXIgd29ya2VyLiBUaGlzIGlzIE5PTi1TVEFOREFSRC5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdHJlYW0sIG9wdGlvbnMgPSB7fSwgd29ya2VyT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBtaW1lVHlwZSwgYXVkaW9CaXRzUGVyU2Vjb25kLCB2aWRlb0JpdHNQZXJTZWNvbmQsIGJpdHNQZXJTZWNvbmQgfSA9IG9wdGlvbnM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAvLyBOT04tU1RBTkRBUkQgb3B0aW9uc1xuICAgIGNvbnN0IHsgZW5jb2RlcldvcmtlckZhY3RvcnksIE9nZ09wdXNFbmNvZGVyV2FzbVBhdGgsIFdlYk1PcHVzRW5jb2Rlcldhc21QYXRoIH0gPSB3b3JrZXJPcHRpb25zO1xuXG4gICAgc3VwZXIoKTtcbiAgICAvLyBBdHRyaWJ1dGVzIGZvciB0aGUgc3BlY2lmaWNhdGlvbiBjb25mb3JtYW5jZS4gVGhlc2UgaGF2ZSB0aGVpciBvd24gZ2V0dGVycy5cbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fc3RhdGUgPSAnaW5hY3RpdmUnO1xuICAgIHRoaXMuX21pbWVUeXBlID0gbWltZVR5cGUgfHwgJyc7XG4gICAgdGhpcy5fYXVkaW9CaXRzUGVyU2Vjb25kID0gYXVkaW9CaXRzUGVyU2Vjb25kIHx8IGJpdHNQZXJTZWNvbmQ7XG4gICAgLyoqIEB0eXBlIHsnaW5hY3RpdmUnfCdyZWFkeVRvSW5pdCd8J2VuY29kaW5nJ3wnY2xvc2VkJ30gKi9cbiAgICB0aGlzLndvcmtlclN0YXRlID0gJ2luYWN0aXZlJztcblxuICAgIC8vIFBhcnNlIE1JTUUgVHlwZVxuICAgIGlmICghT3B1c01lZGlhUmVjb3JkZXIuaXNUeXBlU3VwcG9ydGVkKHRoaXMuX21pbWVUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudHMsIGEgTUlNRSBUeXBlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgc3dpdGNoIChPcHVzTWVkaWFSZWNvcmRlci5fcGFyc2VUeXBlKHRoaXMuX21pbWVUeXBlKS5zdWJ0eXBlKSB7XG4gICAgICBjYXNlICd3YXZlJzpcbiAgICAgIGNhc2UgJ3dhdic6XG4gICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL3dhdmUnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnd2VibSc6XG4gICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL3dlYm0nO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2dnJzpcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSAnYXVkaW8vb2dnJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFNlbGVjdCBhIHR5cGUgZGVwZW5kaW5nIG9uIE9TLlxuICAgICAgICBzd2l0Y2ggKGJyb3dzZXIgJiYgYnJvd3Nlci5uYW1lKSB7XG4gICAgICAgICAgY2FzZSAnY2hyb21lJzpcbiAgICAgICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL3dlYm0nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL29nZyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2VkZ2UnOlxuICAgICAgICAgICAgdGhpcy5fbWltZVR5cGUgPSAnYXVkaW8vd2VibSc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2lvcyc6XG4gICAgICAgICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL3dhdmUnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fbWltZVR5cGUgPSAnYXVkaW8vd2VibSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLl9taW1lVHlwZSkge1xuICAgICAgY2FzZSAnYXVkaW8vd2F2ZSc6XG4gICAgICAgIHRoaXMuX3dhc21QYXRoID0gJyc7IC8vIHdhc20gaXMgbm90IHVzZWRcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2F1ZGlvL3dlYm0nOlxuICAgICAgICB0aGlzLl93YXNtUGF0aCA9IFdlYk1PcHVzRW5jb2Rlcldhc21QYXRoIHx8ICcnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXVkaW8vb2dnJzpcbiAgICAgICAgdGhpcy5fd2FzbVBhdGggPSBPZ2dPcHVzRW5jb2Rlcldhc21QYXRoIHx8ICcnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBFcnJvcjogVW5leHBlY3RlZCBNSU1FIFR5cGU6ICR7dGhpcy5fbWltZVR5cGV9YCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGN1cnJlbnQgZGlyZWN0b3J5IGZvciB3b3JrZXJcbiAgICBsZXQgd29ya2VyRGlyID0gJyc7XG4gICAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICAgIHdvcmtlckRpciA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICAgIH0gZWxzZSBpZiAoc2VsZi5sb2NhdGlvbikge1xuICAgICAgd29ya2VyRGlyID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xuICAgIH1cbiAgICB3b3JrZXJEaXIgPSB3b3JrZXJEaXIuc3Vic3RyKDAsIHdvcmtlckRpci5sYXN0SW5kZXhPZignLycpKSArXG4gICAgICAgICAgICAgICAgJy9lbmNvZGVyV29ya2VyLnVtZC5qcyc7XG4gICAgLy8gSWYgd29ya2VyIGZ1bmN0aW9uIGlzIGltcG9ydGVkIHZpYSA8c2NyaXB0PiB0YWcsIG1ha2UgaXQgYmxvYiB0byBnZXQgVVJMLlxuICAgIGlmICh0eXBlb2YgT3B1c01lZGlhUmVjb3JkZXIuZW5jb2RlcldvcmtlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya2VyRGlyID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbYCgke09wdXNNZWRpYVJlY29yZGVyLmVuY29kZXJXb3JrZXJ9KSgpYF0pKTtcbiAgICB9XG5cbiAgICAvLyBTcGF3biBhIGVuY29kZXIgd29ya2VyXG4gICAgdGhpcy5fd29ya2VyRmFjdG9yeSA9IHR5cGVvZiBlbmNvZGVyV29ya2VyRmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZW5jb2RlcldvcmtlckZhY3RvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF8gPT4gbmV3IFdvcmtlcih3b3JrZXJEaXIpO1xuICAgIHRoaXMuX3NwYXduV29ya2VyKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIE1lZGlhU3RyZWFtIFtHRVRVU0VSTUVESUFdIHRvIGJlIHJlY29yZGVkLlxuICAgKiBAcmV0dXJuIHtNZWRpYVN0cmVhbX1cbiAgICovXG4gIGdldCBzdHJlYW0gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogVGhlIE1JTUUgdHlwZSBbUkZDMjA0Nl0gdGhhdCBoYXMgYmVlbiBzZWxlY3RlZCBhcyB0aGUgY29udGFpbmVyIGZvclxuICAgKiByZWNvcmRpbmcuIFRoaXMgZW50cnkgaW5jbHVkZXMgYWxsIHRoZSBwYXJhbWV0ZXJzIHRvIHRoZSBiYXNlXG4gICAqIG1pbWVUeXBlLiBUaGUgVUEgc2hvdWxkIGJlIGFibGUgdG8gcGxheSBiYWNrIGFueSBvZiB0aGUgTUlNRSB0eXBlc1xuICAgKiBpdCBzdXBwb3J0cyBmb3IgcmVjb3JkaW5nLiBGb3IgZXhhbXBsZSwgaXQgc2hvdWxkIGJlIGFibGUgdG8gZGlzcGxheVxuICAgKiBhIHZpZGVvIHJlY29yZGluZyBpbiB0aGUgSFRNTCA8dmlkZW8+IHRhZy4gVGhlIGRlZmF1bHQgdmFsdWUgZm9yXG4gICAqIHRoaXMgcHJvcGVydHkgaXMgcGxhdGZvcm0tc3BlY2lmaWMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldCBtaW1lVHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbWVUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBPcHVzTWVkaWFSZWNvcmRlciBvYmplY3QuIFdoZW4gdGhlIE9wdXNNZWRpYVJlY29yZGVyXG4gICAqIGlzIGNyZWF0ZWQsIHRoZSBVQSBNVVNUIHNldCB0aGlzIGF0dHJpYnV0ZSB0byBpbmFjdGl2ZS5cbiAgICogQHJldHVybiB7XCJpbmFjdGl2ZVwifFwicmVjb3JkaW5nXCJ8XCJwYXVzZWRcIn1cbiAgICovXG4gIGdldCBzdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgVmlkZW8gZW5jb2RpbmcuIFVuc3VwcG9ydGVkLlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgdmlkZW9CaXRzUGVyU2Vjb25kICgpIHtcbiAgICAvLyBWaWRlbyBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIEF1ZGlvIGVuY29kaW5nIHRhcmdldCBiaXQgcmF0ZSB0aGF0IHdhcyBwYXNzZWQgdG9cbiAgICogdGhlIFBsYXRmb3JtIChwb3RlbnRpYWxseSB0cnVuY2F0ZWQsIHJvdW5kZWQsIGV0YyksIG9yIHRoZSBjYWxjdWxhdGVkIG9uZVxuICAgKiBpZiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIGJpdHNQZXJTZWNvbmQuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgYXVkaW9CaXRzUGVyU2Vjb25kICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXVkaW9CaXRzUGVyU2Vjb25kO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgd29ya2VyXG4gICAqL1xuICBfc3Bhd25Xb3JrZXIgKCkge1xuICAgIHRoaXMud29ya2VyID0gdGhpcy5fd29ya2VyRmFjdG9yeSgpO1xuICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB0aGlzLl9vbm1lc3NhZ2VGcm9tV29ya2VyKGUpO1xuICAgIHRoaXMud29ya2VyLm9uZXJyb3IgPSAoZSkgPT4gdGhpcy5fb25lcnJvckZyb21Xb3JrZXIoZSk7XG5cbiAgICB0aGlzLl9wb3N0TWVzc2FnZVRvV29ya2VyKCdsb2FkRW5jb2RlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG1pbWVUeXBlOiB0aGlzLl9taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzbVBhdGg6IHRoaXMuX3dhc21QYXRoIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvc3QgbWVzc2FnZSB0byB0aGUgZW5jb2RlciB3ZWIgd29ya2VyLlxuICAgKiBAcGFyYW0ge1wiaW5pdFwifFwicHVzaElucHV0RGF0YVwifFwiZ2V0RW5jb2RlZERhdGFcInxcImRvbmVcIn0gY29tbWFuZCAtIFR5cGUgb2YgbWVzc2FnZSB0byBzZW5kIHRvIHRoZSB3b3JrZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IG1lc3NhZ2UgLSBQYXlsb2FkIHRvIHRoZSB3b3JrZXJcbiAgICovXG4gIF9wb3N0TWVzc2FnZVRvV29ya2VyIChjb21tYW5kLCBtZXNzYWdlID0ge30pIHtcbiAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgIGNhc2UgJ2xvYWRFbmNvZGVyJzpcbiAgICAgICAgbGV0IHsgbWltZVR5cGUsIHdhc21QYXRoIH0gPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7IGNvbW1hbmQsIG1pbWVUeXBlLCB3YXNtUGF0aCB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB3b3JrZXJcbiAgICAgICAgbGV0IHsgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50LCBiaXRzUGVyU2Vjb25kIH0gPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7IGNvbW1hbmQsIHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgYml0c1BlclNlY29uZCB9KTtcbiAgICAgICAgdGhpcy53b3JrZXJTdGF0ZSA9ICdlbmNvZGluZyc7XG5cbiAgICAgICAgLy8gU3RhcnQgc3RyZWFtaW5nXG4gICAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5wcm9jZXNzb3IpO1xuICAgICAgICB0aGlzLnByb2Nlc3Nvci5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgIGxldCBldmVudFRvUHVzaCA9IG5ldyBnbG9iYWwuRXZlbnQoJ3N0YXJ0Jyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudFRvUHVzaCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwdXNoSW5wdXREYXRhJzpcbiAgICAgICAgLy8gUGFzcyBpbnB1dCBhdWRpbyBidWZmZXIgdG8gdGhlIGVuY29kZXIgdG8gZW5jb2RlLlxuICAgICAgICAvLyBUaGUgd29ya2VyIE1BWSB0cmlnZ2VyICdlbmNvZGVkRGF0YScuXG4gICAgICAgIGxldCB7IGNoYW5uZWxCdWZmZXJzLCBsZW5ndGgsIGR1cmF0aW9uIH0gPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgY29tbWFuZCwgY2hhbm5lbEJ1ZmZlcnMsIGxlbmd0aCwgZHVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdnZXRFbmNvZGVkRGF0YSc6XG4gICAgICAgIC8vIFJlcXVlc3QgZW5jb2RlZCByZXN1bHQuXG4gICAgICAgIC8vIEV4cGVjdGVkICdlbmNvZGVkRGF0YScgZXZlbnQgZnJvbSB0aGUgd29ya2VyXG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHsgY29tbWFuZCB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAvLyBUZWxsIGVuY29kZXIgZmluYWxsaXplIHRoZSBqb2IgYW5kIGRlc3RvcnkgaXRzZWxmLlxuICAgICAgICAvLyBFeHBlY3RlZCAnbGFzdEVuY29kZWREYXRhJyBldmVudCBmcm9tIHRoZSB3b3JrZXIuXG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHsgY29tbWFuZCB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gZXJyb3IgY2FzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIEVycm9yOiBJbmNvcnJlY3QgcG9zdE1lc3NhZ2UgcmVxdWVzdGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBvbm1lc3NhZ2UoKSBjYWxsYmFjayBmcm9tIHRoZSB3b3JrZXIuXG4gICAqIEBwYXJhbSB7bWVzc2FnZX0gZXZlbnQgLSBtZXNzYWdlIGZyb20gdGhlIHdvcmtlclxuICAgKi9cbiAgX29ubWVzc2FnZUZyb21Xb3JrZXIgKGV2ZW50KSB7XG4gICAgY29uc3QgeyBjb21tYW5kLCBidWZmZXJzIH0gPSBldmVudC5kYXRhO1xuICAgIGxldCBldmVudFRvUHVzaDtcbiAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgIGNhc2UgJ3JlYWR5VG9Jbml0JzpcbiAgICAgICAgY29uc3QgeyBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMud29ya2VyU3RhdGUgPSAncmVhZHlUb0luaXQnO1xuXG4gICAgICAgIC8vIElmIHN0YXJ0KCkgaXMgYWxyZWFkeSBjYWxsZWQgaW5pdGlhbGl6ZSB3b3JrZXJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdyZWNvcmRpbmcnKSB7XG4gICAgICAgICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcignaW5pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHNhbXBsZVJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0c1BlclNlY29uZDogdGhpcy5hdWRpb0JpdHNQZXJTZWNvbmR9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZW5jb2RlZERhdGEnOlxuICAgICAgY2FzZSAnbGFzdEVuY29kZWREYXRhJzpcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgQmxvYihidWZmZXJzLCB7J3R5cGUnOiB0aGlzLl9taW1lVHlwZX0pO1xuICAgICAgICBldmVudFRvUHVzaCA9IG5ldyBnbG9iYWwuRXZlbnQoJ2RhdGFhdmFpbGFibGUnKTtcbiAgICAgICAgZXZlbnRUb1B1c2guZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudFRvUHVzaCk7XG5cbiAgICAgICAgLy8gRGV0ZWN0IG9mIHN0b3AoKSBjYWxsZWQgYmVmb3JlXG4gICAgICAgIGlmIChjb21tYW5kID09PSAnbGFzdEVuY29kZWREYXRhJykge1xuICAgICAgICAgIGV2ZW50VG9QdXNoID0gbmV3IGdsb2JhbC5FdmVudCgnc3RvcCcpO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudFRvUHVzaCk7XG5cbiAgICAgICAgICB0aGlzLndvcmtlclN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrOyAvLyBJZ25vcmVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogb25lcnJvcigpIGNhbGxiYWNrIGZyb20gdGhlIHdvcmtlci5cbiAgICogQHBhcmFtIHtFcnJvckV2ZW50fSBlcnJvciAtIGVycm9yIG9iamVjdCBmcm9tIHRoZSB3b3JrZXJcbiAgICovXG4gIF9vbmVycm9yRnJvbVdvcmtlciAoZXJyb3IpIHtcbiAgICAvLyBTdG9wIHN0cmVhbSBmaXJzdFxuICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnByb2Nlc3Nvci5kaXNjb25uZWN0KCk7XG5cbiAgICB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB0aGlzLndvcmtlclN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBTZW5kIG1lc3NhZ2UgdG8gaG9zdFxuICAgIGxldCBtZXNzYWdlID0gW1xuICAgICAgJ0ZpbGVOYW1lOiAnICsgZXJyb3IuZmlsZW5hbWUsXG4gICAgICAnTGluZU51bWJlcjogJyArIGVycm9yLmxpbmVubyxcbiAgICAgICdNZXNzYWdlOiAnICsgZXJyb3IubWVzc2FnZVxuICAgIF0uam9pbignIC0gJyk7XG4gICAgbGV0IGVycm9yVG9QdXNoID0gbmV3IGdsb2JhbC5FdmVudCgnZXJyb3InKTtcbiAgICBlcnJvclRvUHVzaC5uYW1lID0gJ1Vua25vd25FcnJvcic7XG4gICAgZXJyb3JUb1B1c2gubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVycm9yVG9QdXNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgb25hdWRpb3Byb2Nlc3MoKSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzbGljZSAtIEluIHNlY29uZHMuIE9wdXNNZWRpYVJlY29yZGVyIHNob3VsZCByZXF1ZXN0IGRhdGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHRoZSB3b3JrZXIgZXZlcnkgdGltZXNsaWNlIHNlY29uZHMuXG4gICAqL1xuICBfZW5hYmxlQXVkaW9Qcm9jZXNzQ2FsbGJhY2sgKHRpbWVzbGljZSkge1xuICAgIC8vIHBhc3MgZnJhbWUgYnVmZmVycyB0byB0aGUgd29ya2VyXG4gICAgbGV0IGVsYXBzZWRUaW1lID0gMDtcbiAgICB0aGlzLnByb2Nlc3Nvci5vbmF1ZGlvcHJvY2VzcyA9IChlKSA9PiB7XG4gICAgICBjb25zdCB7IGlucHV0QnVmZmVyLCBwbGF5YmFja1RpbWUgfSA9IGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGNvbnN0IHsgc2FtcGxlUmF0ZSwgbGVuZ3RoLCBkdXJhdGlvbiwgbnVtYmVyT2ZDaGFubmVscyB9ID0gaW5wdXRCdWZmZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgLy8gQ3JlYXRlIGNoYW5uZWwgYnVmZmVycyB0byBwYXNzIHRvIHRoZSB3b3JrZXJcbiAgICAgIGNvbnN0IGNoYW5uZWxCdWZmZXJzID0gbmV3IEFycmF5KG51bWJlck9mQ2hhbm5lbHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNoYW5uZWxzOyBpKyspIHtcbiAgICAgICAgY2hhbm5lbEJ1ZmZlcnNbaV0gPSBpbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGFzcyBkYXRhIHRvIHRoZSB3b3JrZXJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7IGNoYW5uZWxCdWZmZXJzLCBsZW5ndGgsIGR1cmF0aW9uIH07XG4gICAgICB0aGlzLl9wb3N0TWVzc2FnZVRvV29ya2VyKCdwdXNoSW5wdXREYXRhJywgbWVzc2FnZSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aW1lXG4gICAgICBlbGFwc2VkVGltZSArPSBkdXJhdGlvbjtcbiAgICAgIGlmIChlbGFwc2VkVGltZSA+PSB0aW1lc2xpY2UpIHtcbiAgICAgICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcignZ2V0RW5jb2RlZERhdGEnKTtcbiAgICAgICAgZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQmVnaW5zIHJlY29yZGluZyBtZWRpYTsgdGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbHkgYmUgcGFzc2VkIGEgdGltZXNsaWNlXG4gICAqIGFyZ3VtZW50IHdpdGggYSB2YWx1ZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc2xpY2UgLSBJZiB0aGlzIGlzIHNwZWNpZmllZCwgdGhlIG1lZGlhIHdpbGwgYmUgY2FwdHVyZWRcbiAgICogICAgICAgIGluIHNlcGFyYXRlIGNodW5rcyBvZiB0aGF0IGR1cmF0aW9uLCByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICAgKiAgICAgICAgb2YgcmVjb3JkaW5nIHRoZSBtZWRpYSBpbiBhIHNpbmdsZSBsYXJnZSBjaHVuay4gSW4gb3RoZXIgd29yZHMsIGFuXG4gICAqICAgICAgICB1bmRlZmluZWQgdmFsdWUgb2YgdGltZXNsaWNlIHdpbGwgYmUgdW5kZXJzdG9vZCBhcyB0aGUgbGFyZ2VzdCBsb25nIHZhbHVlLlxuICAgKi9cbiAgc3RhcnQgKHRpbWVzbGljZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdpbmFjdGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRE9NRXhjZXB0aW9uOiBJTlZBTElEX1NUQVRFX0VSUiwgc3RhdGUgbXVzdCBiZSBpbmFjdGl2ZS4nKTtcbiAgICB9XG4gICAgaWYgKHRpbWVzbGljZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnRzLCB0aW1lc2xpY2Ugc2hvdWxkIGJlIDAgb3IgaGlnaGVyLicpO1xuICAgIH1cbiAgICB0aW1lc2xpY2UgLz0gMTAwMDsgLy8gQ29udmVydCBtaWxsaXNlY29uZHMgdG8gc2Vjb25kc1xuXG4gICAgLy8gQ2hlY2sgd29ya2VyIGlzIGNsb3NlZCAodXN1YWxseSBieSBzdG9wKCkpIGFuZCBpbml0LlxuICAgIGlmICh0aGlzLndvcmtlclN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5fc3Bhd25Xb3JrZXIoKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgY2hhbm5lbCBjb3VudCBhbmQgc2FtcGxpbmcgcmF0ZVxuICAgIC8vIGNoYW5uZWxDb3VudDogaHR0cHM6Ly93d3cudzMub3JnL1RSL21lZGlhY2FwdHVyZS1zdHJlYW1zLyNtZWRpYS10cmFjay1zZXR0aW5nc1xuICAgIC8vIHNhbXBsZVJhdGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CYXNlQXVkaW9Db250ZXh0L3NhbXBsZVJhdGVcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgbGV0IHRyYWNrcyA9IHRoaXMuc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgaWYgKCF0cmFja3NbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRE9NRXhjZXB0aW9uOiBVbmtvd25FcnJvciwgbWVkaWEgdHJhY2sgbm90IGZvdW5kLicpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5uZWxDb3VudCA9IHRyYWNrc1swXS5nZXRTZXR0aW5ncygpLmNoYW5uZWxDb3VudCB8fCAxO1xuICAgIHRoaXMuc2FtcGxlUmF0ZSA9IHRoaXMuY29udGV4dC5zYW1wbGVSYXRlO1xuXG4gICAgLyoqIEB0eXBlIHtNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZX0gKi9cbiAgICB0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSh0aGlzLnN0cmVhbSk7XG4gICAgLyoqIEB0eXBlIHtTY3JpcHRQcm9jZXNzb3JOb2RlfSAqL1xuICAgIHRoaXMucHJvY2Vzc29yID0gdGhpcy5jb250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcihCVUZGRVJfU0laRSwgdGhpcy5jaGFubmVsQ291bnQsIHRoaXMuY2hhbm5lbENvdW50KTtcblxuICAgIC8vIFN0YXJ0IHJlY29yZGluZ1xuICAgIHRoaXMuX3N0YXRlID0gJ3JlY29yZGluZyc7XG4gICAgdGhpcy5fZW5hYmxlQXVkaW9Qcm9jZXNzQ2FsbGJhY2sodGltZXNsaWNlKTtcblxuICAgIC8vIElmIHRoZSB3b3JrZXIgaXMgYWxyZWFkeSBsb2FkZWQgdGhlbiBzdGFydFxuICAgIGlmICh0aGlzLndvcmtlclN0YXRlID09PSAncmVhZHlUb0luaXQnKSB7XG4gICAgICBjb25zdCB7IHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCB9ID0gdGhpcztcbiAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlVG9Xb3JrZXIoJ2luaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHNhbXBsZVJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHNQZXJTZWNvbmQ6IHRoaXMuYXVkaW9CaXRzUGVyU2Vjb25kIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyByZWNvcmRpbmcsIGF0IHdoaWNoIHBvaW50IGEgZGF0YWF2YWlsYWJsZSBldmVudCBjb250YWluaW5nXG4gICAqIHRoZSBmaW5hbCBCbG9iIG9mIHNhdmVkIGRhdGEgaXMgZmlyZWQuIE5vIG1vcmUgcmVjb3JkaW5nIG9jY3Vycy5cbiAgICovXG4gIHN0b3AgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5hY3RpdmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogSU5WQUxJRF9TVEFURV9FUlIsIHN0YXRlIG11c3QgTk9UIGJlIGluYWN0aXZlLicpO1xuICAgIH1cblxuICAgIC8vIFN0b3Agc3RyZWFtIGZpcnN0XG4gICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMucHJvY2Vzc29yLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmNvbnRleHQuY2xvc2UoKTtcblxuICAgIC8vIFN0b3AgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgYXQgX29ubWVzc2FnZUZyb21Xb3JrZXIoKSxcbiAgICB0aGlzLl9wb3N0TWVzc2FnZVRvV29ya2VyKCdkb25lJyk7XG5cbiAgICB0aGlzLl9zdGF0ZSA9ICdpbmFjdGl2ZSc7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2VzIHRoZSByZWNvcmRpbmcgb2YgbWVkaWEuXG4gICAqL1xuICBwYXVzZSAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdpbmFjdGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRE9NRXhjZXB0aW9uOiBJTlZBTElEX1NUQVRFX0VSUiwgc3RhdGUgbXVzdCBOT1QgYmUgaW5hY3RpdmUuJyk7XG4gICAgfVxuXG4gICAgLy8gU3RvcCBzdHJlYW0gZmlyc3RcbiAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5wcm9jZXNzb3IuZGlzY29ubmVjdCgpO1xuXG4gICAgbGV0IGV2ZW50ID0gbmV3IGdsb2JhbC5FdmVudCgncGF1c2UnKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHRoaXMuX3N0YXRlID0gJ3BhdXNlZCc7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lcyByZWNvcmRpbmcgb2YgbWVkaWEgYWZ0ZXIgaGF2aW5nIGJlZW4gcGF1c2VkLlxuICAgKi9cbiAgcmVzdW1lICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luYWN0aXZlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSLCBzdGF0ZSBtdXN0IE5PVCBiZSBpbmFjdGl2ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBSZXN0YXJ0IHN0cmVhbWluZyBkYXRhXG4gICAgdGhpcy5zb3VyY2UuY29ubmVjdCh0aGlzLnByb2Nlc3Nvcik7XG4gICAgdGhpcy5wcm9jZXNzb3IuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXG4gICAgbGV0IGV2ZW50ID0gbmV3IGdsb2JhbC5FdmVudCgncmVzdW1lJyk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLl9zdGF0ZSA9ICdyZWNvcmRpbmcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGEgQmxvYiBjb250YWluaW5nIHRoZSBzYXZlZCBkYXRhIHJlY2VpdmVkIHRodXMgZmFyIChvciBzaW5jZVxuICAgKiB0aGUgbGFzdCB0aW1lIHJlcXVlc3REYXRhKCkgd2FzIGNhbGxlZC4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCxcbiAgICogcmVjb3JkaW5nIGNvbnRpbnVlcywgYnV0IGluIGEgbmV3IEJsb2IuXG4gICAqL1xuICByZXF1ZXN0RGF0YSAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdpbmFjdGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRE9NRXhjZXB0aW9uOiBJTlZBTElEX1NUQVRFX0VSUiwgc3RhdGUgbXVzdCBOT1QgYmUgaW5hY3RpdmUuJyk7XG4gICAgfVxuXG4gICAgLy8gZGF0YWF2YWlsYWJsZSBldmVudCB3aWxsIGJlIHRyaWdnZXJkIGF0IF9vbm1lc3NhZ2VGcm9tV29ya2VyKClcbiAgICB0aGlzLl9wb3N0TWVzc2FnZVRvV29ya2VyKCdnZXRFbmNvZGVkRGF0YScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGdpdmVuIE1JTUUgdHlwZSBpcyBzdXBwb3J0ZWRcbiAgICogYnkgdGhlIGN1cnJlbnQgdXNlciBhZ2VudCAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlVHlwZSAtIEEgTUlNRSBUeXBlLCBpbmNsdWRpbmcgcGFyYW1ldGVycyB3aGVuIG5lZWRlZCxcbiAgICogICAgICAgICAgc3BlY2lmeWluZyBhIGNvbnRhaW5lciBhbmQvb3IgY29kZWMgZm9ybWF0cyBmb3IgcmVjb3JkaW5nLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVHlwZVN1cHBvcnRlZCAobWltZVR5cGUpIHtcbiAgICAvLyBTZWU6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9tZWRpYWNhcHR1cmUtcmVjb3JkLyNkb20tbWVkaWFyZWNvcmRlci1pc3R5cGVzdXBwb3J0ZWRcblxuICAgIC8vIDEuIElmIGVtcHR5IHN0cmluZywgcmV0dXJuIHRydWUuXG4gICAgaWYgKHR5cGVvZiBtaW1lVHlwZSA9PT0gJ3N0cmluZycgJiYgIW1pbWVUeXBlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHZhciB7dHlwZSwgc3VidHlwZSwgY29kZWN9ID0gT3B1c01lZGlhUmVjb3JkZXIuX3BhcnNlVHlwZShtaW1lVHlwZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIDIuIElmIG5vdCBhIHZhbGlkIHN0cmluZywgcmV0dXJuIGZhbHNlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gJ2F1ZGlvJyB8fFxuICAgICAgIShzdWJ0eXBlID09PSAnb2dnJyB8fCBzdWJ0eXBlID09PSAnd2VibScgfHxcbiAgICAgICAgc3VidHlwZSA9PT0gJ3dhdmUnIHx8IHN1YnR5cGUgPT09ICd3YXYnKSkge1xuICAgICAgLy8gMyw0LiBJZiB0eXBlIGFuZCBzdWJ0eXBlIGFyZSB1bnN1cHBvcnRlZCB0aGUgcmV0dXJuIGZhbHNlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyA1LiBJZiBjb2RlYyBpcyB1bnN1cHBvcnRlZCB0aGVuIHJldHVybiBmYWxzZS5cbiAgICAvLyA2LiBJZiB0aGUgc3BlY2lmaWVkIGNvbWJpbmF0aW9uIG9mIGFsbCBpcyBub3Qgc3VwcG9ydGVkIHRoYW4gcmV0dXJuIGZhbHNlLlxuICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgY2FzZSAnb2dnJzpcbiAgICAgICAgaWYgKGNvZGVjICE9PSAnb3B1cycgJiYgY29kZWMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWJtJzpcbiAgICAgICAgaWYgKGNvZGVjICE9PSAnb3B1cycgJiYgY29kZWMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3YXZlJzpcbiAgICAgIGNhc2UgJ3dhdic6XG4gICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gQ3VycmVudGx5IG9ubHkgc3VwcG9ydHMgc2lnbmVkIDE2IGJpdHNcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gNy4gcmV0dXJuIHRydWUuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgTUlNRS4gQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGlzVHlwZVN1cHBvcnRlZCgpIGFuZCBldGMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSAtIHR5cGVUeXBlIC0gQSBNSU1FIFR5cGUsIGluY2x1ZGluZyBwYXJhbWV0ZXJzIHdoZW4gbmVlZGVkLFxuICAgKiAgICAgICAgICBzcGVjaWZ5aW5nIGEgY29udGFpbmVyIGFuZC9vciBjb2RlYyBmb3JtYXRzIGZvciByZWNvcmRpbmcuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IC0gQW4gb2JqZWN0IHdpdGggdHlwZSwgc3VidHlwZSwgY29kZWMgYXR0cmlidXRlc1xuICAgKiAgICAgICAgICBpZiBwYXJzZWQgY29ycmVjdGx5LiBudWxsIGlzIHJldHVybmVkIGlmIHBhcnNpbmcgZmFpbGVkLlxuICAgKiAgICAgICAgICBJZiBtaW1lVHlwZSBpcyBhbiBlbXB0eSBzdHJpbmcgdGhlbiByZXR1cm4gYW4gb2JqZWN0IHdpdGggYXR0cmlidXRlc1xuICAgKiAgICAgICAgICBhcmUgZW1wdHkgc3RyaW5nc1xuICAgKi9cbiAgc3RhdGljIF9wYXJzZVR5cGUgKG1pbWVUeXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL14oXFx3KylcXC8oXFx3KykoO1xccypjb2RlY3M9KFxcdyspKT8kLztcbiAgICAgIHZhciBbLCB0eXBlLCBzdWJ0eXBlLCAsIGNvZGVjXSA9IG1pbWVUeXBlLm1hdGNoKHJlZ2V4KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHR5cGVvZiBtaW1lVHlwZSA9PT0gJ3N0cmluZycgJiYgIW1pbWVUeXBlKSB7XG4gICAgICAgIHJldHVybiB7dHlwZTogJycsIHN1YnR5cGU6ICcnLCBjb2RlYzogJyd9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7dHlwZSwgc3VidHlwZSwgY29kZWN9O1xuICB9XG59XG5cbi8vIEV2ZW50SGFuZGxlciBhdHRyaWJ1dGVzLlxuLy8gVGhpcyBjb2RlIGlzIGEgbm9uLXN0YW5kYXJkIEV2ZW50VGFyZ2V0IGJ1dCByZXF1aXJlZCBieSBldmVudC10YXJnZXQtc2hpbS5cbltcbiAgJ3N0YXJ0JywgLy8gQ2FsbGVkIHRvIGhhbmRsZSB0aGUge0BsaW5rIE1lZGlhUmVjb3JkZXIjc3RhcnR9IGV2ZW50LlxuICAnc3RvcCcsIC8vIENhbGxlZCB0byBoYW5kbGUgdGhlIHN0b3AgZXZlbnQuXG4gICdkYXRhYXZhaWxhYmxlJywgLyogQ2FsbGVkIHRvIGhhbmRsZSB0aGUgZGF0YWF2YWlsYWJsZSBldmVudC4gVGhlIEJsb2Igb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZGVkIGRhdGEgaXMgY29udGFpbmVkIGluIHRoaXMgZXZlbnQgYW5kIGNhbiBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzZWQgdmlhIGl0cyBkYXRhIGF0dHJpYnV0ZS4gKi9cbiAgJ3BhdXNlJywgLy8gQ2FsbGVkIHRvIGhhbmRsZSB0aGUgcGF1c2UgZXZlbnQuXG4gICdyZXN1bWUnLCAvLyBDYWxsZWQgdG8gaGFuZGxlIHRoZSByZXN1bWUgZXZlbnQuXG4gICdlcnJvcicgLy8gQ2FsbGVkIHRvIGhhbmRsZSBhIE1lZGlhUmVjb3JkZXJFcnJvckV2ZW50LlxuXS5mb3JFYWNoKG5hbWUgPT4gZGVmaW5lRXZlbnRBdHRyaWJ1dGUoT3B1c01lZGlhUmVjb3JkZXIucHJvdG90eXBlLCBuYW1lKSk7XG5cbi8vIE1TIEVkZ2Ugc3BlY2lmaWMgbW9ua2V5IHBhdGNoaW5nOlxuLy8gb25hdWRpb3Byb2Nlc3MgY2FsbGJhY2sgY2Fubm90IGJlIHRyaWdnZXJlZCBtb3JlIHRoYW4gdHdpY2Ugd2hlbiBwb3N0TWVzc2FnZVxuLy8gdXNlcyB0aGUgc2Vjb25kZSB0cmFuc2ZlciBhcmd1bWVudC4gU28gZGlzYWJsZSB0aGUgdHJhbnNmZXIgYXJndW1lbnQgb25seSBpbiBFZGdlLlxuaWYgKGJyb3dzZXIgJiYgYnJvd3Nlci5uYW1lID09PSAnZWRnZScpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JpZ2luYWwgPSBXb3JrZXIucHJvdG90eXBlLnBvc3RNZXNzYWdlO1xuICAgIFdvcmtlci5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXIgPSBudWxsKSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBbbWVzc2FnZV0pO1xuICAgIH07XG4gIH0pKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT3B1c01lZGlhUmVjb3JkZXI7XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlQnVzO1xuaW5oZXJpdHMoUGFnZUJ1cywgRXZlbnRFbWl0dGVyKTtcblxudmFyIGVtaXQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG52YXIgb24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xudmFyIG9uY2UgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2U7XG5cbmZ1bmN0aW9uIFBhZ2VCdXMgKG9wdHMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFnZUJ1cykpIHJldHVybiBuZXcgUGFnZUJ1cyhvcHRzKTtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykgb3B0cyA9IHsga2V5OiBvcHRzIH07XG4gICAgdGhpcy5fa2V5ID0gb3B0cy5rZXkgfHwgJ3BhZ2UtYnVzJztcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KFtdKSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKGV2LmtleSA9PT0gc2VsZi5fa2V5KSB7XG4gICAgICAgICAgICB0cnkgeyB2YXIgdmFsdWUgPSBKU09OLnBhcnNlKGV2Lm5ld1ZhbHVlKSB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7IHJldHVybiB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIGVtaXQuYXBwbHkoc2VsZiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblxuUGFnZUJ1cy5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgIHJldHVybiB0aGlzO1xufTtcbiIsIi8qISBxdWV1ZS1taWNyb3Rhc2suIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmxldCBwcm9taXNlXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nXG4gID8gcXVldWVNaWNyb3Rhc2suYmluZCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbiAgLy8gcmV1c2UgcmVzb2x2ZWQgcHJvbWlzZSwgYW5kIGFsbG9jYXRlIGl0IGxhemlseVxuICA6IGNiID0+IChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKVxuICAgIC50aGVuKGNiKVxuICAgIC5jYXRjaChlcnIgPT4gc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGVyciB9LCAwKSlcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBsaW1pdCBvZiBDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKClcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcnlwdG8vZ2V0UmFuZG9tVmFsdWVzXG52YXIgTUFYX0JZVEVTID0gNjU1MzZcblxuLy8gTm9kZSBzdXBwb3J0cyByZXF1ZXN0aW5nIHVwIHRvIHRoaXMgbnVtYmVyIG9mIGJ5dGVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2ludGVybmFsL2NyeXB0by9yYW5kb20uanMjTDQ4XG52YXIgTUFYX1VJTlQzMiA9IDQyOTQ5NjcyOTVcblxuZnVuY3Rpb24gb2xkQnJvd3NlciAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignU2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci5cXG5Vc2UgQ2hyb21lLCBGaXJlZm94IG9yIEludGVybmV0IEV4cGxvcmVyIDExJylcbn1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cblxuaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZXNcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gb2xkQnJvd3NlclxufVxuXG5mdW5jdGlvbiByYW5kb21CeXRlcyAoc2l6ZSwgY2IpIHtcbiAgLy8gcGhhbnRvbWpzIG5lZWRzIHRvIHRocm93XG4gIGlmIChzaXplID4gTUFYX1VJTlQzMikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlcXVlc3RlZCB0b28gbWFueSByYW5kb20gYnl0ZXMnKVxuXG4gIHZhciBieXRlcyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuXG4gIGlmIChzaXplID4gMCkgeyAgLy8gZ2V0UmFuZG9tVmFsdWVzIGZhaWxzIG9uIElFIGlmIHNpemUgPT0gMFxuICAgIGlmIChzaXplID4gTUFYX0JZVEVTKSB7IC8vIHRoaXMgaXMgdGhlIG1heCBieXRlcyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICAvLyBjYW4gZG8gYXQgb25jZSBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICBmb3IgKHZhciBnZW5lcmF0ZWQgPSAwOyBnZW5lcmF0ZWQgPCBzaXplOyBnZW5lcmF0ZWQgKz0gTUFYX0JZVEVTKSB7XG4gICAgICAgIC8vIGJ1ZmZlci5zbGljZSBhdXRvbWF0aWNhbGx5IGNoZWNrcyBpZiB0aGUgZW5kIGlzIHBhc3QgdGhlIGVuZCBvZlxuICAgICAgICAvLyB0aGUgYnVmZmVyIHNvIHdlIGRvbid0IGhhdmUgdG8gaGVyZVxuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzLnNsaWNlKGdlbmVyYXRlZCwgZ2VuZXJhdGVkICsgTUFYX0JZVEVTKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcylcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2IobnVsbCwgYnl0ZXMpXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gICAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcblxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTsgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cblxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTsgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J1ZmZlcicpLFxuICAgIEJ1ZmZlciA9IF9yZXF1aXJlLkJ1ZmZlcjtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBjdXN0b20gPSBpbnNwZWN0ICYmIGluc3BlY3QuY3VzdG9tIHx8ICdpbnNwZWN0JztcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbe1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiB0aGlzLmhlYWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnN1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICBpZiAobiA8IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBgc2xpY2VgIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICAgICAgdGhpcy5oZWFkLmRhdGEgPSB0aGlzLmhlYWQuZGF0YS5zbGljZShuKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PT0gdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaC5cbiAgICAgICAgcmV0ID0gdGhpcy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyLlxuICAgICAgICByZXQgPSBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdHJpbmcobikge1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICB2YXIgcmV0ID0gcC5kYXRhO1xuICAgICAgbiAtPSByZXQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICBwLmRhdGEuY29weShyZXQpO1xuICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG5cbiAgfSwge1xuICAgIGtleTogY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIC8vIE9ubHkgaW5zcGVjdCBvbmUgbGV2ZWwuXG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAvLyBJdCBzaG91bGQgbm90IHJlY3Vyc2UuXG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7IiwiJ3VzZSBzdHJpY3QnOyAvLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG5cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxufTsiLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gIHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgb3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlO1xuICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTtcblxuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcblxuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG5cbiAgdmFyIG9uZmluaXNoID0gZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICB9O1xuXG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuXG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl93cml0YWJsZVN0YXRlIHx8ICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcblxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cblxuICBzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyJylcbn07XG4iLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlb3M7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1MsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcblxuZnVuY3Rpb24gbm9vcChlcnIpIHtcbiAgLy8gUmV0aHJvdyB0aGUgZXJyb3IgaWYgaXQgZXhpc3RzIHRvIGF2b2lkIHN3YWxsb3dpbmcgaXRcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xufVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICB9KTtcbiAgaWYgKGVvcyA9PT0gdW5kZWZpbmVkKSBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlOyAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudFxuXG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsbChmbikge1xuICBmbigpO1xufVxuXG5mdW5jdGlvbiBwaXBlKGZyb20sIHRvKSB7XG4gIHJldHVybiBmcm9tLnBpcGUodG8pO1xufVxuXG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIGlmICghc3RyZWFtcy5sZW5ndGgpIHJldHVybiBub29wO1xuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5vb3A7XG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBjYWxsYmFjayA9IHBvcENhbGxiYWNrKHN0cmVhbXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF07XG5cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XG4gIH1cblxuICB2YXIgZXJyb3I7XG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgaWYgKHJlYWRpbmcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuXG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICB2YXIgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSk7XG5cbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9IC8vIERlZmF1bHQgdmFsdWVcblxuXG4gIHJldHVybiBzdGF0ZS5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbmV4cG9ydHMuZmluaXNoZWQgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKTtcbmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJyk7XG4iLCIvKiEgcnVuLXdhdGVyZmFsbC4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubW9kdWxlLmV4cG9ydHMgPSBydW5XYXRlcmZhbGxcblxuZnVuY3Rpb24gcnVuV2F0ZXJmYWxsICh0YXNrcywgY2IpIHtcbiAgdmFyIGN1cnJlbnQgPSAwXG4gIHZhciBpc1N5bmMgPSB0cnVlXG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyLCBhcmdzKSB7XG4gICAgZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIGFyZ3MgPSBhcmdzID8gW10uY29uY2F0KGVyciwgYXJncykgOiBbZXJyXVxuICAgICAgaWYgKGNiKSBjYi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpXG4gICAgfVxuICAgIGlmIChpc1N5bmMpIHByb2Nlc3MubmV4dFRpY2soZW5kKVxuICAgIGVsc2UgZW5kKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhY2ggKGVycikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgIGlmICgrK2N1cnJlbnQgPj0gdGFza3MubGVuZ3RoIHx8IGVycikge1xuICAgICAgZG9uZShlcnIsIGFyZ3MpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhc2tzW2N1cnJlbnRdLmFwcGx5KHVuZGVmaW5lZCwgW10uY29uY2F0KGFyZ3MsIGVhY2gpKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICB0YXNrc1swXShlYWNoKVxuICB9IGVsc2Uge1xuICAgIGRvbmUobnVsbClcbiAgfVxuXG4gIGlzU3luYyA9IGZhbHNlXG59XG4iLCIvKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTRFAgaGVscGVycy5cbnZhciBTRFBVdGlscyA9IHt9O1xuXG4vLyBHZW5lcmF0ZSBhbiBhbHBoYW51bWVyaWMgaWRlbnRpZmllciBmb3IgY25hbWUgb3IgbWlkcy5cbi8vIFRPRE86IHVzZSBVVUlEcyBpbnN0ZWFkPyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG5TRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCAxMCk7XG59O1xuXG4vLyBUaGUgUlRDUCBDTkFNRSB1c2VkIGJ5IGFsbCBwZWVyY29ubmVjdGlvbnMgZnJvbSB0aGUgc2FtZSBKUy5cblNEUFV0aWxzLmxvY2FsQ05hbWUgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuLy8gU3BsaXRzIFNEUCBpbnRvIGxpbmVzLCBkZWFsaW5nIHdpdGggYm90aCBDUkxGIGFuZCBMRi5cblNEUFV0aWxzLnNwbGl0TGluZXMgPSBmdW5jdGlvbihibG9iKSB7XG4gIHJldHVybiBibG9iLnRyaW0oKS5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS50cmltKCk7XG4gIH0pO1xufTtcbi8vIFNwbGl0cyBTRFAgaW50byBzZXNzaW9ucGFydCBhbmQgbWVkaWFzZWN0aW9ucy4gRW5zdXJlcyBDUkxGLlxuU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgdmFyIHBhcnRzID0gYmxvYi5zcGxpdCgnXFxubT0nKTtcbiAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbihwYXJ0LCBpbmRleCkge1xuICAgIHJldHVybiAoaW5kZXggPiAwID8gJ209JyArIHBhcnQgOiBwYXJ0KS50cmltKCkgKyAnXFxyXFxuJztcbiAgfSk7XG59O1xuXG4vLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuU0RQVXRpbHMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbihibG9iLCBwcmVmaXgpIHtcbiAgcmV0dXJuIFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYikuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5pbmRleE9mKHByZWZpeCkgPT09IDA7XG4gIH0pO1xufTtcblxuLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuLy8gY2FuZGlkYXRlOjcwMjc4NjM1MCAyIHVkcCA0MTgxOTkwMiA4LjguOC44IDYwNzY5IHR5cCByZWxheSByYWRkciA4LjguOC44XG4vLyBycG9ydCA1NTk5NlwiXG5TRFBVdGlscy5wYXJzZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzO1xuICAvLyBQYXJzZSBib3RoIHZhcmlhbnRzLlxuICBpZiAobGluZS5pbmRleE9mKCdhPWNhbmRpZGF0ZTonKSA9PT0gMCkge1xuICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTIpLnNwbGl0KCcgJyk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMCkuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGUgPSB7XG4gICAgZm91bmRhdGlvbjogcGFydHNbMF0sXG4gICAgY29tcG9uZW50OiBwYXJ0c1sxXSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICBpcDogcGFydHNbNF0sXG4gICAgcG9ydDogcGFyc2VJbnQocGFydHNbNV0sIDEwKSxcbiAgICAvLyBza2lwIHBhcnRzWzZdID09ICd0eXAnXG4gICAgdHlwZTogcGFydHNbN11cbiAgfTtcblxuICBmb3IgKHZhciBpID0gODsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgc3dpdGNoIChwYXJ0c1tpXSkge1xuICAgICAgY2FzZSAncmFkZHInOlxuICAgICAgICBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncnBvcnQnOlxuICAgICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQgPSBwYXJzZUludChwYXJ0c1tpICsgMV0sIDEwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0Y3B0eXBlJzpcbiAgICAgICAgY2FuZGlkYXRlLnRjcFR5cGUgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogLy8gZXh0ZW5zaW9uIGhhbmRsaW5nLCBpbiBwYXJ0aWN1bGFyIHVmcmFnXG4gICAgICAgIGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlO1xufTtcblxuLy8gVHJhbnNsYXRlcyBhIGNhbmRpZGF0ZSBvYmplY3QgaW50byBTRFAgY2FuZGlkYXRlIGF0dHJpYnV0ZS5cblNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gIHZhciBzZHAgPSBbXTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmZvdW5kYXRpb24pO1xuICBzZHAucHVzaChjYW5kaWRhdGUuY29tcG9uZW50KTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUuaXApO1xuICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XG5cbiAgdmFyIHR5cGUgPSBjYW5kaWRhdGUudHlwZTtcbiAgc2RwLnB1c2goJ3R5cCcpO1xuICBzZHAucHVzaCh0eXBlKTtcbiAgaWYgKHR5cGUgIT09ICdob3N0JyAmJiBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgJiZcbiAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCkge1xuICAgIHNkcC5wdXNoKCdyYWRkcicpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyk7IC8vIHdhczogcmVsQWRkclxuICAgIHNkcC5wdXNoKCdycG9ydCcpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCk7IC8vIHdhczogcmVsUG9ydFxuICB9XG4gIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICBzZHAucHVzaCgndGNwdHlwZScpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcbiAgfVxuICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBpY2Utb3B0aW9ucyBsaW5lLCByZXR1cm5zIGFuIGFycmF5IG9mIG9wdGlvbiB0YWdzLlxuLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG5TRFBVdGlscy5wYXJzZUljZU9wdGlvbnMgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHJldHVybiBsaW5lLnN1YnN0cigxNCkuc3BsaXQoJyAnKTtcbn1cblxuLy8gUGFyc2VzIGFuIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcblNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cig5KS5zcGxpdCgnICcpO1xuICB2YXIgcGFyc2VkID0ge1xuICAgIHBheWxvYWRUeXBlOiBwYXJzZUludChwYXJ0cy5zaGlmdCgpLCAxMCkgLy8gd2FzOiBpZFxuICB9O1xuXG4gIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcblxuICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICBwYXJzZWQuY2xvY2tSYXRlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsgLy8gd2FzOiBjbG9ja3JhdGVcbiAgLy8gd2FzOiBjaGFubmVsc1xuICBwYXJzZWQubnVtQ2hhbm5lbHMgPSBwYXJ0cy5sZW5ndGggPT09IDMgPyBwYXJzZUludChwYXJ0c1syXSwgMTApIDogMTtcbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlIGFuIGE9cnRwbWFwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3Jcbi8vIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRwTWFwID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgdmFyIHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICByZXR1cm4gJ2E9cnRwbWFwOicgKyBwdCArICcgJyArIGNvZGVjLm5hbWUgKyAnLycgKyBjb2RlYy5jbG9ja1JhdGUgK1xuICAgICAgKGNvZGVjLm51bUNoYW5uZWxzICE9PSAxID8gJy8nICsgY29kZWMubnVtQ2hhbm5lbHMgOiAnJykgKyAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyBhbiBhPWV4dG1hcCBsaW5lIChoZWFkZXJleHRlbnNpb24gZnJvbSBSRkMgNTI4NSkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuLy8gYT1leHRtYXA6Mi9zZW5kb25seSB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG5TRFBVdGlscy5wYXJzZUV4dG1hcCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoOSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcbiAgICB1cmk6IHBhcnRzWzFdXG4gIH07XG59O1xuXG4vLyBHZW5lcmF0ZXMgYT1leHRtYXAgbGluZSBmcm9tIFJUQ1J0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgb3Jcbi8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cblNEUFV0aWxzLndyaXRlRXh0bWFwID0gZnVuY3Rpb24oaGVhZGVyRXh0ZW5zaW9uKSB7XG4gIHJldHVybiAnYT1leHRtYXA6JyArIChoZWFkZXJFeHRlbnNpb24uaWQgfHwgaGVhZGVyRXh0ZW5zaW9uLnByZWZlcnJlZElkKSArXG4gICAgICAoaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAmJiBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnXG4gICAgICAgICAgPyAnLycgKyBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uXG4gICAgICAgICAgOiAnJykgK1xuICAgICAgJyAnICsgaGVhZGVyRXh0ZW5zaW9uLnVyaSArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGFuIGZ0bXAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxuLy8gQWxzbyBkZWFscyB3aXRoIHZicj1vbjsgY25nPW9uXG5TRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGt2O1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cihsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICBrdiA9IHBhcnRzW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlcyBhbiBhPWZ0bXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbihjb2RlYykge1xuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5wYXJhbWV0ZXJzICYmIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICBwYXJhbXMucHVzaChwYXJhbSArICc9JyArIGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgICB9KTtcbiAgICBsaW5lICs9ICdhPWZtdHA6JyArIHB0ICsgJyAnICsgcGFyYW1zLmpvaW4oJzsnKSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBsaW5lO1xufTtcblxuLy8gUGFyc2VzIGFuIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuU0RQVXRpbHMucGFyc2VSdGNwRmIgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBwYXJ0cy5zaGlmdCgpLFxuICAgIHBhcmFtZXRlcjogcGFydHMuam9pbignICcpXG4gIH07XG59O1xuLy8gR2VuZXJhdGUgYT1ydGNwLWZiIGxpbmVzIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRjcEZiID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgdmFyIGxpbmVzID0gJyc7XG4gIHZhciBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgaWYgKGNvZGVjLnJ0Y3BGZWVkYmFjayAmJiBjb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoKSB7XG4gICAgLy8gRklYTUU6IHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyci1pbnQ/XG4gICAgY29kZWMucnRjcEZlZWRiYWNrLmZvckVhY2goZnVuY3Rpb24oZmIpIHtcbiAgICAgIGxpbmVzICs9ICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnICsgZmIudHlwZSArXG4gICAgICAoZmIucGFyYW1ldGVyICYmIGZiLnBhcmFtZXRlci5sZW5ndGggPyAnICcgKyBmYi5wYXJhbWV0ZXIgOiAnJykgK1xuICAgICAgICAgICdcXHJcXG4nO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBsaW5lcztcbn07XG5cbi8vIFBhcnNlcyBhbiBSRkMgNTU3NiBzc3JjIG1lZGlhIGF0dHJpYnV0ZS4gU2FtcGxlIGlucHV0OlxuLy8gYT1zc3JjOjM3MzU5Mjg1NTkgY25hbWU6c29tZXRoaW5nXG5TRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHNwID0gbGluZS5pbmRleE9mKCcgJyk7XG4gIHZhciBwYXJ0cyA9IHtcbiAgICBzc3JjOiBwYXJzZUludChsaW5lLnN1YnN0cig3LCBzcCAtIDcpLCAxMClcbiAgfTtcbiAgdmFyIGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jywgc3ApO1xuICBpZiAoY29sb24gPiAtMSkge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyKHNwICsgMSwgY29sb24gLSBzcCAtIDEpO1xuICAgIHBhcnRzLnZhbHVlID0gbGluZS5zdWJzdHIoY29sb24gKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cihzcCArIDEpO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn07XG5cbi8vIEV4dHJhY3RzIHRoZSBNSUQgKFJGQyA1ODg4KSBmcm9tIGEgbWVkaWEgc2VjdGlvbi5cbi8vIHJldHVybnMgdGhlIE1JRCBvciB1bmRlZmluZWQgaWYgbm8gbWlkIGxpbmUgd2FzIGZvdW5kLlxuU0RQVXRpbHMuZ2V0TWlkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKVswXTtcbiAgaWYgKG1pZCkge1xuICAgIHJldHVybiBtaWQuc3Vic3RyKDYpO1xuICB9XG59XG5cblNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDE0KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSwgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXG4gICAgdmFsdWU6IHBhcnRzWzFdXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyBEVExTIHBhcmFtZXRlcnMgZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgICAnYT1maW5nZXJwcmludDonKTtcbiAgLy8gTm90ZTogYT1zZXR1cCBsaW5lIGlzIGlnbm9yZWQgc2luY2Ugd2UgdXNlIHRoZSAnYXV0bycgcm9sZS5cbiAgLy8gTm90ZTI6ICdhbGdvcml0aG0nIGlzIG5vdCBjYXNlIHNlbnNpdGl2ZSBleGNlcHQgaW4gRWRnZS5cbiAgcmV0dXJuIHtcbiAgICByb2xlOiAnYXV0bycsXG4gICAgZmluZ2VycHJpbnRzOiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludClcbiAgfTtcbn07XG5cbi8vIFNlcmlhbGl6ZXMgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMsIHNldHVwVHlwZSkge1xuICB2YXIgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xuICBwYXJhbXMuZmluZ2VycHJpbnRzLmZvckVhY2goZnVuY3Rpb24oZnApIHtcbiAgICBzZHAgKz0gJ2E9ZmluZ2VycHJpbnQ6JyArIGZwLmFsZ29yaXRobSArICcgJyArIGZwLnZhbHVlICsgJ1xcclxcbic7XG4gIH0pO1xuICByZXR1cm4gc2RwO1xufTtcbi8vIFBhcnNlcyBJQ0UgaW5mb3JtYXRpb24gZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGljZS11ZnJhZyBhbmQgaWNlLXB3ZCBsaW5lcyBhcyBpbnB1dC5cblNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgLy8gU2VhcmNoIGluIHNlc3Npb24gcGFydCwgdG9vLlxuICBsaW5lcyA9IGxpbmVzLmNvbmNhdChTRFBVdGlscy5zcGxpdExpbmVzKHNlc3Npb25wYXJ0KSk7XG4gIHZhciBpY2VQYXJhbWV0ZXJzID0ge1xuICAgIHVzZXJuYW1lRnJhZ21lbnQ6IGxpbmVzLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZS5pbmRleE9mKCdhPWljZS11ZnJhZzonKSA9PT0gMDtcbiAgICB9KVswXS5zdWJzdHIoMTIpLFxuICAgIHBhc3N3b3JkOiBsaW5lcy5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUuaW5kZXhPZignYT1pY2UtcHdkOicpID09PSAwO1xuICAgIH0pWzBdLnN1YnN0cigxMClcbiAgfTtcbiAgcmV0dXJuIGljZVBhcmFtZXRlcnM7XG59O1xuXG4vLyBTZXJpYWxpemVzIElDRSBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlSWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICByZXR1cm4gJ2E9aWNlLXVmcmFnOicgKyBwYXJhbXMudXNlcm5hbWVGcmFnbWVudCArICdcXHJcXG4nICtcbiAgICAgICdhPWljZS1wd2Q6JyArIHBhcmFtcy5wYXNzd29yZCArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBSVENSdHBQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBkZXNjcmlwdGlvbiA9IHtcbiAgICBjb2RlY3M6IFtdLFxuICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgIGZlY01lY2hhbmlzbXM6IFtdLFxuICAgIHJ0Y3A6IFtdXG4gIH07XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgdmFyIG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgZm9yICh2YXIgaSA9IDM7IGkgPCBtbGluZS5sZW5ndGg7IGkrKykgeyAvLyBmaW5kIGFsbCBjb2RlY3MgZnJvbSBtbGluZVszLi5dXG4gICAgdmFyIHB0ID0gbWxpbmVbaV07XG4gICAgdmFyIHJ0cG1hcGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1ydHBtYXA6JyArIHB0ICsgJyAnKVswXTtcbiAgICBpZiAocnRwbWFwbGluZSkge1xuICAgICAgdmFyIGNvZGVjID0gU0RQVXRpbHMucGFyc2VSdHBNYXAocnRwbWFwbGluZSk7XG4gICAgICB2YXIgZm10cHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgICBtZWRpYVNlY3Rpb24sICdhPWZtdHA6JyArIHB0ICsgJyAnKTtcbiAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IGE9Zm10cDo8cHQ+IGlzIGNvbnNpZGVyZWQuXG4gICAgICBjb2RlYy5wYXJhbWV0ZXJzID0gZm10cHMubGVuZ3RoID8gU0RQVXRpbHMucGFyc2VGbXRwKGZtdHBzWzBdKSA6IHt9O1xuICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOicgKyBwdCArICcgJylcbiAgICAgICAgLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgICBkZXNjcmlwdGlvbi5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAvLyBwYXJzZSBGRUMgbWVjaGFuaXNtcyBmcm9tIHJ0cG1hcCBsaW5lcy5cbiAgICAgIHN3aXRjaCAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ1JFRCc6XG4gICAgICAgIGNhc2UgJ1VMUEZFQyc6XG4gICAgICAgICAgZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5wdXNoKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIG9ubHkgUkVEIGFuZCBVTFBGRUMgYXJlIHJlY29nbml6ZWQgYXMgRkVDIG1lY2hhbmlzbXMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9ZXh0bWFwOicpLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgIGRlc2NyaXB0aW9uLmhlYWRlckV4dGVuc2lvbnMucHVzaChTRFBVdGlscy5wYXJzZUV4dG1hcChsaW5lKSk7XG4gIH0pO1xuICAvLyBGSVhNRTogcGFyc2UgcnRjcC5cbiAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufTtcblxuLy8gR2VuZXJhdGVzIHBhcnRzIG9mIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBkZXNjcmliaW5nIHRoZSBjYXBhYmlsaXRpZXMgL1xuLy8gcGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24gPSBmdW5jdGlvbihraW5kLCBjYXBzKSB7XG4gIHZhciBzZHAgPSAnJztcblxuICAvLyBCdWlsZCB0aGUgbWxpbmUuXG4gIHNkcCArPSAnbT0nICsga2luZCArICcgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLmxlbmd0aCA+IDAgPyAnOScgOiAnMCc7IC8vIHJlamVjdCBpZiBubyBjb2RlY3MuXG4gIHNkcCArPSAnIFVEUC9UTFMvUlRQL1NBVlBGICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5tYXAoZnVuY3Rpb24oY29kZWMpIHtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gY29kZWMucGF5bG9hZFR5cGU7XG4gIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuXG4gIHNkcCArPSAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbic7XG4gIHNkcCArPSAnYT1ydGNwOjkgSU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuXG4gIC8vIEFkZCBhPXJ0cG1hcCBsaW5lcyBmb3IgZWFjaCBjb2RlYy4gQWxzbyBmbXRwIGFuZCBydGNwLWZiLlxuICBjYXBzLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdGNwRmIoY29kZWMpO1xuICB9KTtcbiAgdmFyIG1heHB0aW1lID0gMDtcbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgIGlmIChjb2RlYy5tYXhwdGltZSA+IG1heHB0aW1lKSB7XG4gICAgICBtYXhwdGltZSA9IGNvZGVjLm1heHB0aW1lO1xuICAgIH1cbiAgfSk7XG4gIGlmIChtYXhwdGltZSA+IDApIHtcbiAgICBzZHAgKz0gJ2E9bWF4cHRpbWU6JyArIG1heHB0aW1lICsgJ1xcclxcbic7XG4gIH1cbiAgc2RwICs9ICdhPXJ0Y3AtbXV4XFxyXFxuJztcblxuICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVFeHRtYXAoZXh0ZW5zaW9uKTtcbiAgfSk7XG4gIC8vIEZJWE1FOiB3cml0ZSBmZWNNZWNoYW5pc21zLlxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZlxuLy8gUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBFbmNvZGluZ1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGVuY29kaW5nUGFyYW1ldGVycyA9IFtdO1xuICB2YXIgZGVzY3JpcHRpb24gPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgdmFyIGhhc1JlZCA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignUkVEJykgIT09IC0xO1xuICB2YXIgaGFzVWxwZmVjID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdVTFBGRUMnKSAhPT0gLTE7XG5cbiAgLy8gZmlsdGVyIGE9c3NyYzouLi4gY25hbWU6LCBpZ25vcmUgUGxhbkItbXNpZFxuICB2YXIgc3NyY3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICB9KVxuICAuZmlsdGVyKGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgcmV0dXJuIHBhcnRzLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJztcbiAgfSk7XG4gIHZhciBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcbiAgdmFyIHNlY29uZGFyeVNzcmM7XG5cbiAgdmFyIGZsb3dzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjLWdyb3VwOkZJRCcpXG4gIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICBwYXJ0cy5zaGlmdCgpO1xuICAgIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHBhcnQsIDEwKTtcbiAgICB9KTtcbiAgfSk7XG4gIGlmIChmbG93cy5sZW5ndGggPiAwICYmIGZsb3dzWzBdLmxlbmd0aCA+IDEgJiYgZmxvd3NbMF1bMF0gPT09IHByaW1hcnlTc3JjKSB7XG4gICAgc2Vjb25kYXJ5U3NyYyA9IGZsb3dzWzBdWzFdO1xuICB9XG5cbiAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goZnVuY3Rpb24oY29kZWMpIHtcbiAgICBpZiAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpID09PSAnUlRYJyAmJiBjb2RlYy5wYXJhbWV0ZXJzLmFwdCkge1xuICAgICAgdmFyIGVuY1BhcmFtID0ge1xuICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgY29kZWNQYXlsb2FkVHlwZTogcGFyc2VJbnQoY29kZWMucGFyYW1ldGVycy5hcHQsIDEwKSxcbiAgICAgICAgcnR4OiB7XG4gICAgICAgICAgc3NyYzogc2Vjb25kYXJ5U3NyY1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgaWYgKGhhc1JlZCkge1xuICAgICAgICBlbmNQYXJhbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW0pKTtcbiAgICAgICAgZW5jUGFyYW0uZmVjID0ge1xuICAgICAgICAgIHNzcmM6IHNlY29uZGFyeVNzcmMsXG4gICAgICAgICAgbWVjaGFuaXNtOiBoYXNVbHBmZWMgPyAncmVkK3VscGZlYycgOiAncmVkJ1xuICAgICAgICB9O1xuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKGVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGggPT09IDAgJiYgcHJpbWFyeVNzcmMpIHtcbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaCh7XG4gICAgICBzc3JjOiBwcmltYXJ5U3NyY1xuICAgIH0pO1xuICB9XG5cbiAgLy8gd2Ugc3VwcG9ydCBib3RoIGI9QVMgYW5kIGI9VElBUyBidXQgaW50ZXJwcmV0IEFTIGFzIFRJQVMuXG4gIHZhciBiYW5kd2lkdGggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdiPScpO1xuICBpZiAoYmFuZHdpZHRoLmxlbmd0aCkge1xuICAgIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1USUFTOicpID09PSAwKSB7XG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyKDcpLCAxMCk7XG4gICAgfSBlbHNlIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1BUzonKSA9PT0gMCkge1xuICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cig1KSwgMTApO1xuICAgIH1cbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy5tYXhCaXRyYXRlID0gYmFuZHdpZHRoO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmNvZGluZ1BhcmFtZXRlcnM7XG59O1xuXG4vLyBwYXJzZXMgaHR0cDovL2RyYWZ0Lm9ydGMub3JnLyNydGNydGNwcGFyYW1ldGVycypcblNEUFV0aWxzLnBhcnNlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIHJ0Y3BQYXJhbWV0ZXJzID0ge307XG5cbiAgdmFyIGNuYW1lO1xuICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYXQgd2l0aCBSVFggdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGVcbiAgLy8gU1NSQ3MuXG4gIHZhciByZW1vdGVTc3JjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnO1xuICAgICAgfSlbMF07XG4gIGlmIChyZW1vdGVTc3JjKSB7XG4gICAgcnRjcFBhcmFtZXRlcnMuY25hbWUgPSByZW1vdGVTc3JjLnZhbHVlO1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgPSByZW1vdGVTc3JjLnNzcmM7XG4gIH1cblxuICAvLyBFZGdlIHVzZXMgdGhlIGNvbXBvdW5kIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIHJlZHVjZWRTaXplXG4gIC8vIGNvbXBvdW5kIGlzICFyZWR1Y2VkU2l6ZVxuICB2YXIgcnNpemUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtcnNpemUnKTtcbiAgcnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUgPSByc2l6ZS5sZW5ndGggPiAwO1xuICBydGNwUGFyYW1ldGVycy5jb21wb3VuZCA9IHJzaXplLmxlbmd0aCA9PT0gMDtcblxuICAvLyBwYXJzZXMgdGhlIHJ0Y3AtbXV4IGF0dHLRlmJ1dGUuXG4gIC8vIE5vdGUgdGhhdCBFZGdlIGRvZXMgbm90IHN1cHBvcnQgdW5tdXhlZCBSVENQLlxuICB2YXIgbXV4ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLW11eCcpO1xuICBydGNwUGFyYW1ldGVycy5tdXggPSBtdXgubGVuZ3RoID4gMDtcblxuICByZXR1cm4gcnRjcFBhcmFtZXRlcnM7XG59O1xuXG4vLyBwYXJzZXMgZWl0aGVyIGE9bXNpZDogb3IgYT1zc3JjOi4uLiBtc2lkIGxpbmVzIGFuZCByZXR1cm5zXG4vLyB0aGUgaWQgb2YgdGhlIE1lZGlhU3RyZWFtIGFuZCBNZWRpYVN0cmVhbVRyYWNrLlxuU0RQVXRpbHMucGFyc2VNc2lkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBwYXJ0cztcbiAgdmFyIHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XG4gIGlmIChzcGVjLmxlbmd0aCA9PT0gMSkge1xuICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHIoNykuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbiAgdmFyIHBsYW5CID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKTtcbiAgfSlcbiAgLmZpbHRlcihmdW5jdGlvbihwYXJ0cykge1xuICAgIHJldHVybiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdtc2lkJztcbiAgfSk7XG4gIGlmIChwbGFuQi5sZW5ndGggPiAwKSB7XG4gICAgcGFydHMgPSBwbGFuQlswXS52YWx1ZS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxufTtcblxuU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXG4gIHJldHVybiAndj0wXFxyXFxuJyArXG4gICAgICAnbz10aGlzaXNhZGFwdGVyb3J0YyA4MTY5NjM5OTE1NjQ2OTQzMTM3IDIgSU4gSVA0IDEyNy4wLjAuMVxcclxcbicgK1xuICAgICAgJ3M9LVxcclxcbicgK1xuICAgICAgJ3Q9MCAwXFxyXFxuJztcbn07XG5cblNEUFV0aWxzLndyaXRlTWVkaWFTZWN0aW9uID0gZnVuY3Rpb24odHJhbnNjZWl2ZXIsIGNhcHMsIHR5cGUsIHN0cmVhbSkge1xuICB2YXIgc2RwID0gU0RQVXRpbHMud3JpdGVSdHBEZXNjcmlwdGlvbih0cmFuc2NlaXZlci5raW5kLCBjYXBzKTtcblxuICAvLyBNYXAgSUNFIHBhcmFtZXRlcnMgKHVmcmFnLCBwd2QpIHRvIFNEUC5cbiAgc2RwICs9IFNEUFV0aWxzLndyaXRlSWNlUGFyYW1ldGVycyhcbiAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLmdldExvY2FsUGFyYW1ldGVycygpKTtcblxuICAvLyBNYXAgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cbiAgc2RwICs9IFNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMoXG4gICAgICB0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0LmdldExvY2FsUGFyYW1ldGVycygpLFxuICAgICAgdHlwZSA9PT0gJ29mZmVyJyA/ICdhY3RwYXNzJyA6ICdhY3RpdmUnKTtcblxuICBzZHAgKz0gJ2E9bWlkOicgKyB0cmFuc2NlaXZlci5taWQgKyAnXFxyXFxuJztcblxuICBpZiAodHJhbnNjZWl2ZXIuZGlyZWN0aW9uKSB7XG4gICAgc2RwICs9ICdhPScgKyB0cmFuc2NlaXZlci5kaXJlY3Rpb24gKyAnXFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIgJiYgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIpIHtcbiAgICBzZHAgKz0gJ2E9c2VuZHJlY3ZcXHJcXG4nO1xuICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlcikge1xuICAgIHNkcCArPSAnYT1zZW5kb25seVxcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIpIHtcbiAgICBzZHAgKz0gJ2E9cmVjdm9ubHlcXHJcXG4nO1xuICB9IGVsc2Uge1xuICAgIHNkcCArPSAnYT1pbmFjdGl2ZVxcclxcbic7XG4gIH1cblxuICBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgLy8gc3BlYy5cbiAgICB2YXIgbXNpZCA9ICdtc2lkOicgKyBzdHJlYW0uaWQgKyAnICcgK1xuICAgICAgICB0cmFuc2NlaXZlci5ydHBTZW5kZXIudHJhY2suaWQgKyAnXFxyXFxuJztcbiAgICBzZHAgKz0gJ2E9JyArIG1zaWQ7XG5cbiAgICAvLyBmb3IgQ2hyb21lLlxuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgK1xuICAgICAgICAnICcgKyBtc2lkO1xuICAgIGlmICh0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgICAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAgICcgJyArIG1zaWQ7XG4gICAgICBzZHAgKz0gJ2E9c3NyYy1ncm91cDpGSUQgJyArXG4gICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICsgJyAnICtcbiAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9XG4gIH1cbiAgLy8gRklYTUU6IHRoaXMgc2hvdWxkIGJlIHdyaXR0ZW4gYnkgd3JpdGVSdHBEZXNjcmlwdGlvbi5cbiAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArXG4gICAgICAnIGNuYW1lOicgKyBTRFBVdGlscy5sb2NhbENOYW1lICsgJ1xcclxcbic7XG4gIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIgJiYgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHgpIHtcbiAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICcgY25hbWU6JyArIFNEUFV0aWxzLmxvY2FsQ05hbWUgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gR2V0cyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIG1lZGlhU2VjdGlvbiBvciB0aGUgc2Vzc2lvbnBhcnQuXG5TRFBVdGlscy5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIC8vIExvb2sgZm9yIHNlbmRyZWN2LCBzZW5kb25seSwgcmVjdm9ubHksIGluYWN0aXZlLCBkZWZhdWx0IHRvIHNlbmRyZWN2LlxuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2ggKGxpbmVzW2ldKSB7XG4gICAgICBjYXNlICdhPXNlbmRyZWN2JzpcbiAgICAgIGNhc2UgJ2E9c2VuZG9ubHknOlxuICAgICAgY2FzZSAnYT1yZWN2b25seSc6XG4gICAgICBjYXNlICdhPWluYWN0aXZlJzpcbiAgICAgICAgcmV0dXJuIGxpbmVzW2ldLnN1YnN0cigyKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZJWE1FOiBXaGF0IHNob3VsZCBoYXBwZW4gaGVyZT9cbiAgICB9XG4gIH1cbiAgaWYgKHNlc3Npb25wYXJ0KSB7XG4gICAgcmV0dXJuIFNEUFV0aWxzLmdldERpcmVjdGlvbihzZXNzaW9ucGFydCk7XG4gIH1cbiAgcmV0dXJuICdzZW5kcmVjdic7XG59O1xuXG5TRFBVdGlscy5nZXRLaW5kID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgdmFyIG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgcmV0dXJuIG1saW5lWzBdLnN1YnN0cigyKTtcbn07XG5cblNEUFV0aWxzLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgcmV0dXJuIG1lZGlhU2VjdGlvbi5zcGxpdCgnICcsIDIpWzFdID09PSAnMCc7XG59O1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IFNEUFV0aWxzO1xuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IFNhbXVlbCBvbiA2LzQvMjAxNi5cbiAqIFNpbXBsZSB3cmFwcGVyIGZ1bmN0aW9ucyB0byBwcm9kdWNlIHNob3J0ZXIgVVVJRHMgZm9yIGNvb2tpZXMsIG1heWJlIGV2ZXJ5dGhpbmc/XG4gKi9cblxuY29uc3QgeyB2NDogdXVpZHY0IH0gPSByZXF1aXJlKCd1dWlkJyk7XG5jb25zdCBhbnlCYXNlID0gcmVxdWlyZSgnYW55LWJhc2UnKTtcblxuY29uc3QgZmxpY2tyQmFzZTU4ID0gJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonO1xuY29uc3QgY29va2llQmFzZTkwID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiEjJCUmJygpKistLi86PD0+P0BbXV5fYHt8fX5cIjtcblxuY29uc3QgYmFzZU9wdGlvbnMgPSB7XG4gIGNvbnNpc3RlbnRMZW5ndGg6IHRydWUsXG59O1xuXG4vLyBBIGRlZmF1bHQgZ2VuZXJhdG9yLCBpbnN0YW50aWF0ZWQgb25seSBpZiB1c2VkLlxubGV0IHRvRmxpY2tyO1xuXG4vKipcbiAqIFRha2VzIGEgVVVJRCwgc3RyaXBzIHRoZSBkYXNoZXMsIGFuZCB0cmFuc2xhdGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IGxvbmdJZFxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpfSB0cmFuc2xhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhZGRpbmdQYXJhbXNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBzaG9ydGVuVVVJRCA9IChsb25nSWQsIHRyYW5zbGF0b3IsIHBhZGRpbmdQYXJhbXMpID0+IHtcbiAgY29uc3QgdHJhbnNsYXRlZCA9IHRyYW5zbGF0b3IobG9uZ0lkLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnJykpO1xuXG4gIGlmICghcGFkZGluZ1BhcmFtcyB8fCAhcGFkZGluZ1BhcmFtcy5jb25zaXN0ZW50TGVuZ3RoKSByZXR1cm4gdHJhbnNsYXRlZDtcblxuICByZXR1cm4gdHJhbnNsYXRlZC5wYWRTdGFydChcbiAgICBwYWRkaW5nUGFyYW1zLnNob3J0SWRMZW5ndGgsXG4gICAgcGFkZGluZ1BhcmFtcy5wYWRkaW5nQ2hhcixcbiAgKTtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlIGJhY2sgdG8gaGV4IGFuZCB0dXJuIGJhY2sgaW50byBVVUlEIGZvcm1hdCwgd2l0aCBkYXNoZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydElkXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyl9IHRyYW5zbGF0b3JcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGVubGFyZ2VVVUlEID0gKHNob3J0SWQsIHRyYW5zbGF0b3IpID0+IHtcbiAgY29uc3QgdXUxID0gdHJhbnNsYXRvcihzaG9ydElkKS5wYWRTdGFydCgzMiwgJzAnKTtcblxuICAvLyBKb2luIHRoZSB6ZXJvIHBhZGRpbmcgYW5kIHRoZSBVVUlEIGFuZCB0aGVuIHNsaWNlIGl0IHVwIHdpdGggbWF0Y2hcbiAgY29uc3QgbSA9IHV1MS5tYXRjaCgvKFxcd3s4fSkoXFx3ezR9KShcXHd7NH0pKFxcd3s0fSkoXFx3ezEyfSkvKTtcblxuICAvLyBBY2N1bXVsYXRlIHRoZSBtYXRjaGVzIGFuZCBqb2luIHRoZW0uXG4gIHJldHVybiBbbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XV0uam9pbignLScpO1xufTtcblxuLy8gQ2FsY3VsYXRlIGxlbmd0aCBmb3IgdGhlIHNob3J0ZW5lZCBJRFxuY29uc3QgZ2V0U2hvcnRJZExlbmd0aCA9IChhbHBoYWJldExlbmd0aCkgPT4gKFxuICBNYXRoLmNlaWwoTWF0aC5sb2coMiAqKiAxMjgpIC8gTWF0aC5sb2coYWxwaGFiZXRMZW5ndGgpKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gKCgpID0+IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b0FscGhhYmV0IC0gRGVmYXVsdHMgdG8gZmxpY2tyQmFzZTU4IGlmIG5vdCBwcm92aWRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqXG4gICAqIEByZXR1cm5zIHt7bmV3OiAoZnVuY3Rpb24oKSksXG4gICAqICB1dWlkOiAoZnVuY3Rpb24oKSksXG4gICAqICBmcm9tVVVJRDogKGZ1bmN0aW9uKHN0cmluZykpLFxuICAgKiAgdG9VVUlEOiAoZnVuY3Rpb24oc3RyaW5nKSksXG4gICAqICBhbHBoYWJldDogKHN0cmluZyl9fVxuICAgKi9cbiAgY29uc3QgbWFrZUNvbnZlcnRvciA9ICh0b0FscGhhYmV0LCBvcHRpb25zKSA9PiB7XG4gICAgLy8gRGVmYXVsdCB0byBGbGlja3IgNThcbiAgICBjb25zdCB1c2VBbHBoYWJldCA9IHRvQWxwaGFiZXQgfHwgZmxpY2tyQmFzZTU4O1xuXG4gICAgLy8gRGVmYXVsdCB0byBiYXNlT3B0aW9uc1xuICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IHsgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcblxuICAgIC8vIENoZWNrIGFscGhhYmV0IGZvciBkdXBsaWNhdGUgZW50cmllc1xuICAgIGlmIChbLi4ubmV3IFNldChBcnJheS5mcm9tKHVzZUFscGhhYmV0KSldLmxlbmd0aCAhPT0gdXNlQWxwaGFiZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBBbHBoYWJldCBoYXMgZHVwbGljYXRlIGNoYXJhY3RlcnMgcmVzdWx0aW5nIGluIHVucmVsaWFibGUgcmVzdWx0cycpO1xuICAgIH1cblxuICAgIGNvbnN0IHNob3J0SWRMZW5ndGggPSBnZXRTaG9ydElkTGVuZ3RoKHVzZUFscGhhYmV0Lmxlbmd0aCk7XG5cbiAgICAvLyBQYWRkaW5nIFBhcmFtc1xuICAgIGNvbnN0IHBhZGRpbmdQYXJhbXMgPSB7XG4gICAgICBzaG9ydElkTGVuZ3RoLFxuICAgICAgY29uc2lzdGVudExlbmd0aDogc2VsZWN0ZWRPcHRpb25zLmNvbnNpc3RlbnRMZW5ndGgsXG4gICAgICBwYWRkaW5nQ2hhcjogdXNlQWxwaGFiZXRbMF0sXG4gICAgfTtcblxuICAgIC8vIFVVSURzIGFyZSBpbiBoZXgsIHNvIHdlIHRyYW5zbGF0ZSB0byBhbmQgZnJvbS5cbiAgICBjb25zdCBmcm9tSGV4ID0gYW55QmFzZShhbnlCYXNlLkhFWCwgdXNlQWxwaGFiZXQpO1xuICAgIGNvbnN0IHRvSGV4ID0gYW55QmFzZSh1c2VBbHBoYWJldCwgYW55QmFzZS5IRVgpO1xuICAgIGNvbnN0IGdlbmVyYXRlID0gKCkgPT4gc2hvcnRlblVVSUQodXVpZHY0KCksIGZyb21IZXgsIHBhZGRpbmdQYXJhbXMpO1xuXG4gICAgY29uc3QgdHJhbnNsYXRvciA9IHtcbiAgICAgIG5ldzogZ2VuZXJhdGUsXG4gICAgICBnZW5lcmF0ZSxcbiAgICAgIHV1aWQ6IHV1aWR2NCxcbiAgICAgIGZyb21VVUlEOiAodXVpZCkgPT4gc2hvcnRlblVVSUQodXVpZCwgZnJvbUhleCwgcGFkZGluZ1BhcmFtcyksXG4gICAgICB0b1VVSUQ6IChzaG9ydFV1aWQpID0+IGVubGFyZ2VVVUlEKHNob3J0VXVpZCwgdG9IZXgpLFxuICAgICAgYWxwaGFiZXQ6IHVzZUFscGhhYmV0LFxuICAgICAgbWF4TGVuZ3RoOiBzaG9ydElkTGVuZ3RoLFxuICAgIH07XG5cbiAgICBPYmplY3QuZnJlZXplKHRyYW5zbGF0b3IpO1xuXG4gICAgcmV0dXJuIHRyYW5zbGF0b3I7XG4gIH07XG5cbiAgLy8gRXhwb3NlIHRoZSBjb25zdGFudHMgZm9yIG90aGVyIHB1cnBvc2VzLlxuICBtYWtlQ29udmVydG9yLmNvbnN0YW50cyA9IHtcbiAgICBmbGlja3JCYXNlNTgsXG4gICAgY29va2llQmFzZTkwLFxuICB9O1xuXG4gIC8vIEV4cG9zZSB0aGUgZ2VuZXJpYyB2NCBVVUlEIGdlbmVyYXRvciBmb3IgY29udmVuaWVuY2VcbiAgbWFrZUNvbnZlcnRvci51dWlkID0gdXVpZHY0O1xuXG4gIC8vIFByb3ZpZGUgYSBnZW5lcmljIGdlbmVyYXRvclxuICBtYWtlQ29udmVydG9yLmdlbmVyYXRlID0gKCkgPT4ge1xuICAgIGlmICghdG9GbGlja3IpIHtcbiAgICAgIC8vIEdlbmVyYXRlIG9uIGZpcnN0IHVzZTtcbiAgICAgIHRvRmxpY2tyID0gbWFrZUNvbnZlcnRvcihmbGlja3JCYXNlNTgpLmdlbmVyYXRlO1xuICAgIH1cbiAgICByZXR1cm4gdG9GbGlja3IoKTtcbiAgfTtcblxuICByZXR1cm4gbWFrZUNvbnZlcnRvcjtcbn0pKCk7XG4iLCJ2YXIgZXNzID0gcmVxdWlyZSgnZXZlbnQtc291cmNlLXN0cmVhbScpXG52YXIgbmV0cyA9IHJlcXVpcmUoJ25ldHMnKVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgYXBwKSB7XG4gIGlmICghdXJsKSB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25hbGh1YiB1cmwgcmVxdWlyZWQnKVxuICBpZiAoIWFwcCkgdGhyb3cgbmV3IEVycm9yKCdhcHAgbmFtZSByZXF1aXJlZCBhcyAybmQgYXJndW1lbnQnKVxuICB2YXIgdGhhdCA9IHt9XG5cbiAgaWYgKHVybC5pbmRleE9mKCc6Ly8nKSA9PT0gLTEpIHVybCA9ICdodHRwOi8vJyArIHVybFxuXG4gIHRoYXQuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICByZXR1cm4gZXNzKHVybCArICcvdjEvJyArIGFwcCArICcvJyArIGNoYW5uZWwsIHtqc29uOiB0cnVlfSlcbiAgfVxuXG4gIHRoYXQuYnJvYWRjYXN0ID0gZnVuY3Rpb24gKGNoYW5uZWwsIG1lc3NhZ2UsIGNiKSB7XG4gICAgaWYgKCFjYikgY2IgPSBub29wXG4gICAgbmV0cyh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGpzb246IG1lc3NhZ2UsXG4gICAgICB1cmw6IHVybCArICcvdjEvJyArIGFwcCArICcvJyArIGNoYW5uZWxcbiAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgIT09IDIwMCkgcmV0dXJuIGNiKG5ldyBFcnJvcignQmFkIHN0YXR1czogJyArIHJlcy5zdGF0dXNDb2RlKSlcbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cbiIsInZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHZhciBlcyA9IG5ldyBFdmVudFNvdXJjZSh1cmwpXG4gIHZhciBycyA9IG5ldyBzdHJlYW0uUmVhZGFibGUoe29iamVjdE1vZGU6dHJ1ZX0pXG5cbiAgdmFyIGpzb24gPSAhIW9wdHMuanNvblxuICB2YXIgZGVjb2RlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGpzb24pIHJldHVybiBKU09OLnBhcnNlKGRhdGEpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIHJzLl9yZWFkID0gZnVuY3Rpb24oKSB7fVxuXG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBycy5wdXNoKGRlY29kZShlLmRhdGEpKVxuICB9XG5cbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChycy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSBycy5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZVxuICBycy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVzLmNsb3NlKClcbiAgICBwYXJzZS5lbWl0KCdjbG9zZScpXG4gIH1cblxuICByZXR1cm4gcnNcbn0iLCJ2YXIgcmVxID0gcmVxdWlyZSgncmVxdWVzdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gTmV0c1xuXG5mdW5jdGlvbiBOZXRzIChvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSBvcHRzID0geyB1cmk6IG9wdHMgfVxuXG4gIC8vIGluIG5vZGUsIGlmIGVuY29kaW5nID09PSBudWxsIHRoZW4gcmVzcG9uc2Ugd2lsbCBiZSBhIEJ1ZmZlci4gd2Ugd2FudCB0aGlzIHRvIGJlIHRoZSBkZWZhdWx0XG4gIGlmICghb3B0cy5oYXNPd25Qcm9wZXJ0eSgnZW5jb2RpbmcnKSkgb3B0cy5lbmNvZGluZyA9IG51bGxcblxuICAvLyBpbiBicm93c2VyLCB3ZSBzaG91bGQgYnkgZGVmYXVsdCBjb252ZXJ0IHRoZSBhcnJheWJ1ZmZlciBpbnRvIGEgQnVmZmVyXG4gIGlmIChwcm9jZXNzLmJyb3dzZXIgJiYgIW9wdHMuaGFzT3duUHJvcGVydHkoJ2pzb24nKSAmJiBvcHRzLmVuY29kaW5nID09PSBudWxsKSB7XG4gICAgb3B0cy5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgdmFyIG9yaWdpbmFsQ2IgPSBjYlxuICAgIGNiID0gYnVmZmVyaWZ5XG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJpZnkgKGVyciwgcmVzcCwgYm9keSkge1xuICAgIGlmIChib2R5KSBib2R5ID0gbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShib2R5KSlcbiAgICBvcmlnaW5hbENiKGVyciwgcmVzcCwgYm9keSlcbiAgfVxuXG4gIHJldHVybiByZXEob3B0cywgY2IpXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIG9uY2UgPSByZXF1aXJlKFwib25jZVwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoXCJwYXJzZS1oZWFkZXJzXCIpXG5cblxudmFyIFhIUiA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG52YXIgWERSID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAobmV3IFhIUigpKSA/IFhIUiA6IHdpbmRvdy5YRG9tYWluUmVxdWVzdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVhIUlxuXG5mdW5jdGlvbiBjcmVhdGVYSFIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGxvYWRGdW5jKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIC8vIENocm9tZSB3aXRoIHJlcXVlc3RUeXBlPWJsb2IgdGhyb3dzIGVycm9ycyBhcnJvdW5kIHdoZW4gZXZlbiB0ZXN0aW5nIGFjY2VzcyB0byByZXNwb25zZVRleHRcbiAgICAgICAgdmFyIGJvZHkgPSB1bmRlZmluZWRcblxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlXG4gICAgICAgIH0gZWxzZSBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJ0ZXh0XCIgfHwgIXhoci5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IHhoci5yZXNwb25zZVhNTFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuICAgIFxuICAgIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZXJyb3JGdW5jKGV2dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZighKGV2dCBpbnN0YW5jZW9mIEVycm9yKSl7XG4gICAgICAgICAgICBldnQgPSBuZXcgRXJyb3IoXCJcIiArIChldnQgfHwgXCJ1bmtub3duXCIpIClcbiAgICAgICAgfVxuICAgICAgICBldnQuc3RhdHVzQ29kZSA9IDBcbiAgICAgICAgY2FsbGJhY2soZXZ0LCBmYWlsdXJlUmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRGdW5jKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBcbiAgICAgICAgdmFyIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cylcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gZmFpbHVyZVJlc3BvbnNlXG4gICAgICAgIHZhciBlcnIgPSBudWxsXG4gICAgICAgIFxuICAgICAgICBpZiAoc3RhdHVzICE9PSAwKXtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGdldEJvZHkoKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKXsgLy9yZW1lbWJlciB4aHIgY2FuIGluIGZhY3QgYmUgWERSIGZvciBDT1JTIGluIElFXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gICAgICAgIFxuICAgIH1cbiAgICBcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgdXJpOiBvcHRpb25zIH1cbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIilcbiAgICB9XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGxcblxuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcnMgfHwgb3B0aW9ucy51c2VYRFIpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBYRFIoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHhociA9IG5ldyBYSFIoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleVxuICAgIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmxcbiAgICB2YXIgbWV0aG9kID0geGhyLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGFcbiAgICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgdmFyIHN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICAgIHZhciBpc0pzb24gPSBmYWxzZVxuICAgIHZhciB0aW1lb3V0VGltZXJcblxuICAgIGlmIChcImpzb25cIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlzSnNvbiA9IHRydWVcbiAgICAgICAgaGVhZGVyc1tcIkFjY2VwdFwiXSB8fCAoaGVhZGVyc1tcIkFjY2VwdFwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRGdW5jXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvckZ1bmNcbiAgICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxuICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJRSBtdXN0IGRpZVxuICAgIH1cbiAgICB4aHIub250aW1lb3V0ID0gZXJyb3JGdW5jXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jKVxuICAgIC8vaGFzIHRvIGJlIGFmdGVyIG9wZW5cbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFsc1xuICAgIFxuICAgIC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAgIC8vIG5vdCBzZXR0aW5nIHRpbWVvdXQgb24gdGhlIHhociBvYmplY3QsIGJlY2F1c2Ugb2Ygb2xkIHdlYmtpdHMgZXRjLiBub3QgaGFuZGxpbmcgdGhhdCBjb3JyZWN0bHlcbiAgICAvLyBib3RoIG5wbSdzIHJlcXVlc3QgYW5kIGpxdWVyeSAxLnggdXNlIHRoaXMga2luZCBvZiB0aW1lb3V0LCBzbyB0aGlzIGlzIGJlaW5nIGNvbnNpc3RlbnRcbiAgICBpZiAoIXN5bmMgJiYgb3B0aW9ucy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgeGhyLmFib3J0KFwidGltZW91dFwiKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KzIgKTtcbiAgICB9XG5cbiAgICBpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgZm9yKGtleSBpbiBoZWFkZXJzKXtcbiAgICAgICAgICAgIGlmKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0XCIpXG4gICAgfVxuXG4gICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4gb3B0aW9ucykge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGVcbiAgICB9XG4gICAgXG4gICAgaWYgKFwiYmVmb3JlU2VuZFwiIGluIG9wdGlvbnMgJiYgXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJlZm9yZVNlbmQgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKVxuICAgIH1cblxuICAgIHhoci5zZW5kKGJvZHkpXG5cbiAgICByZXR1cm4geGhyXG5cblxufVxuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBvbmNlXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVyblxuICAgIGNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG59XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcbiIsIlxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHJpbTtcblxuZnVuY3Rpb24gdHJpbShzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cblxuZXhwb3J0cy5sZWZ0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbn07XG5cbmV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccyokLywgJycpO1xufTtcbiIsInZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICAgICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICAgICAgfVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufSIsIi8qISBzaW1wbGUtcGVlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzaW1wbGUtcGVlcicpXG5jb25zdCBnZXRCcm93c2VyUlRDID0gcmVxdWlyZSgnZ2V0LWJyb3dzZXItcnRjJylcbmNvbnN0IHJhbmRvbWJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKVxuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbmNvbnN0IHF1ZXVlTWljcm90YXNrID0gcmVxdWlyZSgncXVldWUtbWljcm90YXNrJykgLy8gVE9ETzogcmVtb3ZlIHdoZW4gTm9kZSAxMCBpcyBub3Qgc3VwcG9ydGVkXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbmNvbnN0IE1BWF9CVUZGRVJFRF9BTU9VTlQgPSA2NCAqIDEwMjRcbmNvbnN0IElDRUNPTVBMRVRFX1RJTUVPVVQgPSA1ICogMTAwMFxuY29uc3QgQ0hBTk5FTF9DTE9TSU5HX1RJTUVPVVQgPSA1ICogMTAwMFxuXG4vLyBIQUNLOiBGaWx0ZXIgdHJpY2tsZSBsaW5lcyB3aGVuIHRyaWNrbGUgaXMgZGlzYWJsZWQgIzM1NFxuZnVuY3Rpb24gZmlsdGVyVHJpY2tsZSAoc2RwKSB7XG4gIHJldHVybiBzZHAucmVwbGFjZSgvYT1pY2Utb3B0aW9uczp0cmlja2xlXFxzXFxuL2csICcnKVxufVxuXG5mdW5jdGlvbiB3YXJuIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKVxufVxuXG4vKipcbiAqIFdlYlJUQyBwZWVyIGNvbm5lY3Rpb24uIFNhbWUgQVBJIGFzIG5vZGUgY29yZSBgbmV0LlNvY2tldGAsIHBsdXMgYSBmZXcgZXh0cmEgbWV0aG9kcy5cbiAqIER1cGxleCBzdHJlYW0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5jbGFzcyBQZWVyIGV4dGVuZHMgc3RyZWFtLkR1cGxleCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYWxsb3dIYWxmT3BlbjogZmFsc2VcbiAgICB9LCBvcHRzKVxuXG4gICAgc3VwZXIob3B0cylcblxuICAgIHRoaXMuX2lkID0gcmFuZG9tYnl0ZXMoNCkudG9TdHJpbmcoJ2hleCcpLnNsaWNlKDAsIDcpXG4gICAgdGhpcy5fZGVidWcoJ25ldyBwZWVyICVvJywgb3B0cylcblxuICAgIHRoaXMuY2hhbm5lbE5hbWUgPSBvcHRzLmluaXRpYXRvclxuICAgICAgPyBvcHRzLmNoYW5uZWxOYW1lIHx8IHJhbmRvbWJ5dGVzKDIwKS50b1N0cmluZygnaGV4JylcbiAgICAgIDogbnVsbFxuXG4gICAgdGhpcy5pbml0aWF0b3IgPSBvcHRzLmluaXRpYXRvciB8fCBmYWxzZVxuICAgIHRoaXMuY2hhbm5lbENvbmZpZyA9IG9wdHMuY2hhbm5lbENvbmZpZyB8fCBQZWVyLmNoYW5uZWxDb25maWdcbiAgICB0aGlzLmNoYW5uZWxOZWdvdGlhdGVkID0gdGhpcy5jaGFubmVsQ29uZmlnLm5lZ290aWF0ZWRcbiAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIFBlZXIuY29uZmlnLCBvcHRzLmNvbmZpZylcbiAgICB0aGlzLm9mZmVyT3B0aW9ucyA9IG9wdHMub2ZmZXJPcHRpb25zIHx8IHt9XG4gICAgdGhpcy5hbnN3ZXJPcHRpb25zID0gb3B0cy5hbnN3ZXJPcHRpb25zIHx8IHt9XG4gICAgdGhpcy5zZHBUcmFuc2Zvcm0gPSBvcHRzLnNkcFRyYW5zZm9ybSB8fCAoc2RwID0+IHNkcClcbiAgICB0aGlzLnN0cmVhbXMgPSBvcHRzLnN0cmVhbXMgfHwgKG9wdHMuc3RyZWFtID8gW29wdHMuc3RyZWFtXSA6IFtdKSAvLyBzdXBwb3J0IG9sZCBcInN0cmVhbVwiIG9wdGlvblxuICAgIHRoaXMudHJpY2tsZSA9IG9wdHMudHJpY2tsZSAhPT0gdW5kZWZpbmVkID8gb3B0cy50cmlja2xlIDogdHJ1ZVxuICAgIHRoaXMuYWxsb3dIYWxmVHJpY2tsZSA9IG9wdHMuYWxsb3dIYWxmVHJpY2tsZSAhPT0gdW5kZWZpbmVkID8gb3B0cy5hbGxvd0hhbGZUcmlja2xlIDogZmFsc2VcbiAgICB0aGlzLmljZUNvbXBsZXRlVGltZW91dCA9IG9wdHMuaWNlQ29tcGxldGVUaW1lb3V0IHx8IElDRUNPTVBMRVRFX1RJTUVPVVRcblxuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgICB0aGlzLmRlc3Ryb3lpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSB1bmRlZmluZWRcbiAgICB0aGlzLnJlbW90ZUZhbWlseSA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVtb3RlUG9ydCA9IHVuZGVmaW5lZFxuICAgIHRoaXMubG9jYWxBZGRyZXNzID0gdW5kZWZpbmVkXG4gICAgdGhpcy5sb2NhbEZhbWlseSA9IHVuZGVmaW5lZFxuICAgIHRoaXMubG9jYWxQb3J0ID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLl93cnRjID0gKG9wdHMud3J0YyAmJiB0eXBlb2Ygb3B0cy53cnRjID09PSAnb2JqZWN0JylcbiAgICAgID8gb3B0cy53cnRjXG4gICAgICA6IGdldEJyb3dzZXJSVEMoKVxuXG4gICAgaWYgKCF0aGlzLl93cnRjKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBTcGVjaWZ5IGBvcHRzLndydGNgIG9wdGlvbiBpbiB0aGlzIGVudmlyb25tZW50JyksICdFUlJfV0VCUlRDX1NVUFBPUlQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBOb3QgYSBzdXBwb3J0ZWQgYnJvd3NlcicpLCAnRVJSX1dFQlJUQ19TVVBQT1JUJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wY1JlYWR5ID0gZmFsc2VcbiAgICB0aGlzLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuICAgIHRoaXMuX2ljZUNvbXBsZXRlID0gZmFsc2UgLy8gaWNlIGNhbmRpZGF0ZSB0cmlja2xlIGRvbmUgKGdvdCBudWxsIGNhbmRpZGF0ZSlcbiAgICB0aGlzLl9pY2VDb21wbGV0ZVRpbWVyID0gbnVsbCAvLyBzZW5kIGFuIG9mZmVyL2Fuc3dlciBhbnl3YXkgYWZ0ZXIgc29tZSB0aW1lb3V0XG4gICAgdGhpcy5fY2hhbm5lbCA9IG51bGxcbiAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdXG5cbiAgICB0aGlzLl9pc05lZ290aWF0aW5nID0gZmFsc2UgLy8gaXMgdGhpcyBwZWVyIHdhaXRpbmcgZm9yIG5lZ290aWF0aW9uIHRvIGNvbXBsZXRlP1xuICAgIHRoaXMuX2ZpcnN0TmVnb3RpYXRpb24gPSB0cnVlXG4gICAgdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uID0gZmFsc2UgLy8gYmF0Y2ggc3luY2hyb25vdXMgbmVnb3RpYXRpb25zXG4gICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSBmYWxzZSAvLyBpcyB0aGVyZSBhIHF1ZXVlZCBuZWdvdGlhdGlvbiByZXF1ZXN0P1xuICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZSA9IFtdXG4gICAgdGhpcy5fc2VuZGVyTWFwID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fY2xvc2luZ0ludGVydmFsID0gbnVsbFxuXG4gICAgdGhpcy5fcmVtb3RlVHJhY2tzID0gW11cbiAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW11cblxuICAgIHRoaXMuX2NodW5rID0gbnVsbFxuICAgIHRoaXMuX2NiID0gbnVsbFxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3BjID0gbmV3ICh0aGlzLl93cnRjLlJUQ1BlZXJDb25uZWN0aW9uKSh0aGlzLmNvbmZpZylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9QQ19DT05TVFJVQ1RPUicpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gV2UgcHJlZmVyIGZlYXR1cmUgZGV0ZWN0aW9uIHdoZW5ldmVyIHBvc3NpYmxlLCBidXQgc29tZXRpbWVzIHRoYXQncyBub3RcbiAgICAvLyBwb3NzaWJsZSBmb3IgY2VydGFpbiBpbXBsZW1lbnRhdGlvbnMuXG4gICAgdGhpcy5faXNSZWFjdE5hdGl2ZVdlYnJ0YyA9IHR5cGVvZiB0aGlzLl9wYy5fcGVlckNvbm5lY3Rpb25JZCA9PT0gJ251bWJlcidcblxuICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25JY2VTdGF0ZUNoYW5nZSgpXG4gICAgfVxuICAgIHRoaXMuX3BjLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkljZVN0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSgpXG4gICAgfVxuICAgIHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25pY2VjYW5kaWRhdGUgPSBldmVudCA9PiB7XG4gICAgICB0aGlzLl9vbkljZUNhbmRpZGF0ZShldmVudClcbiAgICB9XG5cbiAgICAvLyBIQUNLOiBGaXggZm9yIG9kZCBGaXJlZm94IGJlaGF2aW9yLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3Mvc2ltcGxlLXBlZXIvcHVsbC83ODNcbiAgICBpZiAodHlwZW9mIHRoaXMuX3BjLnBlZXJJZGVudGl0eSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX3BjLnBlZXJJZGVudGl0eS5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfUENfUEVFUl9JREVOVElUWScpKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBPdGhlciBzcGVjIGV2ZW50cywgdW51c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb246XG4gICAgLy8gLSBvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZVxuICAgIC8vIC0gb25pY2VjYW5kaWRhdGVlcnJvclxuICAgIC8vIC0gb25maW5nZXJwcmludGZhaWx1cmVcbiAgICAvLyAtIG9ubmVnb3RpYXRpb25uZWVkZWRcblxuICAgIGlmICh0aGlzLmluaXRpYXRvciB8fCB0aGlzLmNoYW5uZWxOZWdvdGlhdGVkKSB7XG4gICAgICB0aGlzLl9zZXR1cERhdGEoe1xuICAgICAgICBjaGFubmVsOiB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbCh0aGlzLmNoYW5uZWxOYW1lLCB0aGlzLmNoYW5uZWxDb25maWcpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXR1cERhdGEoZXZlbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RyZWFtcykge1xuICAgICAgdGhpcy5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgdGhpcy5hZGRTdHJlYW0oc3RyZWFtKVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5fcGMub250cmFjayA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuX29uVHJhY2soZXZlbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcoJ2luaXRpYWwgbmVnb3RpYXRpb24nKVxuICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuXG4gICAgdGhpcy5fb25GaW5pc2hCb3VuZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uRmluaXNoKClcbiAgICB9XG4gICAgdGhpcy5vbmNlKCdmaW5pc2gnLCB0aGlzLl9vbkZpbmlzaEJvdW5kKVxuICB9XG5cbiAgZ2V0IGJ1ZmZlclNpemUgKCkge1xuICAgIHJldHVybiAodGhpcy5fY2hhbm5lbCAmJiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KSB8fCAwXG4gIH1cblxuICAvLyBIQUNLOiBpdCdzIHBvc3NpYmxlIGNoYW5uZWwucmVhZHlTdGF0ZSBpcyBcImNsb3NpbmdcIiBiZWZvcmUgcGVlci5kZXN0cm95KCkgZmlyZXNcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODgyNzQzXG4gIGdldCBjb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiAodGhpcy5fY29ubmVjdGVkICYmIHRoaXMuX2NoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKVxuICB9XG5cbiAgYWRkcmVzcyAoKSB7XG4gICAgcmV0dXJuIHsgcG9ydDogdGhpcy5sb2NhbFBvcnQsIGZhbWlseTogdGhpcy5sb2NhbEZhbWlseSwgYWRkcmVzczogdGhpcy5sb2NhbEFkZHJlc3MgfVxuICB9XG5cbiAgc2lnbmFsIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHNpZ25hbCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkYXRhID0ge31cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGVidWcoJ3NpZ25hbCgpJylcblxuICAgIGlmIChkYXRhLnJlbmVnb3RpYXRlICYmIHRoaXMuaW5pdGlhdG9yKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnZ290IHJlcXVlc3QgdG8gcmVuZWdvdGlhdGUnKVxuICAgICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG4gICAgfVxuICAgIGlmIChkYXRhLnRyYW5zY2VpdmVyUmVxdWVzdCAmJiB0aGlzLmluaXRpYXRvcikge1xuICAgICAgdGhpcy5fZGVidWcoJ2dvdCByZXF1ZXN0IGZvciB0cmFuc2NlaXZlcicpXG4gICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0LmtpbmQsIGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0LmluaXQpXG4gICAgfVxuICAgIGlmIChkYXRhLmNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uICYmIHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUpIHtcbiAgICAgICAgdGhpcy5fYWRkSWNlQ2FuZGlkYXRlKGRhdGEuY2FuZGlkYXRlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMucHVzaChkYXRhLmNhbmRpZGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEuc2RwKSB7XG4gICAgICB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgKHRoaXMuX3dydGMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShkYXRhKSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXVxuXG4gICAgICAgICAgaWYgKHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHRoaXMuX2NyZWF0ZUFuc3dlcigpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9TRVRfUkVNT1RFX0RFU0NSSVBUSU9OJykpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIGlmICghZGF0YS5zZHAgJiYgIWRhdGEuY2FuZGlkYXRlICYmICFkYXRhLnJlbmVnb3RpYXRlICYmICFkYXRhLnRyYW5zY2VpdmVyUmVxdWVzdCkge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdzaWduYWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIHNpZ25hbCBkYXRhJyksICdFUlJfU0lHTkFMSU5HJykpXG4gICAgfVxuICB9XG5cbiAgX2FkZEljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgY29uc3QgaWNlQ2FuZGlkYXRlT2JqID0gbmV3IHRoaXMuX3dydGMuUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICB0aGlzLl9wYy5hZGRJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlT2JqKVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmICghaWNlQ2FuZGlkYXRlT2JqLmFkZHJlc3MgfHwgaWNlQ2FuZGlkYXRlT2JqLmFkZHJlc3MuZW5kc1dpdGgoJy5sb2NhbCcpKSB7XG4gICAgICAgICAgd2FybignSWdub3JpbmcgdW5zdXBwb3J0ZWQgSUNFIGNhbmRpZGF0ZS4nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9BRERfSUNFX0NBTkRJREFURScpKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgdGV4dC9iaW5hcnkgZGF0YSB0byB0aGUgcmVtb3RlIHBlZXIuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfEJ1ZmZlcnxzdHJpbmd8QmxvYn0gY2h1bmtcbiAgICovXG4gIHNlbmQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHNlbmQgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2NoYW5uZWwuc2VuZChjaHVuaylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBUcmFuc2NlaXZlciB0byB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtpbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IGluaXRcbiAgICovXG4gIGFkZFRyYW5zY2VpdmVyIChraW5kLCBpbml0KSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IGFkZFRyYW5zY2VpdmVyIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygnYWRkVHJhbnNjZWl2ZXIoKScpXG5cbiAgICBpZiAodGhpcy5pbml0aWF0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKGtpbmQsIGluaXQpXG4gICAgICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9BRERfVFJBTlNDRUlWRVInKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7IC8vIHJlcXVlc3QgaW5pdGlhdG9yIHRvIHJlbmVnb3RpYXRlXG4gICAgICAgIHR5cGU6ICd0cmFuc2NlaXZlclJlcXVlc3QnLFxuICAgICAgICB0cmFuc2NlaXZlclJlcXVlc3Q6IHsga2luZCwgaW5pdCB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBNZWRpYVN0cmVhbSB0byB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICBhZGRTdHJlYW0gKHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBhZGRTdHJlYW0gYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdhZGRTdHJlYW0oKScpXG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICB0aGlzLmFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBNZWRpYVN0cmVhbVRyYWNrIHRvIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICAgKi9cbiAgYWRkVHJhY2sgKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgYWRkVHJhY2sgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdhZGRUcmFjaygpJylcblxuICAgIGNvbnN0IHN1Ym1hcCA9IHRoaXMuX3NlbmRlck1hcC5nZXQodHJhY2spIHx8IG5ldyBNYXAoKSAvLyBuZXN0ZWQgTWFwcyBtYXAgW3RyYWNrLCBzdHJlYW1dIHRvIHNlbmRlclxuICAgIGxldCBzZW5kZXIgPSBzdWJtYXAuZ2V0KHN0cmVhbSlcbiAgICBpZiAoIXNlbmRlcikge1xuICAgICAgc2VuZGVyID0gdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHN0cmVhbSlcbiAgICAgIHN1Ym1hcC5zZXQoc3RyZWFtLCBzZW5kZXIpXG4gICAgICB0aGlzLl9zZW5kZXJNYXAuc2V0KHRyYWNrLCBzdWJtYXApXG4gICAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKClcbiAgICB9IGVsc2UgaWYgKHNlbmRlci5yZW1vdmVkKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVHJhY2sgaGFzIGJlZW4gcmVtb3ZlZC4gWW91IHNob3VsZCBlbmFibGUvZGlzYWJsZSB0cmFja3MgdGhhdCB5b3Ugd2FudCB0byByZS1hZGQuJyksICdFUlJfU0VOREVSX1JFTU9WRUQnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVHJhY2sgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGF0IHN0cmVhbS4nKSwgJ0VSUl9TRU5ERVJfQUxSRUFEWV9BRERFRCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBNZWRpYVN0cmVhbVRyYWNrIGJ5IGFub3RoZXIgaW4gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gb2xkVHJhY2tcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSBuZXdUcmFja1xuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIHJlcGxhY2VUcmFjayAob2xkVHJhY2ssIG5ld1RyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgcmVwbGFjZVRyYWNrIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygncmVwbGFjZVRyYWNrKCknKVxuXG4gICAgY29uc3Qgc3VibWFwID0gdGhpcy5fc2VuZGVyTWFwLmdldChvbGRUcmFjaylcbiAgICBjb25zdCBzZW5kZXIgPSBzdWJtYXAgPyBzdWJtYXAuZ2V0KHN0cmVhbSkgOiBudWxsXG4gICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDYW5ub3QgcmVwbGFjZSB0cmFjayB0aGF0IHdhcyBuZXZlciBhZGRlZC4nKSwgJ0VSUl9UUkFDS19OT1RfQURERUQnKVxuICAgIH1cbiAgICBpZiAobmV3VHJhY2spIHRoaXMuX3NlbmRlck1hcC5zZXQobmV3VHJhY2ssIHN1Ym1hcClcblxuICAgIGlmIChzZW5kZXIucmVwbGFjZVRyYWNrICE9IG51bGwpIHtcbiAgICAgIHNlbmRlci5yZXBsYWNlVHJhY2sobmV3VHJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcigncmVwbGFjZVRyYWNrIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyksICdFUlJfVU5TVVBQT1JURURfUkVQTEFDRVRSQUNLJykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIE1lZGlhU3RyZWFtVHJhY2sgZnJvbSB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIHJlbW92ZVRyYWNrICh0cmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHJlbW92ZVRyYWNrIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygncmVtb3ZlU2VuZGVyKCknKVxuXG4gICAgY29uc3Qgc3VibWFwID0gdGhpcy5fc2VuZGVyTWFwLmdldCh0cmFjaylcbiAgICBjb25zdCBzZW5kZXIgPSBzdWJtYXAgPyBzdWJtYXAuZ2V0KHN0cmVhbSkgOiBudWxsXG4gICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDYW5ub3QgcmVtb3ZlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLicpLCAnRVJSX1RSQUNLX05PVF9BRERFRCcpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZW5kZXIucmVtb3ZlZCA9IHRydWVcbiAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHNlbmRlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIubmFtZSA9PT0gJ05TX0VSUk9SX1VORVhQRUNURUQnKSB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZS5wdXNoKHNlbmRlcikgLy8gSEFDSzogRmlyZWZveCBtdXN0IHdhaXQgdW50aWwgKHNpZ25hbGluZ1N0YXRlID09PSBzdGFibGUpIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMzM4NzRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9SRU1PVkVfVFJBQ0snKSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgTWVkaWFTdHJlYW0gZnJvbSB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICByZW1vdmVTdHJlYW0gKHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCByZW1vdmVTdHJlYW0gYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdyZW1vdmVTZW5kZXJzKCknKVxuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVUcmFjayh0cmFjaywgc3RyZWFtKVxuICAgIH0pXG4gIH1cblxuICBfbmVlZHNOZWdvdGlhdGlvbiAoKSB7XG4gICAgdGhpcy5fZGVidWcoJ19uZWVkc05lZ290aWF0aW9uJylcbiAgICBpZiAodGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uKSByZXR1cm4gLy8gYmF0Y2ggc3luY2hyb25vdXMgcmVuZWdvdGlhdGlvbnNcbiAgICB0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uID0gZmFsc2VcbiAgICAgIGlmICh0aGlzLmluaXRpYXRvciB8fCAhdGhpcy5fZmlyc3ROZWdvdGlhdGlvbikge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnc3RhcnRpbmcgYmF0Y2hlZCBuZWdvdGlhdGlvbicpXG4gICAgICAgIHRoaXMubmVnb3RpYXRlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdub24taW5pdGlhdG9yIGluaXRpYWwgbmVnb3RpYXRpb24gcmVxdWVzdCBkaXNjYXJkZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy5fZmlyc3ROZWdvdGlhdGlvbiA9IGZhbHNlXG4gICAgfSlcbiAgfVxuXG4gIG5lZ290aWF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IG5lZ290aWF0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG5cbiAgICBpZiAodGhpcy5pbml0aWF0b3IpIHtcbiAgICAgIGlmICh0aGlzLl9pc05lZ290aWF0aW5nKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygnYWxyZWFkeSBuZWdvdGlhdGluZywgcXVldWVpbmcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3N0YXJ0IG5lZ290aWF0aW9uJylcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIEhBQ0s6IENocm9tZSBjcmFzaGVzIGlmIHdlIGltbWVkaWF0ZWx5IGNhbGwgY3JlYXRlT2ZmZXJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVPZmZlcigpXG4gICAgICAgIH0sIDApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9pc05lZ290aWF0aW5nKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygnYWxyZWFkeSBuZWdvdGlhdGluZywgcXVldWVpbmcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3JlcXVlc3RpbmcgbmVnb3RpYXRpb24gZnJvbSBpbml0aWF0b3InKVxuICAgICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHsgLy8gcmVxdWVzdCBpbml0aWF0b3IgdG8gcmVuZWdvdGlhdGVcbiAgICAgICAgICB0eXBlOiAncmVuZWdvdGlhdGUnLFxuICAgICAgICAgIHJlbmVnb3RpYXRlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2lzTmVnb3RpYXRpbmcgPSB0cnVlXG4gIH1cblxuICAvLyBUT0RPOiBEZWxldGUgdGhpcyBtZXRob2Qgb25jZSByZWFkYWJsZS1zdHJlYW0gaXMgdXBkYXRlZCB0byBjb250YWluIGEgZGVmYXVsdFxuICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBkZXN0cm95KCkgdGhhdCBhdXRvbWF0aWNhbGx5IGNhbGxzIF9kZXN0cm95KClcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3JlYWRhYmxlLXN0cmVhbS9pc3N1ZXMvMjgzXG4gIGRlc3Ryb3kgKGVycikge1xuICAgIHRoaXMuX2Rlc3Ryb3koZXJyLCAoKSA9PiB7fSlcbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNiKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8IHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgdGhpcy5kZXN0cm95aW5nID0gdHJ1ZVxuXG4gICAgdGhpcy5fZGVidWcoJ2Rlc3Ryb3lpbmcgKGVycm9yOiAlcyknLCBlcnIgJiYgKGVyci5tZXNzYWdlIHx8IGVycikpXG5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7IC8vIGFsbG93IGV2ZW50cyBjb25jdXJyZW50IHdpdGggdGhlIGNhbGwgdG8gX2Rlc3Ryb3koKSB0byBmaXJlIChzZWUgIzY5MilcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgICAgdGhpcy5kZXN0cm95aW5nID0gZmFsc2VcblxuICAgICAgdGhpcy5fZGVidWcoJ2Rlc3Ryb3kgKGVycm9yOiAlcyknLCBlcnIgJiYgKGVyci5tZXNzYWdlIHx8IGVycikpXG5cbiAgICAgIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gZmFsc2VcblxuICAgICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSB0aGlzLnB1c2gobnVsbClcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgdGhpcy5lbmQoKVxuXG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgdGhpcy5fcGNSZWFkeSA9IGZhbHNlXG4gICAgICB0aGlzLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuICAgICAgdGhpcy5fcmVtb3RlVHJhY2tzID0gbnVsbFxuICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IG51bGxcbiAgICAgIHRoaXMuX3NlbmRlck1hcCA9IG51bGxcblxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jbG9zaW5nSW50ZXJ2YWwpXG4gICAgICB0aGlzLl9jbG9zaW5nSW50ZXJ2YWwgPSBudWxsXG5cbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcbiAgICAgIHRoaXMuX2NodW5rID0gbnVsbFxuICAgICAgdGhpcy5fY2IgPSBudWxsXG5cbiAgICAgIGlmICh0aGlzLl9vbkZpbmlzaEJvdW5kKSB0aGlzLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCB0aGlzLl9vbkZpbmlzaEJvdW5kKVxuICAgICAgdGhpcy5fb25GaW5pc2hCb3VuZCA9IG51bGxcblxuICAgICAgaWYgKHRoaXMuX2NoYW5uZWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9jaGFubmVsLmNsb3NlKClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgICAgIC8vIGFsbG93IGV2ZW50cyBjb25jdXJyZW50IHdpdGggZGVzdHJ1Y3Rpb24gdG8gYmUgaGFuZGxlZFxuICAgICAgICB0aGlzLl9jaGFubmVsLm9ubWVzc2FnZSA9IG51bGxcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbm9wZW4gPSBudWxsXG4gICAgICAgIHRoaXMuX2NoYW5uZWwub25jbG9zZSA9IG51bGxcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbmVycm9yID0gbnVsbFxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAgICAgLy8gYWxsb3cgZXZlbnRzIGNvbmN1cnJlbnQgd2l0aCBkZXN0cnVjdGlvbiB0byBiZSBoYW5kbGVkXG4gICAgICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGxcbiAgICAgICAgdGhpcy5fcGMub250cmFjayA9IG51bGxcbiAgICAgICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IG51bGxcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BjID0gbnVsbFxuICAgICAgdGhpcy5fY2hhbm5lbCA9IG51bGxcblxuICAgICAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBfc2V0dXBEYXRhIChldmVudCkge1xuICAgIGlmICghZXZlbnQuY2hhbm5lbCkge1xuICAgICAgLy8gSW4gc29tZSBzaXR1YXRpb25zIGBwYy5jcmVhdGVEYXRhQ2hhbm5lbCgpYCByZXR1cm5zIGB1bmRlZmluZWRgIChpbiB3cnRjKSxcbiAgICAgIC8vIHdoaWNoIGlzIGludmFsaWQgYmVoYXZpb3IuIEhhbmRsZSBpdCBncmFjZWZ1bGx5LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL3NpbXBsZS1wZWVyL2lzc3Vlcy8xNjNcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0RhdGEgY2hhbm5lbCBldmVudCBpcyBtaXNzaW5nIGBjaGFubmVsYCBwcm9wZXJ0eScpLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgIH1cblxuICAgIHRoaXMuX2NoYW5uZWwgPSBldmVudC5jaGFubmVsXG4gICAgdGhpcy5fY2hhbm5lbC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IE1BWF9CVUZGRVJFRF9BTU9VTlRcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWxOYW1lID0gdGhpcy5fY2hhbm5lbC5sYWJlbFxuXG4gICAgdGhpcy5fY2hhbm5lbC5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5uZWxNZXNzYWdlKGV2ZW50KVxuICAgIH1cbiAgICB0aGlzLl9jaGFubmVsLm9uYnVmZmVyZWRhbW91bnRsb3cgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpXG4gICAgfVxuICAgIHRoaXMuX2NoYW5uZWwub25vcGVuID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25DaGFubmVsT3BlbigpXG4gICAgfVxuICAgIHRoaXMuX2NoYW5uZWwub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uQ2hhbm5lbENsb3NlKClcbiAgICB9XG4gICAgdGhpcy5fY2hhbm5lbC5vbmVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZXJyID0gZXZlbnQuZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICA/IGV2ZW50LmVycm9yXG4gICAgICAgIDogbmV3IEVycm9yKGBEYXRhY2hhbm5lbCBlcnJvcjogJHtldmVudC5tZXNzYWdlfSAke2V2ZW50LmZpbGVuYW1lfToke2V2ZW50LmxpbmVub306JHtldmVudC5jb2xub31gKVxuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgIH1cblxuICAgIC8vIEhBQ0s6IENocm9tZSB3aWxsIHNvbWV0aW1lcyBnZXQgc3R1Y2sgaW4gcmVhZHlTdGF0ZSBcImNsb3NpbmdcIiwgbGV0J3MgY2hlY2sgZm9yIHRoaXMgY29uZGl0aW9uXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODgyNzQzXG4gICAgbGV0IGlzQ2xvc2luZyA9IGZhbHNlXG4gICAgdGhpcy5fY2xvc2luZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4geyAvLyBObyBcIm9uY2xvc2luZ1wiIGV2ZW50XG4gICAgICBpZiAodGhpcy5fY2hhbm5lbCAmJiB0aGlzLl9jaGFubmVsLnJlYWR5U3RhdGUgPT09ICdjbG9zaW5nJykge1xuICAgICAgICBpZiAoaXNDbG9zaW5nKSB0aGlzLl9vbkNoYW5uZWxDbG9zZSgpIC8vIGNsb3NpbmcgdGltZWQgb3V0OiBlcXVpdmFsZW50IHRvIG9uY2xvc2UgZmlyaW5nXG4gICAgICAgIGlzQ2xvc2luZyA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQ2xvc2luZyA9IGZhbHNlXG4gICAgICB9XG4gICAgfSwgQ0hBTk5FTF9DTE9TSU5HX1RJTUVPVVQpXG4gIH1cblxuICBfcmVhZCAoKSB7fVxuXG4gIF93cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIGNiKGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3Qgd3JpdGUgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcblxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2VuZChjaHVuaylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQgPiBNQVhfQlVGRkVSRURfQU1PVU5UKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICAgICAgdGhpcy5fY2IgPSBjYlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGVidWcoJ3dyaXRlIGJlZm9yZSBjb25uZWN0JylcbiAgICAgIHRoaXMuX2NodW5rID0gY2h1bmtcbiAgICAgIHRoaXMuX2NiID0gY2JcbiAgICB9XG4gIH1cblxuICAvLyBXaGVuIHN0cmVhbSBmaW5pc2hlcyB3cml0aW5nLCBjbG9zZSBzb2NrZXQuIEhhbGYgb3BlbiBjb25uZWN0aW9ucyBhcmUgbm90XG4gIC8vIHN1cHBvcnRlZC5cbiAgX29uRmluaXNoICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgZGVzdHJveWluZyBzbyB0aGUgc29ja2V0IGZsdXNoZXMuXG4gICAgLy8gVE9ETzogaXMgdGhlcmUgYSBtb3JlIHJlbGlhYmxlIHdheSB0byBhY2NvbXBsaXNoIHRoaXM/XG4gICAgY29uc3QgZGVzdHJveVNvb24gPSAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGVzdHJveSgpLCAxMDAwKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIGRlc3Ryb3lTb29uKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmNlKCdjb25uZWN0JywgZGVzdHJveVNvb24pXG4gICAgfVxuICB9XG5cbiAgX3N0YXJ0SWNlQ29tcGxldGVUaW1lb3V0ICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICh0aGlzLl9pY2VDb21wbGV0ZVRpbWVyKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1Zygnc3RhcnRlZCBpY2VDb21wbGV0ZSB0aW1lb3V0JylcbiAgICB0aGlzLl9pY2VDb21wbGV0ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2ljZUNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuX2ljZUNvbXBsZXRlID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygnaWNlQ29tcGxldGUgdGltZW91dCBjb21wbGV0ZWQnKVxuICAgICAgICB0aGlzLmVtaXQoJ2ljZVRpbWVvdXQnKVxuICAgICAgICB0aGlzLmVtaXQoJ19pY2VDb21wbGV0ZScpXG4gICAgICB9XG4gICAgfSwgdGhpcy5pY2VDb21wbGV0ZVRpbWVvdXQpXG4gIH1cblxuICBfY3JlYXRlT2ZmZXIgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICB0aGlzLl9wYy5jcmVhdGVPZmZlcih0aGlzLm9mZmVyT3B0aW9ucylcbiAgICAgIC50aGVuKG9mZmVyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgaWYgKCF0aGlzLnRyaWNrbGUgJiYgIXRoaXMuYWxsb3dIYWxmVHJpY2tsZSkgb2ZmZXIuc2RwID0gZmlsdGVyVHJpY2tsZShvZmZlci5zZHApXG4gICAgICAgIG9mZmVyLnNkcCA9IHRoaXMuc2RwVHJhbnNmb3JtKG9mZmVyLnNkcClcblxuICAgICAgICBjb25zdCBzZW5kT2ZmZXIgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IG9mZmVyXG4gICAgICAgICAgdGhpcy5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgICAgICB0eXBlOiBzaWduYWwudHlwZSxcbiAgICAgICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvblN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fZGVidWcoJ2NyZWF0ZU9mZmVyIHN1Y2Nlc3MnKVxuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgICAgaWYgKHRoaXMudHJpY2tsZSB8fCB0aGlzLl9pY2VDb21wbGV0ZSkgc2VuZE9mZmVyKClcbiAgICAgICAgICBlbHNlIHRoaXMub25jZSgnX2ljZUNvbXBsZXRlJywgc2VuZE9mZmVyKSAvLyB3YWl0IGZvciBjYW5kaWRhdGVzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfU0VUX0xPQ0FMX0RFU0NSSVBUSU9OJykpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKVxuICAgICAgICAgIC50aGVuKG9uU3VjY2VzcylcbiAgICAgICAgICAuY2F0Y2gob25FcnJvcilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0NSRUFURV9PRkZFUicpKVxuICAgICAgfSlcbiAgfVxuXG4gIF9yZXF1ZXN0TWlzc2luZ1RyYW5zY2VpdmVycyAoKSB7XG4gICAgaWYgKHRoaXMuX3BjLmdldFRyYW5zY2VpdmVycykge1xuICAgICAgdGhpcy5fcGMuZ2V0VHJhbnNjZWl2ZXJzKCkuZm9yRWFjaCh0cmFuc2NlaXZlciA9PiB7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIubWlkICYmIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjayAmJiAhdHJhbnNjZWl2ZXIucmVxdWVzdGVkKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucmVxdWVzdGVkID0gdHJ1ZSAvLyBIQUNLOiBTYWZhcmkgcmV0dXJucyBuZWdvdGlhdGVkIHRyYW5zY2VpdmVycyB3aXRoIGEgbnVsbCBtaWRcbiAgICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5raW5kKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVBbnN3ZXIgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIodGhpcy5hbnN3ZXJPcHRpb25zKVxuICAgICAgLnRoZW4oYW5zd2VyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgaWYgKCF0aGlzLnRyaWNrbGUgJiYgIXRoaXMuYWxsb3dIYWxmVHJpY2tsZSkgYW5zd2VyLnNkcCA9IGZpbHRlclRyaWNrbGUoYW5zd2VyLnNkcClcbiAgICAgICAgYW5zd2VyLnNkcCA9IHRoaXMuc2RwVHJhbnNmb3JtKGFuc3dlci5zZHApXG5cbiAgICAgICAgY29uc3Qgc2VuZEFuc3dlciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24gfHwgYW5zd2VyXG4gICAgICAgICAgdGhpcy5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgICAgICB0eXBlOiBzaWduYWwudHlwZSxcbiAgICAgICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKCF0aGlzLmluaXRpYXRvcikgdGhpcy5fcmVxdWVzdE1pc3NpbmdUcmFuc2NlaXZlcnMoKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb25TdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgICAgaWYgKHRoaXMudHJpY2tsZSB8fCB0aGlzLl9pY2VDb21wbGV0ZSkgc2VuZEFuc3dlcigpXG4gICAgICAgICAgZWxzZSB0aGlzLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRBbnN3ZXIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfU0VUX0xPQ0FMX0RFU0NSSVBUSU9OJykpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcilcbiAgICAgICAgICAudGhlbihvblN1Y2Nlc3MpXG4gICAgICAgICAgLmNhdGNoKG9uRXJyb3IpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9DUkVBVEVfQU5TV0VSJykpXG4gICAgICB9KVxuICB9XG5cbiAgX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkLicpLCAnRVJSX0NPTk5FQ1RJT05fRkFJTFVSRScpKVxuICAgIH1cbiAgfVxuXG4gIF9vbkljZVN0YXRlQ2hhbmdlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGNvbnN0IGljZUNvbm5lY3Rpb25TdGF0ZSA9IHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZVxuICAgIGNvbnN0IGljZUdhdGhlcmluZ1N0YXRlID0gdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGVcblxuICAgIHRoaXMuX2RlYnVnKFxuICAgICAgJ2ljZVN0YXRlQ2hhbmdlIChjb25uZWN0aW9uOiAlcykgKGdhdGhlcmluZzogJXMpJyxcbiAgICAgIGljZUNvbm5lY3Rpb25TdGF0ZSxcbiAgICAgIGljZUdhdGhlcmluZ1N0YXRlXG4gICAgKVxuICAgIHRoaXMuZW1pdCgnaWNlU3RhdGVDaGFuZ2UnLCBpY2VDb25uZWN0aW9uU3RhdGUsIGljZUdhdGhlcmluZ1N0YXRlKVxuXG4gICAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJykge1xuICAgICAgdGhpcy5fcGNSZWFkeSA9IHRydWVcbiAgICAgIHRoaXMuX21heWJlUmVhZHkoKVxuICAgIH1cbiAgICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdJY2UgY29ubmVjdGlvbiBmYWlsZWQuJyksICdFUlJfSUNFX0NPTk5FQ1RJT05fRkFJTFVSRScpKVxuICAgIH1cbiAgICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdJY2UgY29ubmVjdGlvbiBjbG9zZWQuJyksICdFUlJfSUNFX0NPTk5FQ1RJT05fQ0xPU0VEJykpXG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhdHMgKGNiKSB7XG4gICAgLy8gc3RhdHJlcG9ydHMgY2FuIGNvbWUgd2l0aCBhIHZhbHVlIGFycmF5IGluc3RlYWQgb2YgcHJvcGVydGllc1xuICAgIGNvbnN0IGZsYXR0ZW5WYWx1ZXMgPSByZXBvcnQgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXBvcnQudmFsdWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXBvcnQudmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVwb3J0LCB2YWx1ZSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXBvcnRcbiAgICB9XG5cbiAgICAvLyBQcm9taXNlLWJhc2VkIGdldFN0YXRzKCkgKHN0YW5kYXJkKVxuICAgIGlmICh0aGlzLl9wYy5nZXRTdGF0cy5sZW5ndGggPT09IDAgfHwgdGhpcy5faXNSZWFjdE5hdGl2ZVdlYnJ0Yykge1xuICAgICAgdGhpcy5fcGMuZ2V0U3RhdHMoKVxuICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlcG9ydHMgPSBbXVxuICAgICAgICAgIHJlcy5mb3JFYWNoKHJlcG9ydCA9PiB7XG4gICAgICAgICAgICByZXBvcnRzLnB1c2goZmxhdHRlblZhbHVlcyhyZXBvcnQpKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgY2IobnVsbCwgcmVwb3J0cylcbiAgICAgICAgfSwgZXJyID0+IGNiKGVycikpXG5cbiAgICAvLyBTaW5nbGUtcGFyYW1ldGVyIGNhbGxiYWNrLWJhc2VkIGdldFN0YXRzKCkgKG5vbi1zdGFuZGFyZClcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BjLmdldFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3BjLmdldFN0YXRzKHJlcyA9PiB7XG4gICAgICAgIC8vIElmIHdlIGRlc3Ryb3kgY29ubmVjdGlvbiBpbiBgY29ubmVjdGAgY2FsbGJhY2sgdGhpcyBjb2RlIG1pZ2h0IGhhcHBlbiB0byBydW4gd2hlbiBhY3R1YWwgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHJlcG9ydHMgPSBbXVxuICAgICAgICByZXMucmVzdWx0KCkuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHt9XG4gICAgICAgICAgcmVzdWx0Lm5hbWVzKCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgIHJlcG9ydFtuYW1lXSA9IHJlc3VsdC5zdGF0KG5hbWUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXBvcnQuaWQgPSByZXN1bHQuaWRcbiAgICAgICAgICByZXBvcnQudHlwZSA9IHJlc3VsdC50eXBlXG4gICAgICAgICAgcmVwb3J0LnRpbWVzdGFtcCA9IHJlc3VsdC50aW1lc3RhbXBcbiAgICAgICAgICByZXBvcnRzLnB1c2goZmxhdHRlblZhbHVlcyhyZXBvcnQpKVxuICAgICAgICB9KVxuICAgICAgICBjYihudWxsLCByZXBvcnRzKVxuICAgICAgfSwgZXJyID0+IGNiKGVycikpXG5cbiAgICAvLyBVbmtub3duIGJyb3dzZXIsIHNraXAgZ2V0U3RhdHMoKSBzaW5jZSBpdCdzIGFueW9uZSdzIGd1ZXNzIHdoaWNoIHN0eWxlIG9mXG4gICAgLy8gZ2V0U3RhdHMoKSB0aGV5IGltcGxlbWVudC5cbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbCwgW10pXG4gICAgfVxuICB9XG5cbiAgX21heWJlUmVhZHkgKCkge1xuICAgIHRoaXMuX2RlYnVnKCdtYXliZVJlYWR5IHBjICVzIGNoYW5uZWwgJXMnLCB0aGlzLl9wY1JlYWR5LCB0aGlzLl9jaGFubmVsUmVhZHkpXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCB8fCB0aGlzLl9jb25uZWN0aW5nIHx8ICF0aGlzLl9wY1JlYWR5IHx8ICF0aGlzLl9jaGFubmVsUmVhZHkpIHJldHVyblxuXG4gICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWVcblxuICAgIC8vIEhBQ0s6IFdlIGNhbid0IHJlbHkgb24gb3JkZXIgaGVyZSwgZm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcy1wbGF0Zm9ybS9ub2RlLXdlYnJ0Yy9pc3N1ZXMvMzM5XG4gICAgY29uc3QgZmluZENhbmRpZGF0ZVBhaXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgICB0aGlzLmdldFN0YXRzKChlcnIsIGl0ZW1zKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgICAgLy8gVHJlYXQgZ2V0U3RhdHMgZXJyb3IgYXMgbm9uLWZhdGFsLiBJdCdzIG5vdCBlc3NlbnRpYWwuXG4gICAgICAgIGlmIChlcnIpIGl0ZW1zID0gW11cblxuICAgICAgICBjb25zdCByZW1vdGVDYW5kaWRhdGVzID0ge31cbiAgICAgICAgY29uc3QgbG9jYWxDYW5kaWRhdGVzID0ge31cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlUGFpcnMgPSB7fVxuICAgICAgICBsZXQgZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSBmYWxzZVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgLy8gVE9ETzogT25jZSBhbGwgYnJvd3NlcnMgc3VwcG9ydCB0aGUgaHlwaGVuYXRlZCBzdGF0cyByZXBvcnQgdHlwZXMsIHJlbW92ZVxuICAgICAgICAgIC8vIHRoZSBub24taHlwZW5hdGVkIG9uZXNcbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAncmVtb3RlY2FuZGlkYXRlJyB8fCBpdGVtLnR5cGUgPT09ICdyZW1vdGUtY2FuZGlkYXRlJykge1xuICAgICAgICAgICAgcmVtb3RlQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2xvY2FsY2FuZGlkYXRlJyB8fCBpdGVtLnR5cGUgPT09ICdsb2NhbC1jYW5kaWRhdGUnKSB7XG4gICAgICAgICAgICBsb2NhbENhbmRpZGF0ZXNbaXRlbS5pZF0gPSBpdGVtXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGVwYWlyJyB8fCBpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzW2l0ZW0uaWRdID0gaXRlbVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBzZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSBzZWxlY3RlZENhbmRpZGF0ZVBhaXIgPT4ge1xuICAgICAgICAgIGZvdW5kU2VsZWN0ZWRDYW5kaWRhdGVQYWlyID0gdHJ1ZVxuXG4gICAgICAgICAgbGV0IGxvY2FsID0gbG9jYWxDYW5kaWRhdGVzW3NlbGVjdGVkQ2FuZGlkYXRlUGFpci5sb2NhbENhbmRpZGF0ZUlkXVxuXG4gICAgICAgICAgaWYgKGxvY2FsICYmIChsb2NhbC5pcCB8fCBsb2NhbC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgLy8gU3BlY1xuICAgICAgICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBsb2NhbC5pcCB8fCBsb2NhbC5hZGRyZXNzXG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbC5wb3J0KVxuICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWwgJiYgbG9jYWwuaXBBZGRyZXNzKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IGxvY2FsLmlwQWRkcmVzc1xuICAgICAgICAgICAgdGhpcy5sb2NhbFBvcnQgPSBOdW1iZXIobG9jYWwucG9ydE51bWJlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RlZENhbmRpZGF0ZVBhaXIuZ29vZ0xvY2FsQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgQ2hyb21lIDU4IGlzIHJlbGVhc2VkXG4gICAgICAgICAgICBsb2NhbCA9IHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nTG9jYWxBZGRyZXNzLnNwbGl0KCc6JylcbiAgICAgICAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gbG9jYWxbMF1cbiAgICAgICAgICAgIHRoaXMubG9jYWxQb3J0ID0gTnVtYmVyKGxvY2FsWzFdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxGYW1pbHkgPSB0aGlzLmxvY2FsQWRkcmVzcy5pbmNsdWRlcygnOicpID8gJ0lQdjYnIDogJ0lQdjQnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHJlbW90ZSA9IHJlbW90ZUNhbmRpZGF0ZXNbc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLnJlbW90ZUNhbmRpZGF0ZUlkXVxuXG4gICAgICAgICAgaWYgKHJlbW90ZSAmJiAocmVtb3RlLmlwIHx8IHJlbW90ZS5hZGRyZXNzKSkge1xuICAgICAgICAgICAgLy8gU3BlY1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVtb3RlLmlwIHx8IHJlbW90ZS5hZGRyZXNzXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlLnBvcnQpXG4gICAgICAgICAgfSBlbHNlIGlmIChyZW1vdGUgJiYgcmVtb3RlLmlwQWRkcmVzcykge1xuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVtb3RlLmlwQWRkcmVzc1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZS5wb3J0TnVtYmVyKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nUmVtb3RlQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgQ2hyb21lIDU4IGlzIHJlbGVhc2VkXG4gICAgICAgICAgICByZW1vdGUgPSBzZWxlY3RlZENhbmRpZGF0ZVBhaXIuZ29vZ1JlbW90ZUFkZHJlc3Muc3BsaXQoJzonKVxuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVtb3RlWzBdXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlWzFdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW90ZUZhbWlseSA9IHRoaXMucmVtb3RlQWRkcmVzcy5pbmNsdWRlcygnOicpID8gJ0lQdjYnIDogJ0lQdjQnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAnY29ubmVjdCBsb2NhbDogJXM6JXMgcmVtb3RlOiAlczolcycsXG4gICAgICAgICAgICB0aGlzLmxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxQb3J0LFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVQb3J0XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAvLyBTcGVjLWNvbXBsaWFudFxuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICd0cmFuc3BvcnQnICYmIGl0ZW0uc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkQ2FuZGlkYXRlUGFpcihjYW5kaWRhdGVQYWlyc1tpdGVtLnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPbGQgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGl0ZW0udHlwZSA9PT0gJ2dvb2dDYW5kaWRhdGVQYWlyJyAmJiBpdGVtLmdvb2dBY3RpdmVDb25uZWN0aW9uID09PSAndHJ1ZScpIHx8XG4gICAgICAgICAgICAoKGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZXBhaXInIHx8IGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJykgJiYgaXRlbS5zZWxlY3RlZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkQ2FuZGlkYXRlUGFpcihpdGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBJZ25vcmUgY2FuZGlkYXRlIHBhaXIgc2VsZWN0aW9uIGluIGJyb3dzZXJzIGxpa2UgU2FmYXJpIDExIHRoYXQgZG8gbm90IGhhdmUgYW55IGxvY2FsIG9yIHJlbW90ZSBjYW5kaWRhdGVzXG4gICAgICAgIC8vIEJ1dCB3YWl0IHVudGlsIGF0IGxlYXN0IDEgY2FuZGlkYXRlIHBhaXIgaXMgYXZhaWxhYmxlXG4gICAgICAgIGlmICghZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgJiYgKCFPYmplY3Qua2V5cyhjYW5kaWRhdGVQYWlycykubGVuZ3RoIHx8IE9iamVjdC5rZXlzKGxvY2FsQ2FuZGlkYXRlcykubGVuZ3RoKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZmluZENhbmRpZGF0ZVBhaXIsIDEwMClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2VcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY2h1bmspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKHRoaXMuX2NodW5rKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY2h1bmsgPSBudWxsXG4gICAgICAgICAgdGhpcy5fZGVidWcoJ3NlbnQgY2h1bmsgZnJvbSBcIndyaXRlIGJlZm9yZSBjb25uZWN0XCInKVxuXG4gICAgICAgICAgY29uc3QgY2IgPSB0aGlzLl9jYlxuICAgICAgICAgIHRoaXMuX2NiID0gbnVsbFxuICAgICAgICAgIGNiKG51bGwpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBgYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGRgIGFuZCAnb25idWZmZXJlZGFtb3VudGxvdycgYXJlIHVuc3VwcG9ydGVkLFxuICAgICAgICAvLyBmYWxsYmFjayB0byB1c2luZyBzZXRJbnRlcnZhbCB0byBpbXBsZW1lbnQgYmFja3ByZXNzdXJlLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9vbkludGVydmFsKCksIDE1MClcbiAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWwudW5yZWYpIHRoaXMuX2ludGVydmFsLnVucmVmKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlYnVnKCdjb25uZWN0JylcbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JylcbiAgICAgIH0pXG4gICAgfVxuICAgIGZpbmRDYW5kaWRhdGVQYWlyKClcbiAgfVxuXG4gIF9vbkludGVydmFsICgpIHtcbiAgICBpZiAoIXRoaXMuX2NiIHx8ICF0aGlzLl9jaGFubmVsIHx8IHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQgPiBNQVhfQlVGRkVSRURfQU1PVU5UKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3coKVxuICB9XG5cbiAgX29uU2lnbmFsaW5nU3RhdGVDaGFuZ2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKSB7XG4gICAgICB0aGlzLl9pc05lZ290aWF0aW5nID0gZmFsc2VcblxuICAgICAgLy8gSEFDSzogRmlyZWZveCBkb2Vzbid0IHlldCBzdXBwb3J0IHJlbW92aW5nIHRyYWNrcyB3aGVuIHNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJ1xuICAgICAgdGhpcy5fZGVidWcoJ2ZsdXNoaW5nIHNlbmRlciBxdWV1ZScsIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZSlcbiAgICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHNlbmRlcilcbiAgICAgICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgICB9KVxuICAgICAgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlID0gW11cblxuICAgICAgaWYgKHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdmbHVzaGluZyBuZWdvdGlhdGlvbiBxdWV1ZScpXG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gZmFsc2VcbiAgICAgICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpIC8vIG5lZ290aWF0ZSBhZ2FpblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ25lZ290aWF0ZWQnKVxuICAgICAgICB0aGlzLmVtaXQoJ25lZ290aWF0ZWQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2RlYnVnKCdzaWduYWxpbmdTdGF0ZUNoYW5nZSAlcycsIHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlKVxuICAgIHRoaXMuZW1pdCgnc2lnbmFsaW5nU3RhdGVDaGFuZ2UnLCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSlcbiAgfVxuXG4gIF9vbkljZUNhbmRpZGF0ZSAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmIChldmVudC5jYW5kaWRhdGUgJiYgdGhpcy50cmlja2xlKSB7XG4gICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgdHlwZTogJ2NhbmRpZGF0ZScsXG4gICAgICAgIGNhbmRpZGF0ZToge1xuICAgICAgICAgIGNhbmRpZGF0ZTogZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBldmVudC5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICBzZHBNaWQ6IGV2ZW50LmNhbmRpZGF0ZS5zZHBNaWRcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKCFldmVudC5jYW5kaWRhdGUgJiYgIXRoaXMuX2ljZUNvbXBsZXRlKSB7XG4gICAgICB0aGlzLl9pY2VDb21wbGV0ZSA9IHRydWVcbiAgICAgIHRoaXMuZW1pdCgnX2ljZUNvbXBsZXRlJylcbiAgICB9XG4gICAgLy8gYXMgc29vbiBhcyB3ZSd2ZSByZWNlaXZlZCBvbmUgdmFsaWQgY2FuZGlkYXRlIHN0YXJ0IHRpbWVvdXRcbiAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICB0aGlzLl9zdGFydEljZUNvbXBsZXRlVGltZW91dCgpXG4gICAgfVxuICB9XG5cbiAgX29uQ2hhbm5lbE1lc3NhZ2UgKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICBsZXQgZGF0YSA9IGV2ZW50LmRhdGFcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICB0aGlzLnB1c2goZGF0YSlcbiAgfVxuXG4gIF9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdyAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8ICF0aGlzLl9jYikgcmV0dXJuXG4gICAgdGhpcy5fZGVidWcoJ2VuZGluZyBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICBjb25zdCBjYiA9IHRoaXMuX2NiXG4gICAgdGhpcy5fY2IgPSBudWxsXG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9vbkNoYW5uZWxPcGVuICgpIHtcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkIHx8IHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1Zygnb24gY2hhbm5lbCBvcGVuJylcbiAgICB0aGlzLl9jaGFubmVsUmVhZHkgPSB0cnVlXG4gICAgdGhpcy5fbWF5YmVSZWFkeSgpXG4gIH1cblxuICBfb25DaGFubmVsQ2xvc2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgdGhpcy5fZGVidWcoJ29uIGNoYW5uZWwgY2xvc2UnKVxuICAgIHRoaXMuZGVzdHJveSgpXG4gIH1cblxuICBfb25UcmFjayAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgZXZlbnQuc3RyZWFtcy5mb3JFYWNoKGV2ZW50U3RyZWFtID0+IHtcbiAgICAgIHRoaXMuX2RlYnVnKCdvbiB0cmFjaycpXG4gICAgICB0aGlzLmVtaXQoJ3RyYWNrJywgZXZlbnQudHJhY2ssIGV2ZW50U3RyZWFtKVxuXG4gICAgICB0aGlzLl9yZW1vdGVUcmFja3MucHVzaCh7XG4gICAgICAgIHRyYWNrOiBldmVudC50cmFjayxcbiAgICAgICAgc3RyZWFtOiBldmVudFN0cmVhbVxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuX3JlbW90ZVN0cmVhbXMuc29tZShyZW1vdGVTdHJlYW0gPT4ge1xuICAgICAgICByZXR1cm4gcmVtb3RlU3RyZWFtLmlkID09PSBldmVudFN0cmVhbS5pZFxuICAgICAgfSkpIHJldHVybiAvLyBPbmx5IGZpcmUgb25lICdzdHJlYW0nIGV2ZW50LCBldmVuIHRob3VnaCB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgdHJhY2tzIHBlciBzdHJlYW1cblxuICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcy5wdXNoKGV2ZW50U3RyZWFtKVxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnb24gc3RyZWFtJylcbiAgICAgICAgdGhpcy5lbWl0KCdzdHJlYW0nLCBldmVudFN0cmVhbSkgLy8gZW5zdXJlIGFsbCB0cmFja3MgaGF2ZSBiZWVuIGFkZGVkXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfZGVidWcgKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICBhcmdzWzBdID0gJ1snICsgdGhpcy5faWQgKyAnXSAnICsgYXJnc1swXVxuICAgIGRlYnVnLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH1cbn1cblxuUGVlci5XRUJSVENfU1VQUE9SVCA9ICEhZ2V0QnJvd3NlclJUQygpXG5cbi8qKlxuICogRXhwb3NlIHBlZXIgYW5kIGRhdGEgY2hhbm5lbCBjb25maWcgZm9yIG92ZXJyaWRpbmcgYWxsIFBlZXJcbiAqIGluc3RhbmNlcy4gT3RoZXJ3aXNlLCBqdXN0IHNldCBvcHRzLmNvbmZpZyBvciBvcHRzLmNoYW5uZWxDb25maWdcbiAqIHdoZW4gY29uc3RydWN0aW5nIGEgUGVlci5cbiAqL1xuUGVlci5jb25maWcgPSB7XG4gIGljZVNlcnZlcnM6IFtcbiAgICB7XG4gICAgICB1cmxzOiBbXG4gICAgICAgICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJyxcbiAgICAgICAgJ3N0dW46Z2xvYmFsLnN0dW4udHdpbGlvLmNvbTozNDc4J1xuICAgICAgXVxuICAgIH1cbiAgXSxcbiAgc2RwU2VtYW50aWNzOiAndW5pZmllZC1wbGFuJ1xufVxuXG5QZWVyLmNoYW5uZWxDb25maWcgPSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJcbiIsInZhciBlbmdpbmUgPSByZXF1aXJlKCcuLi9zcmMvc3RvcmUtZW5naW5lJylcblxudmFyIHN0b3JhZ2VzID0gcmVxdWlyZSgnLi4vc3RvcmFnZXMvYWxsJylcbnZhciBwbHVnaW5zID0gW3JlcXVpcmUoJy4uL3BsdWdpbnMvanNvbjInKV1cblxubW9kdWxlLmV4cG9ydHMgPSBlbmdpbmUuY3JlYXRlU3RvcmUoc3RvcmFnZXMsIHBsdWdpbnMpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGpzb24yUGx1Z2luXG5cbmZ1bmN0aW9uIGpzb24yUGx1Z2luKCkge1xuXHRyZXF1aXJlKCcuL2xpYi9qc29uMicpXG5cdHJldHVybiB7fVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLy8gIGpzb24yLmpzXG4vLyAgMjAxNi0xMC0yOFxuLy8gIFB1YmxpYyBEb21haW4uXG4vLyAgTk8gV0FSUkFOVFkgRVhQUkVTU0VEIE9SIElNUExJRUQuIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlxuLy8gIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcbi8vICBUaGlzIGNvZGUgc2hvdWxkIGJlIG1pbmlmaWVkIGJlZm9yZSBkZXBsb3ltZW50LlxuLy8gIFNlZSBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL2pzbWluLmh0bWxcblxuLy8gIFVTRSBZT1VSIE9XTiBDT1BZLiBJVCBJUyBFWFRSRU1FTFkgVU5XSVNFIFRPIExPQUQgQ09ERSBGUk9NIFNFUlZFUlMgWU9VIERPXG4vLyAgTk9UIENPTlRST0wuXG5cbi8vICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbi8vICBhbmQgcGFyc2UuIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgRVM1IEpTT04gY2FwYWJpbGl0eSB0byBFUzMgc3lzdGVtcy5cbi8vICBJZiBhIHByb2plY3QgbWlnaHQgcnVuIG9uIElFOCBvciBlYXJsaWVyLCB0aGVuIHRoaXMgZmlsZSBzaG91bGQgYmUgaW5jbHVkZWQuXG4vLyAgVGhpcyBmaWxlIGRvZXMgbm90aGluZyBvbiBFUzUgc3lzdGVtcy5cblxuLy8gICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKVxuLy8gICAgICAgICAgdmFsdWUgICAgICAgYW55IEphdmFTY3JpcHQgdmFsdWUsIHVzdWFsbHkgYW4gb2JqZWN0IG9yIGFycmF5LlxuLy8gICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuLy8gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbi8vICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbi8vICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4vLyAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbi8vICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuLy8gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzIFwiXFx0XCIgb3IgXCImbmJzcDtcIiksXG4vLyAgICAgICAgICAgICAgICAgICAgICBpdCBjb250YWlucyB0aGUgY2hhcmFjdGVycyB1c2VkIHRvIGluZGVudCBhdCBlYWNoIGxldmVsLlxuLy8gICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG4vLyAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuLy8gICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4vLyAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbi8vICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbi8vICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuLy8gICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4vLyAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWUuXG5cbi8vICAgICAgICAgIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHNlcmlhbGl6ZSBEYXRlcyBhcyBJU08gc3RyaW5ncy5cblxuLy8gICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuIDwgMTApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjBcIiArIG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICA6IG47XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgXCItXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArIFwiVFwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgXCI6XCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyBcIjpcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArIFwiWlwiO1xuLy8gICAgICAgICAgICAgIH07XG5cbi8vICAgICAgICAgIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbCByZXBsYWNlciBtZXRob2QuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuLy8gICAgICAgICAga2V5IGFuZCB2YWx1ZSBvZiBlYWNoIG1lbWJlciwgd2l0aCB0aGlzIGJvdW5kIHRvIHRoZSBjb250YWluaW5nXG4vLyAgICAgICAgICBvYmplY3QuIFRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZyb20geW91ciBtZXRob2Qgd2lsbCBiZVxuLy8gICAgICAgICAgc2VyaWFsaXplZC4gSWYgeW91ciBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4gdGhlIG1lbWJlciB3aWxsXG4vLyAgICAgICAgICBiZSBleGNsdWRlZCBmcm9tIHRoZSBzZXJpYWxpemF0aW9uLlxuXG4vLyAgICAgICAgICBJZiB0aGUgcmVwbGFjZXIgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gaXQgd2lsbCBiZVxuLy8gICAgICAgICAgdXNlZCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc2VyaWFsaXplZC4gSXQgZmlsdGVycyB0aGUgcmVzdWx0c1xuLy8gICAgICAgICAgc3VjaCB0aGF0IG9ubHkgbWVtYmVycyB3aXRoIGtleXMgbGlzdGVkIGluIHRoZSByZXBsYWNlciBhcnJheSBhcmVcbi8vICAgICAgICAgIHN0cmluZ2lmaWVkLlxuXG4vLyAgICAgICAgICBWYWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBKU09OIHJlcHJlc2VudGF0aW9ucywgc3VjaCBhcyB1bmRlZmluZWQgb3Jcbi8vICAgICAgICAgIGZ1bmN0aW9ucywgd2lsbCBub3QgYmUgc2VyaWFsaXplZC4gU3VjaCB2YWx1ZXMgaW4gb2JqZWN0cyB3aWxsIGJlXG4vLyAgICAgICAgICBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2Vcbi8vICAgICAgICAgIGEgcmVwbGFjZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aG9zZSB3aXRoIEpTT04gdmFsdWVzLlxuXG4vLyAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4vLyAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuLy8gICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuLy8gICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbi8vICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbi8vICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4vLyAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4vLyAgICAgICAgICBFeGFtcGxlOlxuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiZVwiLHtcInBsdXJpYnVzXCI6XCJ1bnVtXCJ9XSdcblxuLy8gICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtcImVcIiwge3BsdXJpYnVzOiBcInVudW1cIn1dLCBudWxsLCBcIlxcdFwiKTtcbi8vICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlXG4vLyAgICAgICAgICAgICAgICAgID8gXCJEYXRlKFwiICsgdGhpc1trZXldICsgXCIpXCJcbi8vICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG4vLyAgICAgIEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcilcbi8vICAgICAgICAgIFRoaXMgbWV0aG9kIHBhcnNlcyBhIEpTT04gdGV4dCB0byBwcm9kdWNlIGFuIG9iamVjdCBvciBhcnJheS5cbi8vICAgICAgICAgIEl0IGNhbiB0aHJvdyBhIFN5bnRheEVycm9yIGV4Y2VwdGlvbi5cblxuLy8gICAgICAgICAgVGhlIG9wdGlvbmFsIHJldml2ZXIgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gZmlsdGVyIGFuZFxuLy8gICAgICAgICAgdHJhbnNmb3JtIHRoZSByZXN1bHRzLiBJdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBrZXlzIGFuZCB2YWx1ZXMsXG4vLyAgICAgICAgICBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB3aGF0IGl0IHJlY2VpdmVkLCB0aGVuIHRoZSBzdHJ1Y3R1cmUgaXMgbm90IG1vZGlmaWVkLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB1bmRlZmluZWQgdGhlbiB0aGUgbWVtYmVyIGlzIGRlbGV0ZWQuXG5cbi8vICAgICAgICAgIEV4YW1wbGU6XG5cbi8vICAgICAgICAgIC8vIFBhcnNlIHRoZSB0ZXh0LiBWYWx1ZXMgdGhhdCBsb29rIGxpa2UgSVNPIGRhdGUgc3RyaW5ncyB3aWxsXG4vLyAgICAgICAgICAvLyBiZSBjb252ZXJ0ZWQgdG8gRGF0ZSBvYmplY3RzLlxuXG4vLyAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKHRleHQsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgdmFyIGE7XG4vLyAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuLy8gICAgICAgICAgICAgICAgICBhID1cbi8vICAgL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbi8vICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgK2FbNV0sICthWzZdKSk7XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UoJ1tcIkRhdGUoMDkvMDkvMjAwMSlcIl0nLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHZhciBkO1xuLy8gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDUpID09PSBcIkRhdGUoXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIpXCIpIHtcbi8vICAgICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKHZhbHVlLnNsaWNlKDUsIC0xKSk7XG4vLyAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4vLyAgICAgICAgICB9KTtcblxuLy8gIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG4vLyAgcmVkaXN0cmlidXRlLlxuXG4vKmpzbGludFxuICAgIGV2YWwsIGZvciwgdGhpc1xuKi9cblxuLypwcm9wZXJ0eVxuICAgIEpTT04sIGFwcGx5LCBjYWxsLCBjaGFyQ29kZUF0LCBnZXRVVENEYXRlLCBnZXRVVENGdWxsWWVhciwgZ2V0VVRDSG91cnMsXG4gICAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICAgIGxhc3RJbmRleCwgbGVuZ3RoLCBwYXJzZSwgcHJvdG90eXBlLCBwdXNoLCByZXBsYWNlLCBzbGljZSwgc3RyaW5naWZ5LFxuICAgIHRlc3QsIHRvSlNPTiwgdG9TdHJpbmcsIHZhbHVlT2ZcbiovXG5cblxuLy8gQ3JlYXRlIGEgSlNPTiBvYmplY3Qgb25seSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gV2UgY3JlYXRlIHRoZVxuLy8gbWV0aG9kcyBpbiBhIGNsb3N1cmUgdG8gYXZvaWQgY3JlYXRpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cblxuaWYgKHR5cGVvZiBKU09OICE9PSBcIm9iamVjdFwiKSB7XG4gICAgSlNPTiA9IHt9O1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHJ4X29uZSA9IC9eW1xcXSw6e31cXHNdKiQvO1xuICAgIHZhciByeF90d28gPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xuICAgIHZhciByeF90aHJlZSA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbiAgICB2YXIgcnhfZm91ciA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbiAgICB2YXIgcnhfZXNjYXBhYmxlID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcbiAgICB2YXIgcnhfZGFuZ2Vyb3VzID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7XG5cbiAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgcmV0dXJuIG4gPCAxMFxuICAgICAgICAgICAgPyBcIjBcIiArIG5cbiAgICAgICAgICAgIDogbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aGlzX3ZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09IFwiZnVuY3Rpb25cIikge1xuXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHRoaXMudmFsdWVPZigpKVxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICsgXCJUXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSArIFwiWlwiXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgICAgIE51bWJlci5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICAgIH1cblxuICAgIHZhciBnYXA7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgbWV0YTtcbiAgICB2YXIgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIHJ4X2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcnhfZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKVxuICAgICAgICAgICAgPyBcIlxcXCJcIiArIHN0cmluZy5yZXBsYWNlKHJ4X2VzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gY1xuICAgICAgICAgICAgICAgICAgICA6IFwiXFxcXHVcIiArIChcIjAwMDBcIiArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH0pICsgXCJcXFwiXCJcbiAgICAgICAgICAgIDogXCJcXFwiXCIgKyBzdHJpbmcgKyBcIlxcXCJcIjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuXG4vLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICAgICAgdmFyIGk7ICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIHZhciBrOyAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdmFyIHY7ICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBtaW5kID0gZ2FwO1xuICAgICAgICB2YXIgcGFydGlhbDtcbiAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbi8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgIH1cblxuLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4vLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuXG4vLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogXCJudWxsXCI7XG5cbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSBcIm51bGxcIi4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzIFwib2JqZWN0XCIsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3Jcbi8vIG51bGwuXG5cbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIixcbi8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbi8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBcIltdXCJcbiAgICAgICAgICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJbXFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIl1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIltcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbi8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCI6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBcInt9XCJcbiAgICAgICAgICAgICAgICA6IGdhcFxuICAgICAgICAgICAgICAgICAgICA/IFwie1xcblwiICsgZ2FwICsgcGFydGlhbC5qb2luKFwiLFxcblwiICsgZ2FwKSArIFwiXFxuXCIgKyBtaW5kICsgXCJ9XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIntcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgIFwiXFxiXCI6IFwiXFxcXGJcIixcbiAgICAgICAgICAgIFwiXFx0XCI6IFwiXFxcXHRcIixcbiAgICAgICAgICAgIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgICAgICAgICAgIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgICAgICAgICAgIFwiXFxyXCI6IFwiXFxcXHJcIixcbiAgICAgICAgICAgIFwiXFxcIlwiOiBcIlxcXFxcXFwiXCIsXG4gICAgICAgICAgICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG4gICAgICAgIH07XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gXCJcIjtcbiAgICAgICAgICAgIGluZGVudCA9IFwiXCI7XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbi8vIG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4vLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICAgICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTi5zdHJpbmdpZnlcIik7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgXCJcIi5cbi8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgICAgICAgIHJldHVybiBzdHIoXCJcIiwge1wiXCI6IHZhbHVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcblxuLy8gVGhlIHBhcnNlIG1ldGhvZCB0YWtlcyBhIHRleHQgYW5kIGFuIG9wdGlvbmFsIHJldml2ZXIgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4vLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgICAgICAgIHZhciBqO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG5cbi8vIFRoZSB3YWxrIG1ldGhvZCBpcyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgc29cbi8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICAgIHZhciB2O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuXG4vLyBQYXJzaW5nIGhhcHBlbnMgaW4gZm91ciBzdGFnZXMuIEluIHRoZSBmaXJzdCBzdGFnZSwgd2UgcmVwbGFjZSBjZXJ0YWluXG4vLyBVbmljb2RlIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLiBKYXZhU2NyaXB0IGhhbmRsZXMgbWFueSBjaGFyYWN0ZXJzXG4vLyBpbmNvcnJlY3RseSwgZWl0aGVyIHNpbGVudGx5IGRlbGV0aW5nIHRoZW0sIG9yIHRyZWF0aW5nIHRoZW0gYXMgbGluZSBlbmRpbmdzLlxuXG4gICAgICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgcnhfZGFuZ2Vyb3VzLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAocnhfZGFuZ2Vyb3VzLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ4X2Rhbmdlcm91cywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHVcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiMDAwMFwiICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCBcIigpXCIgYW5kIFwibmV3XCJcbi8vIGJlY2F1c2UgdGhleSBjYW4gY2F1c2UgaW52b2NhdGlvbiwgYW5kIFwiPVwiIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoIFwiQFwiIChhIG5vbi1KU09OIGNoYXJhY3RlcikuIFNlY29uZCwgd2Vcbi8vIHJlcGxhY2UgYWxsIHNpbXBsZSB2YWx1ZSB0b2tlbnMgd2l0aCBcIl1cIiBjaGFyYWN0ZXJzLiBUaGlyZCwgd2UgZGVsZXRlIGFsbFxuLy8gb3BlbiBicmFja2V0cyB0aGF0IGZvbGxvdyBhIGNvbG9uIG9yIGNvbW1hIG9yIHRoYXQgYmVnaW4gdGhlIHRleHQuIEZpbmFsbHksXG4vLyB3ZSBsb29rIHRvIHNlZSB0aGF0IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhcmUgb25seSB3aGl0ZXNwYWNlIG9yIFwiXVwiIG9yXG4vLyBcIixcIiBvciBcIjpcIiBvciBcIntcIiBvciBcIn1cIi4gSWYgdGhhdCBpcyBzbywgdGhlbiB0aGUgdGV4dCBpcyBzYWZlIGZvciBldmFsLlxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcnhfb25lLnRlc3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ4X3R3bywgXCJAXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF90aHJlZSwgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF9mb3VyLCBcIlwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlIFwie1wiIG9wZXJhdG9yIGlzIHN1YmplY3QgdG8gYSBzeW50YWN0aWMgYW1iaWd1aXR5XG4vLyBpbiBKYXZhU2NyaXB0OiBpdCBjYW4gYmVnaW4gYSBibG9jayBvciBhbiBvYmplY3QgbGl0ZXJhbC4gV2Ugd3JhcCB0aGUgdGV4dFxuLy8gaW4gcGFyZW5zIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5LlxuXG4gICAgICAgICAgICAgICAgaiA9IGV2YWwoXCIoXCIgKyB0ZXh0ICsgXCIpXCIpO1xuXG4vLyBJbiB0aGUgb3B0aW9uYWwgZm91cnRoIHN0YWdlLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLCBwYXNzaW5nXG4vLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgcmV2aXZlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICA/IHdhbGsoe1wiXCI6IGp9LCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICA6IGo7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZSB0ZXh0IGlzIG5vdCBKU09OIHBhcnNlYWJsZSwgdGhlbiBhIFN5bnRheEVycm9yIGlzIHRocm93bi5cblxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiSlNPTi5wYXJzZVwiKTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbnZhciBzbGljZSA9IHV0aWwuc2xpY2VcbnZhciBwbHVjayA9IHV0aWwucGx1Y2tcbnZhciBlYWNoID0gdXRpbC5lYWNoXG52YXIgYmluZCA9IHV0aWwuYmluZFxudmFyIGNyZWF0ZSA9IHV0aWwuY3JlYXRlXG52YXIgaXNMaXN0ID0gdXRpbC5pc0xpc3RcbnZhciBpc0Z1bmN0aW9uID0gdXRpbC5pc0Z1bmN0aW9uXG52YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcmVhdGVTdG9yZTogY3JlYXRlU3RvcmVcbn1cblxudmFyIHN0b3JlQVBJID0ge1xuXHR2ZXJzaW9uOiAnMi4wLjEyJyxcblx0ZW5hYmxlZDogZmFsc2UsXG5cdFxuXHQvLyBnZXQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGtleS4gSWYgdGhhdCB2YWx1ZVxuXHQvLyBpcyB1bmRlZmluZWQsIGl0IHJldHVybnMgb3B0aW9uYWxEZWZhdWx0VmFsdWUgaW5zdGVhZC5cblx0Z2V0OiBmdW5jdGlvbihrZXksIG9wdGlvbmFsRGVmYXVsdFZhbHVlKSB7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLnN0b3JhZ2UucmVhZCh0aGlzLl9uYW1lc3BhY2VQcmVmaXggKyBrZXkpXG5cdFx0cmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplKGRhdGEsIG9wdGlvbmFsRGVmYXVsdFZhbHVlKVxuXHR9LFxuXG5cdC8vIHNldCB3aWxsIHN0b3JlIHRoZSBnaXZlbiB2YWx1ZSBhdCBrZXkgYW5kIHJldHVybnMgdmFsdWUuXG5cdC8vIENhbGxpbmcgc2V0IHdpdGggdmFsdWUgPT09IHVuZGVmaW5lZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgcmVtb3ZlLlxuXHRzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlKGtleSlcblx0XHR9XG5cdFx0dGhpcy5zdG9yYWdlLndyaXRlKHRoaXMuX25hbWVzcGFjZVByZWZpeCArIGtleSwgdGhpcy5fc2VyaWFsaXplKHZhbHVlKSlcblx0XHRyZXR1cm4gdmFsdWVcblx0fSxcblxuXHQvLyByZW1vdmUgZGVsZXRlcyB0aGUga2V5IGFuZCB2YWx1ZSBzdG9yZWQgYXQgdGhlIGdpdmVuIGtleS5cblx0cmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcblx0XHR0aGlzLnN0b3JhZ2UucmVtb3ZlKHRoaXMuX25hbWVzcGFjZVByZWZpeCArIGtleSlcblx0fSxcblxuXHQvLyBlYWNoIHdpbGwgY2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBrZXktdmFsdWUgcGFpclxuXHQvLyBpbiB0aGlzIHN0b3JlLlxuXHRlYWNoOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpc1xuXHRcdHRoaXMuc3RvcmFnZS5lYWNoKGZ1bmN0aW9uKHZhbCwgbmFtZXNwYWNlZEtleSkge1xuXHRcdFx0Y2FsbGJhY2suY2FsbChzZWxmLCBzZWxmLl9kZXNlcmlhbGl6ZSh2YWwpLCAobmFtZXNwYWNlZEtleSB8fCAnJykucmVwbGFjZShzZWxmLl9uYW1lc3BhY2VSZWdleHAsICcnKSlcblx0XHR9KVxuXHR9LFxuXG5cdC8vIGNsZWFyQWxsIHdpbGwgcmVtb3ZlIGFsbCB0aGUgc3RvcmVkIGtleS12YWx1ZSBwYWlycyBpbiB0aGlzIHN0b3JlLlxuXHRjbGVhckFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9yYWdlLmNsZWFyQWxsKClcblx0fSxcblxuXHQvLyBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4ndCBsaXZlIGluIHBsdWdpbnNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0Ly8gaGFzTmFtZXNwYWNlIHJldHVybnMgdHJ1ZSBpZiB0aGlzIHN0b3JlIGluc3RhbmNlIGhhcyB0aGUgZ2l2ZW4gbmFtZXNwYWNlLlxuXHRoYXNOYW1lc3BhY2U6IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuXHRcdHJldHVybiAodGhpcy5fbmFtZXNwYWNlUHJlZml4ID09ICdfX3N0b3JlanNfJytuYW1lc3BhY2UrJ18nKVxuXHR9LFxuXG5cdC8vIGNyZWF0ZVN0b3JlIGNyZWF0ZXMgYSBzdG9yZS5qcyBpbnN0YW5jZSB3aXRoIHRoZSBmaXJzdFxuXHQvLyBmdW5jdGlvbmluZyBzdG9yYWdlIGluIHRoZSBsaXN0IG9mIHN0b3JhZ2UgY2FuZGlkYXRlcyxcblx0Ly8gYW5kIGFwcGxpZXMgdGhlIHRoZSBnaXZlbiBtaXhpbnMgdG8gdGhlIGluc3RhbmNlLlxuXHRjcmVhdGVTdG9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZVN0b3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0fSxcblx0XG5cdGFkZFBsdWdpbjogZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0dGhpcy5fYWRkUGx1Z2luKHBsdWdpbilcblx0fSxcblx0XG5cdG5hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZVN0b3JlKHRoaXMuc3RvcmFnZSwgdGhpcy5wbHVnaW5zLCBuYW1lc3BhY2UpXG5cdH1cbn1cblxuZnVuY3Rpb24gX3dhcm4oKSB7XG5cdHZhciBfY29uc29sZSA9ICh0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJyA/IG51bGwgOiBjb25zb2xlKVxuXHRpZiAoIV9jb25zb2xlKSB7IHJldHVybiB9XG5cdHZhciBmbiA9IChfY29uc29sZS53YXJuID8gX2NvbnNvbGUud2FybiA6IF9jb25zb2xlLmxvZylcblx0Zm4uYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RvcmUoc3RvcmFnZXMsIHBsdWdpbnMsIG5hbWVzcGFjZSkge1xuXHRpZiAoIW5hbWVzcGFjZSkge1xuXHRcdG5hbWVzcGFjZSA9ICcnXG5cdH1cblx0aWYgKHN0b3JhZ2VzICYmICFpc0xpc3Qoc3RvcmFnZXMpKSB7XG5cdFx0c3RvcmFnZXMgPSBbc3RvcmFnZXNdXG5cdH1cblx0aWYgKHBsdWdpbnMgJiYgIWlzTGlzdChwbHVnaW5zKSkge1xuXHRcdHBsdWdpbnMgPSBbcGx1Z2luc11cblx0fVxuXG5cdHZhciBuYW1lc3BhY2VQcmVmaXggPSAobmFtZXNwYWNlID8gJ19fc3RvcmVqc18nK25hbWVzcGFjZSsnXycgOiAnJylcblx0dmFyIG5hbWVzcGFjZVJlZ2V4cCA9IChuYW1lc3BhY2UgPyBuZXcgUmVnRXhwKCdeJytuYW1lc3BhY2VQcmVmaXgpIDogbnVsbClcblx0dmFyIGxlZ2FsTmFtZXNwYWNlcyA9IC9eW2EtekEtWjAtOV9cXC1dKiQvIC8vIGFscGhhLW51bWVyaWMgKyB1bmRlcnNjb3JlIGFuZCBkYXNoXG5cdGlmICghbGVnYWxOYW1lc3BhY2VzLnRlc3QobmFtZXNwYWNlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignc3RvcmUuanMgbmFtZXNwYWNlcyBjYW4gb25seSBoYXZlIGFscGhhbnVtZXJpY3MgKyB1bmRlcnNjb3JlcyBhbmQgZGFzaGVzJylcblx0fVxuXHRcblx0dmFyIF9wcml2YXRlU3RvcmVQcm9wcyA9IHtcblx0XHRfbmFtZXNwYWNlUHJlZml4OiBuYW1lc3BhY2VQcmVmaXgsXG5cdFx0X25hbWVzcGFjZVJlZ2V4cDogbmFtZXNwYWNlUmVnZXhwLFxuXG5cdFx0X3Rlc3RTdG9yYWdlOiBmdW5jdGlvbihzdG9yYWdlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgdGVzdFN0ciA9ICdfX3N0b3JlanNfX3Rlc3RfXydcblx0XHRcdFx0c3RvcmFnZS53cml0ZSh0ZXN0U3RyLCB0ZXN0U3RyKVxuXHRcdFx0XHR2YXIgb2sgPSAoc3RvcmFnZS5yZWFkKHRlc3RTdHIpID09PSB0ZXN0U3RyKVxuXHRcdFx0XHRzdG9yYWdlLnJlbW92ZSh0ZXN0U3RyKVxuXHRcdFx0XHRyZXR1cm4gb2tcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2Fzc2lnblBsdWdpbkZuUHJvcDogZnVuY3Rpb24ocGx1Z2luRm5Qcm9wLCBwcm9wTmFtZSkge1xuXHRcdFx0dmFyIG9sZEZuID0gdGhpc1twcm9wTmFtZV1cblx0XHRcdHRoaXNbcHJvcE5hbWVdID0gZnVuY3Rpb24gcGx1Z2luRm4oKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAwKVxuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXNcblxuXHRcdFx0XHQvLyBzdXBlcl9mbiBjYWxscyB0aGUgb2xkIGZ1bmN0aW9uIHdoaWNoIHdhcyBvdmVyd3JpdHRlbiBieVxuXHRcdFx0XHQvLyB0aGlzIG1peGluLlxuXHRcdFx0XHRmdW5jdGlvbiBzdXBlcl9mbigpIHtcblx0XHRcdFx0XHRpZiAoIW9sZEZuKSB7IHJldHVybiB9XG5cdFx0XHRcdFx0ZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZywgaSkge1xuXHRcdFx0XHRcdFx0YXJnc1tpXSA9IGFyZ1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuIG9sZEZuLmFwcGx5KHNlbGYsIGFyZ3MpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHaXZlIG1peGluZyBmdW5jdGlvbiBhY2Nlc3MgdG8gc3VwZXJfZm4gYnkgcHJlZml4aW5nIGFsbCBtaXhpbiBmdW5jdGlvblxuXHRcdFx0XHQvLyBhcmd1bWVudHMgd2l0aCBzdXBlcl9mbi5cblx0XHRcdFx0dmFyIG5ld0ZuQXJncyA9IFtzdXBlcl9mbl0uY29uY2F0KGFyZ3MpXG5cblx0XHRcdFx0cmV0dXJuIHBsdWdpbkZuUHJvcC5hcHBseShzZWxmLCBuZXdGbkFyZ3MpXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iailcblx0XHR9LFxuXG5cdFx0X2Rlc2VyaWFsaXplOiBmdW5jdGlvbihzdHJWYWwsIGRlZmF1bHRWYWwpIHtcblx0XHRcdGlmICghc3RyVmFsKSB7IHJldHVybiBkZWZhdWx0VmFsIH1cblx0XHRcdC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgYSByYXcgc3RyaW5nIHZhbHVlIGhhcyBiZWVuIHByZXZpb3VzbHkgc3RvcmVkXG5cdFx0XHQvLyBpbiBhIHN0b3JhZ2Ugd2l0aG91dCB1c2luZyBzdG9yZS5qcywgbWVhbmluZyBpdCB3aWxsIGJlIGEgcmF3XG5cdFx0XHQvLyBzdHJpbmcgdmFsdWUgaW5zdGVhZCBvZiBhIEpTT04gc2VyaWFsaXplZCBzdHJpbmcuIEJ5IGRlZmF1bHRpbmdcblx0XHRcdC8vIHRvIHRoZSByYXcgc3RyaW5nIHZhbHVlIGluIGNhc2Ugb2YgYSBKU09OIHBhcnNlIGVycm9yLCB3ZSBhbGxvd1xuXHRcdFx0Ly8gZm9yIHBhc3Qgc3RvcmVkIHZhbHVlcyB0byBiZSBmb3J3YXJkcy1jb21wYXRpYmxlIHdpdGggc3RvcmUuanNcblx0XHRcdHZhciB2YWwgPSAnJ1xuXHRcdFx0dHJ5IHsgdmFsID0gSlNPTi5wYXJzZShzdHJWYWwpIH1cblx0XHRcdGNhdGNoKGUpIHsgdmFsID0gc3RyVmFsIH1cblxuXHRcdFx0cmV0dXJuICh2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IGRlZmF1bHRWYWwpXG5cdFx0fSxcblx0XHRcblx0XHRfYWRkU3RvcmFnZTogZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdFx0aWYgKHRoaXMuZW5hYmxlZCkgeyByZXR1cm4gfVxuXHRcdFx0aWYgKHRoaXMuX3Rlc3RTdG9yYWdlKHN0b3JhZ2UpKSB7XG5cdFx0XHRcdHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2Vcblx0XHRcdFx0dGhpcy5lbmFibGVkID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfYWRkUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdHZhciBzZWxmID0gdGhpc1xuXG5cdFx0XHQvLyBJZiB0aGUgcGx1Z2luIGlzIGFuIGFycmF5LCB0aGVuIGFkZCBhbGwgcGx1Z2lucyBpbiB0aGUgYXJyYXkuXG5cdFx0XHQvLyBUaGlzIGFsbG93cyBmb3IgYSBwbHVnaW4gdG8gZGVwZW5kIG9uIG90aGVyIHBsdWdpbnMuXG5cdFx0XHRpZiAoaXNMaXN0KHBsdWdpbikpIHtcblx0XHRcdFx0ZWFjaChwbHVnaW4sIGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0XHRcdHNlbGYuX2FkZFBsdWdpbihwbHVnaW4pXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIGFsbCBwbHVnaW5zIHdlJ3ZlIHNlZW4gc28gZmFyLCBzbyB0aGF0IHdlXG5cdFx0XHQvLyBkb24ndCBhZGQgYW55IG9mIHRoZW0gdHdpY2UuXG5cdFx0XHR2YXIgc2VlblBsdWdpbiA9IHBsdWNrKHRoaXMucGx1Z2lucywgZnVuY3Rpb24oc2VlblBsdWdpbikge1xuXHRcdFx0XHRyZXR1cm4gKHBsdWdpbiA9PT0gc2VlblBsdWdpbilcblx0XHRcdH0pXG5cdFx0XHRpZiAoc2VlblBsdWdpbikge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHRoaXMucGx1Z2lucy5wdXNoKHBsdWdpbilcblxuXHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgcGx1Z2luIGlzIHByb3Blcmx5IGZvcm1lZFxuXHRcdFx0aWYgKCFpc0Z1bmN0aW9uKHBsdWdpbikpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQbHVnaW5zIG11c3QgYmUgZnVuY3Rpb24gdmFsdWVzIHRoYXQgcmV0dXJuIG9iamVjdHMnKVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGx1Z2luUHJvcGVydGllcyA9IHBsdWdpbi5jYWxsKHRoaXMpXG5cdFx0XHRpZiAoIWlzT2JqZWN0KHBsdWdpblByb3BlcnRpZXMpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUGx1Z2lucyBtdXN0IHJldHVybiBhbiBvYmplY3Qgb2YgZnVuY3Rpb24gcHJvcGVydGllcycpXG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0aGUgcGx1Z2luIGZ1bmN0aW9uIHByb3BlcnRpZXMgdG8gdGhpcyBzdG9yZSBpbnN0YW5jZS5cblx0XHRcdGVhY2gocGx1Z2luUHJvcGVydGllcywgZnVuY3Rpb24ocGx1Z2luRm5Qcm9wLCBwcm9wTmFtZSkge1xuXHRcdFx0XHRpZiAoIWlzRnVuY3Rpb24ocGx1Z2luRm5Qcm9wKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQmFkIHBsdWdpbiBwcm9wZXJ0eTogJytwcm9wTmFtZSsnIGZyb20gcGx1Z2luICcrcGx1Z2luLm5hbWUrJy4gUGx1Z2lucyBzaG91bGQgb25seSByZXR1cm4gZnVuY3Rpb25zLicpXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5fYXNzaWduUGx1Z2luRm5Qcm9wKHBsdWdpbkZuUHJvcCwgcHJvcE5hbWUpXG5cdFx0XHR9KVxuXHRcdH0sXG5cdFx0XG5cdFx0Ly8gUHV0IGRlcHJlY2F0ZWQgcHJvcGVydGllcyBpbiB0aGUgcHJpdmF0ZSBBUEksIHNvIGFzIHRvIG5vdCBleHBvc2UgaXQgdG8gYWNjaWRlbnRpYWxcblx0XHQvLyBkaXNjb3ZlcnkgdGhyb3VnaCBpbnNwZWN0aW9uIG9mIHRoZSBzdG9yZSBvYmplY3QuXG5cdFx0XG5cdFx0Ly8gRGVwcmVjYXRlZDogYWRkU3RvcmFnZVxuXHRcdGFkZFN0b3JhZ2U6IGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRcdF93YXJuKCdzdG9yZS5hZGRTdG9yYWdlKHN0b3JhZ2UpIGlzIGRlcHJlY2F0ZWQuIFVzZSBjcmVhdGVTdG9yZShbc3RvcmFnZXNdKScpXG5cdFx0XHR0aGlzLl9hZGRTdG9yYWdlKHN0b3JhZ2UpXG5cdFx0fVxuXHR9XG5cblx0dmFyIHN0b3JlID0gY3JlYXRlKF9wcml2YXRlU3RvcmVQcm9wcywgc3RvcmVBUEksIHtcblx0XHRwbHVnaW5zOiBbXVxuXHR9KVxuXHRzdG9yZS5yYXcgPSB7fVxuXHRlYWNoKHN0b3JlLCBmdW5jdGlvbihwcm9wLCBwcm9wTmFtZSkge1xuXHRcdGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG5cdFx0XHRzdG9yZS5yYXdbcHJvcE5hbWVdID0gYmluZChzdG9yZSwgcHJvcClcdFx0XHRcblx0XHR9XG5cdH0pXG5cdGVhY2goc3RvcmFnZXMsIGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRzdG9yZS5fYWRkU3RvcmFnZShzdG9yYWdlKVxuXHR9KVxuXHRlYWNoKHBsdWdpbnMsIGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdHN0b3JlLl9hZGRQbHVnaW4ocGx1Z2luKVxuXHR9KVxuXHRyZXR1cm4gc3RvcmVcbn1cbiIsInZhciBhc3NpZ24gPSBtYWtlX2Fzc2lnbigpXG52YXIgY3JlYXRlID0gbWFrZV9jcmVhdGUoKVxudmFyIHRyaW0gPSBtYWtlX3RyaW0oKVxudmFyIEdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFzc2lnbjogYXNzaWduLFxuXHRjcmVhdGU6IGNyZWF0ZSxcblx0dHJpbTogdHJpbSxcblx0YmluZDogYmluZCxcblx0c2xpY2U6IHNsaWNlLFxuXHRlYWNoOiBlYWNoLFxuXHRtYXA6IG1hcCxcblx0cGx1Y2s6IHBsdWNrLFxuXHRpc0xpc3Q6IGlzTGlzdCxcblx0aXNGdW5jdGlvbjogaXNGdW5jdGlvbixcblx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuXHRHbG9iYWw6IEdsb2JhbFxufVxuXG5mdW5jdGlvbiBtYWtlX2Fzc2lnbigpIHtcblx0aWYgKE9iamVjdC5hc3NpZ24pIHtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnblxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmdW5jdGlvbiBzaGltQXNzaWduKG9iaiwgcHJvcHMxLCBwcm9wczIsIGV0Yykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZWFjaChPYmplY3QoYXJndW1lbnRzW2ldKSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0XHRcdFx0XHRvYmpba2V5XSA9IHZhbFxuXHRcdFx0XHR9KVxuXHRcdFx0fVx0XHRcdFxuXHRcdFx0cmV0dXJuIG9ialxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBtYWtlX2NyZWF0ZSgpIHtcblx0aWYgKE9iamVjdC5jcmVhdGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlKG9iaiwgYXNzaWduUHJvcHMxLCBhc3NpZ25Qcm9wczIsIGV0Yykge1xuXHRcdFx0dmFyIGFzc2lnbkFyZ3NMaXN0ID0gc2xpY2UoYXJndW1lbnRzLCAxKVxuXHRcdFx0cmV0dXJuIGFzc2lnbi5hcHBseSh0aGlzLCBbT2JqZWN0LmNyZWF0ZShvYmopXS5jb25jYXQoYXNzaWduQXJnc0xpc3QpKVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmdW5jdGlvbiBGKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbm5lci1kZWNsYXJhdGlvbnNcblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlKG9iaiwgYXNzaWduUHJvcHMxLCBhc3NpZ25Qcm9wczIsIGV0Yykge1xuXHRcdFx0dmFyIGFzc2lnbkFyZ3NMaXN0ID0gc2xpY2UoYXJndW1lbnRzLCAxKVxuXHRcdFx0Ri5wcm90b3R5cGUgPSBvYmpcblx0XHRcdHJldHVybiBhc3NpZ24uYXBwbHkodGhpcywgW25ldyBGKCldLmNvbmNhdChhc3NpZ25BcmdzTGlzdCkpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIG1ha2VfdHJpbSgpIHtcblx0aWYgKFN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiB0cmltKHN0cikge1xuXHRcdFx0cmV0dXJuIFN0cmluZy5wcm90b3R5cGUudHJpbS5jYWxsKHN0cilcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJylcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYmluZChvYmosIGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNsaWNlKGFyciwgaW5kZXgpIHtcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyciwgaW5kZXggfHwgMClcbn1cblxuZnVuY3Rpb24gZWFjaChvYmosIGZuKSB7XG5cdHBsdWNrKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0XHRmbih2YWwsIGtleSlcblx0XHRyZXR1cm4gZmFsc2Vcblx0fSlcbn1cblxuZnVuY3Rpb24gbWFwKG9iaiwgZm4pIHtcblx0dmFyIHJlcyA9IChpc0xpc3Qob2JqKSA/IFtdIDoge30pXG5cdHBsdWNrKG9iaiwgZnVuY3Rpb24odiwgaykge1xuXHRcdHJlc1trXSA9IGZuKHYsIGspXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH0pXG5cdHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcGx1Y2sob2JqLCBmbikge1xuXHRpZiAoaXNMaXN0KG9iaikpIHtcblx0XHRmb3IgKHZhciBpPTA7IGk8b2JqLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZm4ob2JqW2ldLCBpKSkge1xuXHRcdFx0XHRyZXR1cm4gb2JqW2ldXG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRpZiAoZm4ob2JqW2tleV0sIGtleSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqW2tleV1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBpc0xpc3QodmFsKSB7XG5cdHJldHVybiAodmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbCAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwubGVuZ3RoID09ICdudW1iZXInKVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuXHRyZXR1cm4gdmFsICYmIHt9LnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcblx0cmV0dXJuIHZhbCAmJiB7fS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcblx0Ly8gTGlzdGVkIGluIG9yZGVyIG9mIHVzYWdlIHByZWZlcmVuY2Vcblx0cmVxdWlyZSgnLi9sb2NhbFN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9vbGRGRi1nbG9iYWxTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vb2xkSUUtdXNlckRhdGFTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vY29va2llU3RvcmFnZScpLFxuXHRyZXF1aXJlKCcuL3Nlc3Npb25TdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vbWVtb3J5U3RvcmFnZScpXG5dXG4iLCIvLyBjb29raWVTdG9yYWdlIGlzIHVzZWZ1bCBTYWZhcmkgcHJpdmF0ZSBicm93c2VyIG1vZGUsIHdoZXJlIGxvY2FsU3RvcmFnZVxuLy8gZG9lc24ndCB3b3JrIGJ1dCBjb29raWVzIGRvLiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGFkb3B0ZWQgZnJvbVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N0b3JhZ2UvTG9jYWxTdG9yYWdlXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG52YXIgdHJpbSA9IHV0aWwudHJpbVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ2Nvb2tpZVN0b3JhZ2UnLFxuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGUsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbnZhciBkb2MgPSBHbG9iYWwuZG9jdW1lbnRcblxuZnVuY3Rpb24gcmVhZChrZXkpIHtcblx0aWYgKCFrZXkgfHwgIV9oYXMoa2V5KSkgeyByZXR1cm4gbnVsbCB9XG5cdHZhciByZWdleHBTdHIgPSBcIig/Ol58Lio7XFxcXHMqKVwiICtcblx0XHRlc2NhcGUoa2V5KS5yZXBsYWNlKC9bXFwtXFwuXFwrXFwqXS9nLCBcIlxcXFwkJlwiKSArXG5cdFx0XCJcXFxccypcXFxcPVxcXFxzKigoPzpbXjtdKD8hOykpKlteO10/KS4qXCJcblx0cmV0dXJuIHVuZXNjYXBlKGRvYy5jb29raWUucmVwbGFjZShuZXcgUmVnRXhwKHJlZ2V4cFN0ciksIFwiJDFcIikpXG59XG5cbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcblx0dmFyIGNvb2tpZXMgPSBkb2MuY29va2llLnNwbGl0KC87ID8vZylcblx0Zm9yICh2YXIgaSA9IGNvb2tpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRpZiAoIXRyaW0oY29va2llc1tpXSkpIHtcblx0XHRcdGNvbnRpbnVlXG5cdFx0fVxuXHRcdHZhciBrdnAgPSBjb29raWVzW2ldLnNwbGl0KCc9Jylcblx0XHR2YXIga2V5ID0gdW5lc2NhcGUoa3ZwWzBdKVxuXHRcdHZhciB2YWwgPSB1bmVzY2FwZShrdnBbMV0pXG5cdFx0Y2FsbGJhY2sodmFsLCBrZXkpXG5cdH1cbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdGlmKCFrZXkpIHsgcmV0dXJuIH1cblx0ZG9jLmNvb2tpZSA9IGVzY2FwZShrZXkpICsgXCI9XCIgKyBlc2NhcGUoZGF0YSkgKyBcIjsgZXhwaXJlcz1UdWUsIDE5IEphbiAyMDM4IDAzOjE0OjA3IEdNVDsgcGF0aD0vXCJcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRpZiAoIWtleSB8fCAhX2hhcyhrZXkpKSB7XG5cdFx0cmV0dXJuXG5cdH1cblx0ZG9jLmNvb2tpZSA9IGVzY2FwZShrZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UOyBwYXRoPS9cIlxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0ZWFjaChmdW5jdGlvbihfLCBrZXkpIHtcblx0XHRyZW1vdmUoa2V5KVxuXHR9KVxufVxuXG5mdW5jdGlvbiBfaGFzKGtleSkge1xuXHRyZXR1cm4gKG5ldyBSZWdFeHAoXCIoPzpefDtcXFxccyopXCIgKyBlc2NhcGUoa2V5KS5yZXBsYWNlKC9bXFwtXFwuXFwrXFwqXS9nLCBcIlxcXFwkJlwiKSArIFwiXFxcXHMqXFxcXD1cIikpLnRlc3QoZG9jLmNvb2tpZSlcbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnbG9jYWxTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG5mdW5jdGlvbiBsb2NhbFN0b3JhZ2UoKSB7XG5cdHJldHVybiBHbG9iYWwubG9jYWxTdG9yYWdlXG59XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5nZXRJdGVtKGtleSlcbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgZGF0YSlcbn1cblxuZnVuY3Rpb24gZWFjaChmbikge1xuXHRmb3IgKHZhciBpID0gbG9jYWxTdG9yYWdlKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gbG9jYWxTdG9yYWdlKCkua2V5KGkpXG5cdFx0Zm4ocmVhZChrZXkpLCBrZXkpXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkucmVtb3ZlSXRlbShrZXkpXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkuY2xlYXIoKVxufVxuIiwiLy8gbWVtb3J5U3RvcmFnZSBpcyBhIHVzZWZ1bCBsYXN0IGZhbGxiYWNrIHRvIGVuc3VyZSB0aGF0IHRoZSBzdG9yZVxuLy8gaXMgZnVuY3Rpb25zIChtZWFuaW5nIHN0b3JlLmdldCgpLCBzdG9yZS5zZXQoKSwgZXRjIHdpbGwgYWxsIGZ1bmN0aW9uKS5cbi8vIEhvd2V2ZXIsIHN0b3JlZCB2YWx1ZXMgd2lsbCBub3QgcGVyc2lzdCB3aGVuIHRoZSBicm93c2VyIG5hdmlnYXRlcyB0b1xuLy8gYSBuZXcgcGFnZSBvciByZWxvYWRzIHRoZSBjdXJyZW50IHBhZ2UuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnbWVtb3J5U3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxudmFyIG1lbW9yeVN0b3JhZ2UgPSB7fVxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRyZXR1cm4gbWVtb3J5U3RvcmFnZVtrZXldXG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRtZW1vcnlTdG9yYWdlW2tleV0gPSBkYXRhXG59XG5cbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcblx0Zm9yICh2YXIga2V5IGluIG1lbW9yeVN0b3JhZ2UpIHtcblx0XHRpZiAobWVtb3J5U3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRjYWxsYmFjayhtZW1vcnlTdG9yYWdlW2tleV0sIGtleSlcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRkZWxldGUgbWVtb3J5U3RvcmFnZVtrZXldXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKGtleSkge1xuXHRtZW1vcnlTdG9yYWdlID0ge31cbn1cbiIsIi8vIG9sZEZGLWdsb2JhbFN0b3JhZ2UgcHJvdmlkZXMgc3RvcmFnZSBmb3IgRmlyZWZveFxuLy8gdmVyc2lvbnMgNiBhbmQgNywgd2hlcmUgbm8gbG9jYWxTdG9yYWdlLCBldGNcbi8vIGlzIGF2YWlsYWJsZS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpXG52YXIgR2xvYmFsID0gdXRpbC5HbG9iYWxcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdvbGRGRi1nbG9iYWxTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgZ2xvYmFsU3RvcmFnZSA9IEdsb2JhbC5nbG9iYWxTdG9yYWdlXG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBnbG9iYWxTdG9yYWdlW2tleV1cbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdGdsb2JhbFN0b3JhZ2Vba2V5XSA9IGRhdGFcbn1cblxuZnVuY3Rpb24gZWFjaChmbikge1xuXHRmb3IgKHZhciBpID0gZ2xvYmFsU3RvcmFnZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdHZhciBrZXkgPSBnbG9iYWxTdG9yYWdlLmtleShpKVxuXHRcdGZuKGdsb2JhbFN0b3JhZ2Vba2V5XSwga2V5KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0cmV0dXJuIGdsb2JhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRlYWNoKGZ1bmN0aW9uKGtleSwgXykge1xuXHRcdGRlbGV0ZSBnbG9iYWxTdG9yYWdlW2tleV1cblx0fSlcbn1cbiIsIi8vIG9sZElFLXVzZXJEYXRhU3RvcmFnZSBwcm92aWRlcyBzdG9yYWdlIGZvciBJbnRlcm5ldCBFeHBsb3JlclxuLy8gdmVyc2lvbnMgNiBhbmQgNywgd2hlcmUgbm8gbG9jYWxTdG9yYWdlLCBzZXNzaW9uU3RvcmFnZSwgZXRjXG4vLyBpcyBhdmFpbGFibGUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnb2xkSUUtdXNlckRhdGFTdG9yYWdlJyxcblx0d3JpdGU6IHdyaXRlLFxuXHRyZWFkOiByZWFkLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgc3RvcmFnZU5hbWUgPSAnc3RvcmVqcydcbnZhciBkb2MgPSBHbG9iYWwuZG9jdW1lbnRcbnZhciBfd2l0aFN0b3JhZ2VFbCA9IF9tYWtlSUVTdG9yYWdlRWxGdW5jdGlvbigpXG52YXIgZGlzYWJsZSA9IChHbG9iYWwubmF2aWdhdG9yID8gR2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQgOiAnJykubWF0Y2goLyAoTVNJRSA4fE1TSUUgOXxNU0lFIDEwKVxcLi8pIC8vIE1TSUUgOS54LCBNU0lFIDEwLnhcblxuZnVuY3Rpb24gd3JpdGUodW5maXhlZEtleSwgZGF0YSkge1xuXHRpZiAoZGlzYWJsZSkgeyByZXR1cm4gfVxuXHR2YXIgZml4ZWRLZXkgPSBmaXhLZXkodW5maXhlZEtleSlcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0c3RvcmFnZUVsLnNldEF0dHJpYnV0ZShmaXhlZEtleSwgZGF0YSlcblx0XHRzdG9yYWdlRWwuc2F2ZShzdG9yYWdlTmFtZSlcblx0fSlcbn1cblxuZnVuY3Rpb24gcmVhZCh1bmZpeGVkS2V5KSB7XG5cdGlmIChkaXNhYmxlKSB7IHJldHVybiB9XG5cdHZhciBmaXhlZEtleSA9IGZpeEtleSh1bmZpeGVkS2V5KVxuXHR2YXIgcmVzID0gbnVsbFxuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHRyZXMgPSBzdG9yYWdlRWwuZ2V0QXR0cmlidXRlKGZpeGVkS2V5KVxuXHR9KVxuXHRyZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBzdG9yYWdlRWwuWE1MRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXNcblx0XHRmb3IgKHZhciBpPWF0dHJpYnV0ZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIGF0dHIgPSBhdHRyaWJ1dGVzW2ldXG5cdFx0XHRjYWxsYmFjayhzdG9yYWdlRWwuZ2V0QXR0cmlidXRlKGF0dHIubmFtZSksIGF0dHIubmFtZSlcblx0XHR9XG5cdH0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZSh1bmZpeGVkS2V5KSB7XG5cdHZhciBmaXhlZEtleSA9IGZpeEtleSh1bmZpeGVkS2V5KVxuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHRzdG9yYWdlRWwucmVtb3ZlQXR0cmlidXRlKGZpeGVkS2V5KVxuXHRcdHN0b3JhZ2VFbC5zYXZlKHN0b3JhZ2VOYW1lKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBzdG9yYWdlRWwuWE1MRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXNcblx0XHRzdG9yYWdlRWwubG9hZChzdG9yYWdlTmFtZSlcblx0XHRmb3IgKHZhciBpPWF0dHJpYnV0ZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0c3RvcmFnZUVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVzW2ldLm5hbWUpXG5cdFx0fVxuXHRcdHN0b3JhZ2VFbC5zYXZlKHN0b3JhZ2VOYW1lKVxuXHR9KVxufVxuXG4vLyBIZWxwZXJzXG4vLy8vLy8vLy8vXG5cbi8vIEluIElFNywga2V5cyBjYW5ub3Qgc3RhcnQgd2l0aCBhIGRpZ2l0IG9yIGNvbnRhaW4gY2VydGFpbiBjaGFycy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFyY3Vzd2VzdGluL3N0b3JlLmpzL2lzc3Vlcy80MFxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjdXN3ZXN0aW4vc3RvcmUuanMvaXNzdWVzLzgzXG52YXIgZm9yYmlkZGVuQ2hhcnNSZWdleCA9IG5ldyBSZWdFeHAoXCJbIVxcXCIjJCUmJygpKissL1xcXFxcXFxcOjs8PT4/QFtcXFxcXV5ge3x9fl1cIiwgXCJnXCIpXG5mdW5jdGlvbiBmaXhLZXkoa2V5KSB7XG5cdHJldHVybiBrZXkucmVwbGFjZSgvXlxcZC8sICdfX18kJicpLnJlcGxhY2UoZm9yYmlkZGVuQ2hhcnNSZWdleCwgJ19fXycpXG59XG5cbmZ1bmN0aW9uIF9tYWtlSUVTdG9yYWdlRWxGdW5jdGlvbigpIHtcblx0aWYgKCFkb2MgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQuYWRkQmVoYXZpb3IpIHtcblx0XHRyZXR1cm4gbnVsbFxuXHR9XG5cdHZhciBzY3JpcHRUYWcgPSAnc2NyaXB0Jyxcblx0XHRzdG9yYWdlT3duZXIsXG5cdFx0c3RvcmFnZUNvbnRhaW5lcixcblx0XHRzdG9yYWdlRWxcblxuXHQvLyBTaW5jZSAjdXNlckRhdGEgc3RvcmFnZSBhcHBsaWVzIG9ubHkgdG8gc3BlY2lmaWMgcGF0aHMsIHdlIG5lZWQgdG9cblx0Ly8gc29tZWhvdyBsaW5rIG91ciBkYXRhIHRvIGEgc3BlY2lmaWMgcGF0aC4gIFdlIGNob29zZSAvZmF2aWNvbi5pY29cblx0Ly8gYXMgYSBwcmV0dHkgc2FmZSBvcHRpb24sIHNpbmNlIGFsbCBicm93c2VycyBhbHJlYWR5IG1ha2UgYSByZXF1ZXN0IHRvXG5cdC8vIHRoaXMgVVJMIGFueXdheSBhbmQgYmVpbmcgYSA0MDQgd2lsbCBub3QgaHVydCB1cyBoZXJlLiAgV2Ugd3JhcCBhblxuXHQvLyBpZnJhbWUgcG9pbnRpbmcgdG8gdGhlIGZhdmljb24gaW4gYW4gQWN0aXZlWE9iamVjdChodG1sZmlsZSkgb2JqZWN0XG5cdC8vIChzZWU6IGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9hYTc1MjU3NCh2PVZTLjg1KS5hc3B4KVxuXHQvLyBzaW5jZSB0aGUgaWZyYW1lIGFjY2VzcyBydWxlcyBhcHBlYXIgdG8gYWxsb3cgZGlyZWN0IGFjY2VzcyBhbmRcblx0Ly8gbWFuaXB1bGF0aW9uIG9mIHRoZSBkb2N1bWVudCBlbGVtZW50LCBldmVuIGZvciBhIDQwNCBwYWdlLiAgVGhpc1xuXHQvLyBkb2N1bWVudCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IGRvY3VtZW50ICh3aGljaCB3b3VsZFxuXHQvLyBoYXZlIGJlZW4gbGltaXRlZCB0byB0aGUgY3VycmVudCBwYXRoKSB0byBwZXJmb3JtICN1c2VyRGF0YSBzdG9yYWdlLlxuXHR0cnkge1xuXHRcdC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG5cdFx0c3RvcmFnZUNvbnRhaW5lciA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpXG5cdFx0c3RvcmFnZUNvbnRhaW5lci5vcGVuKClcblx0XHRzdG9yYWdlQ29udGFpbmVyLndyaXRlKCc8JytzY3JpcHRUYWcrJz5kb2N1bWVudC53PXdpbmRvdzwvJytzY3JpcHRUYWcrJz48aWZyYW1lIHNyYz1cIi9mYXZpY29uLmljb1wiPjwvaWZyYW1lPicpXG5cdFx0c3RvcmFnZUNvbnRhaW5lci5jbG9zZSgpXG5cdFx0c3RvcmFnZU93bmVyID0gc3RvcmFnZUNvbnRhaW5lci53LmZyYW1lc1swXS5kb2N1bWVudFxuXHRcdHN0b3JhZ2VFbCA9IHN0b3JhZ2VPd25lci5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHR9IGNhdGNoKGUpIHtcblx0XHQvLyBzb21laG93IEFjdGl2ZVhPYmplY3QgaW5zdGFudGlhdGlvbiBmYWlsZWQgKHBlcmhhcHMgc29tZSBzcGVjaWFsXG5cdFx0Ly8gc2VjdXJpdHkgc2V0dGluZ3Mgb3Igb3RoZXJ3c2UpLCBmYWxsIGJhY2sgdG8gcGVyLXBhdGggc3RvcmFnZVxuXHRcdHN0b3JhZ2VFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHRcdHN0b3JhZ2VPd25lciA9IGRvYy5ib2R5XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24oc3RvcmVGdW5jdGlvbikge1xuXHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG5cdFx0YXJncy51bnNoaWZ0KHN0b3JhZ2VFbClcblx0XHQvLyBTZWUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMDgxKHY9VlMuODUpLmFzcHhcblx0XHQvLyBhbmQgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxNDI0KHY9VlMuODUpLmFzcHhcblx0XHRzdG9yYWdlT3duZXIuYXBwZW5kQ2hpbGQoc3RvcmFnZUVsKVxuXHRcdHN0b3JhZ2VFbC5hZGRCZWhhdmlvcignI2RlZmF1bHQjdXNlckRhdGEnKVxuXHRcdHN0b3JhZ2VFbC5sb2FkKHN0b3JhZ2VOYW1lKVxuXHRcdHN0b3JlRnVuY3Rpb24uYXBwbHkodGhpcywgYXJncylcblx0XHRzdG9yYWdlT3duZXIucmVtb3ZlQ2hpbGQoc3RvcmFnZUVsKVxuXHRcdHJldHVyblxuXHR9XG59XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ3Nlc3Npb25TdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsXG59XG5cbmZ1bmN0aW9uIHNlc3Npb25TdG9yYWdlKCkge1xuXHRyZXR1cm4gR2xvYmFsLnNlc3Npb25TdG9yYWdlXG59XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLmdldEl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuc2V0SXRlbShrZXksIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IHNlc3Npb25TdG9yYWdlKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gc2Vzc2lvblN0b3JhZ2UoKS5rZXkoaSlcblx0XHRmbihyZWFkKGtleSksIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuY2xlYXIoKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLmNhbGxlZFJlYWQgPSB0cnVlO1xuICB2YXIgbk9yaWcgPSBuO1xuICB2YXIgcmV0O1xuXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICByZXQgPSBudWxsO1xuXG4gICAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIGRlY29kZXIgZGlkIG5vdCByZWNlaXZlIGVub3VnaCBkYXRhXG4gICAgLy8gdG8gcHJvZHVjZSBhIGZ1bGwgY2h1bmssIHRoZW4gaW1tZWRpYXRlbHkgcmVjZWl2ZWQgYW5cbiAgICAvLyBFT0YsIHN0YXRlLmJ1ZmZlciB3aWxsIGNvbnRhaW4gWzxCdWZmZXIgPiwgPEJ1ZmZlciAwMCAuLi4+XS5cbiAgICAvLyBob3dNdWNoVG9SZWFkIHdpbGwgc2VlIHRoaXMgYW5kIGNvZXJjZSB0aGUgYW1vdW50IHRvXG4gICAgLy8gcmVhZCB0byB6ZXJvIChiZWNhdXNlIGl0J3MgbG9va2luZyBhdCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIC8vIGZpcnN0IDxCdWZmZXIgPiBpbiBzdGF0ZS5idWZmZXIpLCBhbmQgd2UnbGwgZW5kIHVwIGhlcmUuXG4gICAgLy9cbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiB2aWEgc3RhdGUuZGVjb2RlciAtLSBubyBvdGhlciB2ZW51ZVxuICAgIC8vIGV4aXN0cyBmb3IgcHVzaGluZyBhIHplcm8tbGVuZ3RoIGNodW5rIGludG8gc3RhdGUuYnVmZmVyXG4gICAgLy8gYW5kIHRyaWdnZXJpbmcgdGhpcyBiZWhhdmlvci4gSW4gdGhpcyBjYXNlLCB3ZSByZXR1cm4gb3VyXG4gICAgLy8gcmVtYWluaW5nIGRhdGEgYW5kIGVuZCB0aGUgc3RyZWFtLCBpZiBhcHByb3ByaWF0ZS5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID4gMCAmJiBzdGF0ZS5kZWNvZGVyKSB7XG4gICAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gcmV0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCBhbmQgd2UgaGF2ZSBzb21lIGRhdGEgbGVmdCwgdGhlbiBlbWl0XG4gIC8vICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIGVsc2VcbiAgICBlbmRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoc3RhdGUuZW1pdHRlZFJlYWRhYmxlKVxuICAgIHJldHVybjtcblxuICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICBpZiAoc3RhdGUuc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH0pO1xuICBlbHNlXG4gICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgaWYgKHJlYWRhYmxlICE9PSBzcmMpIHJldHVybjtcbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbilcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyB0aGUgaGFuZGxlciB0aGF0IHdhaXRzIGZvciByZWFkYWJsZSBldmVudHMgYWZ0ZXIgYWxsXG4gICAgLy8gdGhlIGRhdGEgZ2V0cyBzdWNrZWQgb3V0IGluIGZsb3cuXG4gICAgLy8gVGhpcyB3b3VsZCBiZSBlYXNpZXIgdG8gZm9sbG93IHdpdGggYSAub25jZSgpIGhhbmRsZXJcbiAgICAvLyBpbiBmbG93KCksIGJ1dCB0aGF0IGlzIHRvbyBzbG93LlxuICAgIHRoaXMub24oJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIHRoaXMuZW1pdCgncmVzdW1lJyk7XG4gIH07XG5cbiAgLy8gbm93IG1ha2UgaXQgc3RhcnQsIGp1c3QgaW4gY2FzZSBpdCBoYWRuJ3QgYWxyZWFkeS5cbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgLy9pZiAoc3RhdGUub2JqZWN0TW9kZSAmJiB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpXG4gICAgICByZXR1cm47XG4gICAgZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB0aGlzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmNhbGxlZFJlYWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX2ZsdXNoKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGNodW5rICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKVxuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgY2IoKTtcbiAgaWYgKGZpbmlzaGVkKVxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gIGVsc2VcbiAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNodW5rICE9PSAndW5kZWZpbmVkJyAmJiBjaHVuayAhPT0gbnVsbClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybScpXG4gICwgaW5oZXJpdHMgID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4gICwgeHRlbmQgICAgID0gcmVxdWlyZSgneHRlbmQnKVxuXG5mdW5jdGlvbiBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRzKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKERlc3Ryb3lhYmxlVHJhbnNmb3JtLCBUcmFuc2Zvcm0pXG5cbkRlc3Ryb3lhYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgfSlcbn1cblxuLy8gYSBub29wIF90cmFuc2Zvcm0gZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG51bGwsIGNodW5rKVxufVxuXG5cbi8vIGNyZWF0ZSBhIG5ldyBleHBvcnQgZnVuY3Rpb24sIHVzZWQgYnkgYm90aCB0aGUgbWFpbiBleHBvcnQgYW5kXG4vLyB0aGUgLmN0b3IgZXhwb3J0LCBjb250YWlucyBjb21tb24gbG9naWMgZm9yIGRlYWxpbmcgd2l0aCBhcmd1bWVudHNcbmZ1bmN0aW9uIHRocm91Z2gyIChjb25zdHJ1Y3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZsdXNoICAgICA9IHRyYW5zZm9ybVxuICAgICAgdHJhbnNmb3JtID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyAgID0ge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSAhPSAnZnVuY3Rpb24nKVxuICAgICAgdHJhbnNmb3JtID0gbm9vcFxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaCAhPSAnZnVuY3Rpb24nKVxuICAgICAgZmx1c2ggPSBudWxsXG5cbiAgICByZXR1cm4gY29uc3RydWN0KG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpXG4gIH1cbn1cblxuXG4vLyBtYWluIGV4cG9ydCwganVzdCBtYWtlIG1lIGEgdHJhbnNmb3JtIHN0cmVhbSFcbm1vZHVsZS5leHBvcnRzID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcblxuXG4vLyBtYWtlIG1lIGEgcmV1c2FibGUgcHJvdG90eXBlIHRoYXQgSSBjYW4gYG5ld2AsIG9yIGltcGxpY2l0bHkgYG5ld2Bcbi8vIHdpdGggYSBjb25zdHJ1Y3RvciBjYWxsXG5tb2R1bGUuZXhwb3J0cy5jdG9yID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgZnVuY3Rpb24gVGhyb3VnaDIgKG92ZXJyaWRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRocm91Z2gyKSlcbiAgICAgIHJldHVybiBuZXcgVGhyb3VnaDIob3ZlcnJpZGUpXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB4dGVuZChvcHRpb25zLCBvdmVycmlkZSlcblxuICAgIERlc3Ryb3lhYmxlVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW5oZXJpdHMoVGhyb3VnaDIsIERlc3Ryb3lhYmxlVHJhbnNmb3JtKVxuXG4gIFRocm91Z2gyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIFRocm91Z2gyLnByb3RvdHlwZS5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiBUaHJvdWdoMlxufSlcblxuXG5tb2R1bGUuZXhwb3J0cy5vYmogPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0oeHRlbmQoeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAxNiB9LCBvcHRpb25zKSlcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWYpIHtcblx0Ly8gSWYgdGhlIGJ1ZmZlciBpcyBiYWNrZWQgYnkgYSBVaW50OEFycmF5LCBhIGZhc3RlciB2ZXJzaW9uIHdpbGwgd29ya1xuXHRpZiAoYnVmIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHRcdC8vIElmIHRoZSBidWZmZXIgaXNuJ3QgYSBzdWJhcnJheSwgcmV0dXJuIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG5cdFx0aWYgKGJ1Zi5ieXRlT2Zmc2V0ID09PSAwICYmIGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcblx0XHRcdHJldHVybiBidWYuYnVmZmVyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYnVmLmJ1ZmZlci5zbGljZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gZ2V0IGEgcHJvcGVyIGNvcHlcblx0XHRcdHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKVxuXHRcdH1cblx0fVxuXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuXHRcdC8vIFRoaXMgaXMgdGhlIHNsb3cgdmVyc2lvbiB0aGF0IHdpbGwgd29yayB3aXRoIGFueSBCdWZmZXJcblx0XHQvLyBpbXBsZW1lbnRhdGlvbiAoZXZlbiBpbiBvbGQgYnJvd3NlcnMpXG5cdFx0dmFyIGFycmF5Q29weSA9IG5ldyBVaW50OEFycmF5KGJ1Zi5sZW5ndGgpXG5cdFx0dmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnJheUNvcHlbaV0gPSBidWZbaV1cblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5Q29weS5idWZmZXJcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuXHR9XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInYxXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3Y0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTklMXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9uaWwuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92ZXJzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3ZhbGlkYXRlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcGFyc2UuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjEuanNcIikpO1xuXG52YXIgX3YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92My5qc1wiKSk7XG5cbnZhciBfdjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y0LmpzXCIpKTtcblxudmFyIF92NCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjUuanNcIikpO1xuXG52YXIgX25pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbmlsLmpzXCIpKTtcblxudmFyIF92ZXJzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92ZXJzaW9uLmpzXCIpKTtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG52YXIgX3N0cmluZ2lmeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpKTtcblxudmFyIF9wYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFyc2UuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKlxuICogQnJvd3Nlci1jb21wYXRpYmxlIEphdmFTY3JpcHQgTUQ1XG4gKlxuICogTW9kaWZpY2F0aW9uIG9mIEphdmFTY3JpcHQgTUQ1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvblxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobXNnLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXNbaV0gPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWQ1VG9IZXhFbmNvZGVkQXJyYXkod29yZHNUb01kNShieXRlc1RvV29yZHMoYnl0ZXMpLCBieXRlcy5sZW5ndGggKiA4KSk7XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGFuIGFycmF5IG9mIGJ5dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVUb0hleEVuY29kZWRBcnJheShpbnB1dCkge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgY29uc3QgbGVuZ3RoMzIgPSBpbnB1dC5sZW5ndGggKiAzMjtcbiAgY29uc3QgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoMzI7IGkgKz0gOCkge1xuICAgIGNvbnN0IHggPSBpbnB1dFtpID4+IDVdID4+PiBpICUgMzIgJiAweGZmO1xuICAgIGNvbnN0IGhleCA9IHBhcnNlSW50KGhleFRhYi5jaGFyQXQoeCA+Pj4gNCAmIDB4MGYpICsgaGV4VGFiLmNoYXJBdCh4ICYgMHgwZiksIDE2KTtcbiAgICBvdXRwdXQucHVzaChoZXgpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG91dHB1dCBsZW5ndGggd2l0aCBwYWRkaW5nIGFuZCBiaXQgbGVuZ3RoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRPdXRwdXRMZW5ndGgoaW5wdXRMZW5ndGg4KSB7XG4gIHJldHVybiAoaW5wdXRMZW5ndGg4ICsgNjQgPj4+IDkgPDwgNCkgKyAxNCArIDE7XG59XG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdvcmRzVG9NZDUoeCwgbGVuKSB7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgbGVuICUgMzI7XG4gIHhbZ2V0T3V0cHV0TGVuZ3RoKGxlbikgLSAxXSA9IGxlbjtcbiAgbGV0IGEgPSAxNzMyNTg0MTkzO1xuICBsZXQgYiA9IC0yNzE3MzM4Nzk7XG4gIGxldCBjID0gLTE3MzI1ODQxOTQ7XG4gIGxldCBkID0gMjcxNzMzODc4O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBjb25zdCBvbGRhID0gYTtcbiAgICBjb25zdCBvbGRiID0gYjtcbiAgICBjb25zdCBvbGRjID0gYztcbiAgICBjb25zdCBvbGRkID0gZDtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA0XSwgMTEsIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNCwgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDddLCAxMCwgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDYsIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG4gICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gIH1cblxuICByZXR1cm4gW2EsIGIsIGMsIGRdO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgYnl0ZXMgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aDggPSBpbnB1dC5sZW5ndGggKiA4O1xuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDMyQXJyYXkoZ2V0T3V0cHV0TGVuZ3RoKGxlbmd0aDgpKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xuICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dFtpIC8gOF0gJiAweGZmKSA8PCBpICUgMzI7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcbiAgY29uc3QgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpO1xuICBjb25zdCBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIG1zdyA8PCAxNiB8IGxzdyAmIDB4ZmZmZjtcbn1cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cblxuXG5mdW5jdGlvbiBiaXRSb3RhdGVMZWZ0KG51bSwgY250KSB7XG4gIHJldHVybiBudW0gPDwgY250IHwgbnVtID4+PiAzMiAtIGNudDtcbn1cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5cblxuZnVuY3Rpb24gbWQ1Y21uKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIHNhZmVBZGQoYml0Um90YXRlTGVmdChzYWZlQWRkKHNhZmVBZGQoYSwgcSksIHNhZmVBZGQoeCwgdCkpLCBzKSwgYik7XG59XG5cbmZ1bmN0aW9uIG1kNWZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgYyB8IH5iICYgZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgZCB8IGMgJiB+ZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWhoKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gbWQ1O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHQgPSAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCEoMCwgX3ZhbGlkYXRlLmRlZmF1bHQpKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIGxldCB2O1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxudmFyIF9kZWZhdWx0ID0gcGFyc2U7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcm5nO1xuLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG5sZXQgZ2V0UmFuZG9tVmFsdWVzO1xuY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5cbmZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLy8gQWRhcHRlZCBmcm9tIENocmlzIFZlbmVzcycgU0hBMSBjb2RlIGF0XG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL3NoYTEuaHRtbFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxufVxuXG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgcmV0dXJuIHggPDwgbiB8IHggPj4+IDMyIC0gbjtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICBjb25zdCBLID0gWzB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4Y2E2MmMxZDZdO1xuICBjb25zdCBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcbiAgICBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIGNvbnN0IGwgPSBieXRlcy5sZW5ndGggLyA0ICsgMjtcbiAgY29uc3QgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICBjb25zdCBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgYXJyW2pdID0gYnl0ZXNbaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMl0gPDwgOCB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuXG4gICAgTVtpXSA9IGFycjtcbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICBjb25zdCBXID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcblxuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMTY7ICsrdCkge1xuICAgICAgV1t0XSA9IE1baV1bdF07XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdCA9IDE2OyB0IDwgODA7ICsrdCkge1xuICAgICAgV1t0XSA9IFJPVEwoV1t0IC0gM10gXiBXW3QgLSA4XSBeIFdbdCAtIDE0XSBeIFdbdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgbGV0IGEgPSBIWzBdO1xuICAgIGxldCBiID0gSFsxXTtcbiAgICBsZXQgYyA9IEhbMl07XG4gICAgbGV0IGQgPSBIWzNdO1xuICAgIGxldCBlID0gSFs0XTtcblxuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgODA7ICsrdCkge1xuICAgICAgY29uc3QgcyA9IE1hdGguZmxvb3IodCAvIDIwKTtcbiAgICAgIGNvbnN0IFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1t0XSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG52YXIgX2RlZmF1bHQgPSBzaGExO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5jb25zdCBieXRlVG9IZXggPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgY29uc3QgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxudmFyIF9kZWZhdWx0ID0gc3RyaW5naWZ5O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcm5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ybmcuanNcIikpO1xuXG52YXIgX3N0cmluZ2lmeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxubGV0IF9ub2RlSWQ7XG5cbmxldCBfY2xvY2tzZXE7IC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuXG5cbmxldCBfbGFzdE1TZWNzID0gMDtcbmxldCBfbGFzdE5TZWNzID0gMDsgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcblxuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgbGV0IGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGIgPSBidWYgfHwgbmV3IEFycmF5KDE2KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxldCBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIGxldCBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlZWRCeXRlcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nLmRlZmF1bHQpKCk7XG5cbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW3NlZWRCeXRlc1swXSB8IDB4MDEsIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXTtcbiAgICB9XG5cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH0gLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG5cblxuICBsZXQgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTsgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuXG4gIGxldCBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTsgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuXG4gIGNvbnN0IGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDsgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH0gLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuXG5cbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH0gLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXG5cbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7IC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwOyAvLyBgdGltZV9sb3dgXG5cbiAgY29uc3QgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmOyAvLyBgdGltZV9taWRgXG5cbiAgY29uc3QgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmOyAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjsgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG5cbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwOyAvLyBgY2xvY2tfc2VxX2xvd2BcblxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7IC8vIGBub2RlYFxuXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCAoMCwgX3N0cmluZ2lmeS5kZWZhdWx0KShiKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX21kID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZDUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCB2MyA9ICgwLCBfdi5kZWZhdWx0KSgndjMnLCAweDMwLCBfbWQuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2MztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5leHBvcnRzLlVSTCA9IGV4cG9ydHMuRE5TID0gdm9pZCAwO1xuXG52YXIgX3N0cmluZ2lmeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpKTtcblxudmFyIF9wYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFyc2UuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5jb25zdCBETlMgPSAnNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydHMuRE5TID0gRE5TO1xuY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLlVSTCA9IFVSTDtcblxuZnVuY3Rpb24gX2RlZmF1bHQobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc3BhY2UgPSAoMCwgX3BhcnNlLmRlZmF1bHQpKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX3N0cmluZ2lmeS5kZWZhdWx0KShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcm5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ybmcuanNcIikpO1xuXG52YXIgX3N0cmluZ2lmeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nLmRlZmF1bHQpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfc3RyaW5naWZ5LmRlZmF1bHQpKHJuZHMpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2NDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YzNS5qc1wiKSk7XG5cbnZhciBfc2hhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zaGExLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgdjUgPSAoMCwgX3YuZGVmYXVsdCkoJ3Y1JywgMHg1MCwgX3NoYS5kZWZhdWx0KTtcbnZhciBfZGVmYXVsdCA9IHY1O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVnZXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JlZ2V4LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIF9yZWdleC5kZWZhdWx0LnRlc3QodXVpZCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IHZhbGlkYXRlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5cbnZhciBfZGVmYXVsdCA9IHZlcnNpb247XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTaGltbWluZyBzdGFydHMgaGVyZS5cbihmdW5jdGlvbigpIHtcbiAgLy8gVXRpbHMuXG4gIHZhciBsb2dnaW5nID0gcmVxdWlyZSgnLi91dGlscycpLmxvZztcbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gcmVxdWlyZSgnLi91dGlscycpLmJyb3dzZXJEZXRhaWxzO1xuICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICBtb2R1bGUuZXhwb3J0cy5icm93c2VyRGV0YWlscyA9IGJyb3dzZXJEZXRhaWxzO1xuICBtb2R1bGUuZXhwb3J0cy5leHRyYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vdXRpbHMnKS5leHRyYWN0VmVyc2lvbjtcbiAgbW9kdWxlLmV4cG9ydHMuZGlzYWJsZUxvZyA9IHJlcXVpcmUoJy4vdXRpbHMnKS5kaXNhYmxlTG9nO1xuXG4gIC8vIFVuY29tbWVudCB0aGUgbGluZSBiZWxvdyBpZiB5b3Ugd2FudCBsb2dnaW5nIHRvIG9jY3VyLCBpbmNsdWRpbmcgbG9nZ2luZ1xuICAvLyBmb3IgdGhlIHN3aXRjaCBzdGF0ZW1lbnQgYmVsb3cuIENhbiBhbHNvIGJlIHR1cm5lZCBvbiBpbiB0aGUgYnJvd3NlciB2aWFcbiAgLy8gYWRhcHRlci5kaXNhYmxlTG9nKGZhbHNlKSwgYnV0IHRoZW4gbG9nZ2luZyBmcm9tIHRoZSBzd2l0Y2ggc3RhdGVtZW50IGJlbG93XG4gIC8vIHdpbGwgbm90IGFwcGVhci5cbiAgLy8gcmVxdWlyZSgnLi91dGlscycpLmRpc2FibGVMb2coZmFsc2UpO1xuXG4gIC8vIEJyb3dzZXIgc2hpbXMuXG4gIHZhciBjaHJvbWVTaGltID0gcmVxdWlyZSgnLi9jaHJvbWUvY2hyb21lX3NoaW0nKSB8fCBudWxsO1xuICB2YXIgZWRnZVNoaW0gPSByZXF1aXJlKCcuL2VkZ2UvZWRnZV9zaGltJykgfHwgbnVsbDtcbiAgdmFyIGZpcmVmb3hTaGltID0gcmVxdWlyZSgnLi9maXJlZm94L2ZpcmVmb3hfc2hpbScpIHx8IG51bGw7XG4gIHZhciBzYWZhcmlTaGltID0gcmVxdWlyZSgnLi9zYWZhcmkvc2FmYXJpX3NoaW0nKSB8fCBudWxsO1xuXG4gIC8vIFNoaW0gYnJvd3NlciBpZiBmb3VuZC5cbiAgc3dpdGNoIChicm93c2VyRGV0YWlscy5icm93c2VyKSB7XG4gICAgY2FzZSAnb3BlcmEnOiAvLyBmYWxsdGhyb3VnaCBhcyBpdCB1c2VzIGNocm9tZSBzaGltc1xuICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICBpZiAoIWNocm9tZVNoaW0gfHwgIWNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBjaHJvbWUuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgbW9kdWxlLmV4cG9ydHMuYnJvd3NlclNoaW0gPSBjaHJvbWVTaGltO1xuXG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRVc2VyTWVkaWEoKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbU1lZGlhU3RyZWFtKCk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1Tb3VyY2VPYmplY3QoKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKCk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1PblRyYWNrKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgIGlmICghZmlyZWZveFNoaW0gfHwgIWZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbikge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGZpcmVmb3guJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgbW9kdWxlLmV4cG9ydHMuYnJvd3NlclNoaW0gPSBmaXJlZm94U2hpbTtcblxuICAgICAgZmlyZWZveFNoaW0uc2hpbUdldFVzZXJNZWRpYSgpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVNvdXJjZU9iamVjdCgpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKCk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltT25UcmFjaygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZWRnZSc6XG4gICAgICBpZiAoIWVkZ2VTaGltIHx8ICFlZGdlU2hpbS5zaGltUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgbG9nZ2luZygnTVMgZWRnZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBlZGdlLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIG1vZHVsZS5leHBvcnRzLmJyb3dzZXJTaGltID0gZWRnZVNoaW07XG5cbiAgICAgIGVkZ2VTaGltLnNoaW1HZXRVc2VyTWVkaWEoKTtcbiAgICAgIGVkZ2VTaGltLnNoaW1QZWVyQ29ubmVjdGlvbigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSkge1xuICAgICAgICBsb2dnaW5nKCdTYWZhcmkgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgc2FmYXJpLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIG1vZHVsZS5leHBvcnRzLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgc2FmYXJpU2hpbS5zaGltR2V0VXNlck1lZGlhKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbG9nZ2luZygnVW5zdXBwb3J0ZWQgYnJvd3NlciEnKTtcbiAgfVxufSkoKTtcbiIsIlxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG52YXIgbG9nZ2luZyA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJykubG9nO1xudmFyIGJyb3dzZXJEZXRhaWxzID0gcmVxdWlyZSgnLi4vdXRpbHMuanMnKS5icm93c2VyRGV0YWlscztcblxudmFyIGNocm9tZVNoaW0gPSB7XG4gIHNoaW1NZWRpYVN0cmVhbTogZnVuY3Rpb24oKSB7XG4gICAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcbiAgfSxcblxuICBzaGltT25UcmFjazogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdvbnRyYWNrJyBpblxuICAgICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbnRyYWNrJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vbnRyYWNrO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayA9IGYpO1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBvbmFkZHN0cmVhbSBkb2VzIG5vdCBmaXJlIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhbiBleGlzdGluZ1xuICAgICAgICAgICAgLy8gc3RyZWFtLiBCdXQgc3RyZWFtLm9uYWRkdHJhY2sgaXMgaW1wbGVtZW50ZWQgc28gd2UgdXNlIHRoYXQuXG4gICAgICAgICAgICBlLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIGZ1bmN0aW9uKHRlKSB7XG4gICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0ZS50cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSB7dHJhY2s6IHRlLnRyYWNrfTtcbiAgICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHt0cmFjazogdHJhY2t9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHNoaW1Tb3VyY2VPYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50ICYmXG4gICAgICAgICEoJ3NyY09iamVjdCcgaW4gd2luZG93LkhUTUxNZWRpYUVsZW1lbnQucHJvdG90eXBlKSkge1xuICAgICAgICAvLyBTaGltIHRoZSBzcmNPYmplY3QgcHJvcGVydHksIG9uY2UsIHdoZW4gSFRNTE1lZGlhRWxlbWVudCBpcyBmb3VuZC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50LnByb3RvdHlwZSwgJ3NyY09iamVjdCcsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NyY09iamVjdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBVc2UgX3NyY09iamVjdCBhcyBhIHByaXZhdGUgcHJvcGVydHkgZm9yIHRoaXMgc2hpbVxuICAgICAgICAgICAgdGhpcy5fc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3JjKSB7XG4gICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5zcmMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgICAgICB0aGlzLnNyYyA9ICcnO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVjcmVhdGUgdGhlIGJsb2IgdXJsIHdoZW4gYSB0cmFjayBpcyBhZGRlZCBvclxuICAgICAgICAgICAgLy8gcmVtb3ZlZC4gRG9pbmcgaXQgbWFudWFsbHkgc2luY2Ugd2Ugd2FudCB0byBhdm9pZCBhIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgIHN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5zcmMpIHtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHNlbGYuc3JjKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxmLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLnNyYykge1xuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc2VsZi5zcmMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGUgUlRDUGVlckNvbm5lY3Rpb24gb2JqZWN0LlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKSB7XG4gICAgICAvLyBUcmFuc2xhdGUgaWNlVHJhbnNwb3J0UG9saWN5IHRvIGljZVRyYW5zcG9ydHMsXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD00ODY5XG4gICAgICBsb2dnaW5nKCdQZWVyQ29ubmVjdGlvbicpO1xuICAgICAgaWYgKHBjQ29uZmlnICYmIHBjQ29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSkge1xuICAgICAgICBwY0NvbmZpZy5pY2VUcmFuc3BvcnRzID0gcGNDb25maWcuaWNlVHJhbnNwb3J0UG9saWN5O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGMgPSBuZXcgd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpO1xuICAgICAgdmFyIG9yaWdHZXRTdGF0cyA9IHBjLmdldFN0YXRzLmJpbmQocGMpO1xuICAgICAgcGMuZ2V0U3RhdHMgPSBmdW5jdGlvbihzZWxlY3Rvciwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgLy8gSWYgc2VsZWN0b3IgaXMgYSBmdW5jdGlvbiB0aGVuIHdlIGFyZSBpbiB0aGUgb2xkIHN0eWxlIHN0YXRzIHNvIGp1c3RcbiAgICAgICAgLy8gcGFzcyBiYWNrIHRoZSBvcmlnaW5hbCBnZXRTdGF0cyBmb3JtYXQgdG8gYXZvaWQgYnJlYWtpbmcgb2xkIHVzZXJzLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cyhzZWxlY3Rvciwgc3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXhDaHJvbWVTdGF0c18gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHZhciBzdGFuZGFyZFJlcG9ydCA9IHt9O1xuICAgICAgICAgIHZhciByZXBvcnRzID0gcmVzcG9uc2UucmVzdWx0KCk7XG4gICAgICAgICAgcmVwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHJlcG9ydCkge1xuICAgICAgICAgICAgdmFyIHN0YW5kYXJkU3RhdHMgPSB7XG4gICAgICAgICAgICAgIGlkOiByZXBvcnQuaWQsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogcmVwb3J0LnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgdHlwZTogcmVwb3J0LnR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXBvcnQubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgc3RhbmRhcmRTdGF0c1tuYW1lXSA9IHJlcG9ydC5zdGF0KG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGFuZGFyZFJlcG9ydFtzdGFuZGFyZFN0YXRzLmlkXSA9IHN0YW5kYXJkU3RhdHM7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc3RhbmRhcmRSZXBvcnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2hpbSBnZXRTdGF0cyB3aXRoIG1hcGxpa2Ugc3VwcG9ydFxuICAgICAgICB2YXIgbWFrZU1hcFN0YXRzID0gZnVuY3Rpb24oc3RhdHMsIGxlZ2FjeVN0YXRzKSB7XG4gICAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoT2JqZWN0LmtleXMoc3RhdHMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybltrZXksIHN0YXRzW2tleV1dO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBsZWdhY3lTdGF0cyA9IGxlZ2FjeVN0YXRzIHx8IHN0YXRzO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGxlZ2FjeVN0YXRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgbWFwW2tleV0gPSBsZWdhY3lTdGF0c1trZXldO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBhcmdzWzFdKG1ha2VNYXBTdGF0cyhmaXhDaHJvbWVTdGF0c18ocmVzcG9uc2UpKSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW3N1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfLFxuICAgICAgICAgICAgICBhcmd1bWVudHNbMF1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb21pc2Utc3VwcG9ydFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9yaWdHZXRTdGF0cy5hcHBseShzZWxmLCBbXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgICAgICAgICB9LCByZWplY3RdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgbGVnYWN5IGNocm9tZSBzdGF0cyBvbmx5IG9uIGxlZ2FjeSBhY2Nlc3Mgb2Ygc3RhdHMgb2JqXG4gICAgICAgICAgICBvcmlnR2V0U3RhdHMuYXBwbHkoc2VsZiwgW1xuICAgICAgICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlc3VsdCgpKSk7XG4gICAgICAgICAgICAgIH0sIHJlamVjdF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHBjO1xuICAgIH07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcblxuICAgIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gICAgaWYgKHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICB2YXIgbmF0aXZlTWV0aG9kID0gd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIG5hdGl2ZU1ldGhvZC5hcHBseShzZWxmLCBbcmVzb2x2ZSwgcmVqZWN0LCBvcHRzXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBwcm9taXNlIHN1cHBvcnQgLS0gbmF0aXZlbHkgYXZhaWxhYmxlIGluIENocm9tZSA1MVxuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTEpIHtcbiAgICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZU1ldGhvZCA9IHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICAgICAgd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVNZXRob2QuYXBwbHkoc2VsZiwgW2FyZ3NbMF0sIHJlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBbXSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzWzJdLmFwcGx5KG51bGwsIFtlcnJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzaGltIGltcGxpY2l0IGNyZWF0aW9uIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi9SVENJY2VDYW5kaWRhdGVcbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ11cbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgdmFyIG5hdGl2ZU1ldGhvZCA9IHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICAgIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnKSA/XG4gICAgICAgICAgICAgICAgUlRDSWNlQ2FuZGlkYXRlIDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxuICAgIHZhciBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPVxuICAgICAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn07XG5cblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoaW1NZWRpYVN0cmVhbTogY2hyb21lU2hpbS5zaGltTWVkaWFTdHJlYW0sXG4gIHNoaW1PblRyYWNrOiBjaHJvbWVTaGltLnNoaW1PblRyYWNrLFxuICBzaGltU291cmNlT2JqZWN0OiBjaHJvbWVTaGltLnNoaW1Tb3VyY2VPYmplY3QsXG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24sXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHJlcXVpcmUoJy4vZ2V0dXNlcm1lZGlhJylcbn07XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBsb2dnaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMuanMnKS5sb2c7XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uKGMpIHtcbiAgICBpZiAodHlwZW9mIGMgIT09ICdvYmplY3QnIHx8IGMubWFuZGF0b3J5IHx8IGMub3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICB2YXIgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlcXVpcmUnIHx8IGtleSA9PT0gJ2FkdmFuY2VkJyB8fCBrZXkgPT09ICdtZWRpYVNvdXJjZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHIgPSAodHlwZW9mIGNba2V5XSA9PT0gJ29iamVjdCcpID8gY1trZXldIDoge2lkZWFsOiBjW2tleV19O1xuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgci5taW4gPSByLm1heCA9IHIuZXhhY3Q7XG4gICAgICB9XG4gICAgICB2YXIgb2xkbmFtZV8gPSBmdW5jdGlvbihwcmVmaXgsIG5hbWUpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5hbWUgPT09ICdkZXZpY2VJZCcpID8gJ3NvdXJjZUlkJyA6IG5hbWU7XG4gICAgICB9O1xuICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYy5vcHRpb25hbCA9IGNjLm9wdGlvbmFsIHx8IFtdO1xuICAgICAgICB2YXIgb2MgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtaW4nLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgICAgb2MgPSB7fTtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWF4Jywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuZXhhY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKGZ1bmN0aW9uKG1peCkge1xuICAgICAgICAgIGlmIChyW21peF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKG1peCwga2V5KV0gPSByW21peF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYy5hZHZhbmNlZCkge1xuICAgICAgY2Mub3B0aW9uYWwgPSAoY2Mub3B0aW9uYWwgfHwgW10pLmNvbmNhdChjLmFkdmFuY2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNjO1xuICB9O1xuXG4gIHZhciBzaGltQ29uc3RyYWludHNfID0gZnVuY3Rpb24oY29uc3RyYWludHMsIGZ1bmMpIHtcbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gU2hpbSBmYWNpbmdNb2RlIGZvciBtb2JpbGUsIHdoZXJlIGl0IGRlZmF1bHRzIHRvIFwidXNlclwiLlxuICAgICAgdmFyIGZhY2UgPSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgZmFjZSA9IGZhY2UgJiYgKCh0eXBlb2YgZmFjZSA9PT0gJ29iamVjdCcpID8gZmFjZSA6IHtpZGVhbDogZmFjZX0pO1xuXG4gICAgICBpZiAoKGZhY2UgJiYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8XG4gICAgICAgICAgICAgICAgICAgIGZhY2UuaWRlYWwgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSkgJiZcbiAgICAgICAgICAhKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMgJiZcbiAgICAgICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKS5mYWNpbmdNb2RlKSkge1xuICAgICAgICBkZWxldGUgY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgICAgaWYgKGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50Jykge1xuICAgICAgICAgIC8vIExvb2sgZm9yIFwiYmFja1wiIGluIGxhYmVsLCBvciB1c2UgbGFzdCBjYW0gKHR5cGljYWxseSBiYWNrIGNhbSkuXG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGV2aWNlcykge1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQua2luZCA9PT0gJ3ZpZGVvaW5wdXQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgYmFjayA9IGRldmljZXMuZmluZChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYmFjaycpICE9PSAtMTtcbiAgICAgICAgICAgIH0pIHx8IChkZXZpY2VzLmxlbmd0aCAmJiBkZXZpY2VzW2RldmljZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgaWYgKGJhY2spIHtcbiAgICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uZGV2aWNlSWQgPSBmYWNlLmV4YWN0ID8ge2V4YWN0OiBiYWNrLmRldmljZUlkfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpZGVhbDogYmFjay5kZXZpY2VJZH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcblxuICB2YXIgc2hpbUVycm9yXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3I6ICdPdmVyY29uc3RyYWluZWRFcnJvcidcbiAgICAgIH1bZS5uYW1lXSB8fCBlLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICBjb25zdHJhaW50OiBlLmNvbnN0cmFpbnROYW1lLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgKHRoaXMubWVzc2FnZSAmJiAnOiAnKSArIHRoaXMubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBnZXRVc2VyTWVkaWFfID0gZnVuY3Rpb24oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHNoaW1Db25zdHJhaW50c18oY29uc3RyYWludHMsIGZ1bmN0aW9uKGMpIHtcbiAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEoYywgb25TdWNjZXNzLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIG9uRXJyb3Ioc2hpbUVycm9yXyhlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZ2V0VXNlck1lZGlhXztcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZ2V0VXNlck1lZGlhIGFzIGEgUHJvbWlzZS5cbiAgdmFyIGdldFVzZXJNZWRpYVByb21pc2VfID0gZnVuY3Rpb24oY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9O1xuXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMgPSB7XG4gICAgICBnZXRVc2VyTWVkaWE6IGdldFVzZXJNZWRpYVByb21pc2VfLFxuICAgICAgZW51bWVyYXRlRGV2aWNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIGtpbmRzID0ge2F1ZGlvOiAnYXVkaW9pbnB1dCcsIHZpZGVvOiAndmlkZW9pbnB1dCd9O1xuICAgICAgICAgIHJldHVybiBNZWRpYVN0cmVhbVRyYWNrLmdldFNvdXJjZXMoZnVuY3Rpb24oZGV2aWNlcykge1xuICAgICAgICAgICAgcmVzb2x2ZShkZXZpY2VzLm1hcChmdW5jdGlvbihkZXZpY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtsYWJlbDogZGV2aWNlLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmRzW2RldmljZS5raW5kXSxcbiAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZDogZGV2aWNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6ICcnfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEEgc2hpbSBmb3IgZ2V0VXNlck1lZGlhIG1ldGhvZCBvbiB0aGUgbWVkaWFEZXZpY2VzIG9iamVjdC5cbiAgLy8gVE9ETyhLYXB0ZW5KYW5zc29uKSByZW1vdmUgb25jZSBpbXBsZW1lbnRlZCBpbiBDaHJvbWUgc3RhYmxlLlxuICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjb25zdHJhaW50cykge1xuICAgICAgcmV0dXJuIGdldFVzZXJNZWRpYVByb21pc2VfKGNvbnN0cmFpbnRzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIEV2ZW4gdGhvdWdoIENocm9tZSA0NSBoYXMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBhbmQgYSBnZXRVc2VyTWVkaWFcbiAgICAvLyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgaXQgZG9lcyBub3QgYWNjZXB0IHNwZWMtc3R5bGVcbiAgICAvLyBjb25zdHJhaW50cy5cbiAgICB2YXIgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLlxuICAgICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY3MpIHtcbiAgICAgIHJldHVybiBzaGltQ29uc3RyYWludHNfKGNzLCBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBvcmlnR2V0VXNlck1lZGlhKGMpLnRoZW4oZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fFxuICAgICAgICAgICAgICBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgLy8gRHVtbXkgZGV2aWNlY2hhbmdlIGV2ZW50IG1ldGhvZHMuXG4gIC8vIFRPRE8oS2FwdGVuSmFuc3NvbikgcmVtb3ZlIG9uY2UgaW1wbGVtZW50ZWQgaW4gQ2hyb21lIHN0YWJsZS5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBsb2dnaW5nKCdEdW1teSBtZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lciBjYWxsZWQuJyk7XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIG5hdmlnYXRvci5tZWRpYURldmljZXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxvZ2dpbmcoJ0R1bW15IG1lZGlhRGV2aWNlcy5yZW1vdmVFdmVudExpc3RlbmVyIGNhbGxlZC4nKTtcbiAgICB9O1xuICB9XG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTRFBVdGlscyA9IHJlcXVpcmUoJ3NkcCcpO1xudmFyIGJyb3dzZXJEZXRhaWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5icm93c2VyRGV0YWlscztcblxudmFyIGVkZ2VTaGltID0ge1xuICBzaGltUGVlckNvbm5lY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIGlmICh3aW5kb3cuUlRDSWNlR2F0aGVyZXIpIHtcbiAgICAgIC8vIE9SVEMgZGVmaW5lcyBhbiBSVENJY2VDYW5kaWRhdGUgb2JqZWN0IGJ1dCBubyBjb25zdHJ1Y3Rvci5cbiAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBpbiBFZGdlLlxuICAgICAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlKSB7XG4gICAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBPUlRDIGRvZXMgbm90IGhhdmUgYSBzZXNzaW9uIGRlc2NyaXB0aW9uIG9iamVjdCBidXRcbiAgICAgIC8vIG90aGVyIGJyb3dzZXJzIChpLmUuIENocm9tZSkgdGhhdCB3aWxsIHN1cHBvcnQgYm90aCBQQyBhbmQgT1JUQ1xuICAgICAgLy8gaW4gdGhlIGZ1dHVyZSBtaWdodCBoYXZlIHRoaXMgZGVmaW5lZCBhbHJlYWR5LlxuICAgICAgaWYgKCF3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGFkZHMgYW4gYWRkaXRpb25hbCBldmVudCBsaXN0ZW5lciB0byBNZWRpYVN0cmFja1RyYWNrIHRoYXQgc2lnbmFsc1xuICAgICAgLy8gd2hlbiBhIHRyYWNrcyBlbmFibGVkIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICAgICAgdmFyIG9yaWdNU1RFbmFibGVkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZSwgJ2VuYWJsZWQnKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZSwgJ2VuYWJsZWQnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBvcmlnTVNURW5hYmxlZC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgdmFyIGV2ID0gbmV3IEV2ZW50KCdlbmFibGVkJyk7XG4gICAgICAgICAgZXYuZW5hYmxlZCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgX2V2ZW50VGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgWydhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInLCAnZGlzcGF0Y2hFdmVudCddXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICBzZWxmW21ldGhvZF0gPSBfZXZlbnRUYXJnZXRbbWV0aG9kXS5iaW5kKF9ldmVudFRhcmdldCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMub25pY2VjYW5kaWRhdGUgPSBudWxsO1xuICAgICAgdGhpcy5vbmFkZHN0cmVhbSA9IG51bGw7XG4gICAgICB0aGlzLm9udHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5vbnJlbW92ZXN0cmVhbSA9IG51bGw7XG4gICAgICB0aGlzLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBudWxsO1xuICAgICAgdGhpcy5vbmRhdGFjaGFubmVsID0gbnVsbDtcblxuICAgICAgdGhpcy5sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIHRoaXMucmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgdGhpcy5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubG9jYWxTdHJlYW1zO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZ2V0UmVtb3RlU3RyZWFtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yZW1vdGVTdHJlYW1zO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5sb2NhbERlc2NyaXB0aW9uID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHR5cGU6ICcnLFxuICAgICAgICBzZHA6ICcnXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVtb3RlRGVzY3JpcHRpb24gPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgdHlwZTogJycsXG4gICAgICAgIHNkcDogJydcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZSA9ICdzdGFibGUnO1xuICAgICAgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGUgPSAnbmV3JztcbiAgICAgIHRoaXMuaWNlR2F0aGVyaW5nU3RhdGUgPSAnbmV3JztcblxuICAgICAgdGhpcy5pY2VPcHRpb25zID0ge1xuICAgICAgICBnYXRoZXJQb2xpY3k6ICdhbGwnLFxuICAgICAgICBpY2VTZXJ2ZXJzOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSkge1xuICAgICAgICBzd2l0Y2ggKGNvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kpIHtcbiAgICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICAgIGNhc2UgJ3JlbGF5JzpcbiAgICAgICAgICAgIHRoaXMuaWNlT3B0aW9ucy5nYXRoZXJQb2xpY3kgPSBjb25maWcuaWNlVHJhbnNwb3J0UG9saWN5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAvLyBGSVhNRTogcmVtb3ZlIG9uY2UgaW1wbGVtZW50YXRpb24gYW5kIHNwZWMgaGF2ZSBhZGRlZCB0aGlzLlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWNlVHJhbnNwb3J0UG9saWN5IFwibm9uZVwiIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGljZVRyYW5zcG9ydFBvbGljeS5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVzaW5nQnVuZGxlID0gY29uZmlnICYmIGNvbmZpZy5idW5kbGVQb2xpY3kgPT09ICdtYXgtYnVuZGxlJztcblxuICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcuaWNlU2VydmVycykge1xuICAgICAgICAvLyBFZGdlIGRvZXMgbm90IGxpa2VcbiAgICAgICAgLy8gMSkgc3R1bjpcbiAgICAgICAgLy8gMikgdHVybjogdGhhdCBkb2VzIG5vdCBoYXZlIGFsbCBvZiB0dXJuOmhvc3Q6cG9ydD90cmFuc3BvcnQ9dWRwXG4gICAgICAgIC8vIDMpIHR1cm46IHdpdGggaXB2NiBhZGRyZXNzZXNcbiAgICAgICAgdmFyIGljZVNlcnZlcnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbmZpZy5pY2VTZXJ2ZXJzKSk7XG4gICAgICAgIHRoaXMuaWNlT3B0aW9ucy5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycy5maWx0ZXIoZnVuY3Rpb24oc2VydmVyKSB7XG4gICAgICAgICAgaWYgKHNlcnZlciAmJiBzZXJ2ZXIudXJscykge1xuICAgICAgICAgICAgdmFyIHVybHMgPSBzZXJ2ZXIudXJscztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdXJscyA9IFt1cmxzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHMgPSB1cmxzLmZpbHRlcihmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh1cmwuaW5kZXhPZigndHVybjonKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgdXJsLmluZGV4T2YoJ3RyYW5zcG9ydD11ZHAnKSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgIHVybC5pbmRleE9mKCd0dXJuOlsnKSA9PT0gLTEpIHx8XG4gICAgICAgICAgICAgICAgICAodXJsLmluZGV4T2YoJ3N0dW46JykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSAxNDM5Myk7XG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIHJldHVybiAhIXVybHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG5cbiAgICAgIC8vIHBlci10cmFjayBpY2VHYXRoZXJzLCBpY2VUcmFuc3BvcnRzLCBkdGxzVHJhbnNwb3J0cywgcnRwU2VuZGVycywgLi4uXG4gICAgICAvLyBldmVyeXRoaW5nIHRoYXQgaXMgbmVlZGVkIHRvIGRlc2NyaWJlIGEgU0RQIG0tbGluZS5cbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzID0gW107XG5cbiAgICAgIC8vIHNpbmNlIHRoZSBpY2VHYXRoZXJlciBpcyBjdXJyZW50bHkgY3JlYXRlZCBpbiBjcmVhdGVPZmZlciBidXQgd2VcbiAgICAgIC8vIG11c3Qgbm90IGVtaXQgY2FuZGlkYXRlcyB1bnRpbCBhZnRlciBzZXRMb2NhbERlc2NyaXB0aW9uIHdlIGJ1ZmZlclxuICAgICAgLy8gdGhlbSBpbiB0aGlzIGFycmF5LlxuICAgICAgdGhpcy5fbG9jYWxJY2VDYW5kaWRhdGVzQnVmZmVyID0gW107XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2VtaXRCdWZmZXJlZENhbmRpZGF0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoc2VsZi5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAvLyBGSVhNRTogbmVlZCB0byBhcHBseSBpY2UgY2FuZGlkYXRlcyBpbiBhIHdheSB3aGljaCBpcyBhc3luYyBidXRcbiAgICAgIC8vIGluLW9yZGVyXG4gICAgICB0aGlzLl9sb2NhbEljZUNhbmRpZGF0ZXNCdWZmZXIuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgZW5kID0gIWV2ZW50LmNhbmRpZGF0ZSB8fCBPYmplY3Qua2V5cyhldmVudC5jYW5kaWRhdGUpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgc2VjdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uc1tqXS5pbmRleE9mKCdcXHJcXG5hPWVuZC1vZi1jYW5kaWRhdGVzXFxyXFxuJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHNlY3Rpb25zW2pdICs9ICdhPWVuZC1vZi1jYW5kaWRhdGVzXFxyXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZS5pbmRleE9mKCd0eXAgZW5kT2ZDYW5kaWRhdGVzJylcbiAgICAgICAgICAgID09PSAtMSkge1xuICAgICAgICAgIHNlY3Rpb25zW2V2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4ICsgMV0gKz1cbiAgICAgICAgICAgICAgJ2E9JyArIGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUgKyAnXFxyXFxuJztcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmxvY2FsRGVzY3JpcHRpb24uc2RwID0gc2VjdGlvbnMuam9pbignJyk7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIGlmIChzZWxmLm9uaWNlY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgc2VsZi5vbmljZWNhbmRpZGF0ZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFldmVudC5jYW5kaWRhdGUgJiYgc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIHZhciBjb21wbGV0ZSA9IHNlbGYudHJhbnNjZWl2ZXJzLmV2ZXJ5KGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5zdGF0ZSA9PT0gJ2NvbXBsZXRlZCc7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZWxmLmljZUdhdGhlcmluZ1N0YXRlID0gJ2NvbXBsZXRlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbG9jYWxJY2VDYW5kaWRhdGVzQnVmZmVyID0gW107XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0Q29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIC8vIENsb25lIGlzIG5lY2Vzc2FyeSBmb3IgbG9jYWwgZGVtb3MgbW9zdGx5LCBhdHRhY2hpbmcgZGlyZWN0bHlcbiAgICAgIC8vIHRvIHR3byBkaWZmZXJlbnQgc2VuZGVycyBkb2VzIG5vdCB3b3JrIChidWlsZCAxMDU0NykuXG4gICAgICB2YXIgY2xvbmVkU3RyZWFtID0gc3RyZWFtLmNsb25lKCk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaywgaWR4KSB7XG4gICAgICAgIHZhciBjbG9uZWRUcmFjayA9IGNsb25lZFN0cmVhbS5nZXRUcmFja3MoKVtpZHhdO1xuICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmFibGVkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICBjbG9uZWRUcmFjay5lbmFibGVkID0gZXZlbnQuZW5hYmxlZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9jYWxTdHJlYW1zLnB1c2goY2xvbmVkU3RyZWFtKTtcbiAgICAgIHRoaXMuX21heWJlRmlyZU5lZ290aWF0aW9uTmVlZGVkKCk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5sb2NhbFN0cmVhbXMuaW5kZXhPZihzdHJlYW0pO1xuICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdHJlYW1zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLl9tYXliZUZpcmVOZWdvdGlhdGlvbk5lZWRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zY2VpdmVycy5maWx0ZXIoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhdHJhbnNjZWl2ZXIucnRwU2VuZGVyO1xuICAgICAgfSlcbiAgICAgIC5tYXAoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJ0cFNlbmRlcjtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNjZWl2ZXJzLmZpbHRlcihmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gISF0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBEZXRlcm1pbmVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgbG9jYWwgYW5kIHJlbW90ZSBjYXBhYmlsaXRpZXMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzID1cbiAgICAgICAgZnVuY3Rpb24obG9jYWxDYXBhYmlsaXRpZXMsIHJlbW90ZUNhcGFiaWxpdGllcykge1xuICAgICAgICAgIHZhciBjb21tb25DYXBhYmlsaXRpZXMgPSB7XG4gICAgICAgICAgICBjb2RlY3M6IFtdLFxuICAgICAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICAgICAgICBmZWNNZWNoYW5pc21zOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzLmZvckVhY2goZnVuY3Rpb24obENvZGVjKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW90ZUNhcGFiaWxpdGllcy5jb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJDb2RlYyA9IHJlbW90ZUNhcGFiaWxpdGllcy5jb2RlY3NbaV07XG4gICAgICAgICAgICAgIGlmIChsQ29kZWMubmFtZS50b0xvd2VyQ2FzZSgpID09PSByQ29kZWMubmFtZS50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICAgICAgICBsQ29kZWMuY2xvY2tSYXRlID09PSByQ29kZWMuY2xvY2tSYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGNoYW5uZWxzIGlzIHRoZSBoaWdoZXN0IGNvbW1vbiBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgICAgICAgICAgICByQ29kZWMubnVtQ2hhbm5lbHMgPSBNYXRoLm1pbihsQ29kZWMubnVtQ2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgICAgIHJDb2RlYy5udW1DaGFubmVscyk7XG4gICAgICAgICAgICAgICAgLy8gcHVzaCByQ29kZWMgc28gd2UgcmVwbHkgd2l0aCBvZmZlcmVyIHBheWxvYWQgdHlwZVxuICAgICAgICAgICAgICAgIGNvbW1vbkNhcGFiaWxpdGllcy5jb2RlY3MucHVzaChyQ29kZWMpO1xuXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGNvbW1vbiBmZWVkYmFjayBtZWNoYW5pc21zXG4gICAgICAgICAgICAgICAgckNvZGVjLnJ0Y3BGZWVkYmFjayA9IHJDb2RlYy5ydGNwRmVlZGJhY2suZmlsdGVyKGZ1bmN0aW9uKGZiKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxDb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxDb2RlYy5ydGNwRmVlZGJhY2tbal0udHlwZSA9PT0gZmIudHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbENvZGVjLnJ0Y3BGZWVkYmFja1tqXS5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IGFsc28gbmVlZCB0byBkZXRlcm1pbmUgLnBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAvLyAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVucGVlci9vcnRjL2lzc3Vlcy81NjlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihsSGVhZGVyRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdGVDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBySGVhZGVyRXh0ZW5zaW9uID0gcmVtb3RlQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAobEhlYWRlckV4dGVuc2lvbi51cmkgPT09IHJIZWFkZXJFeHRlbnNpb24udXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbkNhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zLnB1c2gockhlYWRlckV4dGVuc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBGSVhNRTogZmVjTWVjaGFuaXNtc1xuICAgICAgICAgIHJldHVybiBjb21tb25DYXBhYmlsaXRpZXM7XG4gICAgICAgIH07XG5cbiAgICAvLyBDcmVhdGUgSUNFIGdhdGhlcmVyLCBJQ0UgdHJhbnNwb3J0IGFuZCBEVExTIHRyYW5zcG9ydC5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVJY2VBbmREdGxzVHJhbnNwb3J0cyA9XG4gICAgICAgIGZ1bmN0aW9uKG1pZCwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB2YXIgaWNlR2F0aGVyZXIgPSBuZXcgUlRDSWNlR2F0aGVyZXIoc2VsZi5pY2VPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaWNlVHJhbnNwb3J0ID0gbmV3IFJUQ0ljZVRyYW5zcG9ydChpY2VHYXRoZXJlcik7XG4gICAgICAgICAgaWNlR2F0aGVyZXIub25sb2NhbGNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdpY2VjYW5kaWRhdGUnKTtcbiAgICAgICAgICAgIGV2ZW50LmNhbmRpZGF0ZSA9IHtzZHBNaWQ6IG1pZCwgc2RwTUxpbmVJbmRleDogc2RwTUxpbmVJbmRleH07XG5cbiAgICAgICAgICAgIHZhciBjYW5kID0gZXZ0LmNhbmRpZGF0ZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSAhY2FuZCB8fCBPYmplY3Qua2V5cyhjYW5kKS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAvLyBFZGdlIGVtaXRzIGFuIGVtcHR5IG9iamVjdCBmb3IgUlRDSWNlQ2FuZGlkYXRlQ29tcGxldGXigKVcbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgLy8gcG9seWZpbGwgc2luY2UgUlRDSWNlR2F0aGVyZXIuc3RhdGUgaXMgbm90IGltcGxlbWVudGVkIGluXG4gICAgICAgICAgICAgIC8vIEVkZ2UgMTA1NDcgeWV0LlxuICAgICAgICAgICAgICBpZiAoaWNlR2F0aGVyZXIuc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGljZUdhdGhlcmVyLnN0YXRlID0gJ2NvbXBsZXRlZCc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBFbWl0IGEgY2FuZGlkYXRlIHdpdGggdHlwZSBlbmRPZkNhbmRpZGF0ZXMgdG8gbWFrZSB0aGUgc2FtcGxlc1xuICAgICAgICAgICAgICAvLyB3b3JrLiBFZGdlIHJlcXVpcmVzIGFkZEljZUNhbmRpZGF0ZSB3aXRoIHRoaXMgZW1wdHkgY2FuZGlkYXRlXG4gICAgICAgICAgICAgIC8vIHRvIHN0YXJ0IGNoZWNraW5nLiBUaGUgcmVhbCBzb2x1dGlvbiBpcyB0byBzaWduYWxcbiAgICAgICAgICAgICAgLy8gZW5kLW9mLWNhbmRpZGF0ZXMgdG8gdGhlIG90aGVyIHNpZGUgd2hlbiBnZXR0aW5nIHRoZSBudWxsXG4gICAgICAgICAgICAgIC8vIGNhbmRpZGF0ZSBidXQgc29tZSBhcHBzIChsaWtlIHRoZSBzYW1wbGVzKSBkb24ndCBkbyB0aGF0LlxuICAgICAgICAgICAgICBldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlID1cbiAgICAgICAgICAgICAgICAgICdjYW5kaWRhdGU6MSAxIHVkcCAxIDAuMC4wLjAgOSB0eXAgZW5kT2ZDYW5kaWRhdGVzJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJUQ0ljZUNhbmRpZGF0ZSBkb2Vzbid0IGhhdmUgYSBjb21wb25lbnQsIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICAgIGNhbmQuY29tcG9uZW50ID0gaWNlVHJhbnNwb3J0LmNvbXBvbmVudCA9PT0gJ1JUQ1AnID8gMiA6IDE7XG4gICAgICAgICAgICAgIGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUgPSBTRFBVdGlscy53cml0ZUNhbmRpZGF0ZShjYW5kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIGxvY2FsIGRlc2NyaXB0aW9uLlxuICAgICAgICAgICAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhzZWxmLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICAgIGlmIChldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlLmluZGV4T2YoJ3R5cCBlbmRPZkNhbmRpZGF0ZXMnKVxuICAgICAgICAgICAgICAgID09PSAtMSkge1xuICAgICAgICAgICAgICBzZWN0aW9uc1tldmVudC5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCArIDFdICs9XG4gICAgICAgICAgICAgICAgICAnYT0nICsgZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSArICdcXHJcXG4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VjdGlvbnNbZXZlbnQuY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXggKyAxXSArPVxuICAgICAgICAgICAgICAgICAgJ2E9ZW5kLW9mLWNhbmRpZGF0ZXNcXHJcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5sb2NhbERlc2NyaXB0aW9uLnNkcCA9IHNlY3Rpb25zLmpvaW4oJycpO1xuXG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBzZWxmLnRyYW5zY2VpdmVycy5ldmVyeShmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIgJiZcbiAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLnN0YXRlID09PSAnY29tcGxldGVkJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBFbWl0IGNhbmRpZGF0ZSBpZiBsb2NhbERlc2NyaXB0aW9uIGlzIHNldC5cbiAgICAgICAgICAgIC8vIEFsc28gZW1pdHMgbnVsbCBjYW5kaWRhdGUgd2hlbiBhbGwgZ2F0aGVyZXJzIGFyZSBjb21wbGV0ZS5cbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlICduZXcnOlxuICAgICAgICAgICAgICAgIHNlbGYuX2xvY2FsSWNlQ2FuZGlkYXRlc0J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kICYmIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9sb2NhbEljZUNhbmRpZGF0ZXNCdWZmZXIucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgRXZlbnQoJ2ljZWNhbmRpZGF0ZScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2dhdGhlcmluZyc6XG4gICAgICAgICAgICAgICAgc2VsZi5fZW1pdEJ1ZmZlcmVkQ2FuZGlkYXRlcygpO1xuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub25pY2VjYW5kaWRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYub25pY2VjYW5kaWRhdGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2ljZWNhbmRpZGF0ZScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9uaWNlY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25pY2VjYW5kaWRhdGUobmV3IEV2ZW50KCdpY2VjYW5kaWRhdGUnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzZWxmLmljZUdhdGhlcmluZ1N0YXRlID0gJ2NvbXBsZXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlbi4uLiBjdXJyZW50bHkhXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IC8vIG5vLW9wLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWNlVHJhbnNwb3J0Lm9uaWNlc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgZHRsc1RyYW5zcG9ydCA9IG5ldyBSVENEdGxzVHJhbnNwb3J0KGljZVRyYW5zcG9ydCk7XG4gICAgICAgICAgZHRsc1RyYW5zcG9ydC5vbmR0bHNzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkdGxzVHJhbnNwb3J0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG9uZXJyb3IgZG9lcyBub3Qgc2V0IHN0YXRlIHRvIGZhaWxlZCBieSBpdHNlbGYuXG4gICAgICAgICAgICBkdGxzVHJhbnNwb3J0LnN0YXRlID0gJ2ZhaWxlZCc7XG4gICAgICAgICAgICBzZWxmLl91cGRhdGVDb25uZWN0aW9uU3RhdGUoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGljZUdhdGhlcmVyOiBpY2VHYXRoZXJlcixcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydDogaWNlVHJhbnNwb3J0LFxuICAgICAgICAgICAgZHRsc1RyYW5zcG9ydDogZHRsc1RyYW5zcG9ydFxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAvLyBTdGFydCB0aGUgUlRQIFNlbmRlciBhbmQgUmVjZWl2ZXIgZm9yIGEgdHJhbnNjZWl2ZXIuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fdHJhbnNjZWl2ZSA9IGZ1bmN0aW9uKHRyYW5zY2VpdmVyLFxuICAgICAgICBzZW5kLCByZWN2KSB7XG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5fZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzKHRyYW5zY2VpdmVyLmxvY2FsQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlbW90ZUNhcGFiaWxpdGllcyk7XG4gICAgICBpZiAoc2VuZCAmJiB0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgIHBhcmFtcy5ydGNwID0ge1xuICAgICAgICAgIGNuYW1lOiBTRFBVdGlscy5sb2NhbENOYW1lXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHBhcmFtcy5ydGNwLnNzcmMgPSB0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmM7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyLnNlbmQocGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN2ICYmIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyKSB7XG4gICAgICAgIC8vIHJlbW92ZSBSVFggZmllbGQgaW4gRWRnZSAxNDk0MlxuICAgICAgICBpZiAodHJhbnNjZWl2ZXIua2luZCA9PT0gJ3ZpZGVvJ1xuICAgICAgICAgICAgJiYgdHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVycykge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBkZWxldGUgcC5ydHg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgIHBhcmFtcy5ydGNwID0ge1xuICAgICAgICAgIGNuYW1lOiB0cmFuc2NlaXZlci5jbmFtZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXJhbXMucnRjcC5zc3JjID0gdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyLnJlY2VpdmUocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID1cbiAgICAgICAgZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNlY3Rpb25zO1xuICAgICAgICAgIHZhciBzZXNzaW9ucGFydDtcbiAgICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICAgICAgLy8gRklYTUU6IFdoYXQgd2FzIHRoZSBwdXJwb3NlIG9mIHRoaXMgZW1wdHkgaWYgc3RhdGVtZW50P1xuICAgICAgICAgICAgLy8gaWYgKCF0aGlzLl9wZW5kaW5nT2ZmZXIpIHtcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ09mZmVyKSB7XG4gICAgICAgICAgICAgIC8vIFZFUlkgbGltaXRlZCBzdXBwb3J0IGZvciBTRFAgbXVuZ2luZy4gTGltaXRlZCB0bzpcbiAgICAgICAgICAgICAgLy8gKiBjaGFuZ2luZyB0aGUgb3JkZXIgb2YgY29kZWNzXG4gICAgICAgICAgICAgIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgICAgICBzZXNzaW9ucGFydCA9IHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcHMgPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9wZW5kaW5nT2ZmZXJbc2RwTUxpbmVJbmRleF0ubG9jYWxDYXBhYmlsaXRpZXMgPSBjYXBzO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2NlaXZlcnMgPSB0aGlzLl9wZW5kaW5nT2ZmZXI7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nT2ZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICAgICAgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKHNlbGYucmVtb3RlRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICAgIHNlc3Npb25wYXJ0ID0gc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBpc0ljZUxpdGUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChzZXNzaW9ucGFydCxcbiAgICAgICAgICAgICAgICAnYT1pY2UtbGl0ZScpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAgICAgICB2YXIgdHJhbnNjZWl2ZXIgPSBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XTtcbiAgICAgICAgICAgICAgdmFyIGljZUdhdGhlcmVyID0gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXI7XG4gICAgICAgICAgICAgIHZhciBpY2VUcmFuc3BvcnQgPSB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQ7XG4gICAgICAgICAgICAgIHZhciBkdGxzVHJhbnNwb3J0ID0gdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydDtcbiAgICAgICAgICAgICAgdmFyIGxvY2FsQ2FwYWJpbGl0aWVzID0gdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXM7XG4gICAgICAgICAgICAgIHZhciByZW1vdGVDYXBhYmlsaXRpZXMgPSB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXM7XG5cbiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gbWVkaWFTZWN0aW9uLnNwbGl0KCdcXG4nLCAxKVswXVxuICAgICAgICAgICAgICAgICAgLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcblxuICAgICAgICAgICAgICBpZiAoIXJlamVjdGVkICYmICF0cmFuc2NlaXZlci5pc0RhdGFjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW90ZUljZVBhcmFtZXRlcnMgPSBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgICAgICAgICBtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJY2VMaXRlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FuZHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWNhbmRpZGF0ZTonKVxuICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShjYW5kKTtcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbmQuY29tcG9uZW50ID09PSAnMSc7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIC8vIGljZS1saXRlIG9ubHkgaW5jbHVkZXMgaG9zdCBjYW5kaWRhdGVzIGluIHRoZSBTRFAgc28gd2UgY2FuXG4gICAgICAgICAgICAgICAgICAvLyB1c2Ugc2V0UmVtb3RlQ2FuZGlkYXRlcyAod2hpY2ggaW1wbGllcyBhblxuICAgICAgICAgICAgICAgICAgLy8gUlRDSWNlQ2FuZGlkYXRlQ29tcGxldGUpXG4gICAgICAgICAgICAgICAgICBpZiAoY2FuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zZXRSZW1vdGVDYW5kaWRhdGVzKGNhbmRzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlbW90ZUR0bHNQYXJhbWV0ZXJzID0gU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMoXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ljZUxpdGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlbW90ZUR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnc2VydmVyJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYudXNpbmdCdW5kbGUgfHwgc2RwTUxpbmVJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgaWNlVHJhbnNwb3J0LnN0YXJ0KGljZUdhdGhlcmVyLCByZW1vdGVJY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgIGlzSWNlTGl0ZSA/ICdjb250cm9sbGluZycgOiAnY29udHJvbGxlZCcpO1xuICAgICAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydC5zdGFydChyZW1vdGVEdGxzUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBvZiBjYXBhYmlsaXRpZXMuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHNlbGYuX2dldENvbW1vbkNhcGFiaWxpdGllcyhsb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2FwYWJpbGl0aWVzKTtcblxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBSVENSdHBTZW5kZXIuIFRoZSBSVENSdHBSZWNlaXZlciBmb3IgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zY2VpdmVyIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBpbiBzZXRSZW1vdGVEZXNjcmlwdGlvbi5cbiAgICAgICAgICAgICAgICBzZWxmLl90cmFuc2NlaXZlKHRyYW5zY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29kZWNzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sb2NhbERlc2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgICAgICAgIHNkcDogZGVzY3JpcHRpb24uc2RwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29mZmVyJzpcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ2hhdmUtbG9jYWwtb2ZmZXInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbnN3ZXInOlxuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTaWduYWxpbmdTdGF0ZSgnc3RhYmxlJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgdHlwZSBcIicgKyBkZXNjcmlwdGlvbi50eXBlICtcbiAgICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgc3VjY2VzcyBjYWxsYmFjayB3YXMgcHJvdmlkZWQsIGVtaXQgSUNFIGNhbmRpZGF0ZXMgYWZ0ZXIgaXRcbiAgICAgICAgICAvLyBoYXMgYmVlbiBleGVjdXRlZC4gT3RoZXJ3aXNlLCBlbWl0IGNhbGxiYWNrIGFmdGVyIHRoZSBQcm9taXNlIGlzXG4gICAgICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICAgICAgdmFyIGhhc0NhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY2IgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSA9ICdnYXRoZXJpbmcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuX2VtaXRCdWZmZXJlZENhbmRpZGF0ZXMoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIHAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSA9ICdnYXRoZXJpbmcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFVzdWFsbHkgY2FuZGlkYXRlcyB3aWxsIGJlIGVtaXR0ZWQgZWFybGllci5cbiAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VsZi5fZW1pdEJ1ZmZlcmVkQ2FuZGlkYXRlcy5iaW5kKHNlbGYpLCA1MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgICAgIGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXJMaXN0ID0gW107XG4gICAgICAgICAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgIHZhciBzZXNzaW9ucGFydCA9IHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgdmFyIGlzSWNlTGl0ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KHNlc3Npb25wYXJ0LFxuICAgICAgICAgICAgICAnYT1pY2UtbGl0ZScpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgdGhpcy51c2luZ0J1bmRsZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KHNlc3Npb25wYXJ0LFxuICAgICAgICAgICAgICAnYT1ncm91cDpCVU5ETEUgJykubGVuZ3RoID4gMDtcbiAgICAgICAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIG1saW5lID0gbGluZXNbMF0uc3Vic3RyKDIpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICB2YXIga2luZCA9IG1saW5lWzBdO1xuICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gbWxpbmVbMV0gPT09ICcwJztcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBTRFBVdGlscy5nZXREaXJlY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCk7XG5cbiAgICAgICAgICAgIHZhciBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKTtcbiAgICAgICAgICAgIGlmIChtaWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1pZCA9IG1pZFswXS5zdWJzdHIoNik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtaWQgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVqZWN0IGRhdGFjaGFubmVscyB3aGljaCBhcmUgbm90IGltcGxlbWVudGVkIHlldC5cbiAgICAgICAgICAgIGlmIChraW5kID09PSAnYXBwbGljYXRpb24nICYmIG1saW5lWzJdID09PSAnRFRMUy9TQ1RQJykge1xuICAgICAgICAgICAgICBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICBtaWQ6IG1pZCxcbiAgICAgICAgICAgICAgICBpc0RhdGFjaGFubmVsOiB0cnVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRyYW5zY2VpdmVyO1xuICAgICAgICAgICAgdmFyIGljZUdhdGhlcmVyO1xuICAgICAgICAgICAgdmFyIGljZVRyYW5zcG9ydDtcbiAgICAgICAgICAgIHZhciBkdGxzVHJhbnNwb3J0O1xuICAgICAgICAgICAgdmFyIHJ0cFNlbmRlcjtcbiAgICAgICAgICAgIHZhciBydHBSZWNlaXZlcjtcbiAgICAgICAgICAgIHZhciBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgdmFyIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgICAgICB2YXIgbG9jYWxDYXBhYmlsaXRpZXM7XG5cbiAgICAgICAgICAgIHZhciB0cmFjaztcbiAgICAgICAgICAgIC8vIEZJWE1FOiBlbnN1cmUgdGhlIG1lZGlhU2VjdGlvbiBoYXMgcnRjcC1tdXggc2V0LlxuICAgICAgICAgICAgdmFyIHJlbW90ZUNhcGFiaWxpdGllcyA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIHJlbW90ZUljZVBhcmFtZXRlcnM7XG4gICAgICAgICAgICB2YXIgcmVtb3RlRHRsc1BhcmFtZXRlcnM7XG4gICAgICAgICAgICBpZiAoIXJlamVjdGVkKSB7XG4gICAgICAgICAgICAgIHJlbW90ZUljZVBhcmFtZXRlcnMgPSBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbixcbiAgICAgICAgICAgICAgICAgIHNlc3Npb25wYXJ0KTtcbiAgICAgICAgICAgICAgcmVtb3RlRHRsc1BhcmFtZXRlcnMgPSBTRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24sXG4gICAgICAgICAgICAgICAgICBzZXNzaW9ucGFydCk7XG4gICAgICAgICAgICAgIHJlbW90ZUR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnY2xpZW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMgPVxuICAgICAgICAgICAgICAgIFNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG5cbiAgICAgICAgICAgIHZhciBjbmFtZTtcbiAgICAgICAgICAgIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAgICAgICAgICAgLy8gU1NSQ3MuXG4gICAgICAgICAgICB2YXIgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnO1xuICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICAgICAgICAgICAgY25hbWUgPSByZW1vdGVTc3JjLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNDb21wbGV0ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbixcbiAgICAgICAgICAgICAgICAnYT1lbmQtb2YtY2FuZGlkYXRlcycsIHNlc3Npb25wYXJ0KS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIGNhbmRzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1jYW5kaWRhdGU6JylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGNhbmQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShjYW5kKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2FuZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbmQuY29tcG9uZW50ID09PSAnMSc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJyAmJiAhcmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zcG9ydHMgPSBzZWxmLnVzaW5nQnVuZGxlICYmIHNkcE1MaW5lSW5kZXggPiAwID8ge1xuICAgICAgICAgICAgICAgIGljZUdhdGhlcmVyOiBzZWxmLnRyYW5zY2VpdmVyc1swXS5pY2VHYXRoZXJlcixcbiAgICAgICAgICAgICAgICBpY2VUcmFuc3BvcnQ6IHNlbGYudHJhbnNjZWl2ZXJzWzBdLmljZVRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICBkdGxzVHJhbnNwb3J0OiBzZWxmLnRyYW5zY2VpdmVyc1swXS5kdGxzVHJhbnNwb3J0XG4gICAgICAgICAgICAgIH0gOiBzZWxmLl9jcmVhdGVJY2VBbmREdGxzVHJhbnNwb3J0cyhtaWQsIHNkcE1MaW5lSW5kZXgpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0cy5pY2VUcmFuc3BvcnQuc2V0UmVtb3RlQ2FuZGlkYXRlcyhjYW5kcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcyA9IFJUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcyhraW5kKTtcblxuICAgICAgICAgICAgICAvLyBmaWx0ZXIgUlRYIHVudGlsIGFkZGl0aW9uYWwgc3R1ZmYgbmVlZGVkIGZvciBSVFggaXMgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgICAgLy8gaW4gYWRhcHRlci5qc1xuICAgICAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MgPSBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oY29kZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjLm5hbWUgIT09ICdydHgnO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IFt7XG4gICAgICAgICAgICAgICAgc3NyYzogKDIgKiBzZHBNTGluZUluZGV4ICsgMikgKiAxMDAxXG4gICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAgIHJ0cFJlY2VpdmVyID0gbmV3IFJUQ1J0cFJlY2VpdmVyKHRyYW5zcG9ydHMuZHRsc1RyYW5zcG9ydCwga2luZCk7XG5cbiAgICAgICAgICAgICAgdHJhY2sgPSBydHBSZWNlaXZlci50cmFjaztcbiAgICAgICAgICAgICAgcmVjZWl2ZXJMaXN0LnB1c2goW3RyYWNrLCBydHBSZWNlaXZlcl0pO1xuICAgICAgICAgICAgICAvLyBGSVhNRTogbm90IGNvcnJlY3Qgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgc3RyZWFtcyBidXQgdGhhdCBpc1xuICAgICAgICAgICAgICAvLyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBpbiB0aGlzIHNoaW0uXG4gICAgICAgICAgICAgIHN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cbiAgICAgICAgICAgICAgLy8gRklYTUU6IGxvb2sgYXQgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICBpZiAoc2VsZi5sb2NhbFN0cmVhbXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgc2VsZi5sb2NhbFN0cmVhbXNbMF0uZ2V0VHJhY2tzKCkubGVuZ3RoID49IHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxUcmFjaztcbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICAgICAgbG9jYWxUcmFjayA9IHNlbGYubG9jYWxTdHJlYW1zWzBdLmdldEF1ZGlvVHJhY2tzKClbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChraW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbFRyYWNrID0gc2VsZi5sb2NhbFN0cmVhbXNbMF0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgIHJ0cFNlbmRlciA9IG5ldyBSVENSdHBTZW5kZXIobG9jYWxUcmFjayxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRzLmR0bHNUcmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIGljZUdhdGhlcmVyOiB0cmFuc3BvcnRzLmljZUdhdGhlcmVyLFxuICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydDogdHJhbnNwb3J0cy5pY2VUcmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydDogdHJhbnNwb3J0cy5kdGxzVHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzOiBsb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICByZW1vdGVDYXBhYmlsaXRpZXM6IHJlbW90ZUNhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICBydHBTZW5kZXI6IHJ0cFNlbmRlcixcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcjogcnRwUmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgICAgICBtaWQ6IG1pZCxcbiAgICAgICAgICAgICAgICBjbmFtZTogY25hbWUsXG4gICAgICAgICAgICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVyczogc2VuZEVuY29kaW5nUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzOiByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBSVENSdHBSZWNlaXZlciBub3cuIFRoZSBSVFBTZW5kZXIgaXMgc3RhcnRlZCBpblxuICAgICAgICAgICAgICAvLyBzZXRMb2NhbERlc2NyaXB0aW9uLlxuICAgICAgICAgICAgICBzZWxmLl90cmFuc2NlaXZlKHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgICAgICAgIHRyYW5zY2VpdmVyID0gc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF07XG4gICAgICAgICAgICAgIGljZUdhdGhlcmVyID0gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXI7XG4gICAgICAgICAgICAgIGljZVRyYW5zcG9ydCA9IHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydCA9IHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQ7XG4gICAgICAgICAgICAgIHJ0cFNlbmRlciA9IHRyYW5zY2VpdmVyLnJ0cFNlbmRlcjtcbiAgICAgICAgICAgICAgcnRwUmVjZWl2ZXIgPSB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgICAgICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzID0gdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXM7XG5cbiAgICAgICAgICAgICAgc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0ucmVjdkVuY29kaW5nUGFyYW1ldGVycyA9XG4gICAgICAgICAgICAgICAgICByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5yZW1vdGVDYXBhYmlsaXRpZXMgPVxuICAgICAgICAgICAgICAgICAgcmVtb3RlQ2FwYWJpbGl0aWVzO1xuICAgICAgICAgICAgICBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5jbmFtZSA9IGNuYW1lO1xuXG4gICAgICAgICAgICAgIGlmICgoaXNJY2VMaXRlIHx8IGlzQ29tcGxldGUpICYmIGNhbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zZXRSZW1vdGVDYW5kaWRhdGVzKGNhbmRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXNlbGYudXNpbmdCdW5kbGUgfHwgc2RwTUxpbmVJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zdGFydChpY2VHYXRoZXJlciwgcmVtb3RlSWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRyb2xsaW5nJyk7XG4gICAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydC5zdGFydChyZW1vdGVEdGxzUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZWxmLl90cmFuc2NlaXZlKHRyYW5zY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IGRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5JyxcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCBkaXJlY3Rpb24gPT09ICdzZW5kb25seScpO1xuXG4gICAgICAgICAgICAgIGlmIChydHBSZWNlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgKGRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCBkaXJlY3Rpb24gPT09ICdzZW5kb25seScpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sgPSBydHBSZWNlaXZlci50cmFjaztcbiAgICAgICAgICAgICAgICByZWNlaXZlckxpc3QucHVzaChbdHJhY2ssIHJ0cFJlY2VpdmVyXSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogYWN0dWFsbHkgdGhlIHJlY2VpdmVyIHNob3VsZCBiZSBjcmVhdGVkIGxhdGVyLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5yZW1vdGVEZXNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICAgICAgICBzZHA6IGRlc2NyaXB0aW9uLnNkcFxuICAgICAgICAgIH07XG4gICAgICAgICAgc3dpdGNoIChkZXNjcmlwdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdvZmZlcic6XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdoYXZlLXJlbW90ZS1vZmZlcicpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Fuc3dlcic6XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdzdGFibGUnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnN1cHBvcnRlZCB0eXBlIFwiJyArIGRlc2NyaXB0aW9uLnR5cGUgK1xuICAgICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnJlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgaWYgKHNlbGYub25hZGRzdHJlYW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYub25hZGRzdHJlYW0oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVjZWl2ZXJMaXN0LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IGl0ZW1bMF07XG4gICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tFdmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgICB0cmFja0V2ZW50LnRyYWNrID0gdHJhY2s7XG4gICAgICAgICAgICAgICAgdHJhY2tFdmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgICAgIHRyYWNrRXZlbnQuc3RyZWFtcyA9IFtzdHJlYW1dO1xuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub250cmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub250cmFjayh0cmFja0V2ZW50KTtcbiAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGFyZ3VtZW50c1sxXSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgLyogbm90IHlldFxuICAgICAgICBpZiAodHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0KSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlcikge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEZJWE1FOiBjbGVhbiB1cCB0cmFja3MsIGxvY2FsIHN0cmVhbXMsIHJlbW90ZSBzdHJlYW1zLCBldGNcbiAgICAgIHRoaXMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdjbG9zZWQnKTtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBzaWduYWxpbmcgc3RhdGUuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlU2lnbmFsaW5nU3RhdGUgPVxuICAgICAgICBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJyk7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBpZiAodGhpcy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRvIGZpcmUgdGhlIG5lZ290aWF0aW9ubmVlZGVkIGV2ZW50LlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX21heWJlRmlyZU5lZ290aWF0aW9uTmVlZGVkID1cbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gRmlyZSBhd2F5IChmb3Igbm93KS5cbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJyk7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBpZiAodGhpcy5vbm5lZ290aWF0aW9ubmVlZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9ubmVnb3RpYXRpb25uZWVkZWQoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgY29ubmVjdGlvbiBzdGF0ZS5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl91cGRhdGVDb25uZWN0aW9uU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBuZXdTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZXMgPSB7XG4gICAgICAgICduZXcnOiAwLFxuICAgICAgICBjbG9zZWQ6IDAsXG4gICAgICAgIGNvbm5lY3Rpbmc6IDAsXG4gICAgICAgIGNoZWNraW5nOiAwLFxuICAgICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICAgIGNvbXBsZXRlZDogMCxcbiAgICAgICAgZmFpbGVkOiAwXG4gICAgICB9O1xuICAgICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICBzdGF0ZXNbdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LnN0YXRlXSsrO1xuICAgICAgICBzdGF0ZXNbdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5zdGF0ZV0rKztcbiAgICAgIH0pO1xuICAgICAgLy8gSUNFVHJhbnNwb3J0LmNvbXBsZXRlZCBhbmQgY29ubmVjdGVkIGFyZSB0aGUgc2FtZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgc3RhdGVzLmNvbm5lY3RlZCArPSBzdGF0ZXMuY29tcGxldGVkO1xuXG4gICAgICBuZXdTdGF0ZSA9ICduZXcnO1xuICAgICAgaWYgKHN0YXRlcy5mYWlsZWQgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlID0gJ2ZhaWxlZCc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlcy5jb25uZWN0aW5nID4gMCB8fCBzdGF0ZXMuY2hlY2tpbmcgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlID0gJ2Nvbm5lY3RpbmcnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZXMuZGlzY29ubmVjdGVkID4gMCkge1xuICAgICAgICBuZXdTdGF0ZSA9ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZXMubmV3ID4gMCkge1xuICAgICAgICBuZXdTdGF0ZSA9ICduZXcnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZXMuY29ubmVjdGVkID4gMCB8fCBzdGF0ZXMuY29tcGxldGVkID4gMCkge1xuICAgICAgICBuZXdTdGF0ZSA9ICdjb25uZWN0ZWQnO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3U3RhdGUgIT09IHNlbGYuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgIHNlbGYuaWNlQ29ubmVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIGlmICh0aGlzLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdPZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZU9mZmVyIGNhbGxlZCB3aGlsZSB0aGVyZSBpcyBhIHBlbmRpbmcgb2ZmZXIuJyk7XG4gICAgICB9XG4gICAgICB2YXIgb2ZmZXJPcHRpb25zO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvZmZlck9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgb2ZmZXJPcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhY2tzID0gW107XG4gICAgICB2YXIgbnVtQXVkaW9UcmFja3MgPSAwO1xuICAgICAgdmFyIG51bVZpZGVvVHJhY2tzID0gMDtcbiAgICAgIC8vIERlZmF1bHQgdG8gc2VuZHJlY3YuXG4gICAgICBpZiAodGhpcy5sb2NhbFN0cmVhbXMubGVuZ3RoKSB7XG4gICAgICAgIG51bUF1ZGlvVHJhY2tzID0gdGhpcy5sb2NhbFN0cmVhbXNbMF0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGg7XG4gICAgICAgIG51bVZpZGVvVHJhY2tzID0gdGhpcy5sb2NhbFN0cmVhbXNbMF0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyBEZXRlcm1pbmUgbnVtYmVyIG9mIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3Mgd2UgbmVlZCB0byBzZW5kL3JlY3YuXG4gICAgICBpZiAob2ZmZXJPcHRpb25zKSB7XG4gICAgICAgIC8vIFJlamVjdCBDaHJvbWUgbGVnYWN5IGNvbnN0cmFpbnRzLlxuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm1hbmRhdG9yeSB8fCBvZmZlck9wdGlvbnMub3B0aW9uYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAnTGVnYWN5IG1hbmRhdG9yeS9vcHRpb25hbCBjb25zdHJhaW50cyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtQXVkaW9UcmFja3MgPSBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bVZpZGVvVHJhY2tzID0gb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxvY2FsU3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gUHVzaCBsb2NhbCBzdHJlYW1zLlxuICAgICAgICB0aGlzLmxvY2FsU3RyZWFtc1swXS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgdHJhY2tzLnB1c2goe1xuICAgICAgICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgICAgIHdhbnRSZWNlaXZlOiB0cmFjay5raW5kID09PSAnYXVkaW8nID9cbiAgICAgICAgICAgICAgICBudW1BdWRpb1RyYWNrcyA+IDAgOiBudW1WaWRlb1RyYWNrcyA+IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgbnVtQXVkaW9UcmFja3MtLTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIG51bVZpZGVvVHJhY2tzLS07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBNLWxpbmVzIGZvciByZWN2b25seSBzdHJlYW1zLlxuICAgICAgd2hpbGUgKG51bUF1ZGlvVHJhY2tzID4gMCB8fCBudW1WaWRlb1RyYWNrcyA+IDApIHtcbiAgICAgICAgaWYgKG51bUF1ZGlvVHJhY2tzID4gMCkge1xuICAgICAgICAgIHRyYWNrcy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICdhdWRpbycsXG4gICAgICAgICAgICB3YW50UmVjZWl2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG51bUF1ZGlvVHJhY2tzLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bVZpZGVvVHJhY2tzID4gMCkge1xuICAgICAgICAgIHRyYWNrcy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICd2aWRlbycsXG4gICAgICAgICAgICB3YW50UmVjZWl2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG51bVZpZGVvVHJhY2tzLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNkcCA9IFNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlKCk7XG4gICAgICB2YXIgdHJhbnNjZWl2ZXJzID0gW107XG4gICAgICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbihtbGluZSwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAvLyBGb3IgZWFjaCB0cmFjaywgY3JlYXRlIGFuIGljZSBnYXRoZXJlciwgaWNlIHRyYW5zcG9ydCxcbiAgICAgICAgLy8gZHRscyB0cmFuc3BvcnQsIHBvdGVudGlhbGx5IHJ0cHNlbmRlciBhbmQgcnRwcmVjZWl2ZXIuXG4gICAgICAgIHZhciB0cmFjayA9IG1saW5lLnRyYWNrO1xuICAgICAgICB2YXIga2luZCA9IG1saW5lLmtpbmQ7XG4gICAgICAgIHZhciBtaWQgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuICAgICAgICB2YXIgdHJhbnNwb3J0cyA9IHNlbGYudXNpbmdCdW5kbGUgJiYgc2RwTUxpbmVJbmRleCA+IDAgPyB7XG4gICAgICAgICAgaWNlR2F0aGVyZXI6IHRyYW5zY2VpdmVyc1swXS5pY2VHYXRoZXJlcixcbiAgICAgICAgICBpY2VUcmFuc3BvcnQ6IHRyYW5zY2VpdmVyc1swXS5pY2VUcmFuc3BvcnQsXG4gICAgICAgICAgZHRsc1RyYW5zcG9ydDogdHJhbnNjZWl2ZXJzWzBdLmR0bHNUcmFuc3BvcnRcbiAgICAgICAgfSA6IHNlbGYuX2NyZWF0ZUljZUFuZER0bHNUcmFuc3BvcnRzKG1pZCwgc2RwTUxpbmVJbmRleCk7XG5cbiAgICAgICAgdmFyIGxvY2FsQ2FwYWJpbGl0aWVzID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcyhraW5kKTtcbiAgICAgICAgLy8gZmlsdGVyIFJUWCB1bnRpbCBhZGRpdGlvbmFsIHN0dWZmIG5lZWRlZCBmb3IgUlRYIGlzIGltcGxlbWVudGVkXG4gICAgICAgIC8vIGluIGFkYXB0ZXIuanNcbiAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzID0gbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzLmZpbHRlcihcbiAgICAgICAgICAgIGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2RlYy5uYW1lICE9PSAncnR4JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgICAgICAgIC8vIHdvcmsgYXJvdW5kIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD02NTUyXG4gICAgICAgICAgLy8gYnkgYWRkaW5nIGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPTFcbiAgICAgICAgICBpZiAoY29kZWMubmFtZSA9PT0gJ0gyNjQnICYmXG4gICAgICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnNbJ2xldmVsLWFzeW1tZXRyeS1hbGxvd2VkJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29kZWMucGFyYW1ldGVyc1snbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQnXSA9ICcxJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBydHBTZW5kZXI7XG4gICAgICAgIHZhciBydHBSZWNlaXZlcjtcblxuICAgICAgICAvLyBnZW5lcmF0ZSBhbiBzc3JjIG5vdywgdG8gYmUgdXNlZCBsYXRlciBpbiBydHBTZW5kZXIuc2VuZFxuICAgICAgICB2YXIgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IFt7XG4gICAgICAgICAgc3NyYzogKDIgKiBzZHBNTGluZUluZGV4ICsgMSkgKiAxMDAxXG4gICAgICAgIH1dO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICBydHBTZW5kZXIgPSBuZXcgUlRDUnRwU2VuZGVyKHRyYWNrLCB0cmFuc3BvcnRzLmR0bHNUcmFuc3BvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1saW5lLndhbnRSZWNlaXZlKSB7XG4gICAgICAgICAgcnRwUmVjZWl2ZXIgPSBuZXcgUlRDUnRwUmVjZWl2ZXIodHJhbnNwb3J0cy5kdGxzVHJhbnNwb3J0LCBraW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSA9IHtcbiAgICAgICAgICBpY2VHYXRoZXJlcjogdHJhbnNwb3J0cy5pY2VHYXRoZXJlcixcbiAgICAgICAgICBpY2VUcmFuc3BvcnQ6IHRyYW5zcG9ydHMuaWNlVHJhbnNwb3J0LFxuICAgICAgICAgIGR0bHNUcmFuc3BvcnQ6IHRyYW5zcG9ydHMuZHRsc1RyYW5zcG9ydCxcbiAgICAgICAgICBsb2NhbENhcGFiaWxpdGllczogbG9jYWxDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgcmVtb3RlQ2FwYWJpbGl0aWVzOiBudWxsLFxuICAgICAgICAgIHJ0cFNlbmRlcjogcnRwU2VuZGVyLFxuICAgICAgICAgIHJ0cFJlY2VpdmVyOiBydHBSZWNlaXZlcixcbiAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgIG1pZDogbWlkLFxuICAgICAgICAgIHNlbmRFbmNvZGluZ1BhcmFtZXRlcnM6IHNlbmRFbmNvZGluZ1BhcmFtZXRlcnMsXG4gICAgICAgICAgcmVjdkVuY29kaW5nUGFyYW1ldGVyczogbnVsbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy51c2luZ0J1bmRsZSkge1xuICAgICAgICBzZHAgKz0gJ2E9Z3JvdXA6QlVORExFICcgKyB0cmFuc2NlaXZlcnMubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5taWQ7XG4gICAgICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24obWxpbmUsIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgdmFyIHRyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdO1xuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcywgJ29mZmVyJywgc2VsZi5sb2NhbFN0cmVhbXNbMF0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3BlbmRpbmdPZmZlciA9IHRyYW5zY2VpdmVycztcbiAgICAgIHZhciBkZXNjID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHR5cGU6ICdvZmZlcicsXG4gICAgICAgIHNkcDogc2RwXG4gICAgICB9KTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoYXJndW1lbnRzWzBdLCAwLCBkZXNjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzYyk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciBzZHAgPSBTRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSgpO1xuICAgICAgaWYgKHRoaXMudXNpbmdCdW5kbGUpIHtcbiAgICAgICAgc2RwICs9ICdhPWdyb3VwOkJVTkRMRSAnICsgdGhpcy50cmFuc2NlaXZlcnMubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5taWQ7XG4gICAgICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIuaXNEYXRhY2hhbm5lbCkge1xuICAgICAgICAgIHNkcCArPSAnbT1hcHBsaWNhdGlvbiAwIERUTFMvU0NUUCA1MDAwXFxyXFxuJyArXG4gICAgICAgICAgICAgICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJyArXG4gICAgICAgICAgICAgICdhPW1pZDonICsgdHJhbnNjZWl2ZXIubWlkICsgJ1xcclxcbic7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gb2YgY2FwYWJpbGl0aWVzLlxuICAgICAgICB2YXIgY29tbW9uQ2FwYWJpbGl0aWVzID0gc2VsZi5fZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzKFxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXMpO1xuXG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlciwgY29tbW9uQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgJ2Fuc3dlcicsIHNlbGYubG9jYWxTdHJlYW1zWzBdKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICB0eXBlOiAnYW5zd2VyJyxcbiAgICAgICAgc2RwOiBzZHBcbiAgICAgIH0pO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChhcmd1bWVudHNbMF0sIDAsIGRlc2MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKHt9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbUxpbmVJbmRleCA9IGNhbmRpZGF0ZS5zZHBNTGluZUluZGV4O1xuICAgICAgICBpZiAoY2FuZGlkYXRlLnNkcE1pZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2NlaXZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zY2VpdmVyc1tpXS5taWQgPT09IGNhbmRpZGF0ZS5zZHBNaWQpIHtcbiAgICAgICAgICAgICAgbUxpbmVJbmRleCA9IGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNjZWl2ZXIgPSB0aGlzLnRyYW5zY2VpdmVyc1ttTGluZUluZGV4XTtcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgdmFyIGNhbmQgPSBPYmplY3Qua2V5cyhjYW5kaWRhdGUuY2FuZGlkYXRlKS5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoY2FuZGlkYXRlLmNhbmRpZGF0ZSkgOiB7fTtcbiAgICAgICAgICAvLyBJZ25vcmUgQ2hyb21lJ3MgaW52YWxpZCBjYW5kaWRhdGVzIHNpbmNlIEVkZ2UgZG9lcyBub3QgbGlrZSB0aGVtLlxuICAgICAgICAgIGlmIChjYW5kLnByb3RvY29sID09PSAndGNwJyAmJiAoY2FuZC5wb3J0ID09PSAwIHx8IGNhbmQucG9ydCA9PT0gOSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWdub3JlIFJUQ1AgY2FuZGlkYXRlcywgd2UgYXNzdW1lIFJUQ1AtTVVYLlxuICAgICAgICAgIGlmIChjYW5kLmNvbXBvbmVudCAhPT0gJzEnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEEgZGlydHkgaGFjayB0byBtYWtlIHNhbXBsZXMgd29yay5cbiAgICAgICAgICBpZiAoY2FuZC50eXBlID09PSAnZW5kT2ZDYW5kaWRhdGVzJykge1xuICAgICAgICAgICAgY2FuZCA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKGNhbmQpO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSByZW1vdGVEZXNjcmlwdGlvbi5cbiAgICAgICAgICB2YXIgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKHRoaXMucmVtb3RlRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICBzZWN0aW9uc1ttTGluZUluZGV4ICsgMV0gKz0gKGNhbmQudHlwZSA/IGNhbmRpZGF0ZS5jYW5kaWRhdGUudHJpbSgpXG4gICAgICAgICAgICAgIDogJ2E9ZW5kLW9mLWNhbmRpZGF0ZXMnKSArICdcXHJcXG4nO1xuICAgICAgICAgIHRoaXMucmVtb3RlRGVzY3JpcHRpb24uc2RwID0gc2VjdGlvbnMuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGFyZ3VtZW50c1sxXSwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICBbJ3J0cFNlbmRlcicsICdydHBSZWNlaXZlcicsICdpY2VHYXRoZXJlcicsICdpY2VUcmFuc3BvcnQnLFxuICAgICAgICAgICAgJ2R0bHNUcmFuc3BvcnQnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXJbbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godHJhbnNjZWl2ZXJbbWV0aG9kXS5nZXRTdGF0cygpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBhcmd1bWVudHNbMV07XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAvLyBzaGltIGdldFN0YXRzIHdpdGggbWFwbGlrZSBzdXBwb3J0XG4gICAgICAgIHZhciByZXN1bHRzID0gbmV3IE1hcCgpO1xuICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICByZXMuZm9yRWFjaChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICByZXN1bHRzLnNldChpZCwgcmVzdWx0W2lkXSk7XG4gICAgICAgICAgICAgIHJlc3VsdHNbaWRdID0gcmVzdWx0W2lkXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2IsIDAsIHJlc3VsdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGltUGVlckNvbm5lY3Rpb246IGVkZ2VTaGltLnNoaW1QZWVyQ29ubmVjdGlvbixcbiAgc2hpbUdldFVzZXJNZWRpYTogcmVxdWlyZSgnLi9nZXR1c2VybWVkaWEnKVxufTtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2hpbUVycm9yXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1Blcm1pc3Npb25EZW5pZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcid9W2UubmFtZV0gfHwgZS5uYW1lLFxuICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgY29uc3RyYWludDogZS5jb25zdHJhaW50LFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gZ2V0VXNlck1lZGlhIGVycm9yIHNoaW0uXG4gIHZhciBvcmlnR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuXG4gICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gb3JpZ0dldFVzZXJNZWRpYShjKS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2hpbUVycm9yXyhlKSk7XG4gICAgfSk7XG4gIH07XG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyRGV0YWlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuYnJvd3NlckRldGFpbHM7XG5cbnZhciBmaXJlZm94U2hpbSA9IHtcbiAgc2hpbU9uVHJhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW5cbiAgICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb250cmFjaztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayA9IGYpO1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSB7dHJhY2s6IHRyYWNrfTtcbiAgICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBzaGltU291cmNlT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBGaXJlZm94IGhhcyBzdXBwb3J0ZWQgbW96U3JjT2JqZWN0IHNpbmNlIEZGMjIsIHVucHJlZml4ZWQgaW4gNDIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAod2luZG93LkhUTUxNZWRpYUVsZW1lbnQgJiZcbiAgICAgICAgISgnc3JjT2JqZWN0JyBpbiB3aW5kb3cuSFRNTE1lZGlhRWxlbWVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgIC8vIFNoaW0gdGhlIHNyY09iamVjdCBwcm9wZXJ0eSwgb25jZSwgd2hlbiBIVE1MTWVkaWFFbGVtZW50IGlzIGZvdW5kLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LkhUTUxNZWRpYUVsZW1lbnQucHJvdG90eXBlLCAnc3JjT2JqZWN0Jywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3pTcmNPYmplY3Q7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5tb3pTcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICAgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgICAgcmV0dXJuOyAvLyBwcm9iYWJseSBtZWRpYS5wZWVyY29ubmVjdGlvbi5lbmFibGVkPWZhbHNlIGluIGFib3V0OmNvbmZpZ1xuICAgIH1cbiAgICAvLyBUaGUgUlRDUGVlckNvbm5lY3Rpb24gb2JqZWN0LlxuICAgIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cykge1xuICAgICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDM4KSB7XG4gICAgICAgICAgLy8gLnVybHMgaXMgbm90IHN1cHBvcnRlZCBpbiBGRiA8IDM4LlxuICAgICAgICAgIC8vIGNyZWF0ZSBSVENJY2VTZXJ2ZXJzIHdpdGggYSBzaW5nbGUgdXJsLlxuICAgICAgICAgIGlmIChwY0NvbmZpZyAmJiBwY0NvbmZpZy5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbmV3SWNlU2VydmVycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwY0NvbmZpZy5pY2VTZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSBwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldO1xuICAgICAgICAgICAgICBpZiAoc2VydmVyLmhhc093blByb3BlcnR5KCd1cmxzJykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcnZlci51cmxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmV3U2VydmVyID0ge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHNlcnZlci51cmxzW2pdXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlci51cmxzW2pdLmluZGV4T2YoJ3R1cm4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXJ2ZXIudXNlcm5hbWUgPSBzZXJ2ZXIudXNlcm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlcnZlci5jcmVkZW50aWFsID0gc2VydmVyLmNyZWRlbnRpYWw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2gobmV3U2VydmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHBjQ29uZmlnLmljZVNlcnZlcnNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwY0NvbmZpZy5pY2VTZXJ2ZXJzID0gbmV3SWNlU2VydmVycztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBtb3pSVENQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gICAgICB9O1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IG1velJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcblxuICAgICAgLy8gd3JhcCBzdGF0aWMgbWV0aG9kcy4gQ3VycmVudGx5IGp1c3QgZ2VuZXJhdGVDZXJ0aWZpY2F0ZS5cbiAgICAgIGlmIChtb3pSVENQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbW96UlRDUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gbW96UlRDU2Vzc2lvbkRlc2NyaXB0aW9uO1xuICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IG1velJUQ0ljZUNhbmRpZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzaGltIGF3YXkgbmVlZCBmb3Igb2Jzb2xldGUgUlRDSWNlQ2FuZGlkYXRlL1JUQ1Nlc3Npb25EZXNjcmlwdGlvbi5cbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ11cbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgdmFyIG5hdGl2ZU1ldGhvZCA9IFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnKSA/XG4gICAgICAgICAgICAgICAgUlRDSWNlQ2FuZGlkYXRlIDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxuICAgIHZhciBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPVxuICAgICAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDQ4KSB7XG4gICAgICAvLyBzaGltIGdldFN0YXRzIHdpdGggbWFwbGlrZSBzdXBwb3J0XG4gICAgICB2YXIgbWFrZU1hcFN0YXRzID0gZnVuY3Rpb24oc3RhdHMpIHtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3RhdHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgbWFwLnNldChrZXksIHN0YXRzW2tleV0pO1xuICAgICAgICAgIG1hcFtrZXldID0gc3RhdHNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbmF0aXZlR2V0U3RhdHMgPSBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gICAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbihzZWxlY3Rvciwgb25TdWNjLCBvbkVycikge1xuICAgICAgICByZXR1cm4gbmF0aXZlR2V0U3RhdHMuYXBwbHkodGhpcywgW3NlbGVjdG9yIHx8IG51bGxdKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZU1hcFN0YXRzKHN0YXRzKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKG9uU3VjYywgb25FcnIpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGltT25UcmFjazogZmlyZWZveFNoaW0uc2hpbU9uVHJhY2ssXG4gIHNoaW1Tb3VyY2VPYmplY3Q6IGZpcmVmb3hTaGltLnNoaW1Tb3VyY2VPYmplY3QsXG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uLFxuICBzaGltR2V0VXNlck1lZGlhOiByZXF1aXJlKCcuL2dldHVzZXJtZWRpYScpXG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2dnaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5sb2c7XG52YXIgYnJvd3NlckRldGFpbHMgPSByZXF1aXJlKCcuLi91dGlscycpLmJyb3dzZXJEZXRhaWxzO1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2hpbUVycm9yXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBTZWN1cml0eUVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgUGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJ1xuICAgICAgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgJ1RoZSBvcGVyYXRpb24gaXMgaW5zZWN1cmUuJzogJ1RoZSByZXF1ZXN0IGlzIG5vdCBhbGxvd2VkIGJ5IHRoZSAnICtcbiAgICAgICAgJ3VzZXIgYWdlbnQgb3IgdGhlIHBsYXRmb3JtIGluIHRoZSBjdXJyZW50IGNvbnRleHQuJ1xuICAgICAgfVtlLm1lc3NhZ2VdIHx8IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICh0aGlzLm1lc3NhZ2UgJiYgJzogJykgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBnZXRVc2VyTWVkaWEgY29uc3RyYWludHMgc2hpbS5cbiAgdmFyIGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbihjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgdmFyIGNvbnN0cmFpbnRzVG9GRjM3XyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyAhPT0gJ29iamVjdCcgfHwgYy5yZXF1aXJlKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgICAgdmFyIHJlcXVpcmUgPSBbXTtcbiAgICAgIE9iamVjdC5rZXlzKGMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdyZXF1aXJlJyB8fCBrZXkgPT09ICdhZHZhbmNlZCcgfHwga2V5ID09PSAnbWVkaWFTb3VyY2UnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gY1trZXldID0gKHR5cGVvZiBjW2tleV0gPT09ICdvYmplY3QnKSA/XG4gICAgICAgICAgICBjW2tleV0gOiB7aWRlYWw6IGNba2V5XX07XG4gICAgICAgIGlmIChyLm1pbiAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICByLm1heCAhPT0gdW5kZWZpbmVkIHx8IHIuZXhhY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlcXVpcmUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHIuZXhhY3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByLiBtaW4gPSByLm1heCA9IHIuZXhhY3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNba2V5XSA9IHIuZXhhY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSByLmV4YWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyLmlkZWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjLmFkdmFuY2VkID0gYy5hZHZhbmNlZCB8fCBbXTtcbiAgICAgICAgICB2YXIgb2MgPSB7fTtcbiAgICAgICAgICBpZiAodHlwZW9mIHIuaWRlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvY1trZXldID0ge21pbjogci5pZGVhbCwgbWF4OiByLmlkZWFsfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Nba2V5XSA9IHIuaWRlYWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGMuYWR2YW5jZWQucHVzaChvYyk7XG4gICAgICAgICAgZGVsZXRlIHIuaWRlYWw7XG4gICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXF1aXJlLmxlbmd0aCkge1xuICAgICAgICBjLnJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDM4KSB7XG4gICAgICBsb2dnaW5nKCdzcGVjOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICAgIGlmIChjb25zdHJhaW50cy5hdWRpbykge1xuICAgICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzVG9GRjM3Xyhjb25zdHJhaW50cy5hdWRpbyk7XG4gICAgICB9XG4gICAgICBpZiAoY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvRkYzN18oY29uc3RyYWludHMudmlkZW8pO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnZmYzNzogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgfVxuICAgIHJldHVybiBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIG9uRXJyb3Ioc2hpbUVycm9yXyhlKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGdldFVzZXJNZWRpYSBhcyBhIFByb21pc2UuXG4gIHZhciBnZXRVc2VyTWVkaWFQcm9taXNlXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZ2V0VXNlck1lZGlhXyhjb25zdHJhaW50cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBTaGltIGZvciBtZWRpYURldmljZXMgb24gb2xkZXIgdmVyc2lvbnMuXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMgPSB7Z2V0VXNlck1lZGlhOiBnZXRVc2VyTWVkaWFQcm9taXNlXyxcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7IH1cbiAgICB9O1xuICB9XG4gIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyA9XG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIGluZm9zID0gW1xuICAgICAgICAgICAge2tpbmQ6ICdhdWRpb2lucHV0JywgZGV2aWNlSWQ6ICdkZWZhdWx0JywgbGFiZWw6ICcnLCBncm91cElkOiAnJ30sXG4gICAgICAgICAgICB7a2luZDogJ3ZpZGVvaW5wdXQnLCBkZXZpY2VJZDogJ2RlZmF1bHQnLCBsYWJlbDogJycsIGdyb3VwSWQ6ICcnfVxuICAgICAgICAgIF07XG4gICAgICAgICAgcmVzb2x2ZShpbmZvcyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDQxKSB7XG4gICAgLy8gV29yayBhcm91bmQgaHR0cDovL2J1Z3ppbC5sYS8xMTY5NjY1XG4gICAgdmFyIG9yZ0VudW1lcmF0ZURldmljZXMgPVxuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMuYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBvcmdFbnVtZXJhdGVEZXZpY2VzKCkudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNDkpIHtcbiAgICB2YXIgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLlxuICAgICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIG9yaWdHZXRVc2VyTWVkaWEoYykudGhlbihmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWd6aWwubGEvODAyMzI2XG4gICAgICAgIGlmIChjLmF1ZGlvICYmICFzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggfHxcbiAgICAgICAgICAgIGMudmlkZW8gJiYgIXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIG9iamVjdCBjYW4gbm90IGJlIGZvdW5kIGhlcmUuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdOb3RGb3VuZEVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNDQpIHtcbiAgICAgIHJldHVybiBnZXRVc2VyTWVkaWFfKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlIEZpcmVmb3ggNDQrJ3MgZGVwcmVjYXRpb24gd2FybmluZyB3aXRoIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICBjb25zb2xlLndhcm4oJ25hdmlnYXRvci5nZXRVc2VyTWVkaWEgaGFzIGJlZW4gcmVwbGFjZWQgYnkgJyArXG4gICAgICAgICAgICAgICAgICduYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYScpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH07XG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgc2FmYXJpU2hpbSA9IHtcbiAgLy8gVE9ETzogRHJBbGV4LCBzaG91bGQgYmUgaGVyZSwgZG91YmxlIGNoZWNrIGFnYWluc3QgTGF5b3V0VGVzdHNcbiAgLy8gc2hpbU9uVHJhY2s6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gIC8vIFRPRE86IG9uY2UgdGhlIGJhY2stZW5kIGZvciB0aGUgbWFjIHBvcnQgaXMgZG9uZSwgYWRkLlxuICAvLyBUT0RPOiBjaGVjayBmb3Igd2Via2l0R1RLK1xuICAvLyBzaGltUGVlckNvbm5lY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gIHNoaW1HZXRVc2VyTWVkaWE6IGZ1bmN0aW9uKCkge1xuICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhO1xuICB9XG59O1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hpbUdldFVzZXJNZWRpYTogc2FmYXJpU2hpbS5zaGltR2V0VXNlck1lZGlhXG4gIC8vIFRPRE9cbiAgLy8gc2hpbU9uVHJhY2s6IHNhZmFyaVNoaW0uc2hpbU9uVHJhY2ssXG4gIC8vIHNoaW1QZWVyQ29ubmVjdGlvbjogc2FmYXJpU2hpbS5zaGltUGVlckNvbm5lY3Rpb25cbn07XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ0Rpc2FibGVkXyA9IHRydWU7XG5cbi8vIFV0aWxpdHkgbWV0aG9kcy5cbnZhciB1dGlscyA9IHtcbiAgZGlzYWJsZUxvZzogZnVuY3Rpb24oYm9vbCkge1xuICAgIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgK1xuICAgICAgICAgICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICAgIH1cbiAgICBsb2dEaXNhYmxlZF8gPSBib29sO1xuICAgIHJldHVybiAoYm9vbCkgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6XG4gICAgICAgICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XG4gIH0sXG5cbiAgbG9nOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChsb2dEaXNhYmxlZF8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgYnJvd3NlciB2ZXJzaW9uIG91dCBvZiB0aGUgcHJvdmlkZWQgdXNlciBhZ2VudCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdWFzdHJpbmcgdXNlckFnZW50IHN0cmluZy5cbiAgICogQHBhcmFtIHshc3RyaW5nfSBleHByIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIGFzIG1hdGNoIGNyaXRlcmlhLlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IHBvcyBwb3NpdGlvbiBpbiB0aGUgdmVyc2lvbiBzdHJpbmcgdG8gYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4geyFudW1iZXJ9IGJyb3dzZXIgdmVyc2lvbi5cbiAgICovXG4gIGV4dHJhY3RWZXJzaW9uOiBmdW5jdGlvbih1YXN0cmluZywgZXhwciwgcG9zKSB7XG4gICAgdmFyIG1hdGNoID0gdWFzdHJpbmcubWF0Y2goZXhwcik7XG4gICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBwb3MgJiYgcGFyc2VJbnQobWF0Y2hbcG9zXSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCcm93c2VyIGRldGVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IHJlc3VsdCBjb250YWluaW5nIGJyb3dzZXIgYW5kIHZlcnNpb25cbiAgICogICAgIHByb3BlcnRpZXMuXG4gICAqL1xuICBkZXRlY3RCcm93c2VyOiBmdW5jdGlvbigpIHtcbiAgICAvLyBSZXR1cm5lZCByZXN1bHQgb2JqZWN0LlxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICByZXN1bHQuYnJvd3NlciA9IG51bGw7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBudWxsO1xuXG4gICAgLy8gRmFpbCBlYXJseSBpZiBpdCdzIG5vdCBhIGJyb3dzZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIGJyb3dzZXIuJztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveC5cbiAgICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICAgICAgcmVzdWx0LmJyb3dzZXIgPSAnZmlyZWZveCc7XG4gICAgICByZXN1bHQudmVyc2lvbiA9IHRoaXMuZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAvRmlyZWZveFxcLyhbMC05XSspXFwuLywgMSk7XG5cbiAgICAvLyBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzXG4gICAgfSBlbHNlIGlmIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKSB7XG4gICAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYSwgYWxsIHVzZSB0aGUgY2hyb21lIHNoaW0gZm9yIG5vd1xuICAgICAgaWYgKHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgICByZXN1bHQuYnJvd3NlciA9ICdjaHJvbWUnO1xuICAgICAgICByZXN1bHQudmVyc2lvbiA9IHRoaXMuZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAvQ2hyb20oZXxpdW0pXFwvKFswLTldKylcXC4vLCAyKTtcblxuICAgICAgLy8gU2FmYXJpIG9yIHVua25vd24gd2Via2l0LWJhc2VkXG4gICAgICAvLyBmb3IgdGhlIHRpbWUgYmVpbmcgU2FmYXJpIGhhcyBzdXBwb3J0IGZvciBNZWRpYVN0cmVhbXMgYnV0IG5vdCB3ZWJSVENcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNhZmFyaSBVQSBzdWJzdHJpbmdzIG9mIGludGVyZXN0IGZvciByZWZlcmVuY2U6XG4gICAgICAgIC8vIC0gd2Via2l0IHZlcnNpb246ICAgICAgICAgICBBcHBsZVdlYktpdC82MDIuMS4yNSAoYWxzbyB1c2VkIGluIE9wLENyKVxuICAgICAgICAvLyAtIHNhZmFyaSBVSSB2ZXJzaW9uOiAgICAgICAgVmVyc2lvbi85LjAuMyAodW5pcXVlIHRvIFNhZmFyaSlcbiAgICAgICAgLy8gLSBzYWZhcmkgVUkgd2Via2l0IHZlcnNpb246IFNhZmFyaS82MDEuNC40IChhbHNvIHVzZWQgaW4gT3AsQ3IpXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmIHRoZSB3ZWJraXQgdmVyc2lvbiBhbmQgc2FmYXJpIFVJIHdlYmtpdCB2ZXJzaW9ucyBhcmUgZXF1YWxzLFxuICAgICAgICAvLyAuLi4gdGhpcyBpcyBhIHN0YWJsZSB2ZXJzaW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBvbmx5IHRoZSBpbnRlcm5hbCB3ZWJraXQgdmVyc2lvbiBpcyBpbXBvcnRhbnQgdG9kYXkgdG8ga25vdyBpZlxuICAgICAgICAvLyBtZWRpYSBzdHJlYW1zIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKykuKFxcZCspLykpIHtcbiAgICAgICAgICByZXN1bHQuYnJvd3NlciA9ICdzYWZhcmknO1xuICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdGhpcy5leHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgICAgL0FwcGxlV2ViS2l0XFwvKFswLTldKylcXC4vLCAxKTtcblxuICAgICAgICAvLyB1bmtub3duIHdlYmtpdC1iYXNlZCBicm93c2VyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LmJyb3dzZXIgPSAnVW5zdXBwb3J0ZWQgd2Via2l0LWJhc2VkIGJyb3dzZXIgJyArXG4gICAgICAgICAgICAgICd3aXRoIEdVTSBzdXBwb3J0IGJ1dCBubyBXZWJSVEMgc3VwcG9ydC4nO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIEVkZ2UuXG4gICAgfSBlbHNlIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykuKFxcZCspJC8pKSB7XG4gICAgICByZXN1bHQuYnJvd3NlciA9ICdlZGdlJztcbiAgICAgIHJlc3VsdC52ZXJzaW9uID0gdGhpcy5leHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgIC9FZGdlXFwvKFxcZCspLihcXGQrKSQvLCAyKTtcblxuICAgIC8vIERlZmF1bHQgZmFsbHRocm91Z2g6IG5vdCBzdXBwb3J0ZWQuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIHN1cHBvcnRlZCBicm93c2VyLic7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIEV4cG9ydC5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2c6IHV0aWxzLmxvZyxcbiAgZGlzYWJsZUxvZzogdXRpbHMuZGlzYWJsZUxvZyxcbiAgYnJvd3NlckRldGFpbHM6IHV0aWxzLmRldGVjdEJyb3dzZXIoKSxcbiAgZXh0cmFjdFZlcnNpb246IHV0aWxzLmV4dHJhY3RWZXJzaW9uXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsInZhciBidXMgPSByZXF1aXJlKCdwYWdlLWJ1cycpXG52YXIgc2hvcnQgPSByZXF1aXJlKCdzaG9ydC11dWlkJylcbnZhciBpZCA9IHNob3J0KCkuZ2VuZXJhdGUoKVxudmFyIGVtaXR0ZXJzID0ge31cbnZhciBuYW1lcyA9IFtdXG52YXIgbWV0YSA9IGJ1cyh7a2V5OiAnX21ldGFfJ30pXG52YXIgam9pbiA9IGJ1cyh7a2V5OiAnX2pvaW5fJ30pXG52YXIgc2VsZiA9IGJ1cyh7a2V5OiBpZH0pXG52YXIgc3dhcm0gPSB7fSAvLyBpZHNcbnZhciBjb3VudCA9IDBcblxuam9pbi5lbWl0KCdkYXRhJywge2lkOiBpZH0pXG5cbmpvaW4ub24oJ2RhdGEnLCBlID0+IHtcbiAgaWYoZS5pZCA9PSBpZCkgcmV0dXJuXG4gIGxldCBlbSA9IHN3YXJtW2UuaWRdID0gYnVzKHtrZXk6IGUuaWR9KVxuICBjb3VudCsrXG4gIGlmKE1hdGgucmFuZG9tKCkgPD0gMSAvIE1hdGgucG93KGNvdW50LCAyKSkgcmV0dXJuXG4gIGVsc2UgZW0uZW1pdCgnZGF0YScsIHtldmVudHM6IG5hbWVzLCBzd2Ftcm06IE9iamVjdC5rZXlzKHN3YXJtKX0pXG59KVxuXG5zZWxmLm9uKCdkYXRhJywgZSA9PiB7XG4gIGUuZXZlbnRzLmZvckVhY2goZXYgPT4ge1xuICAgIGlmKCFlbWl0dGVyc1tlLm5hbWVdKSB7XG4gICAgICB2YXIgZW1pdHRlciA9IGVtaXR0ZXJzW2UubmFtZV0gPSBidXMoe2tleTplLm5hbWV9KVxuICAgIH1cbiAgfSlcbiAgZS5zd2FybS5mb3JFYWNoKHMgPT4ge1xuICAgIGlmKCFzd2FybVtzXSkgc3dhcm1bc10gPSBidXMoe2tleTogc30pXG4gIH0pXG4gY291bnQgPSBzd2FybS5sZW5ndGhcbn0pXG5cbm1ldGEub24oJ2RhdGEnLCBlID0+IHtcbiAgaWYoIWVtaXR0ZXJzW2UubmFtZV0pIGVtaXR0ZXJzW2UubmFtZV0gPSBidXMoe2tleTplLm5hbWV9KVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7b24sIG9uY2UsIGVtaXR9XG5cbmZ1bmN0aW9uIG9uKG5hbWUsIGZuKXtcbiAgaWYoIWVtaXR0ZXJzW25hbWVdKSB7XG4gICAgbmFtZXMucHVzaChuYW1lKVxuICAgIG1ldGEuZW1pdCgnZGF0YScsIHtuYW1lOiBuYW1lfSlcbiAgICBzZXRUaW1lb3V0KGUgPT4gb24obmFtZSwgZm4pLCAwKVxuICB9ICBcbiAgZWxzZSB7XG4gICAgZW1pdHRlcnNbbmFtZV0ub24obmFtZSwgZm4pXG4gIH1cbn1cblxuZnVuY3Rpb24gb25jZShuYW1lLCBmbil7XG4gIGlmKCFlbWl0dGVyc1tuYW1lXSkge1xuICAgIG1ldGEuZW1pdCgnZGF0YScsIHtuYW1lOiBuYW1lfSlcbiAgICBzZXRUaW1lb3V0KGUgPT4gb24obmFtZSwgZm4pLCAwKVxuICB9ICBcbiAgZWxzZSBlbWl0dGVyc1tuYW1lXS5vbmNlKG5hbWUsIGZuKVxufVxuXG5mdW5jdGlvbiBlbWl0KG5hbWUsIGRhdGEpe1xuICBpZighZW1pdHRlcnNbbmFtZV0pIHtcbiAgICBtZXRhLmVtaXQoJ2RhdGEnLCB7bmFtZTogbmFtZX0pXG4gICAgc2V0VGltZW91dChlID0+IGVtaXQobmFtZSwgZGF0YSwgMCkpXG4gIH0gIFxuICBlbHNlIGVtaXR0ZXJzW25hbWVdLmVtaXQobmFtZSwgZGF0YSlcbn1cbiIsInZhciBtczJzID0gMS4wIC8gMTAwMC4wO1xudmFyIG5zMm1zID0gMS4wIC8gMTAwMDAwMC4wXG52YXIgbnMycyA9IDFlLTlcblxubW9kdWxlLmV4cG9ydHMgPSBUXG5cbmZ1bmN0aW9uIFQoKXtcblx0aWYoIXByb2Nlc3MuaHJ0aW1lKXsgLy8gYnJvd3NlciBmaWxsXG5cblx0XHRwcm9jZXNzLmhydGltZSA9IGZ1bmN0aW9uKCl7XG5cblx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGgpe1xuXHRcdFx0XHRhcmd1bWVudHNbMV0gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdFx0YXJndW1lbnRzWzBdID0gIGFyZ3VtZW50c1sxXSAtIG1pbGxpZXMoYXJndW1lbnRzWzBdKVxuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YXJndW1lbnRzWzBdID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBbcGFyc2VJbnQoYXJndW1lbnRzWzBdICogbXMycyksIHBhcnNlSW50KCgoYXJndW1lbnRzWzBdICogbXMycykgJSAxKSAvIG5zMnMpXTtcblx0XHRcdFxuXHRcdH1cblx0fVxuICBpZighKHRoaXMgaW5zdGFuY2VvZiBUKSkgcmV0dXJuIG5ldyBUKCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5zdGFydCA9IHNlbGYubGFzdCA9IHNlbGYuYmVhdCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gIHNlbGYueCA9IFtdXG4gIHNlbGYuZW5kID0gW11cbiAgc2VsZi5iZWF0cyA9ICBbXVxuICBzZWxmLmF2ZXJhZ2VTZXRTaXplID0gMzMzXG4gIHNlbGYudGhyZXNob2xkID0gMWU2IC8vIDEwLDAwMCwwMDAgbnMgKCAxMCBtcyApXG4gIHNlbGYuc2tpcCA9IGZhbHNlXG59O1xuXG5ULnByb3RvdHlwZS5zaW5jZUJlZ2luID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHByb2Nlc3MuaHJ0aW1lKHRoaXMuc3RhcnQpXG59O1xuXG5ULnByb3RvdHlwZS5zaW5jZUxhc3QgPSBmdW5jdGlvbigpe1xuICB0aGlzLnggPSBwcm9jZXNzLmhydGltZSh0aGlzLmxhc3QpXG4gIHRoaXMubGFzdCA9IHByb2Nlc3MuaHJ0aW1lKClcbiAgcmV0dXJuIHRoaXMueFxufVxuXG5ULnByb3RvdHlwZS5zaW5jZUxhc3ROUyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuYW5vcyh0aGlzLnNpbmNlTGFzdCgpKVxufTtcblxuVC5wcm90b3R5cGUuc2luY2VCZWdpbk5TID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5hbm9zKHRoaXMuc2luY2VCZWdpbigpKVxufTtcblxuVC5wcm90b3R5cGUuYXZnID0gZnVuY3Rpb24oKXtcbiAgdmFyIG5zID0gbmFub3ModGhpcy5zaW5jZUxhc3QoKSlcbiAgdGhpcy5iZWF0cy5wdXNoKG5zKTtcbiAgdGhpcy5iZWF0cyA9IHRoaXMuYmVhdHMuc3BsaWNlKC10aGlzLmF2ZXJhZ2VTZXRTaXplKVxuICByZXR1cm4gYXZnKHRoaXMuYmVhdHMpO1xufTtcblxuVC5wcm90b3R5cGUuZXZlcnlTID0gZnVuY3Rpb24ocywgZm4sIGdvKXtcblx0dGhpcy5ldmVyeShzICogMWU5LCBmbiwgZ28pXG59XG5cblQucHJvdG90eXBlLmV2ZXJ5ID0gZnVuY3Rpb24obnMsIGZuLCBnbyl7XG5cbiAgdmFyIHNlbGYgPSBuZXcgVCgpO1xuICB2YXIgdGltZXIgPSBuZXcgVCgpO1xuXG4gIHZhciBpbnRlciA9IG5zIHx8IDBcbiAgICAsIGZuID0gZm4gfHwgZnVuY3Rpb24odCxjKXtjKCl9XG4gICAgOyAgIFxuICAgICAgXG4gIGZ1bmN0aW9uIHRpY2soKXtcblxuICAgIHZhciBucyA9IG5hbm9zKHNlbGYuc2luY2VMYXN0KCkpO1xuLy8gIHVubmVjZXNzYXJ5IGN1eiBubyBsb25nZXIgdHJ5aW5nIHRvIG9wdGltaXplIGluIGxvb3AoKVxuLy8gICAgc2VsZi5iZWF0cy5wdXNoKG5zKTtcbiAgICBsb29wKClcblxuICB9O1xuXG4gIGZ1bmN0aW9uIGxvb3AoKXtcbiAgICB2YXIgZCA9IGludGVyIC0gKG5hbm9zKHByb2Nlc3MuaHJ0aW1lKCkpIC0gbmFub3Moc2VsZi5iZWF0KSk7XG5cbiAgICBpZihkIDwgMTAwMDApIHtcbiAgICAgIHRvY2soKVxuICAgIH1cblxuICAgIGVsc2UgaWYoc2VsZi5za2lwKSB7XG4gICAgIHNldEltbWVkaWF0ZShsb29wKVxuICAgIH1cblxuICAgIGVsc2UgaWYoZCA8IHNlbGYudGhyZXNob2xkKSB7XG4gICAgICAvLyB1bmRlciB0aGUgdGhyZXNob2xkLCBpdHMgbmV4dFRpY2tzIHVudGlsIHRoZSBpbnRlcnZhbCBpcyB1cFxuICAgICAgc2VsZi5za2lwID0gdHJ1ZTsgc2V0SW1tZWRpYXRlKGxvb3ApIFxuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgaWYoZmFsc2UgJiYgc2VsZi5iZWF0cy5sZW5ndGggPiA5KSB7XG4gICAgICAgIHZhciByID0gc2VsZi5iZWF0cy5sZW5ndGggLyBzZWxmLmF2ZXJhZ2VTZXRTaXplO1xuICAgICAgICBzZWxmLnRocmVzaG9sZCA9IGF2ZyhzZWxmLmJlYXRzKSAqIC40NSAqIHIgKiAyXG4gICAgICB9XG5cbiAgICAgIC8vIGZvciBmdXR1cmUgcmVmZXJlbmNlOlxuICAgICAgLy8gY29uc29sZS5sb2coYXZnKHNlbGYuYmVhdHMpLCBzZWxmLmJlYXRzLmxlbmd0aCwgJ3RocmVzaG9sZCA9ICcgKyBzZWxmLnRocmVzaG9sZClcblxuICAgICAgc2VsZi5za2lwID0gZmFsc2U7IFxuICAgICAgc2V0VGltZW91dChsb29wLCBzZWxmLnRocmVzaG9sZCAvIDFlNilcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9jaygpe1xuICAgIHNlbGYuYmVhdCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgc2VsZi5za2lwID0gZmFsc2U7XG4gICAgZm4odGljaywgbmFub3ModGltZXIuc2luY2VMYXN0KCkpKVxuICB9O1xuICBcbiAgaWYoZ28pIHRvY2soKVxuXG4gIGVsc2UgbG9vcCgpXG5cbn1cblxuZnVuY3Rpb24gbWlsbGllcyhhcnIpe1xuXHRyZXR1cm4gKGFyclswXSAqIDFlMykgKyAoYXJyWzFdICogbnMybXMpXG59XG5cbmZ1bmN0aW9uIG5hbm9zKGFycil7XG4gIHJldHVybiBhcnJbMF0gKiAxZTkgKyBhcnJbMV1cbn1cblxuZnVuY3Rpb24gYWRkKGEsIGIpe1xuICB2YXIgbnMgPSBhWzFdICsgYlsxXTtcbiAgYlswXSArPSBhWzBdO1xuICBiWzFdID0gbnMgJSAxZTk7XG4gIGlmKG5zICE9PSBiWzFdKSBiWzBdKys7XG4gIHJldHVybiBiXG59O1xuXG5mdW5jdGlvbiBhdmcoKXtcblxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzWzBdKS5yZWR1Y2UoZnVuY3Rpb24oYSxpKXtyZXR1cm4gYSArPSBpIH0sMCkgLyBhcmd1bWVudHNbMF0ubGVuZ3RoXG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJyk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIEdlbmVyYXRvckZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24oZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoaXNGblJlZ2V4LnRlc3QoZm5Ub1N0ci5jYWxsKGZuKSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwoZm4pO1xuXHRcdHJldHVybiBzdHIgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cdH1cblx0aWYgKCFnZXRQcm90bykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAodHlwZW9mIEdlbmVyYXRvckZ1bmN0aW9uID09PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xuXHRcdEdlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDogZmFsc2U7XG5cdH1cblx0cmV0dXJuIGdldFByb3RvKGZuKSA9PT0gR2VuZXJhdG9yRnVuY3Rpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGFueVRydWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWFueVRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBhbnlUcnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5TdHJlYW0uZmluaXNoZWQgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpXG5TdHJlYW0ucGlwZWxpbmUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMnKVxuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcbi8qIDxyZXBsYWNlbWVudD4gKi9cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufSAvLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuXG5cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICAgIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOyAvLyBkcmFpbiBldmVudCBmbGFnLlxuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7IC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG5cbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTsgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cblxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuXG4gIHRoaXMuY29ya2VkID0gMDsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cblxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuXG5cbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7IC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuXG4gIHRoaXMucGVuZGluZ2NiID0gMDsgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cblxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7IC8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxuXG5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3kuXG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufSAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5cblxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpOyAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59IC8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cblxuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG5cbiAgaWYgKGVyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cblxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOyAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cblxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcblxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCk7XG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn0gLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5cblxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufSAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuXG5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOyAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tOyAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH0gLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuXG5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG5cbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcblxuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG5cbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cblxuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpO1xuICBlbWl0Q2xvc2VOVChzZWxmKTtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3N1cHBvcnQvdHlwZXMnKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSByZXF1aXJlKCdhdmFpbGFibGUtdHlwZWQtYXJyYXlzJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdGlmICh0eXBlb2YgZ1t0eXBlZEFycmF5XSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGZvdW5kTmFtZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghZm91bmROYW1lKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGdldHRlci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0aWYgKG5hbWUgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZE5hbWUgPSBuYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZE5hbWU7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCFpc1R5cGVkQXJyYXkodmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkgeyByZXR1cm4gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiJdfQ==
